#**************************************************************************
#*                                                                        *
#*                                 OCaml                                  *
#*                                                                        *
#*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *
#*                                                                        *
#*   Copyright 1999 Institut National de Recherche en Informatique et     *
#*     en Automatique.                                                    *
#*                                                                        *
#*   All rights reserved.  This file is distributed under the terms of    *
#*   the GNU Lesser General Public License version 2.1, with the          *
#*   special exception on linking described in the file LICENSE.          *
#*                                                                        *
#**************************************************************************

# Targets and dependencies for compilerlibs archives

# This file is meant to be included from the root Makefile, not to be
# executed directly (this is why it is not simply named Makefile).

# For each group of compilation units, we have a variable GROUP with
# only .cmo files, and a separate variable GROUP_CMI for .cmi files
# corresponding to the .mli-only modules only. These .cmi are not
# linked in the archive, but they are marked as dependencies to ensure
# that they are consistent with the interface digests in the archives.

UTILS=config.cmo build_path_prefix_map.cmo misc.cmo \
	identifiable.cmo numbers.cmo arg_helper.cmo \
	clflags.cmo profile.cmo load_path.cmo \
	terminfo.cmo ccomp.cmo warnings.cmo \
	consistbl.cmo strongly_connected_components.cmo \
	targetint.cmo int_replace_polymorphic_compare.cmo \
	domainstate.cmo
UTILS_CMI=

PARSING=location.cmo longident.cmo \
  docstrings.cmo syntaxerr.cmo \
  ast_helper.cmo \
  pprintast.cmo \
  camlinternalMenhirLib.cmo parser.cmo \
  lexer.cmo parse.cmo printast.cmo \
  ast_mapper.cmo ast_iterator.cmo attr_helper.cmo \
  builtin_attributes.cmo ast_invariants.cmo depend.cmo
PARSING_CMI=\
  asttypes.cmi \
  parsetree.cmi

TYPING=ident.cmo path.cmo \
  primitive.cmo type_immediacy.cmo types.cmo \
  btype.cmo oprint.cmo \
  subst.cmo predef.cmo \
  datarepr.cmo cmi_format.cmo \
  persistent_env.cmo env.cmo \
  typedtree.cmo printtyped.cmo ctype.cmo \
  printtyp.cmo includeclass.cmo \
  mtype.cmo envaux.cmo includecore.cmo \
  tast_iterator.cmo tast_mapper.cmo stypes.cmo \
  cmt_format.cmo cmt2annot.cmo untypeast.cmo \
  includemod.cmo typetexp.cmo printpat.cmo \
  parmatch.cmo \
  typedecl_properties.cmo typedecl_variance.cmo \
  typedecl_unboxed.cmo typedecl_immediacy.cmo \
  typedecl_separability.cmo \
  typedecl.cmo typeopt.cmo \
  rec_check.cmo typecore.cmo typeclass.cmo \
  typemod.cmo
TYPING_CMI=\
  annot.cmi \
  outcometree.cmi

LAMBDA=debuginfo.cmo \
  lambda.cmo printlambda.cmo \
  switch.cmo matching.cmo \
  translobj.cmo translattribute.cmo \
  translprim.cmo translcore.cmo \
  translclass.cmo translmod.cmo \
  simplif.cmo runtimedef.cmo
LAMBDA_CMI=

COMP=\
  meta.cmo opcodes.cmo \
  bytesections.cmo dll.cmo \
  symtable.cmo \
  pparse.cmo compenv.cmo \
  main_args.cmo compmisc.cmo \
  makedepend.cmo \
  compile_common.cmo
COMP_CMI=\
  cmo_format.cmi \
  cmx_format.cmi \
  cmxs_format.cmi
# All file format descriptions (including cmx{,s}) are in the
# ocamlcommon library so that ocamlobjinfo can depend on them.

COMMON_CMI=$(addprefix compilerlibs/,$(UTILS_CMI) $(PARSING_CMI) $(TYPING_CMI) $(LAMBDA_CMI) $(COMP_CMI))

COMMON=$(addprefix compilerlibs/,$(UTILS) $(PARSING) $(TYPING) $(LAMBDA) $(COMP))

BYTECOMP=$(addprefix compilerlibs/,instruct.cmo bytegen.cmo \
  printinstr.cmo emitcode.cmo \
  bytelink.cmo bytelibrarian.cmo bytepackager.cmo \
  errors.cmo compile.cmo)
BYTECOMP_CMI=

ASMCOMP=\
  x86_proc.cmo \
  x86_dsl.cmo \
  x86_gas.cmo \
  x86_masm.cmo \
  arch.cmo \
  cmm.cmo printcmm.cmo \
  reg.cmo reg_with_debug_info.cmo \
  reg_availability_set.cmo \
  mach.cmo proc.cmo \
  afl_instrument.cmo \
  strmatch.cmo \
  cmmgen_state.cmo \
  cmm_helpers.cmo \
  cmmgen.cmo \
  interval.cmo \
  printmach.cmo selectgen.cmo \
  spacetime_profiling.cmo selection.cmo \
  comballoc.cmo \
  CSEgen.cmo CSE.cmo \
  liveness.cmo \
  spill.cmo split.cmo \
  interf.cmo coloring.cmo \
  linscan.cmo \
  reloadgen.cmo reload.cmo \
  deadcode.cmo \
  linear.cmo printlinear.cmo linearize.cmo \
  available_regs.cmo \
  compute_ranges.cmo \
  schedgen.cmo scheduling.cmo \
  branch_relaxation.cmo \
  emitaux.cmo emit.cmo asmgen.cmo \
  asmlink.cmo asmlibrarian.cmo asmpackager.cmo \
  opterrors.cmo optcompile.cmo
ASMCOMP_CMI=\
  archgen.cmi \
  specifics.cmi \
  branch_relaxation_intf.cmi \
  compute_ranges_intf.cmi \
  x86_ast.cmi

# Files under middle_end/ are not to reference files under asmcomp/.
# This ensures that the middle end can be linked (e.g. for objinfo) even when
# the native code compiler is not present for some particular target.

MIDDLE_END_CLOSURE=\
  closure.cmo \
  closure_middle_end.cmo
MIDDLE_END_CLOSURE_CMI=

# Owing to dependencies through [Compilenv], which would be
# difficult to remove, some of the lower parts of Flambda (anything that is
# saved in a .cmx file) have to be included in the [MIDDLE_END] stanza, below.
MIDDLE_END_FLAMBDA=\
  import_approx.cmo \
  lift_code.cmo \
  closure_conversion_aux.cmo \
  closure_conversion.cmo \
  initialize_symbol_to_let_symbol.cmo \
  lift_let_to_initialize_symbol.cmo \
  find_recursive_functions.cmo \
  invariant_params.cmo \
  inconstant_idents.cmo \
  alias_analysis.cmo \
  lift_constants.cmo \
  share_constants.cmo \
  simplify_common.cmo \
  remove_unused_arguments.cmo \
  remove_unused_closure_vars.cmo \
  remove_unused_program_constructs.cmo \
  simplify_boxed_integer_ops.cmo \
  simplify_primitives.cmo \
  inlining_stats_types.cmo \
  inlining_stats.cmo \
  inline_and_simplify_aux.cmo \
  remove_free_vars_equal_to_args.cmo \
  extract_projections.cmo \
  augment_specialised_args.cmo \
  unbox_free_vars_of_closures.cmo \
  unbox_specialised_args.cmo \
  unbox_closures.cmo \
  inlining_transforms.cmo \
  inlining_decision.cmo \
  inline_and_simplify.cmo \
  ref_to_variables.cmo \
  flambda_invariants.cmo \
  traverse_for_exported_symbols.cmo \
  build_export_info.cmo \
  closure_offsets.cmo \
  un_anf.cmo \
  flambda_to_clambda.cmo \
  flambda_middle_end.cmo
MIDDLE_END_FLAMBDA_CMI=\
  inlining_decision_intf.cmi \
  simplify_boxed_integer_ops_intf.cmi

MIDDLE_END=$(addprefix compilerlibs/, \
  internal_variable_names.cmo \
  linkage_name.cmo \
  compilation_unit.cmo \
  variable.cmo \
  closure_element.cmo \
  closure_id.cmo \
  symbol.cmo \
  backend_var.cmo \
  clambda_primitives.cmo \
  printclambda_primitives.cmo \
  clambda.cmo \
  printclambda.cmo \
  semantics_of_primitives.cmo \
  convert_primitives.cmo \
  id_types.cmo \
  export_id.cmo \
  tag.cmo \
  mutable_variable.cmo \
  set_of_closures_id.cmo \
  set_of_closures_origin.cmo \
  closure_origin.cmo \
  var_within_closure.cmo \
  static_exception.cmo \
  pass_wrapper.cmo \
  allocated_const.cmo \
  parameter.cmo \
  projection.cmo \
  flambda.cmo \
  flambda_iterators.cmo \
  flambda_utils.cmo \
  freshening.cmo \
  effect_analysis.cmo \
  inlining_cost.cmo \
  simple_value_approx.cmo \
  export_info.cmo \
  export_info_for_pack.cmo \
  compilenv.cmo \
  $(MIDDLE_END_CLOSURE) \
  $(MIDDLE_END_FLAMBDA))
MIDDLE_END_CMI=$(addprefix compilerlibs/, \
  backend_intf.cmi \
  $(MIDDLE_END_CLOSURE_CMI) \
  $(MIDDLE_END_FLAMBDA_CMI))

OPTCOMP=$(MIDDLE_END) $(addprefix compilerlibs/,$(ASMCOMP))
OPTCOMP_CMI=$(MIDDLE_END_CMI) $(addprefix compilerlibs/,$(ASMCOMP_CMI))

TOPLEVEL=$(addprefix compilerlibs/,genprintval.cmo toploop.cmo \
  trace.cmo topdirs.cmo topmain.cmo)
TOPLEVEL_CMI=

OPTTOPLEVEL=$(addprefix compilerlibs/,genprintval.cmo opttoploop.cmo \
  opttopdirs.cmo opttopmain.cmo)
OPTTOPLEVEL_CMI=


$(COMMON:.cmo=.cmx) $(BYTECOMP:.cmo=.cmx) $(OPTCOMP:.cmo=.cmx): ocamlopt
$(OPTTOPLEVEL:.cmo=.cmx): ocamlopt


compilerlibs/ocamlcommon.cma: $(COMMON_CMI) $(COMMON)
	$(CAMLC) -a -linkall -o $@ $(filter %.cmo,$^)
# XXX Include the .ml files as well?!
partialclean::
	rm -f compilerlibs/ocamlcommon.cma $(addprefix compilerlibs/,$(COMMON_CMI) $(COMMON) $(COMMON:.cmo=.cmi))

compilerlibs/ocamlcommon.cmxa: $(COMMON_CMI) $(COMMON:.cmo=.cmx)
	$(CAMLOPT) -a -linkall -o $@ $(filter %.cmx,$^)
# XXX COMBAK sort out the partialclean target
partialclean::
	rm -f compilerlibs/ocamlcommon.cmxa \
	      compilerlibs/ocamlcommon.a compilerlibs/ocamlcommon.lib


compilerlibs/ocamlbytecomp.cma: $(BYTECOMP_CMI) $(BYTECOMP)
	$(CAMLC) -a -o $@ $(filter %.cmo,$^)
# XXX COMBAK sort out the partialclean target
partialclean::
	rm -f compilerlibs/ocamlbytecomp.cma

compilerlibs/ocamlbytecomp.cmxa: $(BYTECOMP_CMI) $(BYTECOMP:.cmo=.cmx)
	$(CAMLOPT) -a $(OCAML_NATDYNLINKOPTS) -o $@ $(filter %.cmx,$^)
# XXX COMBAK sort out the partialclean target
partialclean::
	rm -f compilerlibs/ocamlbytecomp.cmxa \
	      compilerlibs/ocamlbytecomp.a compilerlibs/ocamlbytecomp.lib


compilerlibs/ocamlmiddleend.cma: $(MIDDLE_END_CMI) $(MIDDLE_END)
	$(CAMLC) -a -o $@ $(filter %.cmo,$^)
compilerlibs/ocamlmiddleend.cmxa: $(MIDDLE_END_CMI) $(MIDDLE_END:%.cmo=%.cmx)
	$(CAMLOPT) -a -o $@ $(filter %.cmx,$^)
# XXX COMBAK sort out the partialclean target
partialclean::
	rm -f compilerlibs/ocamlmiddleend.cma \
	      compilerlibs/ocamlmiddleend.cmxa \
	      compilerlibs/ocamlmiddleend.a \
	      compilerlibs/ocamlmiddleend.lib


compilerlibs/ocamloptcomp.cma: $(OPTCOMP_CMI) $(OPTCOMP)
	$(CAMLC) -a -o $@ $(filter %.cmo,$^)
# XXX COMBAK sort out the partialclean target
partialclean::
	rm -f compilerlibs/ocamloptcomp.cma

compilerlibs/ocamloptcomp.cmxa: $(OPTCOMP_CMI) $(OPTCOMP:.cmo=.cmx)
	$(CAMLOPT) -a -o $@ $(filter %.cmx,$^)
# XXX COMBAK sort out the partialclean target
partialclean::
	rm -f compilerlibs/ocamloptcomp.cmxa \
	      compilerlibs/ocamloptcomp.a compilerlibs/ocamloptcomp.lib


compilerlibs/ocamltoplevel.cma: $(TOPLEVEL_CMI) $(TOPLEVEL)
	$(CAMLC) -a -o $@ $(filter %.cmo,$^)
# XXX COMBAK sort out the partialclean target
partialclean::
	rm -f compilerlibs/ocamltoplevel.cma

compilerlibs/ocamlopttoplevel.cmxa: $(OPTTOPLEVEL_CMI) $(OPTTOPLEVEL:.cmo=.cmx)
	$(CAMLOPT) -a -o $@ $(filter %.cmx,$^)
# XXX COMBAK sort out the partialclean target
partialclean::
	rm -f compilerlibs/ocamlopttoplevel.cmxa \
	  compilerlibs/ocamlopttoplevel.a compilerlibs/ocamlopttoplevel.lib
