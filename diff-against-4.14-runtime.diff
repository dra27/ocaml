diff --git a/otherlibs/systhreads/st_posix.h b/otherlibs/systhreads/st_posix.h
index 957f4717b6..09b243f6a5 100644
--- a/otherlibs/systhreads/st_posix.h
+++ b/otherlibs/systhreads/st_posix.h
@@ -446,7 +446,7 @@ static value st_encode_sigset(sigset_t * set)
 
 static int sigmask_cmd[3] = { SIG_SETMASK, SIG_BLOCK, SIG_UNBLOCK };
 
-value caml_thread_sigmask(value cmd, value sigs) /* ML */
+value caml_thread_sigmask(value cmd, value sigs)
 {
   int how;
   sigset_t set, oldset;
@@ -463,7 +463,7 @@ value caml_thread_sigmask(value cmd, value sigs) /* ML */
   return st_encode_sigset(&oldset);
 }
 
-value caml_wait_signal(value sigs) /* ML */
+value caml_wait_signal(value sigs)
 {
 #ifdef HAS_SIGWAIT
   sigset_t set;
diff --git a/otherlibs/systhreads/st_stubs.c b/otherlibs/systhreads/st_stubs.c
index 043e07031e..c1d8358e93 100644
--- a/otherlibs/systhreads/st_stubs.c
+++ b/otherlibs/systhreads/st_stubs.c
@@ -430,7 +430,7 @@ static void caml_thread_reinitialize(void)
 
 /* Initialize the thread machinery */
 
-CAMLprim value caml_thread_initialize(value unit)   /* ML */
+CAMLprim value caml_thread_initialize(value unit)
 {
   /* Protect against repeated initialization (PR#3532) */
   if (curr_thread != NULL) return Val_unit;
@@ -483,7 +483,7 @@ CAMLprim value caml_thread_initialize(value unit)   /* ML */
    thread take 25ms on average / 50ms in the worst case, so we don't do it on
    program exit. */
 
-CAMLprim value caml_thread_cleanup(value unit)   /* ML */
+CAMLprim value caml_thread_cleanup(value unit)
 {
   if (caml_tick_thread_running){
     caml_tick_thread_stop = 1;
@@ -524,7 +524,6 @@ static ST_THREAD_FUNCTION caml_thread_start(void * arg)
 {
   caml_thread_t th = (caml_thread_t) arg;
   value clos;
-  void * signal_stack;
 #ifdef NATIVE_CODE
   struct longjmp_buffer termination_buf;
   char tos;
@@ -537,7 +536,7 @@ static ST_THREAD_FUNCTION caml_thread_start(void * arg)
   /* Acquire the global mutex */
   caml_leave_blocking_section();
   st_thread_set_id(Ident(th->descr));
-  signal_stack = caml_setup_stack_overflow_detection();
+  caml_setup_stack_overflow_detection();
 #ifdef NATIVE_CODE
   /* Setup termination handler (for caml_thread_exit) */
   if (sigsetjmp(termination_buf.buf, 0) == 0) {
@@ -551,12 +550,12 @@ static ST_THREAD_FUNCTION caml_thread_start(void * arg)
 #ifdef NATIVE_CODE
   }
 #endif
-  caml_stop_stack_overflow_detection(signal_stack);
+  caml_stop_stack_overflow_detection();
   /* The thread now stops running */
   return 0;
 }
 
-CAMLprim value caml_thread_new(value clos)          /* ML */
+CAMLprim value caml_thread_new(value clos)
 {
   caml_thread_t th;
   st_retcode err;
@@ -663,7 +662,7 @@ CAMLexport int caml_c_thread_unregister(void)
 
 /* Return the current thread */
 
-CAMLprim value caml_thread_self(value unit)         /* ML */
+CAMLprim value caml_thread_self(value unit)
 {
   if (curr_thread == NULL)
     caml_invalid_argument("Thread.self: not initialized");
@@ -672,14 +671,14 @@ CAMLprim value caml_thread_self(value unit)         /* ML */
 
 /* Return the identifier of a thread */
 
-CAMLprim value caml_thread_id(value th)          /* ML */
+CAMLprim value caml_thread_id(value th)
 {
   return Ident(th);
 }
 
 /* Print uncaught exception and backtrace */
 
-CAMLprim value caml_thread_uncaught_exception(value exn)  /* ML */
+CAMLprim value caml_thread_uncaught_exception(value exn)
 {
   char * msg = caml_format_exception(exn);
   fprintf(stderr, "Thread %d killed on uncaught exception %s\n",
@@ -692,7 +691,7 @@ CAMLprim value caml_thread_uncaught_exception(value exn)  /* ML */
 
 /* Terminate current thread */
 
-CAMLprim value caml_thread_exit(value unit)   /* ML */
+CAMLprim value caml_thread_exit(value unit)
 {
   struct longjmp_buffer * exit_buf = NULL;
 
@@ -723,7 +722,7 @@ CAMLprim value caml_thread_exit(value unit)   /* ML */
 
 /* Allow re-scheduling */
 
-CAMLprim value caml_thread_yield(value unit)        /* ML */
+CAMLprim value caml_thread_yield(value unit)
 {
   if (st_masterlock_waiters(&caml_master_lock) == 0) return Val_unit;
 
@@ -744,7 +743,7 @@ CAMLprim value caml_thread_yield(value unit)        /* ML */
 
 /* Suspend the current thread until another thread terminates */
 
-CAMLprim value caml_thread_join(value th)          /* ML */
+CAMLprim value caml_thread_join(value th)
 {
   st_retcode rc = caml_threadstatus_wait(Terminated(th));
   st_check_error(rc, "Thread.join");
@@ -783,7 +782,7 @@ static struct custom_operations caml_mutex_ops = {
   custom_fixed_length_default
 };
 
-CAMLprim value caml_mutex_new(value unit)        /* ML */
+CAMLprim value caml_mutex_new(value unit)
 {
   st_mutex mut = NULL;          /* suppress warning */
   value wrapper;
@@ -794,7 +793,7 @@ CAMLprim value caml_mutex_new(value unit)        /* ML */
   return wrapper;
 }
 
-CAMLprim value caml_mutex_lock(value wrapper)     /* ML */
+CAMLprim value caml_mutex_lock(value wrapper)
 {
   st_mutex mut = Mutex_val(wrapper);
   st_retcode retcode;
@@ -811,7 +810,7 @@ CAMLprim value caml_mutex_lock(value wrapper)     /* ML */
   return Val_unit;
 }
 
-CAMLprim value caml_mutex_unlock(value wrapper)           /* ML */
+CAMLprim value caml_mutex_unlock(value wrapper)
 {
   st_mutex mut = Mutex_val(wrapper);
   st_retcode retcode;
@@ -821,7 +820,7 @@ CAMLprim value caml_mutex_unlock(value wrapper)           /* ML */
   return Val_unit;
 }
 
-CAMLprim value caml_mutex_try_lock(value wrapper)           /* ML */
+CAMLprim value caml_mutex_try_lock(value wrapper)
 {
   st_mutex mut = Mutex_val(wrapper);
   st_retcode retcode;
@@ -863,7 +862,7 @@ static struct custom_operations caml_condition_ops = {
   custom_fixed_length_default
 };
 
-CAMLprim value caml_condition_new(value unit)        /* ML */
+CAMLprim value caml_condition_new(value unit)
 {
   st_condvar cond = NULL;       /* suppress warning */
   value wrapper;
@@ -874,7 +873,7 @@ CAMLprim value caml_condition_new(value unit)        /* ML */
   return wrapper;
 }
 
-CAMLprim value caml_condition_wait(value wcond, value wmut)           /* ML */
+CAMLprim value caml_condition_wait(value wcond, value wmut)
 {
   st_condvar cond = Condition_val(wcond);
   st_mutex mut = Mutex_val(wmut);
@@ -889,14 +888,14 @@ CAMLprim value caml_condition_wait(value wcond, value wmut)           /* ML */
   return Val_unit;
 }
 
-CAMLprim value caml_condition_signal(value wrapper)           /* ML */
+CAMLprim value caml_condition_signal(value wrapper)
 {
   st_check_error(st_condvar_signal(Condition_val(wrapper)),
                  "Condition.signal");
   return Val_unit;
 }
 
-CAMLprim value caml_condition_broadcast(value wrapper)           /* ML */
+CAMLprim value caml_condition_broadcast(value wrapper)
 {
   st_check_error(st_condvar_broadcast(Condition_val(wrapper)),
                  "Condition.broadcast");
diff --git a/otherlibs/systhreads/st_win32.h b/otherlibs/systhreads/st_win32.h
index 3f598a715d..21eb674fc5 100644
--- a/otherlibs/systhreads/st_win32.h
+++ b/otherlibs/systhreads/st_win32.h
@@ -525,13 +525,13 @@ static DWORD st_atfork(void (*fn)(void))
 
 /* Signal handling -- none under Win32 */
 
-value caml_thread_sigmask(value cmd, value sigs) /* ML */
+value caml_thread_sigmask(value cmd, value sigs)
 {
   caml_invalid_argument("Thread.sigmask not implemented");
   return Val_int(0);            /* not reached */
 }
 
-value caml_wait_signal(value sigs) /* ML */
+value caml_wait_signal(value sigs)
 {
   caml_invalid_argument("Thread.wait_signal not implemented");
   return Val_int(0);            /* not reached */
diff --git a/runtime/Makefile b/runtime/Makefile
index f5c08d8798..dee25dc02a 100644
--- a/runtime/Makefile
+++ b/runtime/Makefile
@@ -26,7 +26,7 @@ BYTECODE_C_SOURCES := $(addsuffix .c, \
   floats str array io extern intern hash sys meta parsing gc_ctrl md5 obj \
   lexing callback debugger weak compact finalise custom dynlink \
   afl $(UNIX_OR_WIN32) bigarray main memprof domain \
-  skiplist codefrag)
+  skiplist codefrag prng)
 
 NATIVE_C_SOURCES := $(addsuffix .c, \
   startup_aux startup_nat main fail_nat roots_nat signals \
@@ -35,7 +35,7 @@ NATIVE_C_SOURCES := $(addsuffix .c, \
   lexing $(UNIX_OR_WIN32) printexc callback weak compact finalise custom \
   globroots backtrace_nat backtrace dynlink_nat debugger meta \
   dynlink clambda_checks afl bigarray \
-  memprof domain skiplist codefrag)
+  memprof domain skiplist codefrag prng)
 
 # Header files generated by configure
 CONFIGURED_HEADERS := caml/m.h caml/s.h caml/version.h
@@ -199,9 +199,9 @@ ld.conf: $(ROOTDIR)/Makefile.config
 # CAMLprim value caml_foo() ...
 # #else
 # CAMLprim value caml_foo() ...
-# end), horrible things will happen (duplicated entries in Runtimedef ->
+# #endif), horrible things will happen: duplicated entries in Runtimedef ->
 # double registration in Symtable -> empty entry in the PRIM table ->
-# the bytecode interpreter is confused).
+# the bytecode interpreter is confused.
 # We sort the primitive file and remove duplicates to avoid this problem.
 
 # Warning: we use "sort | uniq" instead of "sort -u" because in the MSVC
diff --git a/runtime/bigarray.c b/runtime/bigarray.c
index ed4ff67d21..03151f6946 100644
--- a/runtime/bigarray.c
+++ b/runtime/bigarray.c
@@ -89,7 +89,7 @@ CAMLexport value
 caml_ba_alloc(int flags, int num_dims, void * data, intnat * dim)
 {
   uintnat num_elts, asize, size;
-  int i;
+  int i, is_managed;
   value res;
   struct caml_ba_array * b;
   intnat dimcopy[CAML_BA_MAX_NUM_DIMS];
@@ -97,23 +97,23 @@ caml_ba_alloc(int flags, int num_dims, void * data, intnat * dim)
   CAMLassert(num_dims >= 0 && num_dims <= CAML_BA_MAX_NUM_DIMS);
   CAMLassert((flags & CAML_BA_KIND_MASK) <= CAML_BA_CHAR);
   for (i = 0; i < num_dims; i++) dimcopy[i] = dim[i];
-  size = 0;
-  if (data == NULL) {
-    num_elts = 1;
-    for (i = 0; i < num_dims; i++) {
-      if (caml_umul_overflow(num_elts, dimcopy[i], &num_elts))
-        caml_raise_out_of_memory();
-    }
-    if (caml_umul_overflow(num_elts,
-                           caml_ba_element_size[flags & CAML_BA_KIND_MASK],
-                           &size))
+  num_elts = 1;
+  for (i = 0; i < num_dims; i++) {
+    if (caml_umul_overflow(num_elts, dimcopy[i], &num_elts))
       caml_raise_out_of_memory();
+  }
+  if (caml_umul_overflow(num_elts,
+                         caml_ba_element_size[flags & CAML_BA_KIND_MASK],
+                         &size))
+    caml_raise_out_of_memory();
+  if (data == NULL) {
     data = malloc(size);
     if (data == NULL && size != 0) caml_raise_out_of_memory();
     flags |= CAML_BA_MANAGED;
   }
   asize = SIZEOF_BA_ARRAY + num_dims * sizeof(intnat);
-  res = caml_alloc_custom_mem(&caml_ba_ops, asize, size);
+  is_managed = ((flags & CAML_BA_MANAGED_MASK) == CAML_BA_MANAGED);
+  res = caml_alloc_custom_mem(&caml_ba_ops, asize, is_managed ? size : 0);
   b = Caml_ba_array_val(res);
   b->data = data;
   b->num_dims = num_dims;
diff --git a/runtime/caml/alloc.h b/runtime/caml/alloc.h
index 13f0fac2fb..816da799bb 100644
--- a/runtime/caml/alloc.h
+++ b/runtime/caml/alloc.h
@@ -17,9 +17,6 @@
 #define CAML_ALLOC_H
 
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "misc.h"
 #include "mlvalues.h"
 
diff --git a/runtime/caml/bigarray.h b/runtime/caml/bigarray.h
index fc1fb14570..1664ae3f6e 100644
--- a/runtime/caml/bigarray.h
+++ b/runtime/caml/bigarray.h
@@ -16,9 +16,6 @@
 #ifndef CAML_BIGARRAY_H
 #define CAML_BIGARRAY_H
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "config.h"
 #include "mlvalues.h"
 
diff --git a/runtime/caml/callback.h b/runtime/caml/callback.h
index eef3342ec7..5c45995b8a 100644
--- a/runtime/caml/callback.h
+++ b/runtime/caml/callback.h
@@ -18,9 +18,6 @@
 #ifndef CAML_CALLBACK_H
 #define CAML_CALLBACK_H
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "mlvalues.h"
 
 #ifdef __cplusplus
diff --git a/runtime/caml/camlatomic.h b/runtime/caml/camlatomic.h
new file mode 100644
index 0000000000..7206f0579a
--- /dev/null
+++ b/runtime/caml/camlatomic.h
@@ -0,0 +1,85 @@
+/**************************************************************************/
+/*                                                                        */
+/*                                 OCaml                                  */
+/*                                                                        */
+/*      KC Sivaramakrishnan, Indian Institute of Technology, Madras       */
+/*                Stephen Dolan, University of Cambridge                  */
+/*                                                                        */
+/*   Copyright 2018 Indian Institute of Technology, Madras                */
+/*   Copyright 2018 University of Cambridge                               */
+/*                                                                        */
+/*   All rights reserved.  This file is distributed under the terms of    */
+/*   the GNU Lesser General Public License version 2.1, with the          */
+/*   special exception on linking described in the file LICENSE.          */
+/*                                                                        */
+/**************************************************************************/
+#ifndef CAML_ATOMIC_H
+#define CAML_ATOMIC_H
+
+#include "config.h"
+
+/* On platforms supporting C11 atomics, this file just includes <stdatomic.h>.
+
+   On other platforms, this file includes platform-specific stubs for
+   the subset of C11 atomics needed by the OCaml runtime
+ */
+
+#ifdef __cplusplus
+
+extern "C++" {
+#include <atomic>
+#define ATOMIC_UINTNAT_INIT(x) (x)
+typedef std::atomic<uintnat> atomic_uintnat;
+typedef std::atomic<intnat> atomic_intnat;
+using std::memory_order_relaxed;
+using std::memory_order_acquire;
+using std::memory_order_release;
+using std::memory_order_acq_rel;
+using std::memory_order_seq_cst;
+}
+
+#elif defined(HAS_STDATOMIC_H)
+
+#include <stdatomic.h>
+#define ATOMIC_UINTNAT_INIT(x) (x)
+typedef _Atomic uintnat atomic_uintnat;
+typedef _Atomic intnat atomic_intnat;
+
+#elif defined(__GNUC__)
+
+/* Support for versions of gcc which have built-in atomics but do not
+   expose stdatomic.h (e.g. gcc 4.8) */
+typedef enum memory_order {
+  memory_order_relaxed = __ATOMIC_RELAXED,
+  memory_order_acquire = __ATOMIC_ACQUIRE,
+  memory_order_release = __ATOMIC_RELEASE,
+  memory_order_acq_rel = __ATOMIC_ACQ_REL,
+  memory_order_seq_cst = __ATOMIC_SEQ_CST
+} memory_order;
+
+#define ATOMIC_UINTNAT_INIT(x) { (x) }
+typedef struct { uintnat repr; } atomic_uintnat;
+typedef struct { intnat repr; } atomic_intnat;
+
+#define atomic_load_explicit(x, m) __atomic_load_n(&(x)->repr, (m))
+#define atomic_load(x) atomic_load_explicit((x), memory_order_seq_cst)
+#define atomic_store_explicit(x, v, m) __atomic_store_n(&(x)->repr, (v), (m))
+#define atomic_store(x, v) atomic_store_explicit((x), (v), memory_order_seq_cst)
+#define atomic_compare_exchange_strong(x, oldv, newv) \
+  __atomic_compare_exchange_n( \
+    &(x)->repr, \
+    (oldv), (newv), 0, \
+    memory_order_seq_cst, memory_order_seq_cst)
+#define atomic_exchange(x, newv) \
+  __atomic_exchange_n(&(x)->repr, (newv), memory_order_seq_cst)
+#define atomic_fetch_add(x, n) \
+  __atomic_fetch_add(&(x)->repr, (n), memory_order_seq_cst)
+#define atomic_fetch_or(x, n) \
+  __atomic_fetch_or(&(x)->repr, (n), memory_order_seq_cst)
+#define atomic_thread_fence __atomic_thread_fence
+
+#else
+#error "C11 atomics are unavailable on this platform. See camlatomic.h"
+#endif
+
+#endif /* CAML_ATOMIC_H */
diff --git a/runtime/caml/compatibility.h b/runtime/caml/compatibility.h
deleted file mode 100644
index 1c109aa470..0000000000
--- a/runtime/caml/compatibility.h
+++ /dev/null
@@ -1,373 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/*                                 OCaml                                  */
-/*                                                                        */
-/*           Damien Doligez, projet Moscova, INRIA Rocquencourt           */
-/*                                                                        */
-/*   Copyright 2003 Institut National de Recherche en Informatique et     */
-/*     en Automatique.                                                    */
-/*                                                                        */
-/*   All rights reserved.  This file is distributed under the terms of    */
-/*   the GNU Lesser General Public License version 2.1, with the          */
-/*   special exception on linking described in the file LICENSE.          */
-/*                                                                        */
-/**************************************************************************/
-
-/* definitions for compatibility with old identifiers */
-
-#ifndef CAML_COMPATIBILITY_H
-#define CAML_COMPATIBILITY_H
-
-/* internal global variables renamed between 4.02.1 and 4.03.0 */
-#define caml_stat_top_heap_size Bsize_wsize(caml_stat_top_heap_wsz)
-#define caml_stat_heap_size Bsize_wsize(caml_stat_heap_wsz)
-
-#ifndef CAML_NAME_SPACE
-
-/*
-   #define --> CAMLextern  (defined with CAMLexport or CAMLprim)
-   (rien)  --> CAMLprim
-   g       --> global C identifier
-   x       --> special case
-
-   SP* signals the special cases:
-   - when the identifier was not simply prefixed with [caml_]
-   - when the [caml_] version was already used for something else, and
-     was renamed out of the way (watch out for [caml_alloc] and
-     [caml_array_bound_error] in *.s)
-*/
-
-/* a faire:
-   - ui_*   (reverifier que win32.c n'en depend pas)
-*/
-
-
-/* **** alloc.c */
-#define alloc CAML_DEPRECATED("alloc", "caml_alloc") caml_alloc /*SP*/
-#define alloc_small CAML_DEPRECATED("alloc_small", "caml_alloc_small") caml_alloc_small
-#define alloc_tuple CAML_DEPRECATED("alloc_tuple", "caml_alloc_tuple") caml_alloc_tuple
-#define alloc_string CAML_DEPRECATED("alloc_string", "caml_alloc_string") caml_alloc_string
-#define alloc_final CAML_DEPRECATED("alloc_final", "caml_alloc_final") caml_alloc_final
-#define copy_string CAML_DEPRECATED("copy_string", "caml_copy_string") caml_copy_string
-#define alloc_array CAML_DEPRECATED("alloc_array", "caml_alloc_array") caml_alloc_array
-#define copy_string_array CAML_DEPRECATED("copy_string_array", "caml_copy_string_array") caml_copy_string_array
-#define convert_flag_list CAML_DEPRECATED("convert_flag_list", "caml_convert_flag_list") caml_convert_flag_list
-
-/* **** array.c */
-
-/* **** backtrace.c */
-#define backtrace_active CAML_DEPRECATED("backtrace_active", "caml_backtrace_active") caml_backtrace_active
-#define backtrace_pos CAML_DEPRECATED("backtrace_pos", "caml_backtrace_pos") caml_backtrace_pos
-#define backtrace_buffer CAML_DEPRECATED("backtrace_buffer", "caml_backtrace_buffer") caml_backtrace_buffer
-#define backtrace_last_exn CAML_DEPRECATED("backtrace_last_exn", "caml_backtrace_last_exn") caml_backtrace_last_exn
-#define print_exception_backtrace CAML_DEPRECATED("print_exception_backtrace", "caml_print_exception_backtrace") caml_print_exception_backtrace
-
-/* **** callback.c */
-#define callback_depth CAML_DEPRECATED("callback_depth", "caml_callback_depth") caml_callback_depth
-#define callbackN_exn CAML_DEPRECATED("callbackN_exn", "caml_callbackN_exn") caml_callbackN_exn
-#define callback_exn CAML_DEPRECATED("callback_exn", "caml_callback_exn") caml_callback_exn
-#define callback2_exn CAML_DEPRECATED("callback2_exn", "caml_callback2_exn") caml_callback2_exn
-#define callback3_exn CAML_DEPRECATED("callback3_exn", "caml_callback3_exn") caml_callback3_exn
-#define callback CAML_DEPRECATED("callback", "caml_callback") caml_callback
-#define callback2 CAML_DEPRECATED("callback2", "caml_callback2") caml_callback2
-#define callback3 CAML_DEPRECATED("callback3", "caml_callback3") caml_callback3
-#define callbackN CAML_DEPRECATED("callbackN", "caml_callbackN") caml_callbackN
-
-/* **** compact.c */
-
-/* **** compare.c */
-#define compare_unordered CAML_DEPRECATED("compare_unordered", "caml_compare_unordered") caml_compare_unordered
-
-/* **** custom.c */
-#define alloc_custom CAML_DEPRECATED("alloc_custom", "caml_alloc_custom") caml_alloc_custom
-#define register_custom_operations CAML_DEPRECATED("register_custom_operations", "caml_register_custom_operations") caml_register_custom_operations
-
-/* **** debugger.c */
-
-/* **** dynlink.c */
-
-/* **** extern.c */
-#define output_val CAML_DEPRECATED("output_val", "caml_output_val") caml_output_val
-#define output_value_to_malloc CAML_DEPRECATED("output_value_to_malloc", "caml_output_value_to_malloc") caml_output_value_to_malloc
-#define output_value_to_block CAML_DEPRECATED("output_value_to_block", "caml_output_value_to_block") caml_output_value_to_block
-#define serialize_int_1 CAML_DEPRECATED("serialize_int_1", "caml_serialize_int_1") caml_serialize_int_1
-#define serialize_int_2 CAML_DEPRECATED("serialize_int_2", "caml_serialize_int_2") caml_serialize_int_2
-#define serialize_int_4 CAML_DEPRECATED("serialize_int_4", "caml_serialize_int_4") caml_serialize_int_4
-#define serialize_int_8 CAML_DEPRECATED("serialize_int_8", "caml_serialize_int_8") caml_serialize_int_8
-#define serialize_float_4 CAML_DEPRECATED("serialize_float_4", "caml_serialize_float_4") caml_serialize_float_4
-#define serialize_float_8 CAML_DEPRECATED("serialize_float_8", "caml_serialize_float_8") caml_serialize_float_8
-#define serialize_block_1 CAML_DEPRECATED("serialize_block_1", "caml_serialize_block_1") caml_serialize_block_1
-#define serialize_block_2 CAML_DEPRECATED("serialize_block_2", "caml_serialize_block_2") caml_serialize_block_2
-#define serialize_block_4 CAML_DEPRECATED("serialize_block_4", "caml_serialize_block_4") caml_serialize_block_4
-#define serialize_block_8 CAML_DEPRECATED("serialize_block_8", "caml_serialize_block_8") caml_serialize_block_8
-#define serialize_block_float_8 CAML_DEPRECATED("serialize_block_float_8", "caml_serialize_block_float_8") caml_serialize_block_float_8
-
-/* **** fail.c */
-#define external_raise CAML_DEPRECATED("external_raise", "caml_external_raise") caml_external_raise
-#define mlraise CAML_DEPRECATED("mlraise", "caml_raise") caml_raise /*SP*/
-#define raise_constant CAML_DEPRECATED("raise_constant", "caml_raise_constant") caml_raise_constant
-#define raise_with_arg CAML_DEPRECATED("raise_with_arg", "caml_raise_with_arg") caml_raise_with_arg
-#define raise_with_string CAML_DEPRECATED("raise_with_string", "caml_raise_with_string") caml_raise_with_string
-#define failwith CAML_DEPRECATED("failwith", "caml_failwith") caml_failwith
-#define invalid_argument CAML_DEPRECATED("invalid_argument", "caml_invalid_argument") caml_invalid_argument
-#define array_bound_error CAML_DEPRECATED("array_bound_error", "caml_array_bound_error") caml_array_bound_error /*SP*/
-#define raise_out_of_memory CAML_DEPRECATED("raise_out_of_memory", "caml_raise_out_of_memory") caml_raise_out_of_memory
-#define raise_stack_overflow CAML_DEPRECATED("raise_stack_overflow", "caml_raise_stack_overflow") caml_raise_stack_overflow
-#define raise_sys_error CAML_DEPRECATED("raise_sys_error", "caml_raise_sys_error") caml_raise_sys_error
-#define raise_end_of_file CAML_DEPRECATED("raise_end_of_file", "caml_raise_end_of_file") caml_raise_end_of_file
-#define raise_zero_divide CAML_DEPRECATED("raise_zero_divide", "caml_raise_zero_divide") caml_raise_zero_divide
-#define raise_not_found CAML_DEPRECATED("raise_not_found", "caml_raise_not_found") caml_raise_not_found
-#define raise_sys_blocked_io CAML_DEPRECATED("raise_sys_blocked_io", "caml_raise_sys_blocked_io") caml_raise_sys_blocked_io
-/* **** runtime/fail_nat.c */
-/* **** runtime/<arch>.s */
-
-/* **** finalise.c */
-
-/* **** fix_code.c */
-
-/* **** floats.c */
-/*#define Double_val caml_Double_val             done in mlvalues.h as needed */
-/*#define Store_double_val caml_Store_double_val done in mlvalues.h as needed */
-#define copy_double CAML_DEPRECATED("copy_double", "caml_copy_double") caml_copy_double
-
-/* **** freelist.c */
-
-/* **** gc_ctrl.c */
-
-/* **** globroots.c */
-#define register_global_root CAML_DEPRECATED("register_global_root", "caml_register_global_root") caml_register_global_root
-#define remove_global_root CAML_DEPRECATED("remove_global_root", "caml_remove_global_root") caml_remove_global_root
-
-/* **** hash.c */
-#define hash_variant CAML_DEPRECATED("hash_variant", "caml_hash_variant") caml_hash_variant
-
-/* **** instrtrace.c */
-
-/* **** intern.c */
-#define input_val CAML_DEPRECATED("input_val", "caml_input_val") caml_input_val
-#define input_val_from_string CAML_DEPRECATED("input_val_from_string", "caml_input_val_from_string") caml_input_val_from_string
-#define input_value_from_malloc CAML_DEPRECATED("input_value_from_malloc", "caml_input_value_from_malloc") caml_input_value_from_malloc
-#define input_value_from_block CAML_DEPRECATED("input_value_from_block", "caml_input_value_from_block") caml_input_value_from_block
-#define deserialize_uint_1 CAML_DEPRECATED("deserialize_uint_1", "caml_deserialize_uint_1") caml_deserialize_uint_1
-#define deserialize_sint_1 CAML_DEPRECATED("deserialize_sint_1", "caml_deserialize_sint_1") caml_deserialize_sint_1
-#define deserialize_uint_2 CAML_DEPRECATED("deserialize_uint_2", "caml_deserialize_uint_2") caml_deserialize_uint_2
-#define deserialize_sint_2 CAML_DEPRECATED("deserialize_sint_2", "caml_deserialize_sint_2") caml_deserialize_sint_2
-#define deserialize_uint_4 CAML_DEPRECATED("deserialize_uint_4", "caml_deserialize_uint_4") caml_deserialize_uint_4
-#define deserialize_sint_4 CAML_DEPRECATED("deserialize_sint_4", "caml_deserialize_sint_4") caml_deserialize_sint_4
-#define deserialize_uint_8 CAML_DEPRECATED("deserialize_uint_8", "caml_deserialize_uint_8") caml_deserialize_uint_8
-#define deserialize_sint_8 CAML_DEPRECATED("deserialize_sint_8", "caml_deserialize_sint_8") caml_deserialize_sint_8
-#define deserialize_float_4 CAML_DEPRECATED("deserialize_float_4", "caml_deserialize_float_4") caml_deserialize_float_4
-#define deserialize_float_8 CAML_DEPRECATED("deserialize_float_8", "caml_deserialize_float_8") caml_deserialize_float_8
-#define deserialize_block_1 CAML_DEPRECATED("deserialize_block_1", "caml_deserialize_block_1") caml_deserialize_block_1
-#define deserialize_block_2 CAML_DEPRECATED("deserialize_block_2", "caml_deserialize_block_2") caml_deserialize_block_2
-#define deserialize_block_4 CAML_DEPRECATED("deserialize_block_4", "caml_deserialize_block_4") caml_deserialize_block_4
-#define deserialize_block_8 CAML_DEPRECATED("deserialize_block_8", "caml_deserialize_block_8") caml_deserialize_block_8
-#define deserialize_block_float_8 CAML_DEPRECATED("deserialize_block_float_8", "caml_deserialize_block_float_8") caml_deserialize_block_float_8
-#define deserialize_error CAML_DEPRECATED("deserialize_error", "caml_deserialize_error") caml_deserialize_error
-
-/* **** interp.c */
-
-/* **** ints.c */
-#define int32_ops CAML_DEPRECATED("int32_ops", "caml_int32_ops") caml_int32_ops
-#define copy_int32 CAML_DEPRECATED("copy_int32", "caml_copy_int32") caml_copy_int32
-/*#define Int64_val caml_Int64_val   *** done in mlvalues.h as needed */
-#define int64_ops CAML_DEPRECATED("int64_ops", "caml_int64_ops") caml_int64_ops
-#define copy_int64 CAML_DEPRECATED("copy_int64", "caml_copy_int64") caml_copy_int64
-#define nativeint_ops CAML_DEPRECATED("nativeint_ops", "caml_nativeint_ops") caml_nativeint_ops
-#define copy_nativeint CAML_DEPRECATED("copy_nativeint", "caml_copy_nativeint") caml_copy_nativeint
-
-/* **** io.c */
-#define channel_mutex_free CAML_DEPRECATED("channel_mutex_free", "caml_channel_mutex_free") caml_channel_mutex_free
-#define channel_mutex_lock CAML_DEPRECATED("channel_mutex_lock", "caml_channel_mutex_lock") caml_channel_mutex_lock
-#define channel_mutex_unlock CAML_DEPRECATED("channel_mutex_unlock", "caml_channel_mutex_unlock") caml_channel_mutex_unlock
-#define channel_mutex_unlock_exn CAML_DEPRECATED("channel_mutex_unlock_exn", "caml_channel_mutex_unlock_exn") caml_channel_mutex_unlock_exn
-#define all_opened_channels CAML_DEPRECATED("all_opened_channels", "caml_all_opened_channels") caml_all_opened_channels
-#define open_descriptor_in CAML_DEPRECATED("open_descriptor_in", "caml_open_descriptor_in") caml_open_descriptor_in /*SP*/
-#define open_descriptor_out CAML_DEPRECATED("open_descriptor_out", "caml_open_descriptor_out") caml_open_descriptor_out /*SP*/
-#define close_channel CAML_DEPRECATED("close_channel", "caml_close_channel") caml_close_channel /*SP*/
-#define channel_size CAML_DEPRECATED("channel_size", "caml_channel_size") caml_channel_size /*SP*/
-#define channel_binary_mode CAML_DEPRECATED("channel_binary_mode", "caml_channel_binary_mode") caml_channel_binary_mode
-#define flush_partial CAML_DEPRECATED("flush_partial", "caml_flush_partial") caml_flush_partial /*SP*/
-#define flush CAML_DEPRECATED("flush", "caml_flush") caml_flush /*SP*/
-#define putword CAML_DEPRECATED("putword", "caml_putword") caml_putword
-#define putblock CAML_DEPRECATED("putblock", "caml_putblock") caml_putblock
-#define really_putblock CAML_DEPRECATED("really_putblock", "caml_really_putblock") caml_really_putblock
-#define seek_out CAML_DEPRECATED("seek_out", "caml_seek_out") caml_seek_out /*SP*/
-#define pos_out CAML_DEPRECATED("pos_out", "caml_pos_out") caml_pos_out /*SP*/
-#define do_read CAML_DEPRECATED("do_read", "caml_do_read") caml_do_read
-#define refill CAML_DEPRECATED("refill", "caml_refill") caml_refill
-#define getword CAML_DEPRECATED("getword", "caml_getword") caml_getword
-#define getblock CAML_DEPRECATED("getblock", "caml_getblock") caml_getblock
-#define really_getblock CAML_DEPRECATED("really_getblock", "caml_really_getblock") caml_really_getblock
-#define seek_in CAML_DEPRECATED("seek_in", "caml_seek_in") caml_seek_in /*SP*/
-#define pos_in CAML_DEPRECATED("pos_in", "caml_pos_in") caml_pos_in /*SP*/
-#define input_scan_line CAML_DEPRECATED("input_scan_line", "caml_input_scan_line") caml_input_scan_line /*SP*/
-#define finalize_channel CAML_DEPRECATED("finalize_channel", "caml_finalize_channel") caml_finalize_channel
-#define alloc_channel CAML_DEPRECATED("alloc_channel", "caml_alloc_channel") caml_alloc_channel
-/*#define Val_file_offset caml_Val_file_offset   *** done in io.h as needed */
-/*#define File_offset_val caml_File_offset_val   *** done in io.h as needed */
-
-/* **** lexing.c */
-
-/* **** main.c */
-/* *** no change */
-
-/* **** major_gc.c */
-#define heap_start CAML_DEPRECATED("heap_start", "caml_heap_start") caml_heap_start
-#define page_table CAML_DEPRECATED("page_table", "caml_page_table") caml_page_table
-
-/* **** md5.c */
-#define md5_string CAML_DEPRECATED("md5_string", "caml_md5_string") caml_md5_string
-#define md5_chan CAML_DEPRECATED("md5_chan", "caml_md5_chan") caml_md5_chan
-#define MD5Init CAML_DEPRECATED("MD5Init", "caml_MD5Init") caml_MD5Init
-#define MD5Update CAML_DEPRECATED("MD5Update", "caml_MD5Update") caml_MD5Update
-#define MD5Final CAML_DEPRECATED("MD5Final", "caml_MD5Final") caml_MD5Final
-#define MD5Transform CAML_DEPRECATED("MD5Transform", "caml_MD5Transform") caml_MD5Transform
-
-/* **** memory.c */
-#define alloc_shr CAML_DEPRECATED("alloc_shr", "caml_alloc_shr") caml_alloc_shr
-#define initialize CAML_DEPRECATED("initialize", "caml_initialize") caml_initialize
-#define modify CAML_DEPRECATED("modify", "caml_modify") caml_modify
-#define stat_alloc CAML_DEPRECATED("stat_alloc", "caml_stat_alloc") caml_stat_alloc
-#define stat_free CAML_DEPRECATED("stat_free", "caml_stat_free") caml_stat_free
-#define stat_resize CAML_DEPRECATED("stat_resize", "caml_stat_resize") caml_stat_resize
-
-/* **** meta.c */
-
-/* **** minor_gc.c */
-#define young_start CAML_DEPRECATED("young_start", "caml_young_start") caml_young_start
-#define young_end CAML_DEPRECATED("young_end", "caml_young_end") caml_young_end
-#define young_ptr CAML_DEPRECATED("young_ptr", "caml_young_ptr") caml_young_ptr
-#define young_limit CAML_DEPRECATED("young_limit", "caml_young_limit") caml_young_limit
-#define ref_table CAML_DEPRECATED("ref_table", "caml_ref_table") caml_ref_table
-#define minor_collection CAML_DEPRECATED("minor_collection", "caml_minor_collection") caml_minor_collection
-#define check_urgent_gc CAML_DEPRECATED("check_urgent_gc", "caml_check_urgent_gc") caml_check_urgent_gc
-
-/* **** misc.c */
-
-/* **** obj.c */
-
-/* **** parsing.c */
-
-/* **** prims.c */
-
-/* **** printexc.c */
-#define format_caml_exception CAML_DEPRECATED("format_caml_exception", "caml_format_exception") caml_format_exception /*SP*/
-
-/* **** roots.c */
-#define local_roots CAML_DEPRECATED("local_roots", "caml_local_roots") caml_local_roots
-#define scan_roots_hook CAML_DEPRECATED("scan_roots_hook", "caml_scan_roots_hook") caml_scan_roots_hook
-#define do_local_roots CAML_DEPRECATED("do_local_roots", "caml_do_local_roots") caml_do_local_roots
-
-/* **** signals.c */
-#define pending_signals CAML_DEPRECATED("pending_signals", "caml_pending_signals") caml_pending_signals
-#define something_to_do CAML_DEPRECATED("something_to_do", "caml_something_to_do") caml_something_to_do
-#define enter_blocking_section_hook CAML_DEPRECATED("enter_blocking_section_hook", "caml_enter_blocking_section_hook") caml_enter_blocking_section_hook
-#define leave_blocking_section_hook CAML_DEPRECATED("leave_blocking_section_hook", "caml_leave_blocking_section_hook") caml_leave_blocking_section_hook
-#define enter_blocking_section CAML_DEPRECATED("enter_blocking_section", "caml_enter_blocking_section") caml_enter_blocking_section
-#define leave_blocking_section CAML_DEPRECATED("leave_blocking_section", "caml_leave_blocking_section") caml_leave_blocking_section
-#define convert_signal_number CAML_DEPRECATED("convert_signal_number", "caml_convert_signal_number") caml_convert_signal_number
-
-/* **** runtime/signals.c */
-#define garbage_collection CAML_DEPRECATED("garbage_collection", "caml_garbage_collection") caml_garbage_collection
-
-/* **** stacks.c */
-#define stack_low CAML_DEPRECATED("stack_low", "caml_stack_low") caml_stack_low
-#define stack_high CAML_DEPRECATED("stack_high", "caml_stack_high") caml_stack_high
-#define stack_threshold CAML_DEPRECATED("stack_threshold", "caml_stack_threshold") caml_stack_threshold
-#define extern_sp CAML_DEPRECATED("extern_sp", "caml_extern_sp") caml_extern_sp
-#define trapsp CAML_DEPRECATED("trapsp", "caml_trapsp") caml_trapsp
-#define trap_barrier CAML_DEPRECATED("trap_barrier", "caml_trap_barrier") caml_trap_barrier
-
-/* **** startup.c */
-#define atom_table CAML_DEPRECATED("atom_table", "caml_atom_table") caml_atom_table
-/* **** runtime/startup_nat.c */
-#define static_data_start CAML_DEPRECATED("static_data_start", "caml_static_data_start") caml_static_data_start
-#define static_data_end CAML_DEPRECATED("static_data_end", "caml_static_data_end") caml_static_data_end
-
-/* **** str.c */
-#define string_length CAML_DEPRECATED("string_length", "caml_string_length") caml_string_length
-
-/* **** sys.c */
-#define sys_error CAML_DEPRECATED("sys_error", "caml_sys_error") caml_sys_error
-
-/* **** terminfo.c */
-
-/* **** unix.c  &  win32.c */
-#define search_exe_in_path CAML_DEPRECATED("search_exe_in_path", "caml_search_exe_in_path") caml_search_exe_in_path
-
-/* **** weak.c */
-
-/* **** asmcomp/asmlink.ml */
-
-/* **** asmcomp/cmmgen.ml */
-
-/* **** asmcomp/asmlink.ml, asmcomp/cmmgen.ml, asmcomp/compilenv.ml */
-
-/* ************************************************************* */
-
-/* **** otherlibs/bigarray */
-#define int8 caml_ba_int8
-#define uint8 caml_ba_uint8
-#define int16 caml_ba_int16
-#define uint16 caml_ba_uint16
-#define MAX_NUM_DIMS CAML_DEPRECATED("MAX_NUM_DIMS", "CAML_BA_MAX_NUM_DIMS") CAML_BA_MAX_NUM_DIMS
-#define caml_bigarray_kind CAML_DEPRECATED("caml_bigarray_kind", "caml_ba_kind") caml_ba_kind
-#define BIGARRAY_FLOAT32 CAML_DEPRECATED("BIGARRAY_FLOAT32", "CAML_BA_FLOAT32") CAML_BA_FLOAT32
-#define BIGARRAY_FLOAT64 CAML_DEPRECATED("BIGARRAY_FLOAT64", "CAML_BA_FLOAT64") CAML_BA_FLOAT64
-#define BIGARRAY_SINT8 CAML_DEPRECATED("BIGARRAY_SINT8", "CAML_BA_SINT8") CAML_BA_SINT8
-#define BIGARRAY_UINT8 CAML_DEPRECATED("BIGARRAY_UINT8", "CAML_BA_UINT8") CAML_BA_UINT8
-#define BIGARRAY_SINT16 CAML_DEPRECATED("BIGARRAY_SINT16", "CAML_BA_SINT16") CAML_BA_SINT16
-#define BIGARRAY_UINT16 CAML_DEPRECATED("BIGARRAY_UINT16", "CAML_BA_UINT16") CAML_BA_UINT16
-#define BIGARRAY_INT32 CAML_DEPRECATED("BIGARRAY_INT32", "CAML_BA_INT32") CAML_BA_INT32
-#define BIGARRAY_INT64 CAML_DEPRECATED("BIGARRAY_INT64", "CAML_BA_INT64") CAML_BA_INT64
-#define BIGARRAY_CAML_INT CAML_DEPRECATED("BIGARRAY_CAML_INT", "CAML_BA_CAML_INT") CAML_BA_CAML_INT
-#define BIGARRAY_NATIVE_INT CAML_DEPRECATED("BIGARRAY_NATIVE_INT", "CAML_BA_NATIVE_INT") CAML_BA_NATIVE_INT
-#define BIGARRAY_COMPLEX32 CAML_DEPRECATED("BIGARRAY_COMPLEX32", "CAML_BA_COMPLEX32") CAML_BA_COMPLEX32
-#define BIGARRAY_COMPLEX64 CAML_DEPRECATED("BIGARRAY_COMPLEX64", "CAML_BA_COMPLEX64") CAML_BA_COMPLEX64
-#define BIGARRAY_KIND_MASK CAML_DEPRECATED("BIGARRAY_KIND_MASK", "CAML_BA_KIND_MASK") CAML_BA_KIND_MASK
-#define caml_bigarray_layout CAML_DEPRECATED("caml_bigarray_layout", "caml_ba_layout") caml_ba_layout
-#define BIGARRAY_C_LAYOUT CAML_DEPRECATED("BIGARRAY_C_LAYOUT", "CAML_BA_C_LAYOUT") CAML_BA_C_LAYOUT
-#define BIGARRAY_FORTRAN_LAYOUT CAML_DEPRECATED("BIGARRAY_FORTRAN_LAYOUT", "CAML_BA_FORTRAN_LAYOUT") CAML_BA_FORTRAN_LAYOUT
-#define BIGARRAY_LAYOUT_MASK CAML_DEPRECATED("BIGARRAY_LAYOUT_MASK", "CAML_BA_LAYOUT_MASK") CAML_BA_LAYOUT_MASK
-#define caml_bigarray_managed CAML_DEPRECATED("caml_bigarray_managed", "caml_ba_managed") caml_ba_managed
-#define BIGARRAY_EXTERNAL CAML_DEPRECATED("BIGARRAY_EXTERNAL", "CAML_BA_EXTERNAL") CAML_BA_EXTERNAL
-#define BIGARRAY_MANAGED CAML_DEPRECATED("BIGARRAY_MANAGED", "CAML_BA_MANAGED") CAML_BA_MANAGED
-#define BIGARRAY_MAPPED_FILE CAML_DEPRECATED("BIGARRAY_MAPPED_FILE", "CAML_BA_MAPPED_FILE") CAML_BA_MAPPED_FILE
-#define BIGARRAY_MANAGED_MASK CAML_DEPRECATED("BIGARRAY_MANAGED_MASK", "CAML_BA_MANAGED_MASK") CAML_BA_MANAGED_MASK
-#define caml_bigarray_proxy CAML_DEPRECATED("caml_bigarray_proxy", "caml_ba_proxy") caml_ba_proxy
-#define caml_bigarray CAML_DEPRECATED("caml_bigarray", "caml_ba_array") caml_ba_array
-#define Bigarray_val CAML_DEPRECATED("Bigarray_val", "Caml_ba_array_val") Caml_ba_array_val
-#define Data_bigarray_val CAML_DEPRECATED("Data_bigarray_val", "Caml_ba_data_val") Caml_ba_data_val
-#define alloc_bigarray CAML_DEPRECATED("alloc_bigarray", "caml_ba_alloc") caml_ba_alloc
-#define alloc_bigarray_dims CAML_DEPRECATED("alloc_bigarray_dims", "caml_ba_alloc_dims") caml_ba_alloc_dims
-#define bigarray_map_file CAML_DEPRECATED("bigarray_map_file", "caml_ba_map_file") caml_ba_map_file
-#define bigarray_unmap_file CAML_DEPRECATED("bigarray_unmap_file", "caml_ba_unmap_file") caml_ba_unmap_file
-#define bigarray_element_size CAML_DEPRECATED("bigarray_element_size", "caml_ba_element_size") caml_ba_element_size
-#define bigarray_byte_size CAML_DEPRECATED("bigarray_byte_size", "caml_ba_byte_size") caml_ba_byte_size
-#define bigarray_deserialize CAML_DEPRECATED("bigarray_deserialize", "caml_ba_deserialize") caml_ba_deserialize
-#define MAX_BIGARRAY_MEMORY CAML_DEPRECATED("MAX_BIGARRAY_MEMORY", "CAML_BA_MAX_MEMORY") CAML_BA_MAX_MEMORY
-#define bigarray_create CAML_DEPRECATED("bigarray_create", "caml_ba_create") caml_ba_create
-#define bigarray_get_N CAML_DEPRECATED("bigarray_get_N", "caml_ba_get_N") caml_ba_get_N
-#define bigarray_get_1 CAML_DEPRECATED("bigarray_get_1", "caml_ba_get_1") caml_ba_get_1
-#define bigarray_get_2 CAML_DEPRECATED("bigarray_get_2", "caml_ba_get_2") caml_ba_get_2
-#define bigarray_get_3 CAML_DEPRECATED("bigarray_get_3", "caml_ba_get_3") caml_ba_get_3
-#define bigarray_get_generic CAML_DEPRECATED("bigarray_get_generic", "caml_ba_get_generic") caml_ba_get_generic
-#define bigarray_set_1 CAML_DEPRECATED("bigarray_set_1", "caml_ba_set_1") caml_ba_set_1
-#define bigarray_set_2 CAML_DEPRECATED("bigarray_set_2", "caml_ba_set_2") caml_ba_set_2
-#define bigarray_set_3 CAML_DEPRECATED("bigarray_set_3", "caml_ba_set_3") caml_ba_set_3
-#define bigarray_set_N CAML_DEPRECATED("bigarray_set_N", "caml_ba_set_N") caml_ba_set_N
-#define bigarray_set_generic CAML_DEPRECATED("bigarray_set_generic", "caml_ba_set_generic") caml_ba_set_generic
-#define bigarray_num_dims CAML_DEPRECATED("bigarray_num_dims", "caml_ba_num_dims") caml_ba_num_dims
-#define bigarray_dim CAML_DEPRECATED("bigarray_dim", "caml_ba_dim") caml_ba_dim
-#define bigarray_kind CAML_DEPRECATED("bigarray_kind", "caml_ba_kind") caml_ba_kind
-#define bigarray_layout CAML_DEPRECATED("bigarray_layout", "caml_ba_layout") caml_ba_layout
-#define bigarray_slice CAML_DEPRECATED("bigarray_slice", "caml_ba_slice") caml_ba_slice
-#define bigarray_sub CAML_DEPRECATED("bigarray_sub", "caml_ba_sub") caml_ba_sub
-#define bigarray_blit CAML_DEPRECATED("bigarray_blit", "caml_ba_blit") caml_ba_blit
-#define bigarray_fill CAML_DEPRECATED("bigarray_fill", "caml_ba_fill") caml_ba_fill
-#define bigarray_reshape CAML_DEPRECATED("bigarray_reshape", "caml_ba_reshape") caml_ba_reshape
-#define bigarray_init CAML_DEPRECATED("bigarray_init", "caml_ba_init") caml_ba_init
-
-#endif /* CAML_NAME_SPACE */
-#endif /* CAML_COMPATIBILITY_H */
diff --git a/runtime/caml/config.h b/runtime/caml/config.h
index 471a6bc6f4..a7e56be8d9 100644
--- a/runtime/caml/config.h
+++ b/runtime/caml/config.h
@@ -16,6 +16,15 @@
 #ifndef CAML_CONFIG_H
 #define CAML_CONFIG_H
 
+/* CAML_NAME_SPACE was introduced in OCaml 3.08 to declare compatibility with
+   the newly caml_-prefixed names of C runtime functions and to disable the
+   definition of compatibility macros for the un-prefixed names. The
+   compatibility layer was removed in OCaml 5.00, so CAML_NAME_SPACE is the
+   default. */
+#ifndef CAML_NAME_SPACE
+#define CAML_NAME_SPACE
+#endif
+
 #include "m.h"
 
 /* If supported, tell gcc that we can use 32-bit code addresses for
@@ -41,10 +50,6 @@
 
 #include "s.h"
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
-
 #ifndef CAML_CONFIG_H_NO_TYPEDEFS
 
 #include <stddef.h>
diff --git a/runtime/caml/custom.h b/runtime/caml/custom.h
index 420121f43e..231019aef7 100644
--- a/runtime/caml/custom.h
+++ b/runtime/caml/custom.h
@@ -17,9 +17,6 @@
 #define CAML_CUSTOM_H
 
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "mlvalues.h"
 
 struct custom_fixed_length {
diff --git a/runtime/caml/domain_state.h b/runtime/caml/domain_state.h
index 84e677d041..2ee932459a 100644
--- a/runtime/caml/domain_state.h
+++ b/runtime/caml/domain_state.h
@@ -29,11 +29,7 @@ typedef value extra_params_area[NUM_EXTRA_PARAMS];
  * via native code, which is why the indices are important */
 
 typedef struct {
-#ifdef CAML_NAME_SPACE
 #define DOMAIN_STATE(type, name) CAMLalign(8) type name;
-#else
-#define DOMAIN_STATE(type, name) CAMLalign(8) type _##name;
-#endif
 #include "domain_state.tbl"
 #undef DOMAIN_STATE
 } caml_domain_state;
@@ -45,11 +41,7 @@ enum {
 #undef DOMAIN_STATE
 };
 
-#ifdef CAML_NAME_SPACE
 #define LAST_DOMAIN_STATE_MEMBER extra_params
-#else
-#define LAST_DOMAIN_STATE_MEMBER _extra_params
-#endif
 
 /* Check that the structure was laid out without padding,
    since the runtime assumes this in computing offsets */
@@ -57,11 +49,8 @@ CAML_STATIC_ASSERT(
     offsetof(caml_domain_state, LAST_DOMAIN_STATE_MEMBER) ==
     (Domain_state_num_fields - 1) * 8);
 
-CAMLextern caml_domain_state* Caml_state;
-#ifdef CAML_NAME_SPACE
+CAMLextern caml_domain_state* caml_state;
+#define Caml_state caml_state
 #define Caml_state_field(field) Caml_state->field
-#else
-#define Caml_state_field(field) Caml_state->_##field
-#endif
 
 #endif /* CAML_STATE_H */
diff --git a/runtime/caml/fail.h b/runtime/caml/fail.h
index 822c603260..887ef9c227 100644
--- a/runtime/caml/fail.h
+++ b/runtime/caml/fail.h
@@ -20,9 +20,6 @@
 #include <setjmp.h>
 #endif /* CAML_INTERNALS */
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "misc.h"
 #include "mlvalues.h"
 
diff --git a/runtime/caml/fix_code.h b/runtime/caml/fix_code.h
index 2eafaa814b..83c393a17d 100644
--- a/runtime/caml/fix_code.h
+++ b/runtime/caml/fix_code.h
@@ -34,7 +34,8 @@ void caml_set_instruction (code_t pos, opcode_t instr);
 int caml_is_instruction (opcode_t instr1, opcode_t instr2);
 
 #ifdef THREADED_CODE
-void caml_init_thread_code(void ** instr_table, void * instr_base);
+extern char ** caml_instr_table;
+extern char * caml_instr_base;
 void caml_thread_code (code_t code, asize_t len);
 #endif
 
diff --git a/runtime/caml/intext.h b/runtime/caml/intext.h
index a2a3fb8248..b68030aad8 100644
--- a/runtime/caml/intext.h
+++ b/runtime/caml/intext.h
@@ -18,9 +18,6 @@
 #ifndef CAML_INTEXT_H
 #define CAML_INTEXT_H
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "misc.h"
 #include "mlvalues.h"
 
diff --git a/runtime/caml/m.h.in b/runtime/caml/m.h.in
index 1c3dee1779..ba0074318d 100644
--- a/runtime/caml/m.h.in
+++ b/runtime/caml/m.h.in
@@ -90,7 +90,7 @@
 
 #undef CAML_WITH_FPIC
 
-#undef CAML_SAFE_STRING
+#define CAML_SAFE_STRING 1
 
 #undef FLAT_FLOAT_ARRAY
 
diff --git a/runtime/caml/memory.h b/runtime/caml/memory.h
index d9e58bc2d0..8837d33d25 100644
--- a/runtime/caml/memory.h
+++ b/runtime/caml/memory.h
@@ -18,9 +18,6 @@
 #ifndef CAML_MEMORY_H
 #define CAML_MEMORY_H
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "config.h"
 #ifdef CAML_INTERNALS
 #include "gc.h"
@@ -329,7 +326,7 @@ struct caml__roots_block {
   #define CAMLunused_start __attribute__ ((unused))
   #define CAMLunused_end
   #define CAMLunused __attribute__ ((unused))
-#elif defined(_MSC_VER) && _MSC_VER >= 1500
+#elif _MSC_VER >= 1500
   #define CAMLunused_start  __pragma( warning (push) )           \
     __pragma( warning (disable:4189 ) )
   #define CAMLunused_end __pragma( warning (pop))
diff --git a/runtime/caml/misc.h b/runtime/caml/misc.h
index c605f8711e..b97d20c2bd 100644
--- a/runtime/caml/misc.h
+++ b/runtime/caml/misc.h
@@ -18,9 +18,6 @@
 #ifndef CAML_MISC_H
 #define CAML_MISC_H
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "config.h"
 
 /* Standard definitions */
@@ -29,13 +26,15 @@
 #include <stdlib.h>
 #include <stdarg.h>
 
+#include "camlatomic.h"
+
 /* Deprecation warnings */
 
 #if defined(__GNUC__) || defined(__clang__)
   /* Supported since at least GCC 3.1 */
   #define CAMLdeprecated_typedef(name, type) \
     typedef type name __attribute ((deprecated))
-#elif defined(_MSC_VER) && _MSC_VER >= 1310
+#elif _MSC_VER >= 1310
   /* NB deprecated("message") only supported from _MSC_VER >= 1400 */
   #define CAMLdeprecated_typedef(name, type) \
     typedef __declspec(deprecated) type name
@@ -43,8 +42,7 @@
   #define CAMLdeprecated_typedef(name, type) typedef type name
 #endif
 
-#if defined(__GNUC__) && __STDC_VERSION__ >= 199901L \
- || defined(_MSC_VER) && _MSC_VER >= 1925
+#if defined(__GNUC__) && __STDC_VERSION__ >= 199901L || _MSC_VER >= 1925
 
 #define CAML_STRINGIFY(x) #x
 #ifdef _MSC_VER
@@ -91,7 +89,7 @@ CAMLdeprecated_typedef(addr, char *);
   #define CAMLnoreturn_start
   #define CAMLnoreturn_end __attribute__ ((noreturn))
   #define Noreturn __attribute__ ((noreturn))
-#elif defined(_MSC_VER) && _MSC_VER >= 1500
+#elif _MSC_VER >= 1500
   #define CAMLnoreturn_start __declspec(noreturn)
   #define CAMLnoreturn_end
   #define Noreturn
@@ -139,12 +137,11 @@ CAMLdeprecated_typedef(addr, char *);
 /* we need to be able to compute the exact offset of each member. */
 #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
 #define CAMLalign(n) _Alignas(n)
-#elif defined(__cplusplus) \
-   && (__cplusplus >= 201103L || defined(_MSC_VER) && _MSC_VER >= 1900)
+#elif defined(__cplusplus) && (__cplusplus >= 201103L || _MSC_VER >= 1900)
 #define CAMLalign(n) alignas(n)
 #elif defined(SUPPORTS_ALIGNED_ATTRIBUTE)
 #define CAMLalign(n) __attribute__((aligned(n)))
-#elif defined(_MSC_VER) && _MSC_VER >= 1500
+#elif _MSC_VER >= 1500
 #define CAMLalign(n) __declspec(align(n))
 #else
 #error "How do I align values on this platform?"
@@ -172,7 +169,7 @@ CAMLdeprecated_typedef(addr, char *);
   #define CAMLunused_start __attribute__ ((unused))
   #define CAMLunused_end
   #define CAMLunused __attribute__ ((unused))
-#elif defined(_MSC_VER) && _MSC_VER >= 1500
+#elif _MSC_VER >= 1500
   #define CAMLunused_start  __pragma( warning (push) )           \
     __pragma( warning (disable:4189 ) )
   #define CAMLunused_end __pragma( warning (pop))
diff --git a/runtime/caml/mlvalues.h b/runtime/caml/mlvalues.h
index 677e44e183..00143e5ea0 100644
--- a/runtime/caml/mlvalues.h
+++ b/runtime/caml/mlvalues.h
@@ -16,9 +16,6 @@
 #ifndef CAML_MLVALUES_H
 #define CAML_MLVALUES_H
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "config.h"
 #include "misc.h"
 
@@ -286,11 +283,7 @@ CAMLextern value caml_hash_variant(char const * tag);
 
 /* Strings. */
 #define String_tag 252
-#ifdef CAML_SAFE_STRING
 #define String_val(x) ((const char *) Bp_val(x))
-#else
-#define String_val(x) ((char *) Bp_val(x))
-#endif
 #define Bytes_val(x) ((unsigned char *) Bp_val(x))
 CAMLextern mlsize_t caml_string_length (value);   /* size in bytes */
 CAMLextern int caml_string_is_c_safe (value);
diff --git a/runtime/caml/s.h.in b/runtime/caml/s.h.in
index 8e4efdcc72..9a5d9f4a91 100644
--- a/runtime/caml/s.h.in
+++ b/runtime/caml/s.h.in
@@ -60,6 +60,8 @@
 /* Define HAS_WORKING_ROUND is the round function is correctly implemented. This
    hatch exists primarily for https://sourceforge.net/p/mingw-w64/bugs/573/ */
 
+#undef HAS_GETENTROPY
+
 #undef HAS_GETRUSAGE
 
 #undef HAS_TIMES
@@ -70,6 +72,8 @@
 
 #undef HAS_ISSETUGID
 
+#undef HAS_STDATOMIC_H
+
 /* 2. For the Unix library. */
 
 #undef HAS_SOCKETS
diff --git a/runtime/caml/signals.h b/runtime/caml/signals.h
index 62b0e7fafa..3a3b86911c 100644
--- a/runtime/caml/signals.h
+++ b/runtime/caml/signals.h
@@ -20,9 +20,6 @@
 #include<signal.h>
 #endif
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "misc.h"
 #include "mlvalues.h"
 
@@ -87,8 +84,8 @@ value caml_do_pending_actions_exn (void);
 value caml_process_pending_actions_with_root (value extra_root); // raises
 value caml_process_pending_actions_with_root_exn (value extra_root);
 int caml_set_signal_action(int signo, int action);
-CAMLextern void * caml_setup_stack_overflow_detection(void);
-CAMLextern int caml_stop_stack_overflow_detection(void *);
+CAMLextern int caml_setup_stack_overflow_detection(void);
+CAMLextern int caml_stop_stack_overflow_detection(void);
 CAMLextern void caml_init_signals(void);
 CAMLextern void caml_terminate_signals(void);
 CAMLextern void (*caml_enter_blocking_section_hook)(void);
diff --git a/runtime/caml/sys.h b/runtime/caml/sys.h
index 75b97818c1..3b2d537ac4 100644
--- a/runtime/caml/sys.h
+++ b/runtime/caml/sys.h
@@ -24,6 +24,8 @@
 extern "C" {
 #endif
 
+CAMLextern char * caml_strerror(int errnum, char * buf, size_t buflen);
+
 #define NO_ARG Val_int(0)
 
 CAMLnoreturn_start
diff --git a/runtime/debugger.c b/runtime/debugger.c
index 97d22832a0..c10c7d0f8f 100644
--- a/runtime/debugger.c
+++ b/runtime/debugger.c
@@ -30,6 +30,7 @@
 #include "caml/misc.h"
 #include "caml/osdeps.h"
 #include "caml/skiplist.h"
+#include "caml/sys.h"
 
 int caml_debugger_in_use = 0;
 uintnat caml_event_count;
@@ -110,6 +111,7 @@ static struct skiplist event_points_table = SKIPLIST_STATIC_INITIALIZER;
 
 static void open_connection(void)
 {
+  char buf[1024];
 #ifdef _WIN32
   /* Set socket to synchronous mode (= non-overlapped) so that file
      descriptor-oriented functions (read()/write() etc.) can be
@@ -133,7 +135,7 @@ static void open_connection(void)
     caml_fatal_error("cannot connect to debugger at %s\n"
                      "error: %s",
                      (dbg_addr ? dbg_addr : "(none)"),
-                     strerror (errno));
+                     caml_strerror(errno, buf, sizeof(buf)));
   dbg_in = caml_open_descriptor_in(dbg_socket);
   dbg_out = caml_open_descriptor_out(dbg_socket);
   /* The code in this file does not bracket channel I/O operations with
diff --git a/runtime/domain.c b/runtime/domain.c
index d4d8de53fc..a6f0a3028e 100644
--- a/runtime/domain.c
+++ b/runtime/domain.c
@@ -19,7 +19,7 @@
 #include "caml/domain_state.h"
 #include "caml/memory.h"
 
-CAMLexport caml_domain_state* Caml_state;
+CAMLexport caml_domain_state* caml_state;
 
 void caml_init_domain ()
 {
diff --git a/runtime/dune b/runtime/dune
index 78c39300ed..23eb1d1e8a 100644
--- a/runtime/dune
+++ b/runtime/dune
@@ -21,7 +21,7 @@
      interp.c ints.c io.c
    lexing.c md5.c meta.c memprof.c obj.c parsing.c signals.c str.c sys.c
      callback.c weak.c
-   finalise.c stacks.c dynlink.c backtrace_byt.c backtrace.c
+   finalise.c dynlink.c backtrace_byt.c backtrace.c
      afl.c
    bigarray.c eventlog.c)
  (action  (with-stdout-to %{targets} (run %{dep:gen_primitives.sh}))))
@@ -36,7 +36,7 @@
    ../Makefile.common Makefile
    (glob_files caml/*.h)
    ; matches the line structure of files in Makefile/BYTECODE_C_SOURCES
-   interp.c misc.c stacks.c fix_code.c startup_aux.c startup_byt.c freelist.c
+   interp.c misc.c fix_code.c startup_aux.c startup_byt.c freelist.c
      major_gc.c
    minor_gc.c memory.c alloc.c roots_byt.c globroots.c fail_byt.c signals.c
    signals_byt.c printexc.c backtrace_byt.c backtrace.c compare.c ints.c
diff --git a/runtime/dynlink_nat.c b/runtime/dynlink_nat.c
index dba30c3848..7eea86f8c0 100644
--- a/runtime/dynlink_nat.c
+++ b/runtime/dynlink_nat.c
@@ -118,7 +118,8 @@ CAMLprim value caml_natdynlink_run(value handle_v, value symbol) {
 
   sym = optsym("__code_begin");
   sym2 = optsym("__code_end");
-  if (NULL != sym && NULL != sym2)
+  /* Do not register empty code fragments */
+  if (NULL != sym && NULL != sym2 && sym != sym2)
     caml_register_code_fragment((char *) sym, (char *) sym2,
                                 DIGEST_LATER, NULL);
 
diff --git a/runtime/fix_code.c b/runtime/fix_code.c
index 5584019867..aa059be5df 100644
--- a/runtime/fix_code.c
+++ b/runtime/fix_code.c
@@ -82,14 +82,8 @@ void caml_fixup_endianness(code_t code, asize_t len)
 
 #ifdef THREADED_CODE
 
-static char ** caml_instr_table;
-static char * caml_instr_base;
-
-void caml_init_thread_code(void ** instr_table, void * instr_base)
-{
-  caml_instr_table = (char **) instr_table;
-  caml_instr_base = (char *) instr_base;
-}
+char ** caml_instr_table;
+char * caml_instr_base;
 
 static int* opcode_nargs = NULL;
 int* caml_init_opcode_nargs(void)
diff --git a/runtime/gen_primitives.sh b/runtime/gen_primitives.sh
index a727d5c25c..e76b3300b7 100755
--- a/runtime/gen_primitives.sh
+++ b/runtime/gen_primitives.sh
@@ -25,7 +25,7 @@ export LC_ALL=C
       alloc array compare extern floats gc_ctrl hash intern interp ints io \
       lexing md5 meta memprof obj parsing signals str sys callback weak \
       finalise stacks dynlink backtrace_byt backtrace afl \
-      bigarray eventlog
+      bigarray eventlog prng
   do
       sed -n -e 's/^CAMLprim value \([a-z0-9_][a-z0-9_]*\).*/\1/p' "$prim.c"
   done
diff --git a/runtime/i386.S b/runtime/i386.S
index 4d273c9f04..06a9cf5fa7 100644
--- a/runtime/i386.S
+++ b/runtime/i386.S
@@ -116,7 +116,7 @@ FUNCTION(caml_call_gc)
         CFI_STARTPROC
 LBL(caml_call_gc):
     /* Record lowest stack address and return address */
-        movl    G(Caml_state), %ebx
+        movl    G(caml_state), %ebx
         movl    (%esp), %eax
         movl    %eax, CAML_STATE(last_return_address, %ebx)
         leal    4(%esp), %eax
@@ -128,7 +128,7 @@ LBL(caml_call_gc):
         movl    %eax, 0(%esp)
         addl    $(STACK_PROBE_SIZE), %esp; CFI_ADJUST(-STACK_PROBE_SIZE);
 #endif
-    /* Build array of registers, save it into Caml_state->gc_regs */
+    /* Build array of registers, save it into caml_state->gc_regs */
         pushl   %ebp; CFI_ADJUST(4)
         pushl   %edi; CFI_ADJUST(4)
         pushl   %esi; CFI_ADJUST(4)
@@ -156,7 +156,7 @@ LBL(caml_call_gc):
 
 FUNCTION(caml_alloc1)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
+        movl    G(caml_state), %ebx
         movl    CAML_STATE(young_ptr, %ebx), %eax
         subl    $8, %eax
         movl    %eax, CAML_STATE(young_ptr, %ebx)
@@ -168,7 +168,7 @@ FUNCTION(caml_alloc1)
 
 FUNCTION(caml_alloc2)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
+        movl    G(caml_state), %ebx
         movl    CAML_STATE(young_ptr, %ebx), %eax
         subl    $12, %eax
         movl    %eax, CAML_STATE(young_ptr, %ebx)
@@ -180,7 +180,7 @@ FUNCTION(caml_alloc2)
 
 FUNCTION(caml_alloc3)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
+        movl    G(caml_state), %ebx
         movl    CAML_STATE(young_ptr, %ebx), %eax
         subl    $16, %eax
         movl    %eax, CAML_STATE(young_ptr, %ebx)
@@ -192,10 +192,10 @@ FUNCTION(caml_alloc3)
 
 FUNCTION(caml_allocN)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
-        /* eax = size - Caml_state->young_ptr */
+        movl    G(caml_state), %ebx
+        /* eax = size - caml_state->young_ptr */
         subl    CAML_STATE(young_ptr, %ebx), %eax
-        negl    %eax              /* eax = Caml_state->young_ptr - size */
+        negl    %eax              /* eax = caml_state->young_ptr - size */
         movl    %eax, CAML_STATE(young_ptr, %ebx)
         cmpl    CAML_STATE(young_limit, %ebx), %eax
         jb      LBL(caml_call_gc)
@@ -209,7 +209,7 @@ FUNCTION(caml_c_call)
         CFI_STARTPROC
     /* Record lowest stack address and return address */
     /* ecx and edx are destroyed at C call. Use them as temp. */
-        movl    G(Caml_state), %ecx
+        movl    G(caml_state), %ecx
         movl    (%esp), %edx
         movl    %edx, CAML_STATE(last_return_address, %ecx)
         leal    4(%esp), %edx
@@ -239,7 +239,7 @@ FUNCTION(caml_start_program)
         movl    $ G(caml_program), %esi
     /* Common code for caml_start_program and caml_callback* */
 LBL(106):
-        movl    G(Caml_state), %edi
+        movl    G(caml_state), %edi
     /* Build a callback link */
         pushl   CAML_STATE(gc_regs, %edi); CFI_ADJUST(4)
         pushl   CAML_STATE(last_return_address, %edi); CFI_ADJUST(4)
@@ -253,12 +253,12 @@ LBL(106):
     /* Call the OCaml code */
         call    *%esi
 LBL(107):
-        movl    G(Caml_state), %edi
+        movl    G(caml_state), %edi
     /* Pop the exception handler */
         popl    CAML_STATE(exception_pointer, %edi); CFI_ADJUST(-4)
         addl    $12, %esp       ; CFI_ADJUST(-12)
 LBL(109):
-        movl    G(Caml_state), %edi /* Reload for LBL(109) entry */
+        movl    G(caml_state), %edi /* Reload for LBL(109) entry */
     /* Pop the callback link, restoring the global variables */
         popl    CAML_STATE(bottom_of_stack, %edi); CFI_ADJUST(-4)
         popl    CAML_STATE(last_return_address, %edi); CFI_ADJUST(-4)
@@ -282,7 +282,7 @@ LBL(108):
 
 FUNCTION(caml_raise_exn)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
+        movl    G(caml_state), %ebx
         testl   $1, CAML_STATE(backtrace_active, %ebx)
         jne     LBL(110)
         movl    CAML_STATE(exception_pointer, %ebx), %esp
@@ -312,7 +312,7 @@ LBL(110):
 
 FUNCTION(caml_raise_exception)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
+        movl    G(caml_state), %ebx
         testl   $1, CAML_STATE(backtrace_active, %ebx)
         jne     LBL(112)
         movl    8(%esp), %eax
@@ -405,7 +405,7 @@ FUNCTION(caml_ml_array_bound_error)
         ffree   %st(6)
         ffree   %st(7)
     /* Record lowest stack address and return address */
-        movl    G(Caml_state), %ebx
+        movl    G(caml_state), %ebx
         movl    (%esp), %edx
         movl    %edx, CAML_STATE(last_return_address, %ebx)
         leal    4(%esp), %edx
diff --git a/runtime/interp.c b/runtime/interp.c
index e6700994bc..a59811c87d 100644
--- a/runtime/interp.c
+++ b/runtime/interp.c
@@ -50,9 +50,9 @@ sp is a local copy of the global variable Caml_state->extern_sp. */
 #ifdef THREADED_CODE
 #  define Instruct(name) lbl_##name
 #  if defined(ARCH_SIXTYFOUR) && !defined(ARCH_CODE32)
-#    define Jumptbl_base &&lbl_ACC0
+#    define Jumptbl_base ((char *) &&lbl_ACC0)
 #  else
-#    define Jumptbl_base 0
+#    define Jumptbl_base ((char *) 0)
 #    define jumptbl_base ((char *) 0)
 #  endif
 #  ifdef DEBUG
@@ -249,7 +249,8 @@ value caml_interprete(code_t prog, asize_t prog_size)
 
   if (prog == NULL) {           /* Interpreter is initializing */
 #ifdef THREADED_CODE
-    caml_init_thread_code(jumptable, Jumptbl_base);
+    caml_instr_table = (char **) jumptable;
+    caml_instr_base = Jumptbl_base;
 #endif
     return Val_unit;
   }
diff --git a/runtime/prng.c b/runtime/prng.c
new file mode 100644
index 0000000000..4357afbbfb
--- /dev/null
+++ b/runtime/prng.c
@@ -0,0 +1,69 @@
+/**************************************************************************/
+/*                                                                        */
+/*                                 OCaml                                  */
+/*                                                                        */
+/*          Xavier Leroy, projet Cambium, College de France and Inria     */
+/*                                                                        */
+/*   Copyright 2021 Institut National de Recherche en Informatique et     */
+/*     en Automatique.                                                    */
+/*                                                                        */
+/*   All rights reserved.  This file is distributed under the terms of    */
+/*   the GNU Lesser General Public License version 2.1, with the          */
+/*   special exception on linking described in the file LICENSE.          */
+/*                                                                        */
+/**************************************************************************/
+
+#include <string.h>
+#include "caml/alloc.h"
+#include "caml/bigarray.h"
+#include "caml/mlvalues.h"
+
+/* The L64X128 member of the LXM family.  Taken from figure 1 in
+   "LXM: Better Splittable Pseudorandom Number Generators
+    (and Almost as Fast)" by Guy L. Steele Jr. and Sebastiano Vigna,
+    OOPSLA 2021.  */
+
+static const uint64_t M = 0xd1342543de82ef95;
+
+struct LXM_state {
+  uint64_t a;            /* per-instance additive parameter (odd) */
+  uint64_t s;            /* state of the LCG subgenerator */
+  uint64_t x[2];         /* state of the XBG subgenerator (not 0) */
+};
+
+/* In OCaml, states are represented as a 1D big array of 64-bit integers */
+
+#define LXM_val(v) ((struct LXM_state *) Caml_ba_data_val(v))
+
+Caml_inline uint64_t rotl(const uint64_t x, int k) {
+  return (x << k) | (x >> (64 - k));
+}
+
+CAMLprim uint64_t caml_lxm_next_unboxed(value v)
+{
+  uint64_t z, q0, q1;
+  struct LXM_state * st = LXM_val(v);
+
+  /* Combining operation */
+  z = st->s + st->x[0];
+  /* Mixing function */
+  z = (z ^ (z >> 32)) * 0xdaba0b6eb09322e3;
+  z = (z ^ (z >> 32)) * 0xdaba0b6eb09322e3;
+  z = (z ^ (z >> 32));
+  /* LCG update */
+  st->s = st->s * M + st->a;
+  /* XBG update */
+  q0 = st->x[0]; q1 = st->x[1];
+  q1 ^= q0;
+  q0 = rotl(q0, 24);
+  q0 = q0 ^ q1 ^ (q1 << 16);
+  q1 = rotl(q1, 37);
+  st->x[0] = q0; st->x[1] = q1;
+  /* Return result */
+  return z;
+}
+
+CAMLprim value caml_lxm_next(value v)
+{
+  return caml_copy_int64(caml_lxm_next_unboxed(v));
+}
diff --git a/runtime/signals_byt.c b/runtime/signals_byt.c
index 7cb461ac4d..439fb56404 100644
--- a/runtime/signals_byt.c
+++ b/runtime/signals_byt.c
@@ -81,7 +81,7 @@ int caml_set_signal_action(int signo, int action)
     return 0;
 }
 
-CAMLexport void * caml_setup_stack_overflow_detection(void) { return NULL; }
-CAMLexport int caml_stop_stack_overflow_detection(void * p) { return 0; }
+CAMLexport int caml_setup_stack_overflow_detection(void) { return 0; }
+CAMLexport int caml_stop_stack_overflow_detection(void) { return 0; }
 CAMLexport void caml_init_signals(void) { }
 CAMLexport void caml_terminate_signals(void) { }
diff --git a/runtime/signals_nat.c b/runtime/signals_nat.c
index 1dd8289c12..443f5d53b6 100644
--- a/runtime/signals_nat.c
+++ b/runtime/signals_nat.c
@@ -254,10 +254,6 @@ DECLARE_SIGNAL_HANDLER(segv_handler)
 
 /* Initialization of signal stuff */
 
-#ifdef HAS_STACK_OVERFLOW_DETECTION
-static void * caml_signal_stack = NULL;
-#endif
-
 void caml_init_signals(void)
 {
   /* Bound-check trap handling */
@@ -282,8 +278,7 @@ void caml_init_signals(void)
 #endif
 
 #ifdef HAS_STACK_OVERFLOW_DETECTION
-  caml_signal_stack = caml_setup_stack_overflow_detection();
-  if (caml_signal_stack != NULL) {
+  if (caml_setup_stack_overflow_detection() != -1) {
     struct sigaction act;
     SET_SIGACT(act, segv_handler);
     act.sa_flags |= SA_ONSTACK | SA_NODEFER;
@@ -319,8 +314,7 @@ void caml_terminate_signals(void)
 
 #ifdef HAS_STACK_OVERFLOW_DETECTION
   set_signal_default(SIGSEGV);
-  caml_stop_stack_overflow_detection(caml_signal_stack);
-  caml_signal_stack = NULL;
+  caml_stop_stack_overflow_detection();
 #endif
 }
 
@@ -329,44 +323,37 @@ void caml_terminate_signals(void)
    Each thread needs its own alternate stack.
    The alternate stack used to be statically-allocated for the main thread,
    but this is incompatible with Glibc 2.34 and newer, where SIGSTKSZ
-   may not be a compile-time constant (issue #10250).
-   Return the dynamically-allocated alternate signal stack, or NULL
-   if an error occurred.
-   The returned pointer must be passed to [caml_stop_stack_overflow_detection].
-*/
+   may not be a compile-time constant (issue #10250). */
 
-CAMLexport void * caml_setup_stack_overflow_detection(void)
+CAMLexport int caml_setup_stack_overflow_detection(void)
 {
 #ifdef HAS_STACK_OVERFLOW_DETECTION
   stack_t stk;
+  stk.ss_sp = malloc(SIGSTKSZ);
+  if (stk.ss_sp == NULL) return -1;
   stk.ss_size = SIGSTKSZ;
-  stk.ss_sp = malloc(stk.ss_size);
-  if (stk.ss_sp == NULL) return NULL;
   stk.ss_flags = 0;
   if (sigaltstack(&stk, NULL) == -1) {
     free(stk.ss_sp);
-    return NULL;
+    return -1;
   }
-  return stk.ss_sp;
-#else
-  return NULL;
 #endif
+  /* Success (or stack overflow detection not available) */
+  return 0;
 }
 
-CAMLexport int caml_stop_stack_overflow_detection(void * signal_stack)
+CAMLexport int caml_stop_stack_overflow_detection(void)
 {
 #ifdef HAS_STACK_OVERFLOW_DETECTION
   stack_t oldstk, stk;
   stk.ss_flags = SS_DISABLE;
-  stk.ss_sp = NULL;  /* not required but avoids a valgrind false alarm */
-  stk.ss_size = SIGSTKSZ; /* macOS wants a valid size here */
   if (sigaltstack(&stk, &oldstk) == -1) return -1;
-  /* Check whether someone else installed their own signal stack */
-  if (!(oldstk.ss_flags & SS_DISABLE) && oldstk.ss_sp != signal_stack) {
-    /* Re-activate their signal stack. */
-    sigaltstack(&oldstk, NULL);
-  }
-  free(signal_stack);
-#endif
+  /* If caml_setup_stack_overflow_detection failed, we are not using
+     an alternate signal stack.  SS_DISABLE will be set in oldstk,
+     and there is nothing to free in this case. */
+  if (! (oldstk.ss_flags & SS_DISABLE)) free(oldstk.ss_sp);
   return 0;
+#else
+  return 0;
+#endif
 }
diff --git a/runtime/sys.c b/runtime/sys.c
index a77fd9d1cf..f90d9ba2a8 100644
--- a/runtime/sys.c
+++ b/runtime/sys.c
@@ -45,6 +45,9 @@
 #ifdef HAS_GETTIMEOFDAY
 #include <sys/time.h>
 #endif
+#ifdef __APPLE__
+#include <sys/random.h> /* for getentropy */
+#endif
 #include "caml/alloc.h"
 #include "caml/debugger.h"
 #include "caml/fail.h"
@@ -61,9 +64,21 @@
 #include "caml/callback.h"
 #include "caml/startup_aux.h"
 
-static char * error_message(void)
+CAMLexport char * caml_strerror(int errnum, char * buf, size_t buflen)
 {
-  return strerror(errno);
+#ifdef _WIN32
+  /* Windows has a thread-safe strerror */
+  return strerror(errnum);
+#else
+  int res = strerror_r(errnum, buf, buflen);
+  /* glibc<2.13 returns -1/sets errno, >2.13 returns +ve errno.
+     We assume that buffer size is large enough not to get ERANGE,
+     so we assume we got EINVAL. */
+  if (res != 0) {
+    snprintf(buf, buflen, "Unknown error %d", errnum);
+  }
+  return buf;
+#endif
 }
 
 #ifndef EAGAIN
@@ -77,9 +92,10 @@ CAMLexport void caml_sys_error(value arg)
 {
   CAMLparam1 (arg);
   char * err;
+  char buf[1024];
   CAMLlocal1 (str);
 
-  err = error_message();
+  err = caml_strerror(errno, buf, sizeof(buf));
   if (arg == NO_ARG) {
     str = caml_copy_string(err);
   } else {
@@ -565,20 +581,27 @@ extern int caml_win32_random_seed (intnat data[16]);
 #else
 int caml_unix_random_seed(intnat data[16])
 {
-  int fd;
   int n = 0;
-
-  /* Try /dev/urandom first */
-  fd = open("/dev/urandom", O_RDONLY, 0);
-  if (fd != -1) {
-    unsigned char buffer[12];
-    int nread = read(fd, buffer, 12);
-    close(fd);
-    while (nread > 0) data[n++] = buffer[--nread];
+  unsigned char buffer[12];
+  int nread = 0;
+
+  /* Try kernel entropy first */
+#if defined(HAS_GETENTROPY) || defined(__APPLE__)
+  if (getentropy(buffer, 12) != -1) {
+    nread = 12;
+  } else
+#endif
+  { int fd = open("/dev/urandom", O_RDONLY, 0);
+    if (fd != -1) {
+      nread = read(fd, buffer, 12);
+      close(fd);
+    }
   }
-  /* If the read from /dev/urandom fully succeeded, we now have 96 bits
+  while (nread > 0) data[n++] = buffer[--nread];
+  /* If the kernel provided enough entropy, we now have 96 bits
      of good random data and can stop here. */
   if (n >= 12) return n;
+
   /* Otherwise, complement whatever we got (probably nothing)
      with some not-very-random data. */
   {
