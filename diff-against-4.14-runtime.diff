diff --git a/otherlibs/systhreads/st_posix.h b/otherlibs/systhreads/st_posix.h
index 957f4717b6..09b243f6a5 100644
--- a/otherlibs/systhreads/st_posix.h
+++ b/otherlibs/systhreads/st_posix.h
@@ -446,7 +446,7 @@ static value st_encode_sigset(sigset_t * set)
 
 static int sigmask_cmd[3] = { SIG_SETMASK, SIG_BLOCK, SIG_UNBLOCK };
 
-value caml_thread_sigmask(value cmd, value sigs) /* ML */
+value caml_thread_sigmask(value cmd, value sigs)
 {
   int how;
   sigset_t set, oldset;
@@ -463,7 +463,7 @@ value caml_thread_sigmask(value cmd, value sigs) /* ML */
   return st_encode_sigset(&oldset);
 }
 
-value caml_wait_signal(value sigs) /* ML */
+value caml_wait_signal(value sigs)
 {
 #ifdef HAS_SIGWAIT
   sigset_t set;
diff --git a/otherlibs/systhreads/st_stubs.c b/otherlibs/systhreads/st_stubs.c
index 043e07031e..c1d8358e93 100644
--- a/otherlibs/systhreads/st_stubs.c
+++ b/otherlibs/systhreads/st_stubs.c
@@ -430,7 +430,7 @@ static void caml_thread_reinitialize(void)
 
 /* Initialize the thread machinery */
 
-CAMLprim value caml_thread_initialize(value unit)   /* ML */
+CAMLprim value caml_thread_initialize(value unit)
 {
   /* Protect against repeated initialization (PR#3532) */
   if (curr_thread != NULL) return Val_unit;
@@ -483,7 +483,7 @@ CAMLprim value caml_thread_initialize(value unit)   /* ML */
    thread take 25ms on average / 50ms in the worst case, so we don't do it on
    program exit. */
 
-CAMLprim value caml_thread_cleanup(value unit)   /* ML */
+CAMLprim value caml_thread_cleanup(value unit)
 {
   if (caml_tick_thread_running){
     caml_tick_thread_stop = 1;
@@ -524,7 +524,6 @@ static ST_THREAD_FUNCTION caml_thread_start(void * arg)
 {
   caml_thread_t th = (caml_thread_t) arg;
   value clos;
-  void * signal_stack;
 #ifdef NATIVE_CODE
   struct longjmp_buffer termination_buf;
   char tos;
@@ -537,7 +536,7 @@ static ST_THREAD_FUNCTION caml_thread_start(void * arg)
   /* Acquire the global mutex */
   caml_leave_blocking_section();
   st_thread_set_id(Ident(th->descr));
-  signal_stack = caml_setup_stack_overflow_detection();
+  caml_setup_stack_overflow_detection();
 #ifdef NATIVE_CODE
   /* Setup termination handler (for caml_thread_exit) */
   if (sigsetjmp(termination_buf.buf, 0) == 0) {
@@ -551,12 +550,12 @@ static ST_THREAD_FUNCTION caml_thread_start(void * arg)
 #ifdef NATIVE_CODE
   }
 #endif
-  caml_stop_stack_overflow_detection(signal_stack);
+  caml_stop_stack_overflow_detection();
   /* The thread now stops running */
   return 0;
 }
 
-CAMLprim value caml_thread_new(value clos)          /* ML */
+CAMLprim value caml_thread_new(value clos)
 {
   caml_thread_t th;
   st_retcode err;
@@ -663,7 +662,7 @@ CAMLexport int caml_c_thread_unregister(void)
 
 /* Return the current thread */
 
-CAMLprim value caml_thread_self(value unit)         /* ML */
+CAMLprim value caml_thread_self(value unit)
 {
   if (curr_thread == NULL)
     caml_invalid_argument("Thread.self: not initialized");
@@ -672,14 +671,14 @@ CAMLprim value caml_thread_self(value unit)         /* ML */
 
 /* Return the identifier of a thread */
 
-CAMLprim value caml_thread_id(value th)          /* ML */
+CAMLprim value caml_thread_id(value th)
 {
   return Ident(th);
 }
 
 /* Print uncaught exception and backtrace */
 
-CAMLprim value caml_thread_uncaught_exception(value exn)  /* ML */
+CAMLprim value caml_thread_uncaught_exception(value exn)
 {
   char * msg = caml_format_exception(exn);
   fprintf(stderr, "Thread %d killed on uncaught exception %s\n",
@@ -692,7 +691,7 @@ CAMLprim value caml_thread_uncaught_exception(value exn)  /* ML */
 
 /* Terminate current thread */
 
-CAMLprim value caml_thread_exit(value unit)   /* ML */
+CAMLprim value caml_thread_exit(value unit)
 {
   struct longjmp_buffer * exit_buf = NULL;
 
@@ -723,7 +722,7 @@ CAMLprim value caml_thread_exit(value unit)   /* ML */
 
 /* Allow re-scheduling */
 
-CAMLprim value caml_thread_yield(value unit)        /* ML */
+CAMLprim value caml_thread_yield(value unit)
 {
   if (st_masterlock_waiters(&caml_master_lock) == 0) return Val_unit;
 
@@ -744,7 +743,7 @@ CAMLprim value caml_thread_yield(value unit)        /* ML */
 
 /* Suspend the current thread until another thread terminates */
 
-CAMLprim value caml_thread_join(value th)          /* ML */
+CAMLprim value caml_thread_join(value th)
 {
   st_retcode rc = caml_threadstatus_wait(Terminated(th));
   st_check_error(rc, "Thread.join");
@@ -783,7 +782,7 @@ static struct custom_operations caml_mutex_ops = {
   custom_fixed_length_default
 };
 
-CAMLprim value caml_mutex_new(value unit)        /* ML */
+CAMLprim value caml_mutex_new(value unit)
 {
   st_mutex mut = NULL;          /* suppress warning */
   value wrapper;
@@ -794,7 +793,7 @@ CAMLprim value caml_mutex_new(value unit)        /* ML */
   return wrapper;
 }
 
-CAMLprim value caml_mutex_lock(value wrapper)     /* ML */
+CAMLprim value caml_mutex_lock(value wrapper)
 {
   st_mutex mut = Mutex_val(wrapper);
   st_retcode retcode;
@@ -811,7 +810,7 @@ CAMLprim value caml_mutex_lock(value wrapper)     /* ML */
   return Val_unit;
 }
 
-CAMLprim value caml_mutex_unlock(value wrapper)           /* ML */
+CAMLprim value caml_mutex_unlock(value wrapper)
 {
   st_mutex mut = Mutex_val(wrapper);
   st_retcode retcode;
@@ -821,7 +820,7 @@ CAMLprim value caml_mutex_unlock(value wrapper)           /* ML */
   return Val_unit;
 }
 
-CAMLprim value caml_mutex_try_lock(value wrapper)           /* ML */
+CAMLprim value caml_mutex_try_lock(value wrapper)
 {
   st_mutex mut = Mutex_val(wrapper);
   st_retcode retcode;
@@ -863,7 +862,7 @@ static struct custom_operations caml_condition_ops = {
   custom_fixed_length_default
 };
 
-CAMLprim value caml_condition_new(value unit)        /* ML */
+CAMLprim value caml_condition_new(value unit)
 {
   st_condvar cond = NULL;       /* suppress warning */
   value wrapper;
@@ -874,7 +873,7 @@ CAMLprim value caml_condition_new(value unit)        /* ML */
   return wrapper;
 }
 
-CAMLprim value caml_condition_wait(value wcond, value wmut)           /* ML */
+CAMLprim value caml_condition_wait(value wcond, value wmut)
 {
   st_condvar cond = Condition_val(wcond);
   st_mutex mut = Mutex_val(wmut);
@@ -889,14 +888,14 @@ CAMLprim value caml_condition_wait(value wcond, value wmut)           /* ML */
   return Val_unit;
 }
 
-CAMLprim value caml_condition_signal(value wrapper)           /* ML */
+CAMLprim value caml_condition_signal(value wrapper)
 {
   st_check_error(st_condvar_signal(Condition_val(wrapper)),
                  "Condition.signal");
   return Val_unit;
 }
 
-CAMLprim value caml_condition_broadcast(value wrapper)           /* ML */
+CAMLprim value caml_condition_broadcast(value wrapper)
 {
   st_check_error(st_condvar_broadcast(Condition_val(wrapper)),
                  "Condition.broadcast");
diff --git a/otherlibs/systhreads/st_win32.h b/otherlibs/systhreads/st_win32.h
index 3f598a715d..21eb674fc5 100644
--- a/otherlibs/systhreads/st_win32.h
+++ b/otherlibs/systhreads/st_win32.h
@@ -525,13 +525,13 @@ static DWORD st_atfork(void (*fn)(void))
 
 /* Signal handling -- none under Win32 */
 
-value caml_thread_sigmask(value cmd, value sigs) /* ML */
+value caml_thread_sigmask(value cmd, value sigs)
 {
   caml_invalid_argument("Thread.sigmask not implemented");
   return Val_int(0);            /* not reached */
 }
 
-value caml_wait_signal(value sigs) /* ML */
+value caml_wait_signal(value sigs)
 {
   caml_invalid_argument("Thread.wait_signal not implemented");
   return Val_int(0);            /* not reached */
diff --git a/runtime/HACKING.adoc b/runtime/HACKING.adoc
new file mode 100644
index 0000000000..0ee84a6a5c
--- /dev/null
+++ b/runtime/HACKING.adoc
@@ -0,0 +1,156 @@
+= Tips on hacking the OCaml runtime system =
+
+== Linking a test program with the debug runtime ==
+
+Suppose you have a self-contained OCaml program `test.ml` that
+crashes, you are working on a development repository (not an installed
+version of your system). You probably want to run `test.ml` against
+the "debug runtime", which in particular activates the `CAMLassert`
+debug assertions.
+
+If you want to use the bytecode compiler:
+
+----
+# build the runtime
+make runtime -j
+
+# compile as usual
+./ocamlc.opt -nostdlib -I stdlib test.ml -o test
+
+# run with the debug runtime (ocamlrund)
+./runtime/ocamlrund ./test
+----
+
+If you want to use the native compiler:
+
+----
+# build the native runtime
+make runtimeopt -j
+
+# compile with "-runtime-variant d"
+./ocamlopt.opt -nostdlib -I stdlib -runtime-variant d -I runtime test.ml -o test
+
+./test
+----
+
+Note that the debug runtime does extra work, so it may slow down your
+program -- and sometimes make the issue you are trying to debug
+vanish.
+
+== GC messages ==
+
+The GC can send various messages about what it is doing, enabled with
+the "v" option of OCAMLRUNPARAM. Various options are more or less
+documented in
+link:https://ocaml.org/manual/runtime.html#s:ocamlrun-options[].
+You can enable all printing with
+
+----
+OCAMLRUNPARAM="v=0xffffffff" ./test
+----
+
+Note: `caml_gc_log` can be used to show log messages prefixed with the
+thread number, and it corresponds to the more precise setting
+`v=0x800`.
+
+== Heap verification ==
+
+Another useful OCAMLRUNPARAM setting is `V=1`, which enables
+additional sanity checks on the heap during major GC cycles.
+
+----
+OCAMLRUNPARAM="V=1" ./test
+----
+
+== Getting stack traces after assertion failures (Linux) ==
+
+The output of a crashing OCaml program may end up like this:
+
+----
+[03] file domain.c; line 404 ### Assertion failed: domain_state->young_start == NULL
+Aborted (core dumped)
+----
+
+The message "core dumped" indicates that some debugging information was kept on the disk.
+
+On Linux, systemd-enabled systems tend to use a systemd tool (of course!) to store core dumps.
+
+----
+# ask your system how core dumps are handled.
+$ cat /proc/sys/kernel/core_pattern
+|/usr/lib/systemd/systemd-coredump %P %u %g %s %t %c %h
+----
+
+If your system is also using `systemd-coredump`, then the command
+`coredumpctl dump` will show you information about the last "core
+dump".
+
+----
+$ $ coredumpctl dump
+           PID: 678260 (Domain0)
+           UID: 1000 (gasche)
+           GID: 1000 (gasche)
+        Signal: 6 (ABRT)
+     Timestamp: Fri 2022-02-25 09:30:32 CET (4min 30s ago)
+  Command Line: ./test
+    Executable: /home/gasche/Prog/ocaml/github-max_domains/test
+ Control Group: [...]
+                [...]
+     Disk Size: 133.0K
+       Message: Process 678260 (Domain0) of user 1000 dumped core.
+
+                Stack trace of thread 678266:
+                #0  0x00007f60ee4842a2 raise (libc.so.6 + 0x3d2a2)
+                #1  0x00007f60ee46d8a4 abort (libc.so.6 + 0x268a4)
+                #2  0x0000000000475022 n/a (/home/gasche/Prog/ocaml/github-max_domains/test + 0x75022)
+Refusing to dump core to tty (use shell redirection or specify --output).
+----
+
+You can get a full backtrace using `echo bt | coredumpctl debug`:
+
+----
+$ echo bt | coredumpctl debug
+[...]
+Core was generated by `./test'.
+Program terminated with signal SIGABRT, Aborted.
+#0  0x00007f60ee4842a2 in raise () from /lib64/libc.so.6
+[Current thread is 1 (Thread 0x7f60d77fe640 (LWP 678266))]
+Missing separate debuginfos, use: dnf debuginfo-install glibc-2.33-20.fc34.x86_64
+(gdb) #0  0x00007f60ee4842a2 in raise () from /lib64/libc.so.6
+#1  0x00007f60ee46d8a4 in abort () from /lib64/libc.so.6
+#2  0x0000000000475022 in caml_failed_assert (
+    expr=expr@entry=0x488498 "domain_state->young_start == NULL",
+    file_os=file_os@entry=0x488218 "domain.c", line=line@entry=404) at misc.c:56
+#3  0x0000000000461831 in caml_free_minor_heap () at domain.c:404
+#4  0x000000000046237b in caml_reallocate_minor_heap (wsize=wsize@entry=786432) at domain.c:469
+#5  0x0000000000474404 in caml_set_minor_heap_size (wsize=wsize@entry=786432) at minor_gc.c:130
+#6  0x00000000004696b3 in caml_gc_set (v=<optimized out>) at gc_ctrl.c:222
+#7  <signal handler called>
+#8  0x000000000042a3b2 in camlTest__set_gc_280 () at test.ml:17
+#9  0x000000000042a818 in camlTest__fun_529 () at test.ml:39
+#10 0x000000000044947a in camlStdlib__Domain__body_694 () at domain.ml:204
+#11 <signal handler called>
+#12 0x000000000045fe38 in caml_callback_exn (closure=<optimized out>, arg=<optimized out>, arg@entry=1) at callback.c:169
+#13 0x0000000000460369 in caml_callback (closure=<optimized out>, arg=arg@entry=1) at callback.c:253
+#14 0x0000000000461f6a in domain_thread_func (v=0x7ffdd7357bb0) at domain.c:1034
+#15 0x00007f60ee61f299 in start_thread () from /lib64/libpthread.so.0
+#16 0x00007f60ee547353 in clone () from /lib64/libc.so.6
+(gdb) quit
+----
+
+== Using `rr` for deterministic replay debugging ==
+
+There is a lot of information on how to use `rr` to debug the OCaml
+runtime on the OCaml Multicore wiki:
+link:https://github.com/ocaml-multicore/ocaml-multicore/wiki/Debugging-the-OCaml-Multicore-runtime#rr[].
+
+TODO: it would be nice to migrate some information here.
+
+== Compiling with sanitizers ==
+
+TODO: I would be curious to know!
+
+(For the brave there are some scripts in
+link:../tools/ci/inria/sanitizers/script[], but you probably don't
+want to run them directly, in particular they will `git clean -xfd`,
+destroying changed/uncommited files in your development repository!)
diff --git a/runtime/Makefile b/runtime/Makefile
deleted file mode 100644
index f5c08d8798..0000000000
--- a/runtime/Makefile
+++ /dev/null
@@ -1,421 +0,0 @@
-#**************************************************************************
-#*                                                                        *
-#*                                 OCaml                                  *
-#*                                                                        *
-#*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *
-#*                                                                        *
-#*   Copyright 1999 Institut National de Recherche en Informatique et     *
-#*     en Automatique.                                                    *
-#*                                                                        *
-#*   All rights reserved.  This file is distributed under the terms of    *
-#*   the GNU Lesser General Public License version 2.1, with the          *
-#*   special exception on linking described in the file LICENSE.          *
-#*                                                                        *
-#**************************************************************************
-
-ROOTDIR = ..
-
-include $(ROOTDIR)/Makefile.common
-
-# Lists of source files
-
-BYTECODE_C_SOURCES := $(addsuffix .c, \
-  interp misc stacks fix_code startup_aux startup_byt freelist major_gc \
-  minor_gc memory alloc roots_byt globroots fail_byt signals \
-  signals_byt printexc backtrace_byt backtrace compare ints eventlog \
-  floats str array io extern intern hash sys meta parsing gc_ctrl md5 obj \
-  lexing callback debugger weak compact finalise custom dynlink \
-  afl $(UNIX_OR_WIN32) bigarray main memprof domain \
-  skiplist codefrag)
-
-NATIVE_C_SOURCES := $(addsuffix .c, \
-  startup_aux startup_nat main fail_nat roots_nat signals \
-  signals_nat misc freelist major_gc minor_gc memory alloc compare ints \
-  floats str array io extern intern hash sys parsing gc_ctrl eventlog md5 obj \
-  lexing $(UNIX_OR_WIN32) printexc callback weak compact finalise custom \
-  globroots backtrace_nat backtrace dynlink_nat debugger meta \
-  dynlink clambda_checks afl bigarray \
-  memprof domain skiplist codefrag)
-
-# Header files generated by configure
-CONFIGURED_HEADERS := caml/m.h caml/s.h caml/version.h
-
-# Header files generated by make
-BUILT_HEADERS := caml/opnames.h caml/jumptbl.h build_config.h
-
-ifeq "$(TOOLCHAIN)" "msvc"
-ASM_EXT := asm
-ASM_SOURCES := $(ARCH)nt.$(ASM_EXT)
-else
-ASM_EXT := S
-ASM_SOURCES := $(ARCH).$(ASM_EXT)
-endif
-
-# Targets to build and install
-
-PROGRAMS := ocamlrun$(EXE)
-BYTECODE_STATIC_LIBRARIES := ld.conf libcamlrun.$(A)
-BYTECODE_SHARED_LIBRARIES :=
-NATIVE_STATIC_LIBRARIES := libasmrun.$(A)
-NATIVE_SHARED_LIBRARIES :=
-
-ifeq "$(RUNTIMED)" "true"
-PROGRAMS += ocamlrund$(EXE)
-BYTECODE_STATIC_LIBRARIES += libcamlrund.$(A)
-NATIVE_STATIC_LIBRARIES += libasmrund.$(A)
-endif
-
-ifeq "$(INSTRUMENTED_RUNTIME)" "true"
-PROGRAMS += ocamlruni$(EXE)
-BYTECODE_STATIC_LIBRARIES += libcamlruni.$(A)
-NATIVE_STATIC_LIBRARIES += libasmruni.$(A)
-endif
-
-ifeq "$(UNIX_OR_WIN32)" "unix"
-ifeq "$(SUPPORTS_SHARED_LIBRARIES)" "true"
-BYTECODE_STATIC_LIBRARIES += libcamlrun_pic.$(A)
-BYTECODE_SHARED_LIBRARIES += libcamlrun_shared.$(SO)
-NATIVE_STATIC_LIBRARIES += libasmrun_pic.$(A)
-NATIVE_SHARED_LIBRARIES += libasmrun_shared.$(SO)
-endif
-endif
-
-# List of object files for each target
-
-ASM_OBJECTS := $(ASM_SOURCES:.$(ASM_EXT)=.$(O))
-
-libcamlrun_OBJECTS := $(BYTECODE_C_SOURCES:.c=.b.$(O))
-
-libcamlrun_non_shared_OBJECTS := \
-  $(subst $(UNIX_OR_WIN32).b.$(O),$(UNIX_OR_WIN32)_non_shared.b.$(O), \
-          $(libcamlrun_OBJECTS))
-
-libcamlrund_OBJECTS := $(BYTECODE_C_SOURCES:.c=.bd.$(O)) \
-  instrtrace.bd.$(O)
-
-libcamlruni_OBJECTS := $(BYTECODE_C_SOURCES:.c=.bi.$(O))
-
-libcamlrunpic_OBJECTS := $(BYTECODE_C_SOURCES:.c=.bpic.$(O))
-
-libasmrun_OBJECTS := $(NATIVE_C_SOURCES:.c=.n.$(O)) $(ASM_OBJECTS)
-
-libasmrund_OBJECTS := $(NATIVE_C_SOURCES:.c=.nd.$(O)) $(ASM_OBJECTS)
-
-libasmruni_OBJECTS := $(NATIVE_C_SOURCES:.c=.ni.$(O)) $(ASM_OBJECTS)
-
-libasmrunpic_OBJECTS := $(NATIVE_C_SOURCES:.c=.npic.$(O)) \
-  $(ASM_OBJECTS:.$(O)=_libasmrunpic.$(O))
-
-# General (non target-specific) assembler and compiler flags
-
-ifneq "$(CCOMPTYPE)" "msvc"
-OC_CFLAGS += -g
-endif
-
-OC_CPPFLAGS += -DCAMLDLLIMPORT=
-
-OC_NATIVE_CPPFLAGS = -DNATIVE_CODE -DTARGET_$(ARCH)
-
-ifeq "$(UNIX_OR_WIN32)" "unix"
-OC_NATIVE_CPPFLAGS += -DMODEL_$(MODEL)
-endif
-
-OC_NATIVE_CPPFLAGS += -DSYS_$(SYSTEM)
-
-OC_DEBUG_CPPFLAGS=-DDEBUG
-OC_INSTR_CPPFLAGS=-DCAML_INSTR
-
-ifeq "$(TOOLCHAIN)" "msvc"
-ASMFLAGS=
-endif
-
-ASPPFLAGS = -DSYS_$(SYSTEM) -I$(ROOTDIR)/runtime
-ifeq "$(UNIX_OR_WIN32)" "unix"
-ASPPFLAGS += -DMODEL_$(MODEL)
-endif
-
-# Commands used to build native libraries
-
-LIBS := $(BYTECCLIBS)
-
-ifeq "$(UNIX_OR_WIN32)" "win32"
-LIBS += $(EXTRALIBS)
-endif
-
-# Build, install and clean targets
-
-.PHONY: all
-all: $(BYTECODE_STATIC_LIBRARIES) $(BYTECODE_SHARED_LIBRARIES) $(PROGRAMS) \
-     sak$(EXE)
-
-.PHONY: allopt
-ifneq "$(NATIVE_COMPILER)" "false"
-allopt: $(NATIVE_STATIC_LIBRARIES) $(NATIVE_SHARED_LIBRARIES)
-else
-allopt:
-	$(error The build has been configured with --disable-native-compiler)
-endif
-
-INSTALL_INCDIR=$(INSTALL_LIBDIR)/caml
-.PHONY: install
-install:
-	$(INSTALL_PROG) $(PROGRAMS) "$(INSTALL_BINDIR)"
-	$(INSTALL_DATA) $(BYTECODE_STATIC_LIBRARIES) "$(INSTALL_LIBDIR)"
-ifneq "$(BYTECODE_SHARED_LIBRARIES)" ""
-	$(INSTALL_PROG) $(BYTECODE_SHARED_LIBRARIES) "$(INSTALL_LIBDIR)"
-endif
-	mkdir -p "$(INSTALL_INCDIR)"
-	$(INSTALL_DATA) caml/domain_state.tbl caml/*.h "$(INSTALL_INCDIR)"
-
-.PHONY: installopt
-installopt:
-	$(INSTALL_DATA) $(NATIVE_STATIC_LIBRARIES) "$(INSTALL_LIBDIR)"
-ifneq "$(NATIVE_SHARED_LIBRARIES)" ""
-	$(INSTALL_PROG) $(NATIVE_SHARED_LIBRARIES) "$(INSTALL_LIBDIR)"
-endif
-
-.PHONY: clean
-clean:
-	rm -f *.o *.obj *.a *.lib *.so *.dll ld.conf
-	rm -f ocamlrun ocamlrund ocamlruni ocamlruns sak
-	rm -f ocamlrun.exe ocamlrund.exe ocamlruni.exe ocamlruns.exe sak.exe
-	rm -f primitives primitives.new prims.c $(BUILT_HEADERS)
-	rm -f domain_state*.inc
-	rm -rf $(DEPDIR)
-
-.PHONY: distclean
-distclean: clean
-	rm -f $(CONFIGURED_HEADERS)
-
-# Generated non-object files
-
-ld.conf: $(ROOTDIR)/Makefile.config
-	echo "$(STUBLIBDIR)" > $@
-	echo "$(LIBDIR)" >> $@
-
-# If primitives contain duplicated lines (e.g. because the code is defined
-# like
-# #ifdef X
-# CAMLprim value caml_foo() ...
-# #else
-# CAMLprim value caml_foo() ...
-# end), horrible things will happen (duplicated entries in Runtimedef ->
-# double registration in Symtable -> empty entry in the PRIM table ->
-# the bytecode interpreter is confused).
-# We sort the primitive file and remove duplicates to avoid this problem.
-
-# Warning: we use "sort | uniq" instead of "sort -u" because in the MSVC
-# port, the "sort" program in the path is Microsoft's and not cygwin's
-
-# Warning: POSIX sort is locale dependent, that's why we set LC_ALL explicitly.
-# Sort is unstable for "is_directory" and "isatty"
-# see http://pubs.opengroup.org/onlinepubs/9699919799/utilities/sort.html:
-# "using sort to process pathnames, it is recommended that LC_ALL .. set to C"
-
-# To speed up builds, we avoid changing "primitives" when files
-# containing primitives change but the primitives table does not
-primitives: $(shell ./gen_primitives.sh > primitives.new; \
-                    cmp -s primitives primitives.new || echo primitives.new)
-	cp $^ $@
-
-prims.c : primitives
-	(echo '#define CAML_INTERNALS'; \
-         echo '#include "caml/mlvalues.h"'; \
-	 echo '#include "caml/prims.h"'; \
-	 sed -e 's/.*/extern value &();/' primitives; \
-	 echo 'c_primitive caml_builtin_cprim[] = {'; \
-	 sed -e 's/.*/  &,/' primitives; \
-	 echo '  0 };'; \
-	 echo 'char * caml_names_of_builtin_cprim[] = {'; \
-	 sed -e 's/.*/  "&",/' primitives; \
-	 echo '  0 };') > prims.c
-
-caml/opnames.h : caml/instruct.h
-	tr -d '\r' < $< | \
-	sed -e '/\/\*/d' \
-	    -e '/^#/d' \
-	    -e 's/enum /static char * names_of_/' \
-	    -e 's/{$$/[] = {/' \
-	    -e 's/\([[:upper:]][[:upper:]_0-9]*\)/"\1"/g' > $@
-
-# caml/jumptbl.h is required only if you have GCC 2.0 or later
-caml/jumptbl.h : caml/instruct.h
-	tr -d '\r' < $< | \
-	sed -n -e '/^  /s/ \([A-Z]\)/ \&\&lbl_\1/gp' \
-	       -e '/^}/q' > $@
-# These are provided as a temporary shim to allow cross-compilation systems
-# to supply a host C compiler and different flags and a linking macro.
-SAK_CC ?= $(CC)
-SAK_CFLAGS ?= $(OC_CFLAGS) $(CFLAGS) $(OC_CPPFLAGS) $(CPPFLAGS)
-SAK_LINK ?= $(MKEXE_USING_COMPILER)
-
-sak$(EXE): sak.$(O)
-	$(call SAK_LINK,$@,$^)
-
-sak.$(O): sak.c caml/misc.h caml/config.h
-	$(SAK_CC) -c $(SAK_CFLAGS) $(OUTPUTOBJ)$@ $<
-
-C_LITERAL = $(shell ./sak$(EXE) encode-C-literal '$(1)')
-
-build_config.h: $(ROOTDIR)/Makefile.config sak$(EXE)
-	echo '/* This file is generated from $(ROOTDIR)/Makefile.config */' > $@
-	echo '#define OCAML_STDLIB_DIR $(call C_LITERAL,$(LIBDIR))' >> $@
-	echo '#define HOST "$(HOST)"' >> $@
-
-# Libraries and programs
-
-ocamlrun$(EXE): prims.$(O) libcamlrun.$(A)
-	$(MKEXE) -o $@ $^ $(LIBS)
-
-ocamlruns$(EXE): prims.$(O) libcamlrun_non_shared.$(A)
-	$(call MKEXE_USING_COMPILER,$@,$^ $(LIBS))
-
-libcamlrun.$(A): $(libcamlrun_OBJECTS)
-	$(call MKLIB,$@, $^)
-
-libcamlrun_non_shared.$(A): $(libcamlrun_non_shared_OBJECTS)
-	$(call MKLIB,$@, $^)
-
-ocamlrund$(EXE): prims.$(O) libcamlrund.$(A)
-	$(MKEXE) $(MKEXEDEBUGFLAG) -o $@ $^ $(LIBS)
-
-libcamlrund.$(A): $(libcamlrund_OBJECTS)
-	$(call MKLIB,$@, $^)
-
-ocamlruni$(EXE): prims.$(O) libcamlruni.$(A)
-	$(MKEXE) -o $@ $^ $(INSTRUMENTED_RUNTIME_LIBS) $(LIBS)
-
-libcamlruni.$(A): $(libcamlruni_OBJECTS)
-	$(call MKLIB,$@, $^)
-
-libcamlrun_pic.$(A): $(libcamlrunpic_OBJECTS)
-	$(call MKLIB,$@, $^)
-
-libcamlrun_shared.$(SO): $(libcamlrunpic_OBJECTS)
-	$(MKDLL) -o $@ $^ $(BYTECCLIBS)
-
-libasmrun.$(A): $(libasmrun_OBJECTS)
-	$(call MKLIB,$@, $^)
-
-libasmrund.$(A): $(libasmrund_OBJECTS)
-	$(call MKLIB,$@, $^)
-
-libasmruni.$(A): $(libasmruni_OBJECTS)
-	$(call MKLIB,$@, $^)
-
-libasmrun_pic.$(A): $(libasmrunpic_OBJECTS)
-	$(call MKLIB,$@, $^)
-
-libasmrun_shared.$(SO): $(libasmrunpic_OBJECTS)
-	$(MKDLL) -o $@ $^ $(NATIVECCLIBS)
-
-# Target-specific preprocessor and compiler flags
-
-%.bd.$(O): OC_CPPFLAGS += $(OC_DEBUG_CPPFLAGS)
-%.bd.$(D): OC_CPPFLAGS += $(OC_DEBUG_CPPFLAGS)
-
-%.bi.$(O): OC_CPPFLAGS += $(OC_INSTR_CPPFLAGS)
-%.bi.$(D): OC_CPPFLAGS += $(OC_INSTR_CPPFLAGS)
-
-%.bpic.$(O): OC_CFLAGS += $(SHAREDLIB_CFLAGS)
-
-%.n.$(O): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS)
-%.n.$(D): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS)
-
-%.nd.$(O): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS) $(OC_DEBUG_CPPFLAGS)
-%.nd.$(D): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS) $(OC_DEBUG_CPPFLAGS)
-
-%.ni.$(O): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS) $(OC_INSTR_CPPFLAGS)
-%.ni.$(D): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS) $(OC_INSTR_CPPFLAGS)
-
-%.npic.$(O): OC_CFLAGS += $(SHAREDLIB_CFLAGS)
-%.npic.$(O): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS)
-%.npic.$(D): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS)
-
-# Compilation of C files
-
-# The COMPILE_C_FILE macro below receives as argument the pattern
-# that corresponds to the name of the generated object file
-# (without the extension, which is added by the macro)
-define COMPILE_C_FILE
-ifneq "$(COMPUTE_DEPS)" "false"
-ifneq "$(1)" "%"
-# -MG would ensure that the dependencies are generated even if the files listed
-# in $$(BUILT_HEADERS) haven't been assembled yet. However, this goes subtly
-# wrong if the user has the headers installed, as gcc will pick up a dependency
-# on those instead and the local ones will not be generated. For this reason, we
-# don't use -MG and instead include $(BUILT_HEADERS) in the order only
-# dependencies to ensure that they exist before dependencies are computed.
-$(DEPDIR)/$(1).$(D): %.c | $(DEPDIR) $(BUILT_HEADERS)
-	$$(DEP_CC) $$(OC_CPPFLAGS) $$(CPPFLAGS) $$< -MT \
-	  '$$*$(subst %,,$(1)).$(O)' -MF $$@
-endif # ifneq "$(1)" "%"
-$(1).$(O): $(2).c
-else
-$(1).$(O): $(2).c $(CONFIGURED_HEADERS) $(BUILT_HEADERS) $(RUNTIME_HEADERS)
-endif # ifneq "$(COMPUTE_DEPS)" "false"
-	$$(CC) -c $$(OC_CFLAGS) $$(CFLAGS) $$(OC_CPPFLAGS) $$(CPPFLAGS) \
-	  $$(OUTPUTOBJ)$$@ $$<
-endef
-
-object_types := % %.b %.bd %.bi %.bpic
-ifneq "$(NATIVE_COMPILER)" "false"
-object_types += %.n %.nd %.ni %.np %.npic
-endif
-
-$(foreach object_type, $(object_types), \
-  $(eval $(call COMPILE_C_FILE,$(object_type),%)))
-
-$(UNIX_OR_WIN32)_non_shared.%.$(O): OC_CPPFLAGS += -DBUILDING_LIBCAMLRUNS
-
-$(eval $(call COMPILE_C_FILE,$(UNIX_OR_WIN32)_non_shared.%,$(UNIX_OR_WIN32)))
-
-$(foreach object_type,$(subst %,,$(object_types)), \
-  $(eval dynlink$(object_type).$(O): $(ROOTDIR)/Makefile.config))
-
-# Compilation of assembly files
-
-%.o: %.S
-	$(ASPP) $(ASPPFLAGS) -o $@ $< || \
-	{ echo "If your assembler produced syntax errors, it is probably";\
-          echo "unhappy with the preprocessor. Check your assembler, or";\
-          echo "try producing $*.o by hand.";\
-          exit 2; }
-
-%_libasmrunpic.o: %.S
-	$(ASPP) $(ASPPFLAGS) $(SHAREDLIB_CFLAGS) -o $@ $<
-
-domain_state64.inc: caml/domain_state.tbl gen_domain_state64_inc.awk
-	$(AWK) -f ./gen_domain_state64_inc.awk $< > $@
-
-domain_state32.inc: caml/domain_state.tbl gen_domain_state32_inc.awk
-	$(AWK) -f ./gen_domain_state32_inc.awk $< > $@
-
-amd64nt.obj: amd64nt.asm domain_state64.inc
-	$(ASM)$@ $(ASMFLAGS) $<
-
-i386nt.obj: i386nt.asm domain_state32.inc
-	$(ASM)$@ $(ASMFLAGS) $<
-
-%_libasmrunpic.obj: %.asm
-	$(ASM)$@ $(ASMFLAGS) $<
-
-# Dependencies
-
-DEP_FILES := $(addsuffix .b, $(basename $(BYTECODE_C_SOURCES) instrtrace))
-ifneq "$(NATIVE_COMPILER)" "false"
-DEP_FILES += $(addsuffix .n, $(basename $(NATIVE_C_SOURCES)))
-endif
-DEP_FILES += $(addsuffix d, $(DEP_FILES)) \
-             $(addsuffix i, $(DEP_FILES)) \
-             $(addsuffix pic, $(DEP_FILES))
-DEP_FILES := $(addsuffix .$(D), $(DEP_FILES))
-
-ifeq "$(COMPUTE_DEPS)" "true"
-include $(addprefix $(DEPDIR)/, $(DEP_FILES))
-endif
-
-# This empty target is here for AppVeyor to allow dependencies to be built
-# without doing anything else.
-.PHONY: setup-depend
-setup-depend:
diff --git a/runtime/amd64.S b/runtime/amd64.S
index 756d4a5a0a..8081087c68 100644
--- a/runtime/amd64.S
+++ b/runtime/amd64.S
@@ -295,13 +295,13 @@
         .text
 
 #if defined(FUNCTION_SECTIONS)
-        TEXT_SECTION(caml_hot__code_begin)
-        .globl  G(caml_hot__code_begin)
-G(caml_hot__code_begin):
+        TEXT_SECTION(caml_hot.code_begin)
+        .globl  G(caml_hot.code_begin)
+G(caml_hot.code_begin):
 
-        TEXT_SECTION(caml_hot__code_end)
-        .globl  G(caml_hot__code_end)
-G(caml_hot__code_end):
+        TEXT_SECTION(caml_hot.code_end)
+        .globl  G(caml_hot.code_end)
+G(caml_hot.code_end):
 #endif
 
         TEXT_SECTION(caml_system__code_begin)
@@ -664,9 +664,9 @@ ENDFUNCTION(G(caml_ml_array_bound_error))
 G(caml_system__code_end):
 
         .data
-        .globl  G(caml_system__frametable)
+        .globl  G(caml_system.frametable)
         .align  EIGHT_ALIGN
-G(caml_system__frametable):
+G(caml_system.frametable):
         .quad   1           /* one descriptor */
         .quad   LBL(107)    /* return address into callback */
         .value  -1          /* negative frame size => use callback link */
diff --git a/runtime/arm.S b/runtime/arm.S
index 612757a104..d2632bfceb 100644
--- a/runtime/arm.S
+++ b/runtime/arm.S
@@ -113,13 +113,13 @@ domain_state_ptr  .req    r11
 name:
 
 #if defined(FUNCTION_SECTIONS)
-        TEXT_SECTION(caml_hot__code_begin)
-        .globl  caml_hot__code_begin
-caml_hot__code_begin:
+        TEXT_SECTION(caml_hot.code_begin)
+        .globl  caml_hot.code_begin
+caml_hot.code_begin:
 
-        TEXT_SECTION(caml_hot__code_end)
-        .globl  caml_hot__code_end
-caml_hot__code_end:
+        TEXT_SECTION(caml_hot.code_end)
+        .globl  caml_hot.code_end
+caml_hot.code_end:
 #endif
 
         .set    domain_curr_field, 0
@@ -433,15 +433,15 @@ caml_system__code_end:
 
         .data
         .align  2
-        .globl  caml_system__frametable
-caml_system__frametable:
+        .globl  caml_system.frametable
+caml_system.frametable:
         .word   1               /* one descriptor */
         .word   .Lcaml_retaddr  /* return address into callback */
         .short  -1              /* negative frame size => use callback link */
         .short  0               /* no roots */
         .align  2
-        .type   caml_system__frametable, %object
-        .size   caml_system__frametable, .-caml_system__frametable
+        .type   caml_system.frametable, %object
+        .size   caml_system.frametable, .-caml_system.frametable
 
 /* Mark stack as non-executable */
         .section .note.GNU-stack,"",%progbits
diff --git a/runtime/arm64.S b/runtime/arm64.S
index 02a7ba0832..abb38be6e7 100644
--- a/runtime/arm64.S
+++ b/runtime/arm64.S
@@ -100,13 +100,13 @@
 #endif
 
 #if defined(FUNCTION_SECTIONS)
-        TEXT_SECTION(caml_hot__code_begin)
-        .globl  G(caml_hot__code_begin)
-G(caml_hot__code_begin):
+        TEXT_SECTION(caml_hot.code_begin)
+        .globl  G(caml_hot.code_begin)
+G(caml_hot.code_begin):
 
-        TEXT_SECTION(caml_hot__code_end)
-        .globl  G(caml_hot__code_end)
-G(caml_hot__code_end):
+        TEXT_SECTION(caml_hot.code_end)
+        .globl  G(caml_hot.code_end)
+G(caml_hot.code_end):
 #endif
 
 #if defined(SYS_macosx)
@@ -533,13 +533,13 @@ G(caml_system__code_end):
 
 /* GC roots for callback */
 
-OBJECT(caml_system__frametable)
+OBJECT(caml_system.frametable)
         .quad   1               /* one descriptor */
         .quad   L(caml_retaddr) /* return address into callback */
         .short  -1              /* negative frame size => use callback link */
         .short  0               /* no roots */
         .align  3
-        END_OBJECT(caml_system__frametable)
+        END_OBJECT(caml_system.frametable)
 
 #if !defined(SYS_macosx)
 /* Mark stack as non-executable */
diff --git a/runtime/bigarray.c b/runtime/bigarray.c
index ed4ff67d21..03151f6946 100644
--- a/runtime/bigarray.c
+++ b/runtime/bigarray.c
@@ -89,7 +89,7 @@ CAMLexport value
 caml_ba_alloc(int flags, int num_dims, void * data, intnat * dim)
 {
   uintnat num_elts, asize, size;
-  int i;
+  int i, is_managed;
   value res;
   struct caml_ba_array * b;
   intnat dimcopy[CAML_BA_MAX_NUM_DIMS];
@@ -97,23 +97,23 @@ caml_ba_alloc(int flags, int num_dims, void * data, intnat * dim)
   CAMLassert(num_dims >= 0 && num_dims <= CAML_BA_MAX_NUM_DIMS);
   CAMLassert((flags & CAML_BA_KIND_MASK) <= CAML_BA_CHAR);
   for (i = 0; i < num_dims; i++) dimcopy[i] = dim[i];
-  size = 0;
-  if (data == NULL) {
-    num_elts = 1;
-    for (i = 0; i < num_dims; i++) {
-      if (caml_umul_overflow(num_elts, dimcopy[i], &num_elts))
-        caml_raise_out_of_memory();
-    }
-    if (caml_umul_overflow(num_elts,
-                           caml_ba_element_size[flags & CAML_BA_KIND_MASK],
-                           &size))
+  num_elts = 1;
+  for (i = 0; i < num_dims; i++) {
+    if (caml_umul_overflow(num_elts, dimcopy[i], &num_elts))
       caml_raise_out_of_memory();
+  }
+  if (caml_umul_overflow(num_elts,
+                         caml_ba_element_size[flags & CAML_BA_KIND_MASK],
+                         &size))
+    caml_raise_out_of_memory();
+  if (data == NULL) {
     data = malloc(size);
     if (data == NULL && size != 0) caml_raise_out_of_memory();
     flags |= CAML_BA_MANAGED;
   }
   asize = SIZEOF_BA_ARRAY + num_dims * sizeof(intnat);
-  res = caml_alloc_custom_mem(&caml_ba_ops, asize, size);
+  is_managed = ((flags & CAML_BA_MANAGED_MASK) == CAML_BA_MANAGED);
+  res = caml_alloc_custom_mem(&caml_ba_ops, asize, is_managed ? size : 0);
   b = Caml_ba_array_val(res);
   b->data = data;
   b->num_dims = num_dims;
diff --git a/runtime/caml/alloc.h b/runtime/caml/alloc.h
index 13f0fac2fb..816da799bb 100644
--- a/runtime/caml/alloc.h
+++ b/runtime/caml/alloc.h
@@ -17,9 +17,6 @@
 #define CAML_ALLOC_H
 
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "misc.h"
 #include "mlvalues.h"
 
diff --git a/runtime/caml/bigarray.h b/runtime/caml/bigarray.h
index fc1fb14570..1664ae3f6e 100644
--- a/runtime/caml/bigarray.h
+++ b/runtime/caml/bigarray.h
@@ -16,9 +16,6 @@
 #ifndef CAML_BIGARRAY_H
 #define CAML_BIGARRAY_H
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "config.h"
 #include "mlvalues.h"
 
diff --git a/runtime/caml/callback.h b/runtime/caml/callback.h
index eef3342ec7..5c45995b8a 100644
--- a/runtime/caml/callback.h
+++ b/runtime/caml/callback.h
@@ -18,9 +18,6 @@
 #ifndef CAML_CALLBACK_H
 #define CAML_CALLBACK_H
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "mlvalues.h"
 
 #ifdef __cplusplus
diff --git a/runtime/caml/camlatomic.h b/runtime/caml/camlatomic.h
new file mode 100644
index 0000000000..7206f0579a
--- /dev/null
+++ b/runtime/caml/camlatomic.h
@@ -0,0 +1,85 @@
+/**************************************************************************/
+/*                                                                        */
+/*                                 OCaml                                  */
+/*                                                                        */
+/*      KC Sivaramakrishnan, Indian Institute of Technology, Madras       */
+/*                Stephen Dolan, University of Cambridge                  */
+/*                                                                        */
+/*   Copyright 2018 Indian Institute of Technology, Madras                */
+/*   Copyright 2018 University of Cambridge                               */
+/*                                                                        */
+/*   All rights reserved.  This file is distributed under the terms of    */
+/*   the GNU Lesser General Public License version 2.1, with the          */
+/*   special exception on linking described in the file LICENSE.          */
+/*                                                                        */
+/**************************************************************************/
+#ifndef CAML_ATOMIC_H
+#define CAML_ATOMIC_H
+
+#include "config.h"
+
+/* On platforms supporting C11 atomics, this file just includes <stdatomic.h>.
+
+   On other platforms, this file includes platform-specific stubs for
+   the subset of C11 atomics needed by the OCaml runtime
+ */
+
+#ifdef __cplusplus
+
+extern "C++" {
+#include <atomic>
+#define ATOMIC_UINTNAT_INIT(x) (x)
+typedef std::atomic<uintnat> atomic_uintnat;
+typedef std::atomic<intnat> atomic_intnat;
+using std::memory_order_relaxed;
+using std::memory_order_acquire;
+using std::memory_order_release;
+using std::memory_order_acq_rel;
+using std::memory_order_seq_cst;
+}
+
+#elif defined(HAS_STDATOMIC_H)
+
+#include <stdatomic.h>
+#define ATOMIC_UINTNAT_INIT(x) (x)
+typedef _Atomic uintnat atomic_uintnat;
+typedef _Atomic intnat atomic_intnat;
+
+#elif defined(__GNUC__)
+
+/* Support for versions of gcc which have built-in atomics but do not
+   expose stdatomic.h (e.g. gcc 4.8) */
+typedef enum memory_order {
+  memory_order_relaxed = __ATOMIC_RELAXED,
+  memory_order_acquire = __ATOMIC_ACQUIRE,
+  memory_order_release = __ATOMIC_RELEASE,
+  memory_order_acq_rel = __ATOMIC_ACQ_REL,
+  memory_order_seq_cst = __ATOMIC_SEQ_CST
+} memory_order;
+
+#define ATOMIC_UINTNAT_INIT(x) { (x) }
+typedef struct { uintnat repr; } atomic_uintnat;
+typedef struct { intnat repr; } atomic_intnat;
+
+#define atomic_load_explicit(x, m) __atomic_load_n(&(x)->repr, (m))
+#define atomic_load(x) atomic_load_explicit((x), memory_order_seq_cst)
+#define atomic_store_explicit(x, v, m) __atomic_store_n(&(x)->repr, (v), (m))
+#define atomic_store(x, v) atomic_store_explicit((x), (v), memory_order_seq_cst)
+#define atomic_compare_exchange_strong(x, oldv, newv) \
+  __atomic_compare_exchange_n( \
+    &(x)->repr, \
+    (oldv), (newv), 0, \
+    memory_order_seq_cst, memory_order_seq_cst)
+#define atomic_exchange(x, newv) \
+  __atomic_exchange_n(&(x)->repr, (newv), memory_order_seq_cst)
+#define atomic_fetch_add(x, n) \
+  __atomic_fetch_add(&(x)->repr, (n), memory_order_seq_cst)
+#define atomic_fetch_or(x, n) \
+  __atomic_fetch_or(&(x)->repr, (n), memory_order_seq_cst)
+#define atomic_thread_fence __atomic_thread_fence
+
+#else
+#error "C11 atomics are unavailable on this platform. See camlatomic.h"
+#endif
+
+#endif /* CAML_ATOMIC_H */
diff --git a/runtime/caml/compatibility.h b/runtime/caml/compatibility.h
deleted file mode 100644
index 1c109aa470..0000000000
--- a/runtime/caml/compatibility.h
+++ /dev/null
@@ -1,373 +0,0 @@
-/**************************************************************************/
-/*                                                                        */
-/*                                 OCaml                                  */
-/*                                                                        */
-/*           Damien Doligez, projet Moscova, INRIA Rocquencourt           */
-/*                                                                        */
-/*   Copyright 2003 Institut National de Recherche en Informatique et     */
-/*     en Automatique.                                                    */
-/*                                                                        */
-/*   All rights reserved.  This file is distributed under the terms of    */
-/*   the GNU Lesser General Public License version 2.1, with the          */
-/*   special exception on linking described in the file LICENSE.          */
-/*                                                                        */
-/**************************************************************************/
-
-/* definitions for compatibility with old identifiers */
-
-#ifndef CAML_COMPATIBILITY_H
-#define CAML_COMPATIBILITY_H
-
-/* internal global variables renamed between 4.02.1 and 4.03.0 */
-#define caml_stat_top_heap_size Bsize_wsize(caml_stat_top_heap_wsz)
-#define caml_stat_heap_size Bsize_wsize(caml_stat_heap_wsz)
-
-#ifndef CAML_NAME_SPACE
-
-/*
-   #define --> CAMLextern  (defined with CAMLexport or CAMLprim)
-   (rien)  --> CAMLprim
-   g       --> global C identifier
-   x       --> special case
-
-   SP* signals the special cases:
-   - when the identifier was not simply prefixed with [caml_]
-   - when the [caml_] version was already used for something else, and
-     was renamed out of the way (watch out for [caml_alloc] and
-     [caml_array_bound_error] in *.s)
-*/
-
-/* a faire:
-   - ui_*   (reverifier que win32.c n'en depend pas)
-*/
-
-
-/* **** alloc.c */
-#define alloc CAML_DEPRECATED("alloc", "caml_alloc") caml_alloc /*SP*/
-#define alloc_small CAML_DEPRECATED("alloc_small", "caml_alloc_small") caml_alloc_small
-#define alloc_tuple CAML_DEPRECATED("alloc_tuple", "caml_alloc_tuple") caml_alloc_tuple
-#define alloc_string CAML_DEPRECATED("alloc_string", "caml_alloc_string") caml_alloc_string
-#define alloc_final CAML_DEPRECATED("alloc_final", "caml_alloc_final") caml_alloc_final
-#define copy_string CAML_DEPRECATED("copy_string", "caml_copy_string") caml_copy_string
-#define alloc_array CAML_DEPRECATED("alloc_array", "caml_alloc_array") caml_alloc_array
-#define copy_string_array CAML_DEPRECATED("copy_string_array", "caml_copy_string_array") caml_copy_string_array
-#define convert_flag_list CAML_DEPRECATED("convert_flag_list", "caml_convert_flag_list") caml_convert_flag_list
-
-/* **** array.c */
-
-/* **** backtrace.c */
-#define backtrace_active CAML_DEPRECATED("backtrace_active", "caml_backtrace_active") caml_backtrace_active
-#define backtrace_pos CAML_DEPRECATED("backtrace_pos", "caml_backtrace_pos") caml_backtrace_pos
-#define backtrace_buffer CAML_DEPRECATED("backtrace_buffer", "caml_backtrace_buffer") caml_backtrace_buffer
-#define backtrace_last_exn CAML_DEPRECATED("backtrace_last_exn", "caml_backtrace_last_exn") caml_backtrace_last_exn
-#define print_exception_backtrace CAML_DEPRECATED("print_exception_backtrace", "caml_print_exception_backtrace") caml_print_exception_backtrace
-
-/* **** callback.c */
-#define callback_depth CAML_DEPRECATED("callback_depth", "caml_callback_depth") caml_callback_depth
-#define callbackN_exn CAML_DEPRECATED("callbackN_exn", "caml_callbackN_exn") caml_callbackN_exn
-#define callback_exn CAML_DEPRECATED("callback_exn", "caml_callback_exn") caml_callback_exn
-#define callback2_exn CAML_DEPRECATED("callback2_exn", "caml_callback2_exn") caml_callback2_exn
-#define callback3_exn CAML_DEPRECATED("callback3_exn", "caml_callback3_exn") caml_callback3_exn
-#define callback CAML_DEPRECATED("callback", "caml_callback") caml_callback
-#define callback2 CAML_DEPRECATED("callback2", "caml_callback2") caml_callback2
-#define callback3 CAML_DEPRECATED("callback3", "caml_callback3") caml_callback3
-#define callbackN CAML_DEPRECATED("callbackN", "caml_callbackN") caml_callbackN
-
-/* **** compact.c */
-
-/* **** compare.c */
-#define compare_unordered CAML_DEPRECATED("compare_unordered", "caml_compare_unordered") caml_compare_unordered
-
-/* **** custom.c */
-#define alloc_custom CAML_DEPRECATED("alloc_custom", "caml_alloc_custom") caml_alloc_custom
-#define register_custom_operations CAML_DEPRECATED("register_custom_operations", "caml_register_custom_operations") caml_register_custom_operations
-
-/* **** debugger.c */
-
-/* **** dynlink.c */
-
-/* **** extern.c */
-#define output_val CAML_DEPRECATED("output_val", "caml_output_val") caml_output_val
-#define output_value_to_malloc CAML_DEPRECATED("output_value_to_malloc", "caml_output_value_to_malloc") caml_output_value_to_malloc
-#define output_value_to_block CAML_DEPRECATED("output_value_to_block", "caml_output_value_to_block") caml_output_value_to_block
-#define serialize_int_1 CAML_DEPRECATED("serialize_int_1", "caml_serialize_int_1") caml_serialize_int_1
-#define serialize_int_2 CAML_DEPRECATED("serialize_int_2", "caml_serialize_int_2") caml_serialize_int_2
-#define serialize_int_4 CAML_DEPRECATED("serialize_int_4", "caml_serialize_int_4") caml_serialize_int_4
-#define serialize_int_8 CAML_DEPRECATED("serialize_int_8", "caml_serialize_int_8") caml_serialize_int_8
-#define serialize_float_4 CAML_DEPRECATED("serialize_float_4", "caml_serialize_float_4") caml_serialize_float_4
-#define serialize_float_8 CAML_DEPRECATED("serialize_float_8", "caml_serialize_float_8") caml_serialize_float_8
-#define serialize_block_1 CAML_DEPRECATED("serialize_block_1", "caml_serialize_block_1") caml_serialize_block_1
-#define serialize_block_2 CAML_DEPRECATED("serialize_block_2", "caml_serialize_block_2") caml_serialize_block_2
-#define serialize_block_4 CAML_DEPRECATED("serialize_block_4", "caml_serialize_block_4") caml_serialize_block_4
-#define serialize_block_8 CAML_DEPRECATED("serialize_block_8", "caml_serialize_block_8") caml_serialize_block_8
-#define serialize_block_float_8 CAML_DEPRECATED("serialize_block_float_8", "caml_serialize_block_float_8") caml_serialize_block_float_8
-
-/* **** fail.c */
-#define external_raise CAML_DEPRECATED("external_raise", "caml_external_raise") caml_external_raise
-#define mlraise CAML_DEPRECATED("mlraise", "caml_raise") caml_raise /*SP*/
-#define raise_constant CAML_DEPRECATED("raise_constant", "caml_raise_constant") caml_raise_constant
-#define raise_with_arg CAML_DEPRECATED("raise_with_arg", "caml_raise_with_arg") caml_raise_with_arg
-#define raise_with_string CAML_DEPRECATED("raise_with_string", "caml_raise_with_string") caml_raise_with_string
-#define failwith CAML_DEPRECATED("failwith", "caml_failwith") caml_failwith
-#define invalid_argument CAML_DEPRECATED("invalid_argument", "caml_invalid_argument") caml_invalid_argument
-#define array_bound_error CAML_DEPRECATED("array_bound_error", "caml_array_bound_error") caml_array_bound_error /*SP*/
-#define raise_out_of_memory CAML_DEPRECATED("raise_out_of_memory", "caml_raise_out_of_memory") caml_raise_out_of_memory
-#define raise_stack_overflow CAML_DEPRECATED("raise_stack_overflow", "caml_raise_stack_overflow") caml_raise_stack_overflow
-#define raise_sys_error CAML_DEPRECATED("raise_sys_error", "caml_raise_sys_error") caml_raise_sys_error
-#define raise_end_of_file CAML_DEPRECATED("raise_end_of_file", "caml_raise_end_of_file") caml_raise_end_of_file
-#define raise_zero_divide CAML_DEPRECATED("raise_zero_divide", "caml_raise_zero_divide") caml_raise_zero_divide
-#define raise_not_found CAML_DEPRECATED("raise_not_found", "caml_raise_not_found") caml_raise_not_found
-#define raise_sys_blocked_io CAML_DEPRECATED("raise_sys_blocked_io", "caml_raise_sys_blocked_io") caml_raise_sys_blocked_io
-/* **** runtime/fail_nat.c */
-/* **** runtime/<arch>.s */
-
-/* **** finalise.c */
-
-/* **** fix_code.c */
-
-/* **** floats.c */
-/*#define Double_val caml_Double_val             done in mlvalues.h as needed */
-/*#define Store_double_val caml_Store_double_val done in mlvalues.h as needed */
-#define copy_double CAML_DEPRECATED("copy_double", "caml_copy_double") caml_copy_double
-
-/* **** freelist.c */
-
-/* **** gc_ctrl.c */
-
-/* **** globroots.c */
-#define register_global_root CAML_DEPRECATED("register_global_root", "caml_register_global_root") caml_register_global_root
-#define remove_global_root CAML_DEPRECATED("remove_global_root", "caml_remove_global_root") caml_remove_global_root
-
-/* **** hash.c */
-#define hash_variant CAML_DEPRECATED("hash_variant", "caml_hash_variant") caml_hash_variant
-
-/* **** instrtrace.c */
-
-/* **** intern.c */
-#define input_val CAML_DEPRECATED("input_val", "caml_input_val") caml_input_val
-#define input_val_from_string CAML_DEPRECATED("input_val_from_string", "caml_input_val_from_string") caml_input_val_from_string
-#define input_value_from_malloc CAML_DEPRECATED("input_value_from_malloc", "caml_input_value_from_malloc") caml_input_value_from_malloc
-#define input_value_from_block CAML_DEPRECATED("input_value_from_block", "caml_input_value_from_block") caml_input_value_from_block
-#define deserialize_uint_1 CAML_DEPRECATED("deserialize_uint_1", "caml_deserialize_uint_1") caml_deserialize_uint_1
-#define deserialize_sint_1 CAML_DEPRECATED("deserialize_sint_1", "caml_deserialize_sint_1") caml_deserialize_sint_1
-#define deserialize_uint_2 CAML_DEPRECATED("deserialize_uint_2", "caml_deserialize_uint_2") caml_deserialize_uint_2
-#define deserialize_sint_2 CAML_DEPRECATED("deserialize_sint_2", "caml_deserialize_sint_2") caml_deserialize_sint_2
-#define deserialize_uint_4 CAML_DEPRECATED("deserialize_uint_4", "caml_deserialize_uint_4") caml_deserialize_uint_4
-#define deserialize_sint_4 CAML_DEPRECATED("deserialize_sint_4", "caml_deserialize_sint_4") caml_deserialize_sint_4
-#define deserialize_uint_8 CAML_DEPRECATED("deserialize_uint_8", "caml_deserialize_uint_8") caml_deserialize_uint_8
-#define deserialize_sint_8 CAML_DEPRECATED("deserialize_sint_8", "caml_deserialize_sint_8") caml_deserialize_sint_8
-#define deserialize_float_4 CAML_DEPRECATED("deserialize_float_4", "caml_deserialize_float_4") caml_deserialize_float_4
-#define deserialize_float_8 CAML_DEPRECATED("deserialize_float_8", "caml_deserialize_float_8") caml_deserialize_float_8
-#define deserialize_block_1 CAML_DEPRECATED("deserialize_block_1", "caml_deserialize_block_1") caml_deserialize_block_1
-#define deserialize_block_2 CAML_DEPRECATED("deserialize_block_2", "caml_deserialize_block_2") caml_deserialize_block_2
-#define deserialize_block_4 CAML_DEPRECATED("deserialize_block_4", "caml_deserialize_block_4") caml_deserialize_block_4
-#define deserialize_block_8 CAML_DEPRECATED("deserialize_block_8", "caml_deserialize_block_8") caml_deserialize_block_8
-#define deserialize_block_float_8 CAML_DEPRECATED("deserialize_block_float_8", "caml_deserialize_block_float_8") caml_deserialize_block_float_8
-#define deserialize_error CAML_DEPRECATED("deserialize_error", "caml_deserialize_error") caml_deserialize_error
-
-/* **** interp.c */
-
-/* **** ints.c */
-#define int32_ops CAML_DEPRECATED("int32_ops", "caml_int32_ops") caml_int32_ops
-#define copy_int32 CAML_DEPRECATED("copy_int32", "caml_copy_int32") caml_copy_int32
-/*#define Int64_val caml_Int64_val   *** done in mlvalues.h as needed */
-#define int64_ops CAML_DEPRECATED("int64_ops", "caml_int64_ops") caml_int64_ops
-#define copy_int64 CAML_DEPRECATED("copy_int64", "caml_copy_int64") caml_copy_int64
-#define nativeint_ops CAML_DEPRECATED("nativeint_ops", "caml_nativeint_ops") caml_nativeint_ops
-#define copy_nativeint CAML_DEPRECATED("copy_nativeint", "caml_copy_nativeint") caml_copy_nativeint
-
-/* **** io.c */
-#define channel_mutex_free CAML_DEPRECATED("channel_mutex_free", "caml_channel_mutex_free") caml_channel_mutex_free
-#define channel_mutex_lock CAML_DEPRECATED("channel_mutex_lock", "caml_channel_mutex_lock") caml_channel_mutex_lock
-#define channel_mutex_unlock CAML_DEPRECATED("channel_mutex_unlock", "caml_channel_mutex_unlock") caml_channel_mutex_unlock
-#define channel_mutex_unlock_exn CAML_DEPRECATED("channel_mutex_unlock_exn", "caml_channel_mutex_unlock_exn") caml_channel_mutex_unlock_exn
-#define all_opened_channels CAML_DEPRECATED("all_opened_channels", "caml_all_opened_channels") caml_all_opened_channels
-#define open_descriptor_in CAML_DEPRECATED("open_descriptor_in", "caml_open_descriptor_in") caml_open_descriptor_in /*SP*/
-#define open_descriptor_out CAML_DEPRECATED("open_descriptor_out", "caml_open_descriptor_out") caml_open_descriptor_out /*SP*/
-#define close_channel CAML_DEPRECATED("close_channel", "caml_close_channel") caml_close_channel /*SP*/
-#define channel_size CAML_DEPRECATED("channel_size", "caml_channel_size") caml_channel_size /*SP*/
-#define channel_binary_mode CAML_DEPRECATED("channel_binary_mode", "caml_channel_binary_mode") caml_channel_binary_mode
-#define flush_partial CAML_DEPRECATED("flush_partial", "caml_flush_partial") caml_flush_partial /*SP*/
-#define flush CAML_DEPRECATED("flush", "caml_flush") caml_flush /*SP*/
-#define putword CAML_DEPRECATED("putword", "caml_putword") caml_putword
-#define putblock CAML_DEPRECATED("putblock", "caml_putblock") caml_putblock
-#define really_putblock CAML_DEPRECATED("really_putblock", "caml_really_putblock") caml_really_putblock
-#define seek_out CAML_DEPRECATED("seek_out", "caml_seek_out") caml_seek_out /*SP*/
-#define pos_out CAML_DEPRECATED("pos_out", "caml_pos_out") caml_pos_out /*SP*/
-#define do_read CAML_DEPRECATED("do_read", "caml_do_read") caml_do_read
-#define refill CAML_DEPRECATED("refill", "caml_refill") caml_refill
-#define getword CAML_DEPRECATED("getword", "caml_getword") caml_getword
-#define getblock CAML_DEPRECATED("getblock", "caml_getblock") caml_getblock
-#define really_getblock CAML_DEPRECATED("really_getblock", "caml_really_getblock") caml_really_getblock
-#define seek_in CAML_DEPRECATED("seek_in", "caml_seek_in") caml_seek_in /*SP*/
-#define pos_in CAML_DEPRECATED("pos_in", "caml_pos_in") caml_pos_in /*SP*/
-#define input_scan_line CAML_DEPRECATED("input_scan_line", "caml_input_scan_line") caml_input_scan_line /*SP*/
-#define finalize_channel CAML_DEPRECATED("finalize_channel", "caml_finalize_channel") caml_finalize_channel
-#define alloc_channel CAML_DEPRECATED("alloc_channel", "caml_alloc_channel") caml_alloc_channel
-/*#define Val_file_offset caml_Val_file_offset   *** done in io.h as needed */
-/*#define File_offset_val caml_File_offset_val   *** done in io.h as needed */
-
-/* **** lexing.c */
-
-/* **** main.c */
-/* *** no change */
-
-/* **** major_gc.c */
-#define heap_start CAML_DEPRECATED("heap_start", "caml_heap_start") caml_heap_start
-#define page_table CAML_DEPRECATED("page_table", "caml_page_table") caml_page_table
-
-/* **** md5.c */
-#define md5_string CAML_DEPRECATED("md5_string", "caml_md5_string") caml_md5_string
-#define md5_chan CAML_DEPRECATED("md5_chan", "caml_md5_chan") caml_md5_chan
-#define MD5Init CAML_DEPRECATED("MD5Init", "caml_MD5Init") caml_MD5Init
-#define MD5Update CAML_DEPRECATED("MD5Update", "caml_MD5Update") caml_MD5Update
-#define MD5Final CAML_DEPRECATED("MD5Final", "caml_MD5Final") caml_MD5Final
-#define MD5Transform CAML_DEPRECATED("MD5Transform", "caml_MD5Transform") caml_MD5Transform
-
-/* **** memory.c */
-#define alloc_shr CAML_DEPRECATED("alloc_shr", "caml_alloc_shr") caml_alloc_shr
-#define initialize CAML_DEPRECATED("initialize", "caml_initialize") caml_initialize
-#define modify CAML_DEPRECATED("modify", "caml_modify") caml_modify
-#define stat_alloc CAML_DEPRECATED("stat_alloc", "caml_stat_alloc") caml_stat_alloc
-#define stat_free CAML_DEPRECATED("stat_free", "caml_stat_free") caml_stat_free
-#define stat_resize CAML_DEPRECATED("stat_resize", "caml_stat_resize") caml_stat_resize
-
-/* **** meta.c */
-
-/* **** minor_gc.c */
-#define young_start CAML_DEPRECATED("young_start", "caml_young_start") caml_young_start
-#define young_end CAML_DEPRECATED("young_end", "caml_young_end") caml_young_end
-#define young_ptr CAML_DEPRECATED("young_ptr", "caml_young_ptr") caml_young_ptr
-#define young_limit CAML_DEPRECATED("young_limit", "caml_young_limit") caml_young_limit
-#define ref_table CAML_DEPRECATED("ref_table", "caml_ref_table") caml_ref_table
-#define minor_collection CAML_DEPRECATED("minor_collection", "caml_minor_collection") caml_minor_collection
-#define check_urgent_gc CAML_DEPRECATED("check_urgent_gc", "caml_check_urgent_gc") caml_check_urgent_gc
-
-/* **** misc.c */
-
-/* **** obj.c */
-
-/* **** parsing.c */
-
-/* **** prims.c */
-
-/* **** printexc.c */
-#define format_caml_exception CAML_DEPRECATED("format_caml_exception", "caml_format_exception") caml_format_exception /*SP*/
-
-/* **** roots.c */
-#define local_roots CAML_DEPRECATED("local_roots", "caml_local_roots") caml_local_roots
-#define scan_roots_hook CAML_DEPRECATED("scan_roots_hook", "caml_scan_roots_hook") caml_scan_roots_hook
-#define do_local_roots CAML_DEPRECATED("do_local_roots", "caml_do_local_roots") caml_do_local_roots
-
-/* **** signals.c */
-#define pending_signals CAML_DEPRECATED("pending_signals", "caml_pending_signals") caml_pending_signals
-#define something_to_do CAML_DEPRECATED("something_to_do", "caml_something_to_do") caml_something_to_do
-#define enter_blocking_section_hook CAML_DEPRECATED("enter_blocking_section_hook", "caml_enter_blocking_section_hook") caml_enter_blocking_section_hook
-#define leave_blocking_section_hook CAML_DEPRECATED("leave_blocking_section_hook", "caml_leave_blocking_section_hook") caml_leave_blocking_section_hook
-#define enter_blocking_section CAML_DEPRECATED("enter_blocking_section", "caml_enter_blocking_section") caml_enter_blocking_section
-#define leave_blocking_section CAML_DEPRECATED("leave_blocking_section", "caml_leave_blocking_section") caml_leave_blocking_section
-#define convert_signal_number CAML_DEPRECATED("convert_signal_number", "caml_convert_signal_number") caml_convert_signal_number
-
-/* **** runtime/signals.c */
-#define garbage_collection CAML_DEPRECATED("garbage_collection", "caml_garbage_collection") caml_garbage_collection
-
-/* **** stacks.c */
-#define stack_low CAML_DEPRECATED("stack_low", "caml_stack_low") caml_stack_low
-#define stack_high CAML_DEPRECATED("stack_high", "caml_stack_high") caml_stack_high
-#define stack_threshold CAML_DEPRECATED("stack_threshold", "caml_stack_threshold") caml_stack_threshold
-#define extern_sp CAML_DEPRECATED("extern_sp", "caml_extern_sp") caml_extern_sp
-#define trapsp CAML_DEPRECATED("trapsp", "caml_trapsp") caml_trapsp
-#define trap_barrier CAML_DEPRECATED("trap_barrier", "caml_trap_barrier") caml_trap_barrier
-
-/* **** startup.c */
-#define atom_table CAML_DEPRECATED("atom_table", "caml_atom_table") caml_atom_table
-/* **** runtime/startup_nat.c */
-#define static_data_start CAML_DEPRECATED("static_data_start", "caml_static_data_start") caml_static_data_start
-#define static_data_end CAML_DEPRECATED("static_data_end", "caml_static_data_end") caml_static_data_end
-
-/* **** str.c */
-#define string_length CAML_DEPRECATED("string_length", "caml_string_length") caml_string_length
-
-/* **** sys.c */
-#define sys_error CAML_DEPRECATED("sys_error", "caml_sys_error") caml_sys_error
-
-/* **** terminfo.c */
-
-/* **** unix.c  &  win32.c */
-#define search_exe_in_path CAML_DEPRECATED("search_exe_in_path", "caml_search_exe_in_path") caml_search_exe_in_path
-
-/* **** weak.c */
-
-/* **** asmcomp/asmlink.ml */
-
-/* **** asmcomp/cmmgen.ml */
-
-/* **** asmcomp/asmlink.ml, asmcomp/cmmgen.ml, asmcomp/compilenv.ml */
-
-/* ************************************************************* */
-
-/* **** otherlibs/bigarray */
-#define int8 caml_ba_int8
-#define uint8 caml_ba_uint8
-#define int16 caml_ba_int16
-#define uint16 caml_ba_uint16
-#define MAX_NUM_DIMS CAML_DEPRECATED("MAX_NUM_DIMS", "CAML_BA_MAX_NUM_DIMS") CAML_BA_MAX_NUM_DIMS
-#define caml_bigarray_kind CAML_DEPRECATED("caml_bigarray_kind", "caml_ba_kind") caml_ba_kind
-#define BIGARRAY_FLOAT32 CAML_DEPRECATED("BIGARRAY_FLOAT32", "CAML_BA_FLOAT32") CAML_BA_FLOAT32
-#define BIGARRAY_FLOAT64 CAML_DEPRECATED("BIGARRAY_FLOAT64", "CAML_BA_FLOAT64") CAML_BA_FLOAT64
-#define BIGARRAY_SINT8 CAML_DEPRECATED("BIGARRAY_SINT8", "CAML_BA_SINT8") CAML_BA_SINT8
-#define BIGARRAY_UINT8 CAML_DEPRECATED("BIGARRAY_UINT8", "CAML_BA_UINT8") CAML_BA_UINT8
-#define BIGARRAY_SINT16 CAML_DEPRECATED("BIGARRAY_SINT16", "CAML_BA_SINT16") CAML_BA_SINT16
-#define BIGARRAY_UINT16 CAML_DEPRECATED("BIGARRAY_UINT16", "CAML_BA_UINT16") CAML_BA_UINT16
-#define BIGARRAY_INT32 CAML_DEPRECATED("BIGARRAY_INT32", "CAML_BA_INT32") CAML_BA_INT32
-#define BIGARRAY_INT64 CAML_DEPRECATED("BIGARRAY_INT64", "CAML_BA_INT64") CAML_BA_INT64
-#define BIGARRAY_CAML_INT CAML_DEPRECATED("BIGARRAY_CAML_INT", "CAML_BA_CAML_INT") CAML_BA_CAML_INT
-#define BIGARRAY_NATIVE_INT CAML_DEPRECATED("BIGARRAY_NATIVE_INT", "CAML_BA_NATIVE_INT") CAML_BA_NATIVE_INT
-#define BIGARRAY_COMPLEX32 CAML_DEPRECATED("BIGARRAY_COMPLEX32", "CAML_BA_COMPLEX32") CAML_BA_COMPLEX32
-#define BIGARRAY_COMPLEX64 CAML_DEPRECATED("BIGARRAY_COMPLEX64", "CAML_BA_COMPLEX64") CAML_BA_COMPLEX64
-#define BIGARRAY_KIND_MASK CAML_DEPRECATED("BIGARRAY_KIND_MASK", "CAML_BA_KIND_MASK") CAML_BA_KIND_MASK
-#define caml_bigarray_layout CAML_DEPRECATED("caml_bigarray_layout", "caml_ba_layout") caml_ba_layout
-#define BIGARRAY_C_LAYOUT CAML_DEPRECATED("BIGARRAY_C_LAYOUT", "CAML_BA_C_LAYOUT") CAML_BA_C_LAYOUT
-#define BIGARRAY_FORTRAN_LAYOUT CAML_DEPRECATED("BIGARRAY_FORTRAN_LAYOUT", "CAML_BA_FORTRAN_LAYOUT") CAML_BA_FORTRAN_LAYOUT
-#define BIGARRAY_LAYOUT_MASK CAML_DEPRECATED("BIGARRAY_LAYOUT_MASK", "CAML_BA_LAYOUT_MASK") CAML_BA_LAYOUT_MASK
-#define caml_bigarray_managed CAML_DEPRECATED("caml_bigarray_managed", "caml_ba_managed") caml_ba_managed
-#define BIGARRAY_EXTERNAL CAML_DEPRECATED("BIGARRAY_EXTERNAL", "CAML_BA_EXTERNAL") CAML_BA_EXTERNAL
-#define BIGARRAY_MANAGED CAML_DEPRECATED("BIGARRAY_MANAGED", "CAML_BA_MANAGED") CAML_BA_MANAGED
-#define BIGARRAY_MAPPED_FILE CAML_DEPRECATED("BIGARRAY_MAPPED_FILE", "CAML_BA_MAPPED_FILE") CAML_BA_MAPPED_FILE
-#define BIGARRAY_MANAGED_MASK CAML_DEPRECATED("BIGARRAY_MANAGED_MASK", "CAML_BA_MANAGED_MASK") CAML_BA_MANAGED_MASK
-#define caml_bigarray_proxy CAML_DEPRECATED("caml_bigarray_proxy", "caml_ba_proxy") caml_ba_proxy
-#define caml_bigarray CAML_DEPRECATED("caml_bigarray", "caml_ba_array") caml_ba_array
-#define Bigarray_val CAML_DEPRECATED("Bigarray_val", "Caml_ba_array_val") Caml_ba_array_val
-#define Data_bigarray_val CAML_DEPRECATED("Data_bigarray_val", "Caml_ba_data_val") Caml_ba_data_val
-#define alloc_bigarray CAML_DEPRECATED("alloc_bigarray", "caml_ba_alloc") caml_ba_alloc
-#define alloc_bigarray_dims CAML_DEPRECATED("alloc_bigarray_dims", "caml_ba_alloc_dims") caml_ba_alloc_dims
-#define bigarray_map_file CAML_DEPRECATED("bigarray_map_file", "caml_ba_map_file") caml_ba_map_file
-#define bigarray_unmap_file CAML_DEPRECATED("bigarray_unmap_file", "caml_ba_unmap_file") caml_ba_unmap_file
-#define bigarray_element_size CAML_DEPRECATED("bigarray_element_size", "caml_ba_element_size") caml_ba_element_size
-#define bigarray_byte_size CAML_DEPRECATED("bigarray_byte_size", "caml_ba_byte_size") caml_ba_byte_size
-#define bigarray_deserialize CAML_DEPRECATED("bigarray_deserialize", "caml_ba_deserialize") caml_ba_deserialize
-#define MAX_BIGARRAY_MEMORY CAML_DEPRECATED("MAX_BIGARRAY_MEMORY", "CAML_BA_MAX_MEMORY") CAML_BA_MAX_MEMORY
-#define bigarray_create CAML_DEPRECATED("bigarray_create", "caml_ba_create") caml_ba_create
-#define bigarray_get_N CAML_DEPRECATED("bigarray_get_N", "caml_ba_get_N") caml_ba_get_N
-#define bigarray_get_1 CAML_DEPRECATED("bigarray_get_1", "caml_ba_get_1") caml_ba_get_1
-#define bigarray_get_2 CAML_DEPRECATED("bigarray_get_2", "caml_ba_get_2") caml_ba_get_2
-#define bigarray_get_3 CAML_DEPRECATED("bigarray_get_3", "caml_ba_get_3") caml_ba_get_3
-#define bigarray_get_generic CAML_DEPRECATED("bigarray_get_generic", "caml_ba_get_generic") caml_ba_get_generic
-#define bigarray_set_1 CAML_DEPRECATED("bigarray_set_1", "caml_ba_set_1") caml_ba_set_1
-#define bigarray_set_2 CAML_DEPRECATED("bigarray_set_2", "caml_ba_set_2") caml_ba_set_2
-#define bigarray_set_3 CAML_DEPRECATED("bigarray_set_3", "caml_ba_set_3") caml_ba_set_3
-#define bigarray_set_N CAML_DEPRECATED("bigarray_set_N", "caml_ba_set_N") caml_ba_set_N
-#define bigarray_set_generic CAML_DEPRECATED("bigarray_set_generic", "caml_ba_set_generic") caml_ba_set_generic
-#define bigarray_num_dims CAML_DEPRECATED("bigarray_num_dims", "caml_ba_num_dims") caml_ba_num_dims
-#define bigarray_dim CAML_DEPRECATED("bigarray_dim", "caml_ba_dim") caml_ba_dim
-#define bigarray_kind CAML_DEPRECATED("bigarray_kind", "caml_ba_kind") caml_ba_kind
-#define bigarray_layout CAML_DEPRECATED("bigarray_layout", "caml_ba_layout") caml_ba_layout
-#define bigarray_slice CAML_DEPRECATED("bigarray_slice", "caml_ba_slice") caml_ba_slice
-#define bigarray_sub CAML_DEPRECATED("bigarray_sub", "caml_ba_sub") caml_ba_sub
-#define bigarray_blit CAML_DEPRECATED("bigarray_blit", "caml_ba_blit") caml_ba_blit
-#define bigarray_fill CAML_DEPRECATED("bigarray_fill", "caml_ba_fill") caml_ba_fill
-#define bigarray_reshape CAML_DEPRECATED("bigarray_reshape", "caml_ba_reshape") caml_ba_reshape
-#define bigarray_init CAML_DEPRECATED("bigarray_init", "caml_ba_init") caml_ba_init
-
-#endif /* CAML_NAME_SPACE */
-#endif /* CAML_COMPATIBILITY_H */
diff --git a/runtime/caml/config.h b/runtime/caml/config.h
index 471a6bc6f4..a7e56be8d9 100644
--- a/runtime/caml/config.h
+++ b/runtime/caml/config.h
@@ -16,6 +16,15 @@
 #ifndef CAML_CONFIG_H
 #define CAML_CONFIG_H
 
+/* CAML_NAME_SPACE was introduced in OCaml 3.08 to declare compatibility with
+   the newly caml_-prefixed names of C runtime functions and to disable the
+   definition of compatibility macros for the un-prefixed names. The
+   compatibility layer was removed in OCaml 5.00, so CAML_NAME_SPACE is the
+   default. */
+#ifndef CAML_NAME_SPACE
+#define CAML_NAME_SPACE
+#endif
+
 #include "m.h"
 
 /* If supported, tell gcc that we can use 32-bit code addresses for
@@ -41,10 +50,6 @@
 
 #include "s.h"
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
-
 #ifndef CAML_CONFIG_H_NO_TYPEDEFS
 
 #include <stddef.h>
diff --git a/runtime/caml/custom.h b/runtime/caml/custom.h
index 420121f43e..231019aef7 100644
--- a/runtime/caml/custom.h
+++ b/runtime/caml/custom.h
@@ -17,9 +17,6 @@
 #define CAML_CUSTOM_H
 
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "mlvalues.h"
 
 struct custom_fixed_length {
diff --git a/runtime/caml/domain_state.h b/runtime/caml/domain_state.h
index 84e677d041..2ee932459a 100644
--- a/runtime/caml/domain_state.h
+++ b/runtime/caml/domain_state.h
@@ -29,11 +29,7 @@ typedef value extra_params_area[NUM_EXTRA_PARAMS];
  * via native code, which is why the indices are important */
 
 typedef struct {
-#ifdef CAML_NAME_SPACE
 #define DOMAIN_STATE(type, name) CAMLalign(8) type name;
-#else
-#define DOMAIN_STATE(type, name) CAMLalign(8) type _##name;
-#endif
 #include "domain_state.tbl"
 #undef DOMAIN_STATE
 } caml_domain_state;
@@ -45,11 +41,7 @@ enum {
 #undef DOMAIN_STATE
 };
 
-#ifdef CAML_NAME_SPACE
 #define LAST_DOMAIN_STATE_MEMBER extra_params
-#else
-#define LAST_DOMAIN_STATE_MEMBER _extra_params
-#endif
 
 /* Check that the structure was laid out without padding,
    since the runtime assumes this in computing offsets */
@@ -57,11 +49,8 @@ CAML_STATIC_ASSERT(
     offsetof(caml_domain_state, LAST_DOMAIN_STATE_MEMBER) ==
     (Domain_state_num_fields - 1) * 8);
 
-CAMLextern caml_domain_state* Caml_state;
-#ifdef CAML_NAME_SPACE
+CAMLextern caml_domain_state* caml_state;
+#define Caml_state caml_state
 #define Caml_state_field(field) Caml_state->field
-#else
-#define Caml_state_field(field) Caml_state->_##field
-#endif
 
 #endif /* CAML_STATE_H */
diff --git a/runtime/caml/fail.h b/runtime/caml/fail.h
index 822c603260..887ef9c227 100644
--- a/runtime/caml/fail.h
+++ b/runtime/caml/fail.h
@@ -20,9 +20,6 @@
 #include <setjmp.h>
 #endif /* CAML_INTERNALS */
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "misc.h"
 #include "mlvalues.h"
 
diff --git a/runtime/caml/fix_code.h b/runtime/caml/fix_code.h
index 2eafaa814b..83c393a17d 100644
--- a/runtime/caml/fix_code.h
+++ b/runtime/caml/fix_code.h
@@ -34,7 +34,8 @@ void caml_set_instruction (code_t pos, opcode_t instr);
 int caml_is_instruction (opcode_t instr1, opcode_t instr2);
 
 #ifdef THREADED_CODE
-void caml_init_thread_code(void ** instr_table, void * instr_base);
+extern char ** caml_instr_table;
+extern char * caml_instr_base;
 void caml_thread_code (code_t code, asize_t len);
 #endif
 
diff --git a/runtime/caml/intext.h b/runtime/caml/intext.h
index a2a3fb8248..b68030aad8 100644
--- a/runtime/caml/intext.h
+++ b/runtime/caml/intext.h
@@ -18,9 +18,6 @@
 #ifndef CAML_INTEXT_H
 #define CAML_INTEXT_H
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "misc.h"
 #include "mlvalues.h"
 
diff --git a/runtime/caml/m.h.in b/runtime/caml/m.h.in
index 1c3dee1779..ba0074318d 100644
--- a/runtime/caml/m.h.in
+++ b/runtime/caml/m.h.in
@@ -90,7 +90,7 @@
 
 #undef CAML_WITH_FPIC
 
-#undef CAML_SAFE_STRING
+#define CAML_SAFE_STRING 1
 
 #undef FLAT_FLOAT_ARRAY
 
diff --git a/runtime/caml/memory.h b/runtime/caml/memory.h
index d9e58bc2d0..8837d33d25 100644
--- a/runtime/caml/memory.h
+++ b/runtime/caml/memory.h
@@ -18,9 +18,6 @@
 #ifndef CAML_MEMORY_H
 #define CAML_MEMORY_H
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "config.h"
 #ifdef CAML_INTERNALS
 #include "gc.h"
@@ -329,7 +326,7 @@ struct caml__roots_block {
   #define CAMLunused_start __attribute__ ((unused))
   #define CAMLunused_end
   #define CAMLunused __attribute__ ((unused))
-#elif defined(_MSC_VER) && _MSC_VER >= 1500
+#elif _MSC_VER >= 1500
   #define CAMLunused_start  __pragma( warning (push) )           \
     __pragma( warning (disable:4189 ) )
   #define CAMLunused_end __pragma( warning (pop))
diff --git a/runtime/caml/misc.h b/runtime/caml/misc.h
index c605f8711e..b97d20c2bd 100644
--- a/runtime/caml/misc.h
+++ b/runtime/caml/misc.h
@@ -18,9 +18,6 @@
 #ifndef CAML_MISC_H
 #define CAML_MISC_H
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "config.h"
 
 /* Standard definitions */
@@ -29,13 +26,15 @@
 #include <stdlib.h>
 #include <stdarg.h>
 
+#include "camlatomic.h"
+
 /* Deprecation warnings */
 
 #if defined(__GNUC__) || defined(__clang__)
   /* Supported since at least GCC 3.1 */
   #define CAMLdeprecated_typedef(name, type) \
     typedef type name __attribute ((deprecated))
-#elif defined(_MSC_VER) && _MSC_VER >= 1310
+#elif _MSC_VER >= 1310
   /* NB deprecated("message") only supported from _MSC_VER >= 1400 */
   #define CAMLdeprecated_typedef(name, type) \
     typedef __declspec(deprecated) type name
@@ -43,8 +42,7 @@
   #define CAMLdeprecated_typedef(name, type) typedef type name
 #endif
 
-#if defined(__GNUC__) && __STDC_VERSION__ >= 199901L \
- || defined(_MSC_VER) && _MSC_VER >= 1925
+#if defined(__GNUC__) && __STDC_VERSION__ >= 199901L || _MSC_VER >= 1925
 
 #define CAML_STRINGIFY(x) #x
 #ifdef _MSC_VER
@@ -91,7 +89,7 @@ CAMLdeprecated_typedef(addr, char *);
   #define CAMLnoreturn_start
   #define CAMLnoreturn_end __attribute__ ((noreturn))
   #define Noreturn __attribute__ ((noreturn))
-#elif defined(_MSC_VER) && _MSC_VER >= 1500
+#elif _MSC_VER >= 1500
   #define CAMLnoreturn_start __declspec(noreturn)
   #define CAMLnoreturn_end
   #define Noreturn
@@ -139,12 +137,11 @@ CAMLdeprecated_typedef(addr, char *);
 /* we need to be able to compute the exact offset of each member. */
 #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
 #define CAMLalign(n) _Alignas(n)
-#elif defined(__cplusplus) \
-   && (__cplusplus >= 201103L || defined(_MSC_VER) && _MSC_VER >= 1900)
+#elif defined(__cplusplus) && (__cplusplus >= 201103L || _MSC_VER >= 1900)
 #define CAMLalign(n) alignas(n)
 #elif defined(SUPPORTS_ALIGNED_ATTRIBUTE)
 #define CAMLalign(n) __attribute__((aligned(n)))
-#elif defined(_MSC_VER) && _MSC_VER >= 1500
+#elif _MSC_VER >= 1500
 #define CAMLalign(n) __declspec(align(n))
 #else
 #error "How do I align values on this platform?"
@@ -172,7 +169,7 @@ CAMLdeprecated_typedef(addr, char *);
   #define CAMLunused_start __attribute__ ((unused))
   #define CAMLunused_end
   #define CAMLunused __attribute__ ((unused))
-#elif defined(_MSC_VER) && _MSC_VER >= 1500
+#elif _MSC_VER >= 1500
   #define CAMLunused_start  __pragma( warning (push) )           \
     __pragma( warning (disable:4189 ) )
   #define CAMLunused_end __pragma( warning (pop))
diff --git a/runtime/caml/mlvalues.h b/runtime/caml/mlvalues.h
index 677e44e183..00143e5ea0 100644
--- a/runtime/caml/mlvalues.h
+++ b/runtime/caml/mlvalues.h
@@ -16,9 +16,6 @@
 #ifndef CAML_MLVALUES_H
 #define CAML_MLVALUES_H
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "config.h"
 #include "misc.h"
 
@@ -286,11 +283,7 @@ CAMLextern value caml_hash_variant(char const * tag);
 
 /* Strings. */
 #define String_tag 252
-#ifdef CAML_SAFE_STRING
 #define String_val(x) ((const char *) Bp_val(x))
-#else
-#define String_val(x) ((char *) Bp_val(x))
-#endif
 #define Bytes_val(x) ((unsigned char *) Bp_val(x))
 CAMLextern mlsize_t caml_string_length (value);   /* size in bytes */
 CAMLextern int caml_string_is_c_safe (value);
diff --git a/runtime/caml/s.h.in b/runtime/caml/s.h.in
index 8e4efdcc72..9a5d9f4a91 100644
--- a/runtime/caml/s.h.in
+++ b/runtime/caml/s.h.in
@@ -60,6 +60,8 @@
 /* Define HAS_WORKING_ROUND is the round function is correctly implemented. This
    hatch exists primarily for https://sourceforge.net/p/mingw-w64/bugs/573/ */
 
+#undef HAS_GETENTROPY
+
 #undef HAS_GETRUSAGE
 
 #undef HAS_TIMES
@@ -70,6 +72,8 @@
 
 #undef HAS_ISSETUGID
 
+#undef HAS_STDATOMIC_H
+
 /* 2. For the Unix library. */
 
 #undef HAS_SOCKETS
diff --git a/runtime/caml/signals.h b/runtime/caml/signals.h
index 62b0e7fafa..3a3b86911c 100644
--- a/runtime/caml/signals.h
+++ b/runtime/caml/signals.h
@@ -20,9 +20,6 @@
 #include<signal.h>
 #endif
 
-#ifndef CAML_NAME_SPACE
-#include "compatibility.h"
-#endif
 #include "misc.h"
 #include "mlvalues.h"
 
@@ -87,8 +84,8 @@ value caml_do_pending_actions_exn (void);
 value caml_process_pending_actions_with_root (value extra_root); // raises
 value caml_process_pending_actions_with_root_exn (value extra_root);
 int caml_set_signal_action(int signo, int action);
-CAMLextern void * caml_setup_stack_overflow_detection(void);
-CAMLextern int caml_stop_stack_overflow_detection(void *);
+CAMLextern int caml_setup_stack_overflow_detection(void);
+CAMLextern int caml_stop_stack_overflow_detection(void);
 CAMLextern void caml_init_signals(void);
 CAMLextern void caml_terminate_signals(void);
 CAMLextern void (*caml_enter_blocking_section_hook)(void);
diff --git a/runtime/caml/sys.h b/runtime/caml/sys.h
index 75b97818c1..3b2d537ac4 100644
--- a/runtime/caml/sys.h
+++ b/runtime/caml/sys.h
@@ -24,6 +24,8 @@
 extern "C" {
 #endif
 
+CAMLextern char * caml_strerror(int errnum, char * buf, size_t buflen);
+
 #define NO_ARG Val_int(0)
 
 CAMLnoreturn_start
diff --git a/runtime/debugger.c b/runtime/debugger.c
index 97d22832a0..c10c7d0f8f 100644
--- a/runtime/debugger.c
+++ b/runtime/debugger.c
@@ -30,6 +30,7 @@
 #include "caml/misc.h"
 #include "caml/osdeps.h"
 #include "caml/skiplist.h"
+#include "caml/sys.h"
 
 int caml_debugger_in_use = 0;
 uintnat caml_event_count;
@@ -110,6 +111,7 @@ static struct skiplist event_points_table = SKIPLIST_STATIC_INITIALIZER;
 
 static void open_connection(void)
 {
+  char buf[1024];
 #ifdef _WIN32
   /* Set socket to synchronous mode (= non-overlapped) so that file
      descriptor-oriented functions (read()/write() etc.) can be
@@ -133,7 +135,7 @@ static void open_connection(void)
     caml_fatal_error("cannot connect to debugger at %s\n"
                      "error: %s",
                      (dbg_addr ? dbg_addr : "(none)"),
-                     strerror (errno));
+                     caml_strerror(errno, buf, sizeof(buf)));
   dbg_in = caml_open_descriptor_in(dbg_socket);
   dbg_out = caml_open_descriptor_out(dbg_socket);
   /* The code in this file does not bracket channel I/O operations with
diff --git a/runtime/domain.c b/runtime/domain.c
index d4d8de53fc..a6f0a3028e 100644
--- a/runtime/domain.c
+++ b/runtime/domain.c
@@ -19,7 +19,7 @@
 #include "caml/domain_state.h"
 #include "caml/memory.h"
 
-CAMLexport caml_domain_state* Caml_state;
+CAMLexport caml_domain_state* caml_state;
 
 void caml_init_domain ()
 {
diff --git a/runtime/dune b/runtime/dune
index 78c39300ed..23eb1d1e8a 100644
--- a/runtime/dune
+++ b/runtime/dune
@@ -21,7 +21,7 @@
      interp.c ints.c io.c
    lexing.c md5.c meta.c memprof.c obj.c parsing.c signals.c str.c sys.c
      callback.c weak.c
-   finalise.c stacks.c dynlink.c backtrace_byt.c backtrace.c
+   finalise.c dynlink.c backtrace_byt.c backtrace.c
      afl.c
    bigarray.c eventlog.c)
  (action  (with-stdout-to %{targets} (run %{dep:gen_primitives.sh}))))
@@ -36,7 +36,7 @@
    ../Makefile.common Makefile
    (glob_files caml/*.h)
    ; matches the line structure of files in Makefile/BYTECODE_C_SOURCES
-   interp.c misc.c stacks.c fix_code.c startup_aux.c startup_byt.c freelist.c
+   interp.c misc.c fix_code.c startup_aux.c startup_byt.c freelist.c
      major_gc.c
    minor_gc.c memory.c alloc.c roots_byt.c globroots.c fail_byt.c signals.c
    signals_byt.c printexc.c backtrace_byt.c backtrace.c compare.c ints.c
diff --git a/runtime/dynlink_nat.c b/runtime/dynlink_nat.c
index dba30c3848..628d837208 100644
--- a/runtime/dynlink_nat.c
+++ b/runtime/dynlink_nat.c
@@ -43,7 +43,7 @@ static value Val_handle(void* handle) {
 }
 
 static void *getsym(void *handle, const char *module, const char *name){
-  char *fullname = caml_stat_strconcat(3, "caml", module, name);
+  char *fullname = caml_stat_strconcat(4, "caml", module, ".", name);
   void *sym;
   sym = caml_dlsym (handle, fullname);
   /*  printf("%s => %lx\n", fullname, (uintnat) sym); */
@@ -105,26 +105,27 @@ CAMLprim value caml_natdynlink_run(value handle_v, value symbol) {
 
   unit = String_val(symbol);
 
-  sym = optsym("__frametable");
+  sym = optsym("frametable");
   if (NULL != sym) caml_register_frametable(sym);
 
-  sym = optsym("__gc_roots");
+  sym = optsym("gc_roots");
   if (NULL != sym) caml_register_dyn_global(sym);
 
-  sym = optsym("__data_begin");
-  sym2 = optsym("__data_end");
+  sym = optsym("data_begin");
+  sym2 = optsym("data_end");
   if (NULL != sym && NULL != sym2)
     caml_page_table_add(In_static_data, sym, sym2);
 
-  sym = optsym("__code_begin");
-  sym2 = optsym("__code_end");
-  if (NULL != sym && NULL != sym2)
+  sym = optsym("code_begin");
+  sym2 = optsym("code_end");
+  /* Do not register empty code fragments */
+  if (NULL != sym && NULL != sym2 && sym != sym2)
     caml_register_code_fragment((char *) sym, (char *) sym2,
                                 DIGEST_LATER, NULL);
 
   if( caml_natdynlink_hook != NULL ) caml_natdynlink_hook(handle,unit);
 
-  entrypoint = optsym("__entry");
+  entrypoint = optsym("entry");
   if (NULL != entrypoint) result = caml_callback((value)(&entrypoint), 0);
   else result = Val_unit;
 
diff --git a/runtime/fix_code.c b/runtime/fix_code.c
index 5584019867..aa059be5df 100644
--- a/runtime/fix_code.c
+++ b/runtime/fix_code.c
@@ -82,14 +82,8 @@ void caml_fixup_endianness(code_t code, asize_t len)
 
 #ifdef THREADED_CODE
 
-static char ** caml_instr_table;
-static char * caml_instr_base;
-
-void caml_init_thread_code(void ** instr_table, void * instr_base)
-{
-  caml_instr_table = (char **) instr_table;
-  caml_instr_base = (char *) instr_base;
-}
+char ** caml_instr_table;
+char * caml_instr_base;
 
 static int* opcode_nargs = NULL;
 int* caml_init_opcode_nargs(void)
diff --git a/runtime/gen_primitives.sh b/runtime/gen_primitives.sh
index a727d5c25c..01644a8a17 100755
--- a/runtime/gen_primitives.sh
+++ b/runtime/gen_primitives.sh
@@ -25,10 +25,11 @@ export LC_ALL=C
       alloc array compare extern floats gc_ctrl hash intern interp ints io \
       lexing md5 meta memprof obj parsing signals str sys callback weak \
       finalise stacks dynlink backtrace_byt backtrace afl \
-      bigarray eventlog
+      bigarray eventlog prng
   do
-      sed -n -e 's/^CAMLprim value \([a-z0-9_][a-z0-9_]*\).*/\1/p' "$prim.c"
+      sed -n -e 's/^CAMLprim value \([a-z0-9_][a-z0-9_]*\).*/\1/p' \
+        "runtime/$prim.c"
   done
   sed -n -e 's/^CAMLprim_int64_[0-9](\([a-z0-9_][a-z0-9_]*\)).*/caml_int64_\1\
-caml_int64_\1_native/p' ints.c
+caml_int64_\1_native/p' runtime/ints.c
 ) | sort | uniq
diff --git a/runtime/hash.c b/runtime/hash.c
index f33634c227..da111db629 100644
--- a/runtime/hash.c
+++ b/runtime/hash.c
@@ -301,6 +301,15 @@ CAMLprim value caml_hash(value count, value limit, value seed, value obj)
   return Val_int(h & 0x3FFFFFFFU);
 }
 
+CAMLprim value caml_string_hash(value seed, value string)
+{
+  uint32_t h;
+  h = Int_val(seed);
+  h = caml_hash_mix_string (h, string);
+  FINAL_MIX(h);
+  return Val_int(h & 0x3FFFFFFFU);
+}
+
 /* Hashing variant tags */
 
 CAMLexport value caml_hash_variant(char const * tag)
diff --git a/runtime/i386.S b/runtime/i386.S
index 4d273c9f04..585c2e4c5b 100644
--- a/runtime/i386.S
+++ b/runtime/i386.S
@@ -98,13 +98,13 @@
 
         .text
 #if defined(FUNCTION_SECTIONS)
-        TEXT_SECTION(caml_hot__code_begin)
-        .globl  G(caml_hot__code_begin)
-G(caml_hot__code_begin):
+        TEXT_SECTION(caml_hot.code_begin)
+        .globl  G(caml_hot.code_begin)
+G(caml_hot.code_begin):
 
-        TEXT_SECTION(caml_hot__code_end)
-        .globl  G(caml_hot__code_end)
-G(caml_hot__code_end):
+        TEXT_SECTION(caml_hot.code_end)
+        .globl  G(caml_hot.code_end)
+G(caml_hot.code_end):
 #endif
 
 /* Allocation */
@@ -116,7 +116,7 @@ FUNCTION(caml_call_gc)
         CFI_STARTPROC
 LBL(caml_call_gc):
     /* Record lowest stack address and return address */
-        movl    G(Caml_state), %ebx
+        movl    G(caml_state), %ebx
         movl    (%esp), %eax
         movl    %eax, CAML_STATE(last_return_address, %ebx)
         leal    4(%esp), %eax
@@ -128,7 +128,7 @@ LBL(caml_call_gc):
         movl    %eax, 0(%esp)
         addl    $(STACK_PROBE_SIZE), %esp; CFI_ADJUST(-STACK_PROBE_SIZE);
 #endif
-    /* Build array of registers, save it into Caml_state->gc_regs */
+    /* Build array of registers, save it into caml_state->gc_regs */
         pushl   %ebp; CFI_ADJUST(4)
         pushl   %edi; CFI_ADJUST(4)
         pushl   %esi; CFI_ADJUST(4)
@@ -156,7 +156,7 @@ LBL(caml_call_gc):
 
 FUNCTION(caml_alloc1)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
+        movl    G(caml_state), %ebx
         movl    CAML_STATE(young_ptr, %ebx), %eax
         subl    $8, %eax
         movl    %eax, CAML_STATE(young_ptr, %ebx)
@@ -168,7 +168,7 @@ FUNCTION(caml_alloc1)
 
 FUNCTION(caml_alloc2)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
+        movl    G(caml_state), %ebx
         movl    CAML_STATE(young_ptr, %ebx), %eax
         subl    $12, %eax
         movl    %eax, CAML_STATE(young_ptr, %ebx)
@@ -180,7 +180,7 @@ FUNCTION(caml_alloc2)
 
 FUNCTION(caml_alloc3)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
+        movl    G(caml_state), %ebx
         movl    CAML_STATE(young_ptr, %ebx), %eax
         subl    $16, %eax
         movl    %eax, CAML_STATE(young_ptr, %ebx)
@@ -192,10 +192,10 @@ FUNCTION(caml_alloc3)
 
 FUNCTION(caml_allocN)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
-        /* eax = size - Caml_state->young_ptr */
+        movl    G(caml_state), %ebx
+        /* eax = size - caml_state->young_ptr */
         subl    CAML_STATE(young_ptr, %ebx), %eax
-        negl    %eax              /* eax = Caml_state->young_ptr - size */
+        negl    %eax              /* eax = caml_state->young_ptr - size */
         movl    %eax, CAML_STATE(young_ptr, %ebx)
         cmpl    CAML_STATE(young_limit, %ebx), %eax
         jb      LBL(caml_call_gc)
@@ -209,7 +209,7 @@ FUNCTION(caml_c_call)
         CFI_STARTPROC
     /* Record lowest stack address and return address */
     /* ecx and edx are destroyed at C call. Use them as temp. */
-        movl    G(Caml_state), %ecx
+        movl    G(caml_state), %ecx
         movl    (%esp), %edx
         movl    %edx, CAML_STATE(last_return_address, %ecx)
         leal    4(%esp), %edx
@@ -239,7 +239,7 @@ FUNCTION(caml_start_program)
         movl    $ G(caml_program), %esi
     /* Common code for caml_start_program and caml_callback* */
 LBL(106):
-        movl    G(Caml_state), %edi
+        movl    G(caml_state), %edi
     /* Build a callback link */
         pushl   CAML_STATE(gc_regs, %edi); CFI_ADJUST(4)
         pushl   CAML_STATE(last_return_address, %edi); CFI_ADJUST(4)
@@ -253,12 +253,12 @@ LBL(106):
     /* Call the OCaml code */
         call    *%esi
 LBL(107):
-        movl    G(Caml_state), %edi
+        movl    G(caml_state), %edi
     /* Pop the exception handler */
         popl    CAML_STATE(exception_pointer, %edi); CFI_ADJUST(-4)
         addl    $12, %esp       ; CFI_ADJUST(-12)
 LBL(109):
-        movl    G(Caml_state), %edi /* Reload for LBL(109) entry */
+        movl    G(caml_state), %edi /* Reload for LBL(109) entry */
     /* Pop the callback link, restoring the global variables */
         popl    CAML_STATE(bottom_of_stack, %edi); CFI_ADJUST(-4)
         popl    CAML_STATE(last_return_address, %edi); CFI_ADJUST(-4)
@@ -282,7 +282,7 @@ LBL(108):
 
 FUNCTION(caml_raise_exn)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
+        movl    G(caml_state), %ebx
         testl   $1, CAML_STATE(backtrace_active, %ebx)
         jne     LBL(110)
         movl    CAML_STATE(exception_pointer, %ebx), %esp
@@ -312,7 +312,7 @@ LBL(110):
 
 FUNCTION(caml_raise_exception)
         CFI_STARTPROC
-        movl    G(Caml_state), %ebx
+        movl    G(caml_state), %ebx
         testl   $1, CAML_STATE(backtrace_active, %ebx)
         jne     LBL(112)
         movl    8(%esp), %eax
@@ -405,7 +405,7 @@ FUNCTION(caml_ml_array_bound_error)
         ffree   %st(6)
         ffree   %st(7)
     /* Record lowest stack address and return address */
-        movl    G(Caml_state), %ebx
+        movl    G(caml_state), %ebx
         movl    (%esp), %edx
         movl    %edx, CAML_STATE(last_return_address, %ebx)
         leal    4(%esp), %edx
@@ -422,8 +422,8 @@ FUNCTION(caml_ml_array_bound_error)
 G(caml_system__code_end):
 
         .data
-        .globl  G(caml_system__frametable)
-G(caml_system__frametable):
+        .globl  G(caml_system.frametable)
+G(caml_system.frametable):
         .long   1               /* one descriptor */
         .long   LBL(107)        /* return address into callback */
 #ifndef SYS_solaris
diff --git a/runtime/interp.c b/runtime/interp.c
index e6700994bc..a59811c87d 100644
--- a/runtime/interp.c
+++ b/runtime/interp.c
@@ -50,9 +50,9 @@ sp is a local copy of the global variable Caml_state->extern_sp. */
 #ifdef THREADED_CODE
 #  define Instruct(name) lbl_##name
 #  if defined(ARCH_SIXTYFOUR) && !defined(ARCH_CODE32)
-#    define Jumptbl_base &&lbl_ACC0
+#    define Jumptbl_base ((char *) &&lbl_ACC0)
 #  else
-#    define Jumptbl_base 0
+#    define Jumptbl_base ((char *) 0)
 #    define jumptbl_base ((char *) 0)
 #  endif
 #  ifdef DEBUG
@@ -249,7 +249,8 @@ value caml_interprete(code_t prog, asize_t prog_size)
 
   if (prog == NULL) {           /* Interpreter is initializing */
 #ifdef THREADED_CODE
-    caml_init_thread_code(jumptable, Jumptbl_base);
+    caml_instr_table = (char **) jumptable;
+    caml_instr_base = Jumptbl_base;
 #endif
     return Val_unit;
   }
diff --git a/runtime/power.S b/runtime/power.S
index 4ca1a14538..68486cb7dc 100644
--- a/runtime/power.S
+++ b/runtime/power.S
@@ -645,9 +645,9 @@ caml_system__code_end:
 /* Frame table */
 
         .section ".data"
-        .globl  caml_system__frametable
-        .type   caml_system__frametable, @object
-caml_system__frametable:
+        .globl  caml_system.frametable
+        .type   caml_system.frametable, @object
+caml_system.frametable:
         datag   1               /* one descriptor */
         datag   .L105 + 4       /* return address into callback */
         .short  -1              /* negative size count => use callback link */
diff --git a/runtime/prng.c b/runtime/prng.c
new file mode 100644
index 0000000000..4357afbbfb
--- /dev/null
+++ b/runtime/prng.c
@@ -0,0 +1,69 @@
+/**************************************************************************/
+/*                                                                        */
+/*                                 OCaml                                  */
+/*                                                                        */
+/*          Xavier Leroy, projet Cambium, College de France and Inria     */
+/*                                                                        */
+/*   Copyright 2021 Institut National de Recherche en Informatique et     */
+/*     en Automatique.                                                    */
+/*                                                                        */
+/*   All rights reserved.  This file is distributed under the terms of    */
+/*   the GNU Lesser General Public License version 2.1, with the          */
+/*   special exception on linking described in the file LICENSE.          */
+/*                                                                        */
+/**************************************************************************/
+
+#include <string.h>
+#include "caml/alloc.h"
+#include "caml/bigarray.h"
+#include "caml/mlvalues.h"
+
+/* The L64X128 member of the LXM family.  Taken from figure 1 in
+   "LXM: Better Splittable Pseudorandom Number Generators
+    (and Almost as Fast)" by Guy L. Steele Jr. and Sebastiano Vigna,
+    OOPSLA 2021.  */
+
+static const uint64_t M = 0xd1342543de82ef95;
+
+struct LXM_state {
+  uint64_t a;            /* per-instance additive parameter (odd) */
+  uint64_t s;            /* state of the LCG subgenerator */
+  uint64_t x[2];         /* state of the XBG subgenerator (not 0) */
+};
+
+/* In OCaml, states are represented as a 1D big array of 64-bit integers */
+
+#define LXM_val(v) ((struct LXM_state *) Caml_ba_data_val(v))
+
+Caml_inline uint64_t rotl(const uint64_t x, int k) {
+  return (x << k) | (x >> (64 - k));
+}
+
+CAMLprim uint64_t caml_lxm_next_unboxed(value v)
+{
+  uint64_t z, q0, q1;
+  struct LXM_state * st = LXM_val(v);
+
+  /* Combining operation */
+  z = st->s + st->x[0];
+  /* Mixing function */
+  z = (z ^ (z >> 32)) * 0xdaba0b6eb09322e3;
+  z = (z ^ (z >> 32)) * 0xdaba0b6eb09322e3;
+  z = (z ^ (z >> 32));
+  /* LCG update */
+  st->s = st->s * M + st->a;
+  /* XBG update */
+  q0 = st->x[0]; q1 = st->x[1];
+  q1 ^= q0;
+  q0 = rotl(q0, 24);
+  q0 = q0 ^ q1 ^ (q1 << 16);
+  q1 = rotl(q1, 37);
+  st->x[0] = q0; st->x[1] = q1;
+  /* Return result */
+  return z;
+}
+
+CAMLprim value caml_lxm_next(value v)
+{
+  return caml_copy_int64(caml_lxm_next_unboxed(v));
+}
diff --git a/runtime/riscv.S b/runtime/riscv.S
index 25b624b56b..112627726f 100644
--- a/runtime/riscv.S
+++ b/runtime/riscv.S
@@ -442,12 +442,12 @@ caml_system__code_end:
 
         .section .data
         .align  3
-        .globl  caml_system__frametable
-        .type   caml_system__frametable, @object
-caml_system__frametable:
+        .globl  caml_system.frametable
+        .type   caml_system.frametable, @object
+caml_system.frametable:
         .quad   1               /* one descriptor */
         .quad   .Lcaml_retaddr  /* return address into callback */
         .short  -1              /* negative frame size => use callback link */
         .short  0               /* no roots */
         .align  3
-        .size   caml_system__frametable, .-caml_system__frametable
+        .size   caml_system.frametable, .-caml_system.frametable
diff --git a/runtime/s390x.S b/runtime/s390x.S
index aab63e9b24..a05f721836 100644
--- a/runtime/s390x.S
+++ b/runtime/s390x.S
@@ -342,9 +342,9 @@ caml_system__code_end:
 
         .section ".data"
         .align 8
-        .globl  caml_system__frametable
-        .type   caml_system__frametable, @object
-caml_system__frametable:
+        .globl  caml_system.frametable
+        .type   caml_system.frametable, @object
+caml_system.frametable:
         .quad   1               /* one descriptor */
         .quad   .L105           /* return address into callback */
         .short  -1              /* negative size count => use callback link */
diff --git a/runtime/signals_byt.c b/runtime/signals_byt.c
index 7cb461ac4d..439fb56404 100644
--- a/runtime/signals_byt.c
+++ b/runtime/signals_byt.c
@@ -81,7 +81,7 @@ int caml_set_signal_action(int signo, int action)
     return 0;
 }
 
-CAMLexport void * caml_setup_stack_overflow_detection(void) { return NULL; }
-CAMLexport int caml_stop_stack_overflow_detection(void * p) { return 0; }
+CAMLexport int caml_setup_stack_overflow_detection(void) { return 0; }
+CAMLexport int caml_stop_stack_overflow_detection(void) { return 0; }
 CAMLexport void caml_init_signals(void) { }
 CAMLexport void caml_terminate_signals(void) { }
diff --git a/runtime/signals_nat.c b/runtime/signals_nat.c
index 1dd8289c12..443f5d53b6 100644
--- a/runtime/signals_nat.c
+++ b/runtime/signals_nat.c
@@ -254,10 +254,6 @@ DECLARE_SIGNAL_HANDLER(segv_handler)
 
 /* Initialization of signal stuff */
 
-#ifdef HAS_STACK_OVERFLOW_DETECTION
-static void * caml_signal_stack = NULL;
-#endif
-
 void caml_init_signals(void)
 {
   /* Bound-check trap handling */
@@ -282,8 +278,7 @@ void caml_init_signals(void)
 #endif
 
 #ifdef HAS_STACK_OVERFLOW_DETECTION
-  caml_signal_stack = caml_setup_stack_overflow_detection();
-  if (caml_signal_stack != NULL) {
+  if (caml_setup_stack_overflow_detection() != -1) {
     struct sigaction act;
     SET_SIGACT(act, segv_handler);
     act.sa_flags |= SA_ONSTACK | SA_NODEFER;
@@ -319,8 +314,7 @@ void caml_terminate_signals(void)
 
 #ifdef HAS_STACK_OVERFLOW_DETECTION
   set_signal_default(SIGSEGV);
-  caml_stop_stack_overflow_detection(caml_signal_stack);
-  caml_signal_stack = NULL;
+  caml_stop_stack_overflow_detection();
 #endif
 }
 
@@ -329,44 +323,37 @@ void caml_terminate_signals(void)
    Each thread needs its own alternate stack.
    The alternate stack used to be statically-allocated for the main thread,
    but this is incompatible with Glibc 2.34 and newer, where SIGSTKSZ
-   may not be a compile-time constant (issue #10250).
-   Return the dynamically-allocated alternate signal stack, or NULL
-   if an error occurred.
-   The returned pointer must be passed to [caml_stop_stack_overflow_detection].
-*/
+   may not be a compile-time constant (issue #10250). */
 
-CAMLexport void * caml_setup_stack_overflow_detection(void)
+CAMLexport int caml_setup_stack_overflow_detection(void)
 {
 #ifdef HAS_STACK_OVERFLOW_DETECTION
   stack_t stk;
+  stk.ss_sp = malloc(SIGSTKSZ);
+  if (stk.ss_sp == NULL) return -1;
   stk.ss_size = SIGSTKSZ;
-  stk.ss_sp = malloc(stk.ss_size);
-  if (stk.ss_sp == NULL) return NULL;
   stk.ss_flags = 0;
   if (sigaltstack(&stk, NULL) == -1) {
     free(stk.ss_sp);
-    return NULL;
+    return -1;
   }
-  return stk.ss_sp;
-#else
-  return NULL;
 #endif
+  /* Success (or stack overflow detection not available) */
+  return 0;
 }
 
-CAMLexport int caml_stop_stack_overflow_detection(void * signal_stack)
+CAMLexport int caml_stop_stack_overflow_detection(void)
 {
 #ifdef HAS_STACK_OVERFLOW_DETECTION
   stack_t oldstk, stk;
   stk.ss_flags = SS_DISABLE;
-  stk.ss_sp = NULL;  /* not required but avoids a valgrind false alarm */
-  stk.ss_size = SIGSTKSZ; /* macOS wants a valid size here */
   if (sigaltstack(&stk, &oldstk) == -1) return -1;
-  /* Check whether someone else installed their own signal stack */
-  if (!(oldstk.ss_flags & SS_DISABLE) && oldstk.ss_sp != signal_stack) {
-    /* Re-activate their signal stack. */
-    sigaltstack(&oldstk, NULL);
-  }
-  free(signal_stack);
-#endif
+  /* If caml_setup_stack_overflow_detection failed, we are not using
+     an alternate signal stack.  SS_DISABLE will be set in oldstk,
+     and there is nothing to free in this case. */
+  if (! (oldstk.ss_flags & SS_DISABLE)) free(oldstk.ss_sp);
   return 0;
+#else
+  return 0;
+#endif
 }
diff --git a/runtime/sys.c b/runtime/sys.c
index a77fd9d1cf..9508d3f903 100644
--- a/runtime/sys.c
+++ b/runtime/sys.c
@@ -45,6 +45,9 @@
 #ifdef HAS_GETTIMEOFDAY
 #include <sys/time.h>
 #endif
+#ifdef __APPLE__
+#include <sys/random.h> /* for getentropy */
+#endif
 #include "caml/alloc.h"
 #include "caml/debugger.h"
 #include "caml/fail.h"
@@ -61,9 +64,21 @@
 #include "caml/callback.h"
 #include "caml/startup_aux.h"
 
-static char * error_message(void)
+CAMLexport char * caml_strerror(int errnum, char * buf, size_t buflen)
 {
-  return strerror(errno);
+#ifdef _WIN32
+  /* Windows has a thread-safe strerror */
+  return strerror(errnum);
+#else
+  int res = strerror_r(errnum, buf, buflen);
+  /* glibc<2.13 returns -1/sets errno, >2.13 returns +ve errno.
+     We assume that buffer size is large enough not to get ERANGE,
+     so we assume we got EINVAL. */
+  if (res != 0) {
+    snprintf(buf, buflen, "Unknown error %d", errnum);
+  }
+  return buf;
+#endif
 }
 
 #ifndef EAGAIN
@@ -77,9 +92,10 @@ CAMLexport void caml_sys_error(value arg)
 {
   CAMLparam1 (arg);
   char * err;
+  char buf[1024];
   CAMLlocal1 (str);
 
-  err = error_message();
+  err = caml_strerror(errno, buf, sizeof(buf));
   if (arg == NO_ARG) {
     str = caml_copy_string(err);
   } else {
@@ -236,7 +252,7 @@ CAMLprim value caml_sys_close(value fd_v)
   return Val_unit;
 }
 
-CAMLprim value caml_sys_file_exists(value name)
+static int caml_sys_file_mode(value name)
 {
 #ifdef _WIN32
   struct _stati64 st;
@@ -246,39 +262,42 @@ CAMLprim value caml_sys_file_exists(value name)
   char_os * p;
   int ret;
 
-  if (! caml_string_is_c_safe(name)) return Val_false;
+  if (! caml_string_is_c_safe(name)) { errno = ENOENT; return -1; }
   p = caml_stat_strdup_to_os(String_val(name));
   caml_enter_blocking_section();
   ret = stat_os(p, &st);
   caml_leave_blocking_section();
   caml_stat_free(p);
+  if (ret == -1) return -1; else return st.st_mode;
+}
 
-  return Val_bool(ret == 0);
+CAMLprim value caml_sys_file_exists(value name)
+{
+  int mode = caml_sys_file_mode(name);
+  return (Val_bool(mode != -1));
 }
 
 CAMLprim value caml_sys_is_directory(value name)
 {
   CAMLparam1(name);
-#ifdef _WIN32
-  struct _stati64 st;
+  int mode = caml_sys_file_mode(name);
+  if (mode == -1) caml_sys_error(name);
+#ifdef S_ISDIR
+  CAMLreturn(Val_bool(S_ISDIR(mode)));
 #else
-  struct stat st;
+  CAMLreturn(Val_bool(mode & S_IFDIR));
 #endif
-  char_os * p;
-  int ret;
-
-  caml_sys_check_path(name);
-  p = caml_stat_strdup_to_os(String_val(name));
-  caml_enter_blocking_section();
-  ret = stat_os(p, &st);
-  caml_leave_blocking_section();
-  caml_stat_free(p);
+}
 
-  if (ret == -1) caml_sys_error(name);
-#ifdef S_ISDIR
-  CAMLreturn(Val_bool(S_ISDIR(st.st_mode)));
+CAMLprim value caml_sys_is_regular_file(value name)
+{
+  CAMLparam1(name);
+  int mode = caml_sys_file_mode(name);
+  if (mode == -1) caml_sys_error(name);
+#ifdef S_ISREG
+  CAMLreturn(Val_bool(S_ISREG(mode)));
 #else
-  CAMLreturn(Val_bool(st.st_mode & S_IFDIR));
+  CAMLreturn(Val_bool(mode & S_IFREG));
 #endif
 }
 
@@ -565,20 +584,27 @@ extern int caml_win32_random_seed (intnat data[16]);
 #else
 int caml_unix_random_seed(intnat data[16])
 {
-  int fd;
   int n = 0;
-
-  /* Try /dev/urandom first */
-  fd = open("/dev/urandom", O_RDONLY, 0);
-  if (fd != -1) {
-    unsigned char buffer[12];
-    int nread = read(fd, buffer, 12);
-    close(fd);
-    while (nread > 0) data[n++] = buffer[--nread];
+  unsigned char buffer[12];
+  int nread = 0;
+
+  /* Try kernel entropy first */
+#if defined(HAS_GETENTROPY) || defined(__APPLE__)
+  if (getentropy(buffer, 12) != -1) {
+    nread = 12;
+  } else
+#endif
+  { int fd = open("/dev/urandom", O_RDONLY, 0);
+    if (fd != -1) {
+      nread = read(fd, buffer, 12);
+      close(fd);
+    }
   }
-  /* If the read from /dev/urandom fully succeeded, we now have 96 bits
+  while (nread > 0) data[n++] = buffer[--nread];
+  /* If the kernel provided enough entropy, we now have 96 bits
      of good random data and can stop here. */
   if (n >= 12) return n;
+
   /* Otherwise, complement whatever we got (probably nothing)
      with some not-very-random data. */
   {
