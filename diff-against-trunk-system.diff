diff --git a/.Diff-of-diff.diff b/.Diff-of-diff.diff
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/Changes b/Changes
index a8b35ccf67..9a41022525 100644
--- a/Changes
+++ b/Changes
@@ -253,13 +253,13 @@ OCaml 4.14.0
 - #10549: Stack overflow detection and naked pointers checking for ARM64
   (Xavier Leroy, review by Stephen Dolan)
 
-* #10675: Emit deprecation warnings when old C runtime function names
+* #10675, #10937: Emit deprecation warnings when old C runtime function names
   are used.  This will break C stub code that uses these old names and
   treats warnings as errors.  The workaround is to use the new names.
   (Xavier Leroy and David Allsopp, review by Sébastien Hinderer and
    Damien Doligez)
 
-- #10698, #10726: Free the alternate signal stack when the main OCaml
+- #10698, #10726, #10891: Free the alternate signal stack when the main OCaml
    code or an OCaml thread stops
   (Xavier Leroy, review by David Allsopp and Damien Doligez)
 
@@ -359,6 +359,9 @@ OCaml 4.14.0
 - #10786: The implementation of Complex.norm now uses Float.hypot.
   (Christophe Troestler, review by David Allsopp and Xavier Leroy)
 
+* #10922: Add deprecation warnings on {Int32,Int64,Nativeint}.format.
+  (Nicolás Ojeda Bär, review by Xavier Leroy and Florian Angeletti)
+
 ### Other libraries:
 
 - #10192: Add support for Unix domain sockets on Windows and use them
@@ -607,6 +610,9 @@ OCaml 4.14.0
 
 ### Build system:
 
+- #10828 Build native-code compilers on OpenBSD/aarch64
+  (Christopher Zimmermann)
+
 - #10835 Disable DT_TEXTREL warnings on x86 32 bit architecture by passing
   -Wl,-z,notext in mksharedlib and mkmaindll. Fixes relocation issues, reported
   in #9800, making local patches in Debian, Alpine, and FreeBSD superfluous.
diff --git a/Makefile.config.in b/Makefile.config.in
index 6ee1453d88..97cca9a733 100644
--- a/Makefile.config.in
+++ b/Makefile.config.in
@@ -252,7 +252,7 @@ FLAT_FLOAT_ARRAY=@flat_float_array@
 FUNCTION_SECTIONS=@function_sections@
 AWK=@AWK@
 STDLIB_MANPAGES=@stdlib_manpages@
-NAKED_POINTERS=false
+NAKED_POINTERS=@naked_pointers@
 
 ### Native command to build ocamlrun.exe
 
diff --git a/VERSION b/VERSION
index 8dfc6cf83f..4ef434f979 100644
--- a/VERSION
+++ b/VERSION
@@ -1,4 +1,4 @@
-5.0.0+dev0-2021-11-05
+5.0.0+jst-backport
 
 # Starting with OCaml 4.14, although the version string that appears above is
 # still correct and this file can thus still be used to figure it out,
diff --git a/api_docgen/Makefile.docfiles b/api_docgen/Makefile.docfiles
index d85ccfb1a2..201f1e75c1 100644
--- a/api_docgen/Makefile.docfiles
+++ b/api_docgen/Makefile.docfiles
@@ -35,7 +35,8 @@ str_MLIS := str.mli
 unix_MLIS := unix.mli unixLabels.mli
 dynlink_MLIS := dynlink.mli
 thread_MLIS := \
-  thread.mli event.mli
+  thread.mli condition.mli mutex.mli event.mli \
+  semaphore.mli
 
 STDLIB=$(STDLIB_MODULES)
 
diff --git a/asmcomp/amd64/emit.mlp b/asmcomp/amd64/emit.mlp
index 2e03adf10d..22a45aa904 100644
--- a/asmcomp/amd64/emit.mlp
+++ b/asmcomp/amd64/emit.mlp
@@ -63,6 +63,7 @@ let cfi_endproc () =
 let cfi_adjust_cfa_offset n =
   if Config.asm_cfi_supported then D.cfi_adjust_cfa_offset n
 
+(* BACKPORT
 let cfi_remember_state () =
   if Config.asm_cfi_supported then D.cfi_remember_state ()
 
@@ -71,13 +72,16 @@ let cfi_restore_state () =
 
 let cfi_def_cfa_register reg =
   if Config.asm_cfi_supported then D.cfi_def_cfa_register reg
+*)
 
 let emit_debug_info dbg =
   emit_debug_info_gen dbg D.file D.loc
 
 let fp = Config.with_frame_pointers
 
+(* BACKPORT
 let stack_threshold_size = Config.stack_threshold * 8 (* bytes *)
+*)
 
 let frame_size env =                     (* includes return address *)
   if env.f.fun_frame_required then begin
@@ -536,8 +540,9 @@ let emit_instr env fallthrough i =
           end
         end
       end
-  | Lop(Iextcall { func; alloc; stack_ofs }) ->
+  | Lop(Iextcall { func; alloc; stack_ofs = _ }) ->
       add_used_symbol func;
+(* BACKPORT
       let base_stack_size =
         if Arch.win64 then
           32 (* Windows x64 rcx+rdx+r8+r9 shadow stack *)
@@ -549,11 +554,26 @@ let emit_instr env fallthrough i =
         load_symbol_addr func rax;
         emit_call "caml_c_call_stack_args";
         record_frame env i.live (Dbg_other i.dbg);
-      end else if alloc then begin
+      end else*) if alloc then begin
         load_symbol_addr func rax;
         emit_call "caml_c_call";
         record_frame env i.live (Dbg_other i.dbg);
+(* BACKPORT BEGIN *)
+        if system <> S_win64 then begin
+
+          (* In amd64.S, "caml_c_call" tail-calls the C function (in order to
+             produce nicer backtraces), so we need to restore r15 manually after
+             it returns (note that this increases code size).
+
+             In amd64nt.asm (used for Win64), "caml_c_call" invokes the C
+             function via a regular call, and restores r15 itself, thus avoiding
+             the code size increase. *)
+
+          I.mov (domain_field Domainstate.Domain_young_ptr) r15
+        end
+(* BACKPORT END *)
       end else begin
+(* BACKPORT
         I.mov rsp rbp;
         cfi_remember_state ();
         cfi_def_cfa_register "rbp";
@@ -561,10 +581,12 @@ let emit_instr env fallthrough i =
            will not unwind through this unless we were to tag this
            calling frame with cfi_signal_frame in it's definition. *)
         I.mov (domain_field Domainstate.Domain_c_stack) rsp;
-
+*)
         emit_call func;
+(* BACKPORT
         I.mov rbp rsp;
         cfi_restore_state ();
+*)
       end
   | Lop(Istackoffset n) ->
       if n < 0
@@ -741,7 +763,10 @@ let emit_instr env fallthrough i =
   | Lop(Ispecific(Izextend32)) ->
       I.mov (arg32 i 0) (res32 i 0)
   | Lop (Idls_get) ->
+      assert false
+(* BACKPORT
       I.mov (domain_field Domainstate.Domain_dls_root) (res i 0)
+*)
   | Lreloadretaddr ->
       ()
   | Lreturn ->
@@ -845,12 +870,24 @@ let emit_instr env fallthrough i =
       load_label_addr lbl_handler r11;
       I.push r11;
       cfi_adjust_cfa_offset 8;
+(* BACKPORT BEGIN
       I.push (domain_field Domainstate.Domain_exn_handler);
+*)
+      I.push (domain_field Domainstate.Domain_exception_pointer);
+(* BACKPORT END *)
       cfi_adjust_cfa_offset 8;
+(* BACKPORT BEGIN
       I.mov rsp (domain_field Domainstate.Domain_exn_handler);
+*)
+      I.mov rsp (domain_field Domainstate.Domain_exception_pointer);
+(* BACKPORT END *)
       env.stack_offset <- env.stack_offset + 16;
   | Lpoptrap ->
+(* BACKPORT BEGIN
       I.pop (domain_field Domainstate.Domain_exn_handler);
+*)
+      I.pop (domain_field Domainstate.Domain_exception_pointer);
+(* BACKPORT END *)
       cfi_adjust_cfa_offset (-8);
       I.add (int 8) rsp;
       cfi_adjust_cfa_offset (-8);
@@ -858,14 +895,26 @@ let emit_instr env fallthrough i =
   | Lraise k ->
       begin match k with
       | Lambda.Raise_regular ->
+(* BACKPORT BEGIN *)
+          I.mov (int 0) (domain_field Domainstate.Domain_backtrace_pos);
+(* BACKPORT END *)
           emit_call "caml_raise_exn";
           record_frame env Reg.Set.empty (Dbg_raise i.dbg)
       | Lambda.Raise_reraise ->
+(* BACKPORT BEGIN
           emit_call "caml_reraise_exn";
+*)
+          emit_call "caml_raise_exn";
+(* BACKPORT END *)
           record_frame env Reg.Set.empty (Dbg_raise i.dbg)
       | Lambda.Raise_notrace ->
+(* BACKPORT BEGIN
           I.mov (domain_field Domainstate.Domain_exn_handler) rsp;
           I.pop (domain_field Domainstate.Domain_exn_handler);
+*)
+          I.mov (domain_field Domainstate.Domain_exception_pointer) rsp;
+          I.pop (domain_field Domainstate.Domain_exception_pointer);
+(* BACKPORT END *)
           I.pop r11;
           I.jmp r11
       end
@@ -898,6 +947,7 @@ let fundecl fundecl =
   D.label (emit_symbol fundecl.fun_name);
   emit_debug_info fundecl.fun_dbg;
   cfi_startproc ();
+(* BACKPORT
   if !Clflags.runtime_variant = "d" then
     emit_call "caml_assert_stack_invariants";
   let { max_frame_size; contains_nontail_calls} =
@@ -914,9 +964,11 @@ let fundecl fundecl =
     def_label ret;
     handle_overflow := Some (overflow, ret)
   end;
+*)
   emit_all env true fundecl.fun_body;
   List.iter emit_call_gc env.call_gc_sites;
   emit_call_bound_errors env;
+(* BACKPORT
   begin match !handle_overflow with
   | None -> ()
   | Some (overflow,ret) -> begin
@@ -931,6 +983,7 @@ let fundecl fundecl =
       I.jmp (label ret)
     end
   end;
+*)
   if fundecl.fun_frame_required then begin
     let n = (frame_size env) - 8 - (if fp then 8 else 0) in
     if n <> 0
diff --git a/asmcomp/amd64/proc.ml b/asmcomp/amd64/proc.ml
index 64b05a95c8..dbeaff0cbe 100644
--- a/asmcomp/amd64/proc.ml
+++ b/asmcomp/amd64/proc.ml
@@ -297,12 +297,20 @@ let destroyed_at_c_call =
   if win64 then
     (* Win64: rbx, rsi, rdi, r12-r15, xmm6-xmm15 preserved *)
     Array.of_list(List.map phys_reg
+(* BACKPORT BEGIN
       [0;4;5;6;7;10;11;12;
+*)
+      [0;4;5;6;7;10;11;
+(* BACKPORT END *)
        100;101;102;103;104;105])
   else
     (* Unix: rbx, r12-r15 preserved *)
     Array.of_list(List.map phys_reg
+(* BACKPORT BEGIN
       [0;2;3;4;5;6;7;10;11;12;
+*)
+      [0;2;3;4;5;6;7;10;11;
+(* BACKPORT END *)
        100;101;102;103;104;105;106;107;
        108;109;110;111;112;113;114;115])
 
diff --git a/asmcomp/arm64/emit.mlp b/asmcomp/arm64/emit.mlp
index 3a3a9e5d0a..b338424dad 100644
--- a/asmcomp/arm64/emit.mlp
+++ b/asmcomp/arm64/emit.mlp
@@ -35,8 +35,10 @@ let reg_trap_ptr = phys_reg 23 (* x26 *)
 let reg_alloc_ptr = phys_reg 24 (* x27 *)
 let reg_tmp1 = phys_reg 26 (* x16 *)
 let reg_x8 = phys_reg 8 (* x8 *)
+(* BACKPORT
 let reg_stack_arg_begin = phys_reg 17  (* x20 *)
 let reg_stack_arg_end  = phys_reg 18 (* x21 *)
+*)
 
 (* Output a label *)
 
@@ -462,24 +464,38 @@ module BR = Branch_relaxation.Make (struct
     | Lop (Itailcall_ind) -> epilogue_size f
     | Lop (Itailcall_imm { func; _ }) ->
       if func = f.fun_name then 1 else epilogue_size f
-    | Lop (Iextcall {alloc; stack_ofs} ) ->
+    | Lop (Iextcall {alloc; stack_ofs = _} ) ->
+(* BACKPORT
       if stack_ofs > 0 then 5
-      else if alloc then 3
+      else*) if alloc then 3
+(* BACKPORT BEGIN
       else 5
+*)
+      else 1
+(* BACKPORT END *)
     | Lop (Istackoffset _) -> 2
+(* BACKPORT BEGIN
     | Lop (Iload  { memory_chunk; addressing_mode; is_atomic }) ->
       let based = match addressing_mode with Iindexed _ -> 0 | Ibased _ -> 1
       and barrier = if is_atomic then 1 else 0
       and single = match memory_chunk with Single -> 2 | _ -> 1 in
       based + barrier + single
     | Lop (Istore (memory_chunk, addressing_mode, assignment)) ->
+*)
+    | Lop (Iload  { memory_chunk; addressing_mode })
+    | Lop (Istore (memory_chunk, addressing_mode, _)) ->
+(* BACKPORT END *)
       let based = match addressing_mode with Iindexed _ -> 0 | Ibased _ -> 1
+      in
+      based + begin match memory_chunk with Single -> 2 | _ -> 1 end
+(* BACKPORT
       and barrier =
         match memory_chunk, assignment with
         | (Word_int | Word_val), true -> 1
         | _ -> 0
       and single = match memory_chunk with Single -> 2 | _ -> 1 in
       based + barrier + single
+*)
     | Lop (Ialloc _) when f.fun_fast -> 5
     | Lop (Ispecific (Ifar_alloc _)) when f.fun_fast -> 6
     | Lop (Ipoll _) -> 3
@@ -538,7 +554,11 @@ module BR = Branch_relaxation.Make (struct
     | Lpoptrap -> 1
     | Lraise k ->
       begin match k with
+(* BACKPORT BEGIN
       | Lambda.Raise_regular -> 1
+*)
+      | Lambda.Raise_regular -> 2
+(* BACKPORT END *)
       | Lambda.Raise_reraise -> 1
       | Lambda.Raise_notrace -> 4
       end
@@ -726,7 +746,8 @@ let emit_instr env i =
           `	b	{emit_label env.f.fun_tailrec_entry_point_label}\n`
         else
           output_epilogue env (fun () -> `	b	{emit_symbol func}\n`)
-    | Lop(Iextcall {func; alloc; stack_ofs}) ->
+    | Lop(Iextcall {func; alloc; stack_ofs = _}) ->
+(* BACKPORT BEGIN
         if stack_ofs > 0 then begin
           ` mov {emit_reg reg_stack_arg_begin}, sp\n`;
           ` add {emit_reg reg_stack_arg_end}, sp, #{emit_int (Misc.align stack_ofs 16)}\n`;
@@ -734,9 +755,18 @@ let emit_instr env i =
           ` bl  {emit_symbol "caml_c_call_stack_args"}\n`;
           `{record_frame env i.live (Dbg_other i.dbg)}\n`
         end else if alloc then begin
+*)
+        if not alloc then
+        `	bl	{emit_symbol func}\n`
+        else begin
+(* BACKPORT END *)
           emit_load_symbol_addr reg_x8 func;
           ` bl  {emit_symbol "caml_c_call"}\n`;
           `{record_frame env i.live (Dbg_other i.dbg)}\n`
+(* BACKPORT BEGIN *)
+        end
+(* BACKPORT END *)
+(* BACKPORT
         end else begin
           (* store ocaml stack in the frame pointer register
              NB: no need to store previous x29 because OCaml frames don't
@@ -751,6 +781,7 @@ let emit_instr env i =
           ` mov sp, x29\n`;
           cfi_restore_state ()
         end
+*)
     | Lop(Istackoffset n) ->
         assert (n mod 16 = 0);
         emit_stack_adjustment (-n);
@@ -791,7 +822,11 @@ let emit_instr env i =
         | Double ->
             `	ldr	{emit_reg dst}, {emit_addressing addressing_mode base}\n`
         end
+(* BACKPORT BEGIN
     | Lop(Istore(size, addr, assignment)) ->
+*)
+    | Lop(Istore(size, addr, _)) ->
+(* BACKPORT END *)
         (* NB: assignments other than Word_int and Word_val do not follow the
         Multicore OCaml memory model and so do not emit a barrier *)
         let src = i.arg.(0) in
@@ -814,7 +849,9 @@ let emit_instr env i =
             `	str	s7, {emit_addressing addr base}\n`;
         | Word_int | Word_val ->
             (* memory model barrier for non-initializing store *)
+(* BACKPORT
             if assignment then ` dmb ishld\n`;
+*)
             `	str	{emit_reg src}, {emit_addressing addr base}\n`
         | Double ->
             `	str	{emit_reg src}, {emit_addressing addr base}\n`
@@ -939,8 +976,13 @@ let emit_instr env i =
     | Lop(Ispecific(Isignext size)) ->
         `	sbfm	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, #0, #{emit_int (size - 1)}\n`
     | Lop(Idls_get) ->
+(* BACKPORT BEGIN *)
+        assert false
+(* BACKPORT END *)
+(* BACKPORT
         let offset = Domainstate.(idx_of_field Domain_dls_root) * 8 in
         ` ldr {emit_reg i.res.(0)}, [{emit_reg reg_domain_state_ptr}, {emit_int offset}]\n`
+*)
     | Lreloadretaddr ->
         ()
     | Lreturn ->
@@ -1039,10 +1081,18 @@ let emit_instr env i =
     | Lraise k ->
         begin match k with
         | Lambda.Raise_regular ->
+(* BACKPORT BEGIN *)
+          let offset = Domainstate.(idx_of_field Domain_backtrace_pos) * 8 in
+          `	str	xzr, [{emit_reg reg_domain_state_ptr}, {emit_int offset}]\n`;
+(* BACKPORT END *)
           `	bl	{emit_symbol "caml_raise_exn"}\n`;
           `{record_frame env Reg.Set.empty (Dbg_raise i.dbg)}\n`
         | Lambda.Raise_reraise ->
+(* BACKPORT BEGIN
           `	bl	{emit_symbol "caml_reraise_exn"}\n`;
+*)
+          `	bl	{emit_symbol "caml_raise_exn"}\n`;
+(* BACKPORT END *)
           `{record_frame env Reg.Set.empty (Dbg_raise i.dbg)}\n`
         | Lambda.Raise_notrace ->
           `	mov	sp, {emit_reg reg_trap_ptr}\n`;
@@ -1071,6 +1121,7 @@ let fundecl fundecl =
     num_call_gc_and_check_bound_points env
   in
 
+(* BACKPORT
   (* Dynamic stack checking *)
   let stack_threshold_size = Config.stack_threshold * 8 in (* bytes *)
   let { max_frame_size; contains_nontail_calls} =
@@ -1092,9 +1143,12 @@ let fundecl fundecl =
     handle_overflow := Some (overflow, ret);
     stack_check_size := 5
   end;
+*)
 
   let max_out_of_line_code_offset =
+(* BACKPORT
     !stack_check_size +
+*)
     max_out_of_line_code_offset ~num_call_gc
       ~num_check_bound
   in
@@ -1107,6 +1161,7 @@ let fundecl fundecl =
   assert (List.length env.call_gc_sites = num_call_gc);
   assert (List.length env.bound_error_sites = num_check_bound);
 
+(* BACKPORT
   begin match !handle_overflow with
   | None -> ()
   | Some (overflow,ret) -> begin
@@ -1121,6 +1176,7 @@ let fundecl fundecl =
       `  b {emit_label ret}\n`
     end
   end;
+*)
 
   cfi_endproc();
   emit_symbol_type emit_symbol fundecl.fun_name "function";
diff --git a/asmcomp/cmm_helpers.ml b/asmcomp/cmm_helpers.ml
index f92ec296a1..7fe7ef5c96 100644
--- a/asmcomp/cmm_helpers.ml
+++ b/asmcomp/cmm_helpers.ml
@@ -2203,8 +2203,13 @@ let assignment_kind
     (init: Lambda.initialization_or_assignment) =
   match init, ptr with
   | Assignment, Pointer -> Caml_modify
+(* BACKPORT BEGIN
   | Heap_initialization, Pointer
   | Root_initialization, Pointer -> Caml_initialize
+*)
+  | Heap_initialization, Pointer -> Caml_initialize
+  | Root_initialization, Pointer -> Simple
+(* BACKPORT END *)
   | Assignment, Immediate
   | Heap_initialization, Immediate
   | Root_initialization, Immediate -> Simple
diff --git a/asmcomp/i386/emit.mlp b/asmcomp/i386/emit.mlp
index b76af3687d..e3e85fe1b6 100644
--- a/asmcomp/i386/emit.mlp
+++ b/asmcomp/i386/emit.mlp
@@ -137,7 +137,7 @@ let domain_field f r =
   mem32 DWORD (Domainstate.idx_of_field f * 8) r
 
 let load_domain_state r =
-  I.mov (sym32 "Caml_state") r
+  I.mov (sym32 "caml_state") r
 
 let x86_data_type_for_stack_slot = function
   | Float -> REAL8
@@ -962,7 +962,7 @@ let begin_assembly() =
     D.extrn "_caml_alloc3" PROC;
     D.extrn "_caml_ml_array_bound_error" PROC;
     D.extrn "_caml_raise_exn" PROC;
-    D.extrn "_Caml_state" DWORD;
+    D.extrn "_caml_state" DWORD;
   end;
 
   D.data ();
diff --git a/boot/ocamlc b/boot/ocamlc
index c5bcc5dba3..804880e707 100755
Binary files a/boot/ocamlc and b/boot/ocamlc differ
diff --git a/boot/ocamllex b/boot/ocamllex
index 13c44be1f3..9c4fe66628 100755
Binary files a/boot/ocamllex and b/boot/ocamllex differ
diff --git a/build-aux/ocaml_version.m4 b/build-aux/ocaml_version.m4
index 2c66a918a3..0a59107ea8 100644
--- a/build-aux/ocaml_version.m4
+++ b/build-aux/ocaml_version.m4
@@ -36,7 +36,7 @@ m4_define([OCAML__VERSION_MINOR], [0])
 m4_define([OCAML__VERSION_PATCHLEVEL], [0])
 # Note that the OCAML__VERSION_EXTRA string defined below is always empty
 # for officially-released versions of OCaml.
-m4_define([OCAML__VERSION_EXTRA], [dev0-2021-11-05])
+m4_define([OCAML__VERSION_EXTRA], [jst-backport])
 
 # The OCAML__VERSION_EXTRA_PREFIX macro defined below should be a
 # single character:
diff --git a/bytecomp/emitcode.ml b/bytecomp/emitcode.ml
index ea423e50b7..bd961633a9 100644
--- a/bytecomp/emitcode.ml
+++ b/bytecomp/emitcode.ml
@@ -300,10 +300,14 @@ let emit_instr = function
   | Kgetpubmet tag -> out opGETPUBMET; out_int tag; out_int 0
   | Kgetdynmet -> out opGETDYNMET
   | Kevent ev -> record_event ev
+(* BACKPORT BEGIN
   | Kperform -> out opPERFORM
   | Kresume -> out opRESUME
   | Kresumeterm n -> out opRESUMETERM; out_int n
   | Kreperformterm n -> out opREPERFORMTERM; out_int n
+*)
+  | Kperform | Kresume | Kresumeterm _ | Kreperformterm _ -> assert false
+(* BACKPORT END *)
   | Kstop -> out opSTOP
 
 (* Emission of a list of instructions. Include some peephole optimization. *)
diff --git a/configure b/configure
index c399043b88..bcea9b6884 100755
Binary files a/configure and b/configure differ
diff --git a/configure.ac b/configure.ac
index dd7fc9a80c..940de94b1b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -168,6 +168,8 @@ AC_SUBST([flexlink_flags])
 AC_SUBST([PACKLD])
 AC_SUBST([stdlib_manpages])
 AC_SUBST([compute_deps])
+AC_SUBST([naked_pointers])
+AC_SUBST([naked_pointers_checker])
 AC_SUBST([force_instrumented_runtime])
 
 ## Generated files
@@ -201,10 +203,10 @@ AC_CANONICAL_TARGET
 # Systems that are known not to work, even in bytecode only.
 
 AS_CASE([$host],
-  [*-pc-windows],
-    [AC_MSG_ERROR([the MSVC compiler is not supported currently], 69)],
-  [*-*-cygwin*],
-    [AC_MSG_ERROR([Cygwin is not supported currently], 69)],
+dnl   [*-pc-windows],
+dnl     [AC_MSG_ERROR([the MSVC compiler is not supported currently], 69)],
+dnl   [*-*-cygwin*],
+dnl    [AC_MSG_ERROR([Cygwin is not supported currently], 69)],
   [i386-*-solaris*],
     [AC_MSG_ERROR([Building for 32 bits target is not supported. \
 If your host is 64 bits, you can try with './configure CC="gcc -m64"' \
@@ -313,15 +315,23 @@ AC_ARG_ENABLE([frame-pointers],
   [AS_HELP_STRING([--enable-frame-pointers],
     [use frame pointers in runtime and generated code])])
 
-AC_ARG_ENABLE([naked-pointers], [],
-  [AS_IF([test "x$enableval" != 'xno'],
-    [AC_MSG_ERROR([Naked pointers were prohibited in OCaml 5.0.])])],
-  [])
+dnl AC_ARG_ENABLE([naked-pointers], [],
+dnl   [AS_IF([test "x$enableval" != 'xno'],
+dnl     [AC_MSG_ERROR([Naked pointers were prohibited in OCaml 5.0.])])],
+dnl   [])
 
-AC_ARG_ENABLE([naked-pointers-checker], [],
-  [AS_IF([test "x$enableval" != 'xno'],
-    [AC_MSG_ERROR([The naked pointers checker was removed in OCaml 5.0.])])],
-  [])
+dnl AC_ARG_ENABLE([naked-pointers-checker], [],
+dnl   [AS_IF([test "x$enableval" != 'xno'],
+dnl     [AC_MSG_ERROR(m4_normalize([The naked pointers checker was removed in
+dnl       OCaml 5.0.]))])],
+dnl   [])
+AC_ARG_ENABLE([naked-pointers],
+  [AS_HELP_STRING([--disable-naked-pointers],
+    [do not allow naked pointers])])
+
+AC_ARG_ENABLE([naked-pointers-checker],
+  [AS_HELP_STRING([--enable-naked-pointers-checker],
+    [enable the naked pointers checker])])
 
 AC_ARG_ENABLE([spacetime], [],
   [AS_IF([test "x$enableval" != 'xno'],
@@ -1050,77 +1060,77 @@ model=default
 system=unknown
 
 AS_CASE([$host],
-dnl [[i[3456]86-*-linux*]],
-dnl   [arch=i386; system=linux_elf],
-dnl [[i[3456]86-*-*bsd*]],
-dnl   [arch=i386; system=bsd_elf],
-dnl [[i[3456]86-*-haiku*]],
-dnl   [arch=i386; system=beos],
-dnl [[i[3456]86-*-cygwin]],
-dnl   [arch=i386; system=cygwin],
-dnl [[i[3456]86-*-gnu*]],
-dnl   [arch=i386; system=gnu],
-dnl [[i[3456]86-*-mingw32]],
-dnl   [arch=i386; system=mingw],
-dnl [i686-pc-windows],
-dnl   [arch=i386; system=win32],
-dnl [x86_64-pc-windows],
-dnl   [arch=amd64; system=win64],
-dnl [[powerpc64le*-*-linux*]],
-dnl   [arch=power; model=ppc64le; system=elf],
-dnl [[powerpc*-*-linux*]],
-dnl   [arch=power; AS_IF([$arch64],[model=ppc64],[model=ppc]); system=elf],
-dnl [[s390x*-*-linux*]],
-dnl   [arch=s390x; model=z10; system=elf],
-dnl # expected to match "gnueabihf" as well as "musleabihf"
-dnl [armv6*-*-linux-*eabihf],
-dnl   [arch=arm; model=armv6; system=linux_eabihf],
-dnl [armv7*-*-linux-*eabihf],
-dnl   [arch=arm; model=armv7; system=linux_eabihf],
-dnl [armv8*-*-linux-*eabihf],
-dnl   [arch=arm; model=armv8; system=linux_eabihf],
-dnl [armv8*-*-linux-*eabi],
-dnl   [arch=arm; model=armv8; system=linux_eabi],
-dnl [armv7*-*-linux-*eabi],
-dnl   [arch=arm; model=armv7; system=linux_eabi],
-dnl [armv6t2*-*-linux-*eabi],
-dnl   [arch=arm; model=armv6t2; system=linux_eabi],
-dnl [armv6*-*-linux-*eabi],
-dnl   [arch=arm; model=armv6; system=linux_eabi],
-dnl [armv6*-*-freebsd*],
-dnl   [arch=arm; model=armv6; system=freebsd],
-dnl [earmv6*-*-netbsd*],
-dnl   [arch=arm; model=armv6; system=netbsd],
-dnl [earmv7*-*-netbsd*],
-dnl   [arch=arm; model=armv7; system=netbsd],
-dnl [armv5te*-*-linux-*eabi],
-dnl   [arch=arm; model=armv5te; system=linux_eabi],
-dnl [armv5*-*-linux-*eabi],
-dnl   [arch=arm; model=armv5; system=linux_eabi],
-dnl [arm*-*-linux-*eabihf],
-dnl   [arch=arm; system=linux_eabihf],
-dnl [arm*-*-linux-*eabi],
-dnl   [arch=arm; system=linux_eabi],
-dnl [arm*-*-openbsd*],
-dnl   [arch=arm; system=bsd],
-dnl [zaurus*-*-openbsd*],
-dnl   [arch=arm; system=bsd],
+  [[i[3456]86-*-linux*]],
+    [arch=i386; system=linux_elf],
+  [[i[3456]86-*-*bsd*]],
+    [arch=i386; system=bsd_elf],
+  [[i[3456]86-*-haiku*]],
+    [arch=i386; system=beos],
+  [[i[3456]86-*-cygwin]],
+    [arch=i386; system=cygwin],
+  [[i[3456]86-*-gnu*]],
+    [arch=i386; system=gnu],
+  [[i[3456]86-*-mingw32]],
+    [arch=i386; system=mingw],
+  [i686-pc-windows],
+    [arch=i386; system=win32],
+  [x86_64-pc-windows],
+    [arch=amd64; system=win64],
+  [[powerpc64le*-*-linux*]],
+    [arch=power; model=ppc64le; system=elf],
+  [[powerpc*-*-linux*]],
+    [arch=power; AS_IF([$arch64],[model=ppc64],[model=ppc]); system=elf],
+  [[s390x*-*-linux*]],
+    [arch=s390x; model=z10; system=elf],
+  # expected to match "gnueabihf" as well as "musleabihf"
+  [armv6*-*-linux-*eabihf],
+    [arch=arm; model=armv6; system=linux_eabihf],
+  [armv7*-*-linux-*eabihf],
+    [arch=arm; model=armv7; system=linux_eabihf],
+  [armv8*-*-linux-*eabihf],
+    [arch=arm; model=armv8; system=linux_eabihf],
+  [armv8*-*-linux-*eabi],
+    [arch=arm; model=armv8; system=linux_eabi],
+  [armv7*-*-linux-*eabi],
+    [arch=arm; model=armv7; system=linux_eabi],
+  [armv6t2*-*-linux-*eabi],
+    [arch=arm; model=armv6t2; system=linux_eabi],
+  [armv6*-*-linux-*eabi],
+    [arch=arm; model=armv6; system=linux_eabi],
+  [armv6*-*-freebsd*],
+    [arch=arm; model=armv6; system=freebsd],
+  [earmv6*-*-netbsd*],
+    [arch=arm; model=armv6; system=netbsd],
+  [earmv7*-*-netbsd*],
+    [arch=arm; model=armv7; system=netbsd],
+  [armv5te*-*-linux-*eabi],
+    [arch=arm; model=armv5te; system=linux_eabi],
+  [armv5*-*-linux-*eabi],
+    [arch=arm; model=armv5; system=linux_eabi],
+  [arm*-*-linux-*eabihf],
+    [arch=arm; system=linux_eabihf],
+  [arm*-*-linux-*eabi],
+    [arch=arm; system=linux_eabi],
+  [arm*-*-openbsd*],
+    [arch=arm; system=bsd],
+  [zaurus*-*-openbsd*],
+    [arch=arm; system=bsd],
   [x86_64-*-linux*],
     [arch=amd64; system=linux],
-dnl [x86_64-*-gnu*],
-dnl   [arch=amd64; system=gnu],
-dnl [x86_64-*-dragonfly*],
-dnl   [arch=amd64; system=dragonfly],
-dnl [x86_64-*-solaris*],
-dnl   [arch=amd64; system=solaris],
+  [x86_64-*-gnu*],
+    [arch=amd64; system=gnu],
+  [x86_64-*-dragonfly*],
+    [arch=amd64; system=dragonfly],
+  [x86_64-*-solaris*],
+    [arch=amd64; system=solaris],
   [x86_64-*-freebsd*],
     [arch=amd64; system=freebsd],
   [x86_64-*-netbsd*],
     [arch=amd64; system=netbsd],
   [x86_64-*-openbsd*],
     [arch=amd64; system=openbsd],
-dnl [x86_64-*-haiku*],
-dnl   [arch=amd64; system=beos],
+  [x86_64-*-haiku*],
+    [arch=amd64; system=beos],
   [arm64-*-darwin*],
     [arch=arm64; system=macosx],
   [aarch64-*-darwin*],
@@ -1131,14 +1141,14 @@ dnl   [arch=amd64; system=beos],
     [arch=amd64; system=mingw64],
   [aarch64-*-linux*],
     [arch=arm64; system=linux],
-dnl [aarch64-*-freebsd*],
-dnl   [arch=arm64; system=freebsd],
+  [aarch64-*-freebsd*],
+    [arch=arm64; system=freebsd],
   [aarch64-*-openbsd*],
     [arch=arm64; system=openbsd],
-dnl [x86_64-*-cygwin*],
-dnl   [arch=amd64; system=cygwin],
-dnl [riscv64-*-linux*],
-dnl   [arch=riscv; model=riscv64; system=linux]
+  [x86_64-*-cygwin*],
+    [arch=amd64; system=cygwin],
+  [riscv64-*-linux*],
+    [arch=riscv; model=riscv64; system=linux]
 )
 
 AS_CASE([$enable_native_compiler,$arch],
@@ -1810,7 +1820,8 @@ AS_CASE([$arch,$system],
 
 AS_CASE([$host],
   [*-*-mingw32|*-pc-windows],
-    [PTHREAD_LIBS="-lpthread"],
+dnl    [PTHREAD_LIBS="-lpthread"],
+    [PTHREAD_LIBS=''],
   [AX_PTHREAD(
     [common_cflags="$common_cflags $PTHREAD_CFLAGS"
     saved_CFLAGS="$CFLAGS"
@@ -1859,6 +1870,30 @@ AS_IF([test x"$enable_frame_pointers" = "xyes"],
   [AC_MSG_NOTICE([not using frame pointers])
   frame_pointers=false])
 
+## No naked pointers
+
+AS_IF([test x"$enable_naked_pointers" = "xno" ],
+  [naked_pointers=false
+   AC_DEFINE([NO_NAKED_POINTERS])],
+  [naked_pointers=true])
+
+AS_IF([test x"$enable_naked_pointers_checker" = "xyes" ],
+  [AS_IF([test x"$enable_naked_pointers" = "xno" ],
+         [AC_MSG_ERROR(m4_normalize([
+               --enable-naked-pointers-checker and --disable-naked-pointers
+               are incompatible]))])
+   AS_CASE(["$arch","$system"],
+    [amd64,linux|amd64,macosx \
+    |amd64,openbsd|amd64,win64 \
+    |amd64,freebsd|amd64,solaris \
+    |arm64,linux|arm64,macosx],
+      [naked_pointers_checker=true
+      AC_DEFINE([NAKED_POINTERS_CHECKER])],
+    [*],
+      [AC_MSG_ERROR([naked pointers checker not supported on this platform])]
+  )],
+  [naked_pointers_checker=false])
+
 ## Check for mmap support for huge pages and contiguous heap
 OCAML_MMAP_SUPPORTS_HUGE_PAGES
 
@@ -1994,8 +2029,10 @@ AC_CHECK_LIB(execinfo, backtrace, cclibs="$cclibs -lexecinfo",[])
 
 AS_CASE([$host],
   [*-*-mingw32],
-    [bytecclibs="-lws2_32 -lversion -lpthread -lgcc_eh -lDbgHelp"
-    nativecclibs="-lws2_32 -lversion -lpthread -lgcc_eh -lDbgHelp"],
+dnl    [bytecclibs="-lws2_32 -lversion -lpthread -lgcc_eh -lDbgHelp"
+dnl    nativecclibs="-lws2_32 -lversion -lpthread -lgcc_eh -lDbgHelp"],
+    [bytecclibs="-lws2_32 -lversion -lgcc_eh -lDbgHelp"
+    nativecclibs="-lws2_32 -lversion -lgcc_eh -lDbgHelp"],
   [*-pc-windows],
     [bytecclibs="advapi32.lib ws2_32.lib version.lib"
     nativecclibs="advapi32.lib ws2_32.lib version.lib"],
diff --git a/diff-against-4.14-runtime.diff b/diff-against-4.14-runtime.diff
new file mode 100644
index 0000000000..d9e135d7b5
--- /dev/null
+++ b/diff-against-4.14-runtime.diff
@@ -0,0 +1,1672 @@
+diff --git a/otherlibs/systhreads/st_posix.h b/otherlibs/systhreads/st_posix.h
+index 957f4717b6..09b243f6a5 100644
+--- a/otherlibs/systhreads/st_posix.h
++++ b/otherlibs/systhreads/st_posix.h
+@@ -446,7 +446,7 @@ static value st_encode_sigset(sigset_t * set)
+ 
+ static int sigmask_cmd[3] = { SIG_SETMASK, SIG_BLOCK, SIG_UNBLOCK };
+ 
+-value caml_thread_sigmask(value cmd, value sigs) /* ML */
++value caml_thread_sigmask(value cmd, value sigs)
+ {
+   int how;
+   sigset_t set, oldset;
+@@ -463,7 +463,7 @@ value caml_thread_sigmask(value cmd, value sigs) /* ML */
+   return st_encode_sigset(&oldset);
+ }
+ 
+-value caml_wait_signal(value sigs) /* ML */
++value caml_wait_signal(value sigs)
+ {
+ #ifdef HAS_SIGWAIT
+   sigset_t set;
+diff --git a/otherlibs/systhreads/st_stubs.c b/otherlibs/systhreads/st_stubs.c
+index 043e07031e..c1d8358e93 100644
+--- a/otherlibs/systhreads/st_stubs.c
++++ b/otherlibs/systhreads/st_stubs.c
+@@ -430,7 +430,7 @@ static void caml_thread_reinitialize(void)
+ 
+ /* Initialize the thread machinery */
+ 
+-CAMLprim value caml_thread_initialize(value unit)   /* ML */
++CAMLprim value caml_thread_initialize(value unit)
+ {
+   /* Protect against repeated initialization (PR#3532) */
+   if (curr_thread != NULL) return Val_unit;
+@@ -483,7 +483,7 @@ CAMLprim value caml_thread_initialize(value unit)   /* ML */
+    thread take 25ms on average / 50ms in the worst case, so we don't do it on
+    program exit. */
+ 
+-CAMLprim value caml_thread_cleanup(value unit)   /* ML */
++CAMLprim value caml_thread_cleanup(value unit)
+ {
+   if (caml_tick_thread_running){
+     caml_tick_thread_stop = 1;
+@@ -524,7 +524,6 @@ static ST_THREAD_FUNCTION caml_thread_start(void * arg)
+ {
+   caml_thread_t th = (caml_thread_t) arg;
+   value clos;
+-  void * signal_stack;
+ #ifdef NATIVE_CODE
+   struct longjmp_buffer termination_buf;
+   char tos;
+@@ -537,7 +536,7 @@ static ST_THREAD_FUNCTION caml_thread_start(void * arg)
+   /* Acquire the global mutex */
+   caml_leave_blocking_section();
+   st_thread_set_id(Ident(th->descr));
+-  signal_stack = caml_setup_stack_overflow_detection();
++  caml_setup_stack_overflow_detection();
+ #ifdef NATIVE_CODE
+   /* Setup termination handler (for caml_thread_exit) */
+   if (sigsetjmp(termination_buf.buf, 0) == 0) {
+@@ -551,12 +550,12 @@ static ST_THREAD_FUNCTION caml_thread_start(void * arg)
+ #ifdef NATIVE_CODE
+   }
+ #endif
+-  caml_stop_stack_overflow_detection(signal_stack);
++  caml_stop_stack_overflow_detection();
+   /* The thread now stops running */
+   return 0;
+ }
+ 
+-CAMLprim value caml_thread_new(value clos)          /* ML */
++CAMLprim value caml_thread_new(value clos)
+ {
+   caml_thread_t th;
+   st_retcode err;
+@@ -663,7 +662,7 @@ CAMLexport int caml_c_thread_unregister(void)
+ 
+ /* Return the current thread */
+ 
+-CAMLprim value caml_thread_self(value unit)         /* ML */
++CAMLprim value caml_thread_self(value unit)
+ {
+   if (curr_thread == NULL)
+     caml_invalid_argument("Thread.self: not initialized");
+@@ -672,14 +671,14 @@ CAMLprim value caml_thread_self(value unit)         /* ML */
+ 
+ /* Return the identifier of a thread */
+ 
+-CAMLprim value caml_thread_id(value th)          /* ML */
++CAMLprim value caml_thread_id(value th)
+ {
+   return Ident(th);
+ }
+ 
+ /* Print uncaught exception and backtrace */
+ 
+-CAMLprim value caml_thread_uncaught_exception(value exn)  /* ML */
++CAMLprim value caml_thread_uncaught_exception(value exn)
+ {
+   char * msg = caml_format_exception(exn);
+   fprintf(stderr, "Thread %d killed on uncaught exception %s\n",
+@@ -692,7 +691,7 @@ CAMLprim value caml_thread_uncaught_exception(value exn)  /* ML */
+ 
+ /* Terminate current thread */
+ 
+-CAMLprim value caml_thread_exit(value unit)   /* ML */
++CAMLprim value caml_thread_exit(value unit)
+ {
+   struct longjmp_buffer * exit_buf = NULL;
+ 
+@@ -723,7 +722,7 @@ CAMLprim value caml_thread_exit(value unit)   /* ML */
+ 
+ /* Allow re-scheduling */
+ 
+-CAMLprim value caml_thread_yield(value unit)        /* ML */
++CAMLprim value caml_thread_yield(value unit)
+ {
+   if (st_masterlock_waiters(&caml_master_lock) == 0) return Val_unit;
+ 
+@@ -744,7 +743,7 @@ CAMLprim value caml_thread_yield(value unit)        /* ML */
+ 
+ /* Suspend the current thread until another thread terminates */
+ 
+-CAMLprim value caml_thread_join(value th)          /* ML */
++CAMLprim value caml_thread_join(value th)
+ {
+   st_retcode rc = caml_threadstatus_wait(Terminated(th));
+   st_check_error(rc, "Thread.join");
+@@ -783,7 +782,7 @@ static struct custom_operations caml_mutex_ops = {
+   custom_fixed_length_default
+ };
+ 
+-CAMLprim value caml_mutex_new(value unit)        /* ML */
++CAMLprim value caml_mutex_new(value unit)
+ {
+   st_mutex mut = NULL;          /* suppress warning */
+   value wrapper;
+@@ -794,7 +793,7 @@ CAMLprim value caml_mutex_new(value unit)        /* ML */
+   return wrapper;
+ }
+ 
+-CAMLprim value caml_mutex_lock(value wrapper)     /* ML */
++CAMLprim value caml_mutex_lock(value wrapper)
+ {
+   st_mutex mut = Mutex_val(wrapper);
+   st_retcode retcode;
+@@ -811,7 +810,7 @@ CAMLprim value caml_mutex_lock(value wrapper)     /* ML */
+   return Val_unit;
+ }
+ 
+-CAMLprim value caml_mutex_unlock(value wrapper)           /* ML */
++CAMLprim value caml_mutex_unlock(value wrapper)
+ {
+   st_mutex mut = Mutex_val(wrapper);
+   st_retcode retcode;
+@@ -821,7 +820,7 @@ CAMLprim value caml_mutex_unlock(value wrapper)           /* ML */
+   return Val_unit;
+ }
+ 
+-CAMLprim value caml_mutex_try_lock(value wrapper)           /* ML */
++CAMLprim value caml_mutex_try_lock(value wrapper)
+ {
+   st_mutex mut = Mutex_val(wrapper);
+   st_retcode retcode;
+@@ -863,7 +862,7 @@ static struct custom_operations caml_condition_ops = {
+   custom_fixed_length_default
+ };
+ 
+-CAMLprim value caml_condition_new(value unit)        /* ML */
++CAMLprim value caml_condition_new(value unit)
+ {
+   st_condvar cond = NULL;       /* suppress warning */
+   value wrapper;
+@@ -874,7 +873,7 @@ CAMLprim value caml_condition_new(value unit)        /* ML */
+   return wrapper;
+ }
+ 
+-CAMLprim value caml_condition_wait(value wcond, value wmut)           /* ML */
++CAMLprim value caml_condition_wait(value wcond, value wmut)
+ {
+   st_condvar cond = Condition_val(wcond);
+   st_mutex mut = Mutex_val(wmut);
+@@ -889,14 +888,14 @@ CAMLprim value caml_condition_wait(value wcond, value wmut)           /* ML */
+   return Val_unit;
+ }
+ 
+-CAMLprim value caml_condition_signal(value wrapper)           /* ML */
++CAMLprim value caml_condition_signal(value wrapper)
+ {
+   st_check_error(st_condvar_signal(Condition_val(wrapper)),
+                  "Condition.signal");
+   return Val_unit;
+ }
+ 
+-CAMLprim value caml_condition_broadcast(value wrapper)           /* ML */
++CAMLprim value caml_condition_broadcast(value wrapper)
+ {
+   st_check_error(st_condvar_broadcast(Condition_val(wrapper)),
+                  "Condition.broadcast");
+diff --git a/otherlibs/systhreads/st_win32.h b/otherlibs/systhreads/st_win32.h
+index 3f598a715d..21eb674fc5 100644
+--- a/otherlibs/systhreads/st_win32.h
++++ b/otherlibs/systhreads/st_win32.h
+@@ -525,13 +525,13 @@ static DWORD st_atfork(void (*fn)(void))
+ 
+ /* Signal handling -- none under Win32 */
+ 
+-value caml_thread_sigmask(value cmd, value sigs) /* ML */
++value caml_thread_sigmask(value cmd, value sigs)
+ {
+   caml_invalid_argument("Thread.sigmask not implemented");
+   return Val_int(0);            /* not reached */
+ }
+ 
+-value caml_wait_signal(value sigs) /* ML */
++value caml_wait_signal(value sigs)
+ {
+   caml_invalid_argument("Thread.wait_signal not implemented");
+   return Val_int(0);            /* not reached */
+diff --git a/runtime/Makefile b/runtime/Makefile
+index f5c08d8798..dee25dc02a 100644
+--- a/runtime/Makefile
++++ b/runtime/Makefile
+@@ -26,7 +26,7 @@ BYTECODE_C_SOURCES := $(addsuffix .c, \
+   floats str array io extern intern hash sys meta parsing gc_ctrl md5 obj \
+   lexing callback debugger weak compact finalise custom dynlink \
+   afl $(UNIX_OR_WIN32) bigarray main memprof domain \
+-  skiplist codefrag)
++  skiplist codefrag prng)
+ 
+ NATIVE_C_SOURCES := $(addsuffix .c, \
+   startup_aux startup_nat main fail_nat roots_nat signals \
+@@ -35,7 +35,7 @@ NATIVE_C_SOURCES := $(addsuffix .c, \
+   lexing $(UNIX_OR_WIN32) printexc callback weak compact finalise custom \
+   globroots backtrace_nat backtrace dynlink_nat debugger meta \
+   dynlink clambda_checks afl bigarray \
+-  memprof domain skiplist codefrag)
++  memprof domain skiplist codefrag prng)
+ 
+ # Header files generated by configure
+ CONFIGURED_HEADERS := caml/m.h caml/s.h caml/version.h
+@@ -199,9 +199,9 @@ ld.conf: $(ROOTDIR)/Makefile.config
+ # CAMLprim value caml_foo() ...
+ # #else
+ # CAMLprim value caml_foo() ...
+-# end), horrible things will happen (duplicated entries in Runtimedef ->
++# #endif), horrible things will happen: duplicated entries in Runtimedef ->
+ # double registration in Symtable -> empty entry in the PRIM table ->
+-# the bytecode interpreter is confused).
++# the bytecode interpreter is confused.
+ # We sort the primitive file and remove duplicates to avoid this problem.
+ 
+ # Warning: we use "sort | uniq" instead of "sort -u" because in the MSVC
+diff --git a/runtime/bigarray.c b/runtime/bigarray.c
+index ed4ff67d21..03151f6946 100644
+--- a/runtime/bigarray.c
++++ b/runtime/bigarray.c
+@@ -89,7 +89,7 @@ CAMLexport value
+ caml_ba_alloc(int flags, int num_dims, void * data, intnat * dim)
+ {
+   uintnat num_elts, asize, size;
+-  int i;
++  int i, is_managed;
+   value res;
+   struct caml_ba_array * b;
+   intnat dimcopy[CAML_BA_MAX_NUM_DIMS];
+@@ -97,23 +97,23 @@ caml_ba_alloc(int flags, int num_dims, void * data, intnat * dim)
+   CAMLassert(num_dims >= 0 && num_dims <= CAML_BA_MAX_NUM_DIMS);
+   CAMLassert((flags & CAML_BA_KIND_MASK) <= CAML_BA_CHAR);
+   for (i = 0; i < num_dims; i++) dimcopy[i] = dim[i];
+-  size = 0;
+-  if (data == NULL) {
+-    num_elts = 1;
+-    for (i = 0; i < num_dims; i++) {
+-      if (caml_umul_overflow(num_elts, dimcopy[i], &num_elts))
+-        caml_raise_out_of_memory();
+-    }
+-    if (caml_umul_overflow(num_elts,
+-                           caml_ba_element_size[flags & CAML_BA_KIND_MASK],
+-                           &size))
++  num_elts = 1;
++  for (i = 0; i < num_dims; i++) {
++    if (caml_umul_overflow(num_elts, dimcopy[i], &num_elts))
+       caml_raise_out_of_memory();
++  }
++  if (caml_umul_overflow(num_elts,
++                         caml_ba_element_size[flags & CAML_BA_KIND_MASK],
++                         &size))
++    caml_raise_out_of_memory();
++  if (data == NULL) {
+     data = malloc(size);
+     if (data == NULL && size != 0) caml_raise_out_of_memory();
+     flags |= CAML_BA_MANAGED;
+   }
+   asize = SIZEOF_BA_ARRAY + num_dims * sizeof(intnat);
+-  res = caml_alloc_custom_mem(&caml_ba_ops, asize, size);
++  is_managed = ((flags & CAML_BA_MANAGED_MASK) == CAML_BA_MANAGED);
++  res = caml_alloc_custom_mem(&caml_ba_ops, asize, is_managed ? size : 0);
+   b = Caml_ba_array_val(res);
+   b->data = data;
+   b->num_dims = num_dims;
+diff --git a/runtime/caml/alloc.h b/runtime/caml/alloc.h
+index 13f0fac2fb..816da799bb 100644
+--- a/runtime/caml/alloc.h
++++ b/runtime/caml/alloc.h
+@@ -17,9 +17,6 @@
+ #define CAML_ALLOC_H
+ 
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "misc.h"
+ #include "mlvalues.h"
+ 
+diff --git a/runtime/caml/bigarray.h b/runtime/caml/bigarray.h
+index fc1fb14570..1664ae3f6e 100644
+--- a/runtime/caml/bigarray.h
++++ b/runtime/caml/bigarray.h
+@@ -16,9 +16,6 @@
+ #ifndef CAML_BIGARRAY_H
+ #define CAML_BIGARRAY_H
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "config.h"
+ #include "mlvalues.h"
+ 
+diff --git a/runtime/caml/callback.h b/runtime/caml/callback.h
+index eef3342ec7..5c45995b8a 100644
+--- a/runtime/caml/callback.h
++++ b/runtime/caml/callback.h
+@@ -18,9 +18,6 @@
+ #ifndef CAML_CALLBACK_H
+ #define CAML_CALLBACK_H
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "mlvalues.h"
+ 
+ #ifdef __cplusplus
+diff --git a/runtime/caml/camlatomic.h b/runtime/caml/camlatomic.h
+new file mode 100644
+index 0000000000..7206f0579a
+--- /dev/null
++++ b/runtime/caml/camlatomic.h
+@@ -0,0 +1,85 @@
++/**************************************************************************/
++/*                                                                        */
++/*                                 OCaml                                  */
++/*                                                                        */
++/*      KC Sivaramakrishnan, Indian Institute of Technology, Madras       */
++/*                Stephen Dolan, University of Cambridge                  */
++/*                                                                        */
++/*   Copyright 2018 Indian Institute of Technology, Madras                */
++/*   Copyright 2018 University of Cambridge                               */
++/*                                                                        */
++/*   All rights reserved.  This file is distributed under the terms of    */
++/*   the GNU Lesser General Public License version 2.1, with the          */
++/*   special exception on linking described in the file LICENSE.          */
++/*                                                                        */
++/**************************************************************************/
++#ifndef CAML_ATOMIC_H
++#define CAML_ATOMIC_H
++
++#include "config.h"
++
++/* On platforms supporting C11 atomics, this file just includes <stdatomic.h>.
++
++   On other platforms, this file includes platform-specific stubs for
++   the subset of C11 atomics needed by the OCaml runtime
++ */
++
++#ifdef __cplusplus
++
++extern "C++" {
++#include <atomic>
++#define ATOMIC_UINTNAT_INIT(x) (x)
++typedef std::atomic<uintnat> atomic_uintnat;
++typedef std::atomic<intnat> atomic_intnat;
++using std::memory_order_relaxed;
++using std::memory_order_acquire;
++using std::memory_order_release;
++using std::memory_order_acq_rel;
++using std::memory_order_seq_cst;
++}
++
++#elif defined(HAS_STDATOMIC_H)
++
++#include <stdatomic.h>
++#define ATOMIC_UINTNAT_INIT(x) (x)
++typedef _Atomic uintnat atomic_uintnat;
++typedef _Atomic intnat atomic_intnat;
++
++#elif defined(__GNUC__)
++
++/* Support for versions of gcc which have built-in atomics but do not
++   expose stdatomic.h (e.g. gcc 4.8) */
++typedef enum memory_order {
++  memory_order_relaxed = __ATOMIC_RELAXED,
++  memory_order_acquire = __ATOMIC_ACQUIRE,
++  memory_order_release = __ATOMIC_RELEASE,
++  memory_order_acq_rel = __ATOMIC_ACQ_REL,
++  memory_order_seq_cst = __ATOMIC_SEQ_CST
++} memory_order;
++
++#define ATOMIC_UINTNAT_INIT(x) { (x) }
++typedef struct { uintnat repr; } atomic_uintnat;
++typedef struct { intnat repr; } atomic_intnat;
++
++#define atomic_load_explicit(x, m) __atomic_load_n(&(x)->repr, (m))
++#define atomic_load(x) atomic_load_explicit((x), memory_order_seq_cst)
++#define atomic_store_explicit(x, v, m) __atomic_store_n(&(x)->repr, (v), (m))
++#define atomic_store(x, v) atomic_store_explicit((x), (v), memory_order_seq_cst)
++#define atomic_compare_exchange_strong(x, oldv, newv) \
++  __atomic_compare_exchange_n( \
++    &(x)->repr, \
++    (oldv), (newv), 0, \
++    memory_order_seq_cst, memory_order_seq_cst)
++#define atomic_exchange(x, newv) \
++  __atomic_exchange_n(&(x)->repr, (newv), memory_order_seq_cst)
++#define atomic_fetch_add(x, n) \
++  __atomic_fetch_add(&(x)->repr, (n), memory_order_seq_cst)
++#define atomic_fetch_or(x, n) \
++  __atomic_fetch_or(&(x)->repr, (n), memory_order_seq_cst)
++#define atomic_thread_fence __atomic_thread_fence
++
++#else
++#error "C11 atomics are unavailable on this platform. See camlatomic.h"
++#endif
++
++#endif /* CAML_ATOMIC_H */
+diff --git a/runtime/caml/compatibility.h b/runtime/caml/compatibility.h
+deleted file mode 100644
+index 1c109aa470..0000000000
+--- a/runtime/caml/compatibility.h
++++ /dev/null
+@@ -1,373 +0,0 @@
+-/**************************************************************************/
+-/*                                                                        */
+-/*                                 OCaml                                  */
+-/*                                                                        */
+-/*           Damien Doligez, projet Moscova, INRIA Rocquencourt           */
+-/*                                                                        */
+-/*   Copyright 2003 Institut National de Recherche en Informatique et     */
+-/*     en Automatique.                                                    */
+-/*                                                                        */
+-/*   All rights reserved.  This file is distributed under the terms of    */
+-/*   the GNU Lesser General Public License version 2.1, with the          */
+-/*   special exception on linking described in the file LICENSE.          */
+-/*                                                                        */
+-/**************************************************************************/
+-
+-/* definitions for compatibility with old identifiers */
+-
+-#ifndef CAML_COMPATIBILITY_H
+-#define CAML_COMPATIBILITY_H
+-
+-/* internal global variables renamed between 4.02.1 and 4.03.0 */
+-#define caml_stat_top_heap_size Bsize_wsize(caml_stat_top_heap_wsz)
+-#define caml_stat_heap_size Bsize_wsize(caml_stat_heap_wsz)
+-
+-#ifndef CAML_NAME_SPACE
+-
+-/*
+-   #define --> CAMLextern  (defined with CAMLexport or CAMLprim)
+-   (rien)  --> CAMLprim
+-   g       --> global C identifier
+-   x       --> special case
+-
+-   SP* signals the special cases:
+-   - when the identifier was not simply prefixed with [caml_]
+-   - when the [caml_] version was already used for something else, and
+-     was renamed out of the way (watch out for [caml_alloc] and
+-     [caml_array_bound_error] in *.s)
+-*/
+-
+-/* a faire:
+-   - ui_*   (reverifier que win32.c n'en depend pas)
+-*/
+-
+-
+-/* **** alloc.c */
+-#define alloc CAML_DEPRECATED("alloc", "caml_alloc") caml_alloc /*SP*/
+-#define alloc_small CAML_DEPRECATED("alloc_small", "caml_alloc_small") caml_alloc_small
+-#define alloc_tuple CAML_DEPRECATED("alloc_tuple", "caml_alloc_tuple") caml_alloc_tuple
+-#define alloc_string CAML_DEPRECATED("alloc_string", "caml_alloc_string") caml_alloc_string
+-#define alloc_final CAML_DEPRECATED("alloc_final", "caml_alloc_final") caml_alloc_final
+-#define copy_string CAML_DEPRECATED("copy_string", "caml_copy_string") caml_copy_string
+-#define alloc_array CAML_DEPRECATED("alloc_array", "caml_alloc_array") caml_alloc_array
+-#define copy_string_array CAML_DEPRECATED("copy_string_array", "caml_copy_string_array") caml_copy_string_array
+-#define convert_flag_list CAML_DEPRECATED("convert_flag_list", "caml_convert_flag_list") caml_convert_flag_list
+-
+-/* **** array.c */
+-
+-/* **** backtrace.c */
+-#define backtrace_active CAML_DEPRECATED("backtrace_active", "caml_backtrace_active") caml_backtrace_active
+-#define backtrace_pos CAML_DEPRECATED("backtrace_pos", "caml_backtrace_pos") caml_backtrace_pos
+-#define backtrace_buffer CAML_DEPRECATED("backtrace_buffer", "caml_backtrace_buffer") caml_backtrace_buffer
+-#define backtrace_last_exn CAML_DEPRECATED("backtrace_last_exn", "caml_backtrace_last_exn") caml_backtrace_last_exn
+-#define print_exception_backtrace CAML_DEPRECATED("print_exception_backtrace", "caml_print_exception_backtrace") caml_print_exception_backtrace
+-
+-/* **** callback.c */
+-#define callback_depth CAML_DEPRECATED("callback_depth", "caml_callback_depth") caml_callback_depth
+-#define callbackN_exn CAML_DEPRECATED("callbackN_exn", "caml_callbackN_exn") caml_callbackN_exn
+-#define callback_exn CAML_DEPRECATED("callback_exn", "caml_callback_exn") caml_callback_exn
+-#define callback2_exn CAML_DEPRECATED("callback2_exn", "caml_callback2_exn") caml_callback2_exn
+-#define callback3_exn CAML_DEPRECATED("callback3_exn", "caml_callback3_exn") caml_callback3_exn
+-#define callback CAML_DEPRECATED("callback", "caml_callback") caml_callback
+-#define callback2 CAML_DEPRECATED("callback2", "caml_callback2") caml_callback2
+-#define callback3 CAML_DEPRECATED("callback3", "caml_callback3") caml_callback3
+-#define callbackN CAML_DEPRECATED("callbackN", "caml_callbackN") caml_callbackN
+-
+-/* **** compact.c */
+-
+-/* **** compare.c */
+-#define compare_unordered CAML_DEPRECATED("compare_unordered", "caml_compare_unordered") caml_compare_unordered
+-
+-/* **** custom.c */
+-#define alloc_custom CAML_DEPRECATED("alloc_custom", "caml_alloc_custom") caml_alloc_custom
+-#define register_custom_operations CAML_DEPRECATED("register_custom_operations", "caml_register_custom_operations") caml_register_custom_operations
+-
+-/* **** debugger.c */
+-
+-/* **** dynlink.c */
+-
+-/* **** extern.c */
+-#define output_val CAML_DEPRECATED("output_val", "caml_output_val") caml_output_val
+-#define output_value_to_malloc CAML_DEPRECATED("output_value_to_malloc", "caml_output_value_to_malloc") caml_output_value_to_malloc
+-#define output_value_to_block CAML_DEPRECATED("output_value_to_block", "caml_output_value_to_block") caml_output_value_to_block
+-#define serialize_int_1 CAML_DEPRECATED("serialize_int_1", "caml_serialize_int_1") caml_serialize_int_1
+-#define serialize_int_2 CAML_DEPRECATED("serialize_int_2", "caml_serialize_int_2") caml_serialize_int_2
+-#define serialize_int_4 CAML_DEPRECATED("serialize_int_4", "caml_serialize_int_4") caml_serialize_int_4
+-#define serialize_int_8 CAML_DEPRECATED("serialize_int_8", "caml_serialize_int_8") caml_serialize_int_8
+-#define serialize_float_4 CAML_DEPRECATED("serialize_float_4", "caml_serialize_float_4") caml_serialize_float_4
+-#define serialize_float_8 CAML_DEPRECATED("serialize_float_8", "caml_serialize_float_8") caml_serialize_float_8
+-#define serialize_block_1 CAML_DEPRECATED("serialize_block_1", "caml_serialize_block_1") caml_serialize_block_1
+-#define serialize_block_2 CAML_DEPRECATED("serialize_block_2", "caml_serialize_block_2") caml_serialize_block_2
+-#define serialize_block_4 CAML_DEPRECATED("serialize_block_4", "caml_serialize_block_4") caml_serialize_block_4
+-#define serialize_block_8 CAML_DEPRECATED("serialize_block_8", "caml_serialize_block_8") caml_serialize_block_8
+-#define serialize_block_float_8 CAML_DEPRECATED("serialize_block_float_8", "caml_serialize_block_float_8") caml_serialize_block_float_8
+-
+-/* **** fail.c */
+-#define external_raise CAML_DEPRECATED("external_raise", "caml_external_raise") caml_external_raise
+-#define mlraise CAML_DEPRECATED("mlraise", "caml_raise") caml_raise /*SP*/
+-#define raise_constant CAML_DEPRECATED("raise_constant", "caml_raise_constant") caml_raise_constant
+-#define raise_with_arg CAML_DEPRECATED("raise_with_arg", "caml_raise_with_arg") caml_raise_with_arg
+-#define raise_with_string CAML_DEPRECATED("raise_with_string", "caml_raise_with_string") caml_raise_with_string
+-#define failwith CAML_DEPRECATED("failwith", "caml_failwith") caml_failwith
+-#define invalid_argument CAML_DEPRECATED("invalid_argument", "caml_invalid_argument") caml_invalid_argument
+-#define array_bound_error CAML_DEPRECATED("array_bound_error", "caml_array_bound_error") caml_array_bound_error /*SP*/
+-#define raise_out_of_memory CAML_DEPRECATED("raise_out_of_memory", "caml_raise_out_of_memory") caml_raise_out_of_memory
+-#define raise_stack_overflow CAML_DEPRECATED("raise_stack_overflow", "caml_raise_stack_overflow") caml_raise_stack_overflow
+-#define raise_sys_error CAML_DEPRECATED("raise_sys_error", "caml_raise_sys_error") caml_raise_sys_error
+-#define raise_end_of_file CAML_DEPRECATED("raise_end_of_file", "caml_raise_end_of_file") caml_raise_end_of_file
+-#define raise_zero_divide CAML_DEPRECATED("raise_zero_divide", "caml_raise_zero_divide") caml_raise_zero_divide
+-#define raise_not_found CAML_DEPRECATED("raise_not_found", "caml_raise_not_found") caml_raise_not_found
+-#define raise_sys_blocked_io CAML_DEPRECATED("raise_sys_blocked_io", "caml_raise_sys_blocked_io") caml_raise_sys_blocked_io
+-/* **** runtime/fail_nat.c */
+-/* **** runtime/<arch>.s */
+-
+-/* **** finalise.c */
+-
+-/* **** fix_code.c */
+-
+-/* **** floats.c */
+-/*#define Double_val caml_Double_val             done in mlvalues.h as needed */
+-/*#define Store_double_val caml_Store_double_val done in mlvalues.h as needed */
+-#define copy_double CAML_DEPRECATED("copy_double", "caml_copy_double") caml_copy_double
+-
+-/* **** freelist.c */
+-
+-/* **** gc_ctrl.c */
+-
+-/* **** globroots.c */
+-#define register_global_root CAML_DEPRECATED("register_global_root", "caml_register_global_root") caml_register_global_root
+-#define remove_global_root CAML_DEPRECATED("remove_global_root", "caml_remove_global_root") caml_remove_global_root
+-
+-/* **** hash.c */
+-#define hash_variant CAML_DEPRECATED("hash_variant", "caml_hash_variant") caml_hash_variant
+-
+-/* **** instrtrace.c */
+-
+-/* **** intern.c */
+-#define input_val CAML_DEPRECATED("input_val", "caml_input_val") caml_input_val
+-#define input_val_from_string CAML_DEPRECATED("input_val_from_string", "caml_input_val_from_string") caml_input_val_from_string
+-#define input_value_from_malloc CAML_DEPRECATED("input_value_from_malloc", "caml_input_value_from_malloc") caml_input_value_from_malloc
+-#define input_value_from_block CAML_DEPRECATED("input_value_from_block", "caml_input_value_from_block") caml_input_value_from_block
+-#define deserialize_uint_1 CAML_DEPRECATED("deserialize_uint_1", "caml_deserialize_uint_1") caml_deserialize_uint_1
+-#define deserialize_sint_1 CAML_DEPRECATED("deserialize_sint_1", "caml_deserialize_sint_1") caml_deserialize_sint_1
+-#define deserialize_uint_2 CAML_DEPRECATED("deserialize_uint_2", "caml_deserialize_uint_2") caml_deserialize_uint_2
+-#define deserialize_sint_2 CAML_DEPRECATED("deserialize_sint_2", "caml_deserialize_sint_2") caml_deserialize_sint_2
+-#define deserialize_uint_4 CAML_DEPRECATED("deserialize_uint_4", "caml_deserialize_uint_4") caml_deserialize_uint_4
+-#define deserialize_sint_4 CAML_DEPRECATED("deserialize_sint_4", "caml_deserialize_sint_4") caml_deserialize_sint_4
+-#define deserialize_uint_8 CAML_DEPRECATED("deserialize_uint_8", "caml_deserialize_uint_8") caml_deserialize_uint_8
+-#define deserialize_sint_8 CAML_DEPRECATED("deserialize_sint_8", "caml_deserialize_sint_8") caml_deserialize_sint_8
+-#define deserialize_float_4 CAML_DEPRECATED("deserialize_float_4", "caml_deserialize_float_4") caml_deserialize_float_4
+-#define deserialize_float_8 CAML_DEPRECATED("deserialize_float_8", "caml_deserialize_float_8") caml_deserialize_float_8
+-#define deserialize_block_1 CAML_DEPRECATED("deserialize_block_1", "caml_deserialize_block_1") caml_deserialize_block_1
+-#define deserialize_block_2 CAML_DEPRECATED("deserialize_block_2", "caml_deserialize_block_2") caml_deserialize_block_2
+-#define deserialize_block_4 CAML_DEPRECATED("deserialize_block_4", "caml_deserialize_block_4") caml_deserialize_block_4
+-#define deserialize_block_8 CAML_DEPRECATED("deserialize_block_8", "caml_deserialize_block_8") caml_deserialize_block_8
+-#define deserialize_block_float_8 CAML_DEPRECATED("deserialize_block_float_8", "caml_deserialize_block_float_8") caml_deserialize_block_float_8
+-#define deserialize_error CAML_DEPRECATED("deserialize_error", "caml_deserialize_error") caml_deserialize_error
+-
+-/* **** interp.c */
+-
+-/* **** ints.c */
+-#define int32_ops CAML_DEPRECATED("int32_ops", "caml_int32_ops") caml_int32_ops
+-#define copy_int32 CAML_DEPRECATED("copy_int32", "caml_copy_int32") caml_copy_int32
+-/*#define Int64_val caml_Int64_val   *** done in mlvalues.h as needed */
+-#define int64_ops CAML_DEPRECATED("int64_ops", "caml_int64_ops") caml_int64_ops
+-#define copy_int64 CAML_DEPRECATED("copy_int64", "caml_copy_int64") caml_copy_int64
+-#define nativeint_ops CAML_DEPRECATED("nativeint_ops", "caml_nativeint_ops") caml_nativeint_ops
+-#define copy_nativeint CAML_DEPRECATED("copy_nativeint", "caml_copy_nativeint") caml_copy_nativeint
+-
+-/* **** io.c */
+-#define channel_mutex_free CAML_DEPRECATED("channel_mutex_free", "caml_channel_mutex_free") caml_channel_mutex_free
+-#define channel_mutex_lock CAML_DEPRECATED("channel_mutex_lock", "caml_channel_mutex_lock") caml_channel_mutex_lock
+-#define channel_mutex_unlock CAML_DEPRECATED("channel_mutex_unlock", "caml_channel_mutex_unlock") caml_channel_mutex_unlock
+-#define channel_mutex_unlock_exn CAML_DEPRECATED("channel_mutex_unlock_exn", "caml_channel_mutex_unlock_exn") caml_channel_mutex_unlock_exn
+-#define all_opened_channels CAML_DEPRECATED("all_opened_channels", "caml_all_opened_channels") caml_all_opened_channels
+-#define open_descriptor_in CAML_DEPRECATED("open_descriptor_in", "caml_open_descriptor_in") caml_open_descriptor_in /*SP*/
+-#define open_descriptor_out CAML_DEPRECATED("open_descriptor_out", "caml_open_descriptor_out") caml_open_descriptor_out /*SP*/
+-#define close_channel CAML_DEPRECATED("close_channel", "caml_close_channel") caml_close_channel /*SP*/
+-#define channel_size CAML_DEPRECATED("channel_size", "caml_channel_size") caml_channel_size /*SP*/
+-#define channel_binary_mode CAML_DEPRECATED("channel_binary_mode", "caml_channel_binary_mode") caml_channel_binary_mode
+-#define flush_partial CAML_DEPRECATED("flush_partial", "caml_flush_partial") caml_flush_partial /*SP*/
+-#define flush CAML_DEPRECATED("flush", "caml_flush") caml_flush /*SP*/
+-#define putword CAML_DEPRECATED("putword", "caml_putword") caml_putword
+-#define putblock CAML_DEPRECATED("putblock", "caml_putblock") caml_putblock
+-#define really_putblock CAML_DEPRECATED("really_putblock", "caml_really_putblock") caml_really_putblock
+-#define seek_out CAML_DEPRECATED("seek_out", "caml_seek_out") caml_seek_out /*SP*/
+-#define pos_out CAML_DEPRECATED("pos_out", "caml_pos_out") caml_pos_out /*SP*/
+-#define do_read CAML_DEPRECATED("do_read", "caml_do_read") caml_do_read
+-#define refill CAML_DEPRECATED("refill", "caml_refill") caml_refill
+-#define getword CAML_DEPRECATED("getword", "caml_getword") caml_getword
+-#define getblock CAML_DEPRECATED("getblock", "caml_getblock") caml_getblock
+-#define really_getblock CAML_DEPRECATED("really_getblock", "caml_really_getblock") caml_really_getblock
+-#define seek_in CAML_DEPRECATED("seek_in", "caml_seek_in") caml_seek_in /*SP*/
+-#define pos_in CAML_DEPRECATED("pos_in", "caml_pos_in") caml_pos_in /*SP*/
+-#define input_scan_line CAML_DEPRECATED("input_scan_line", "caml_input_scan_line") caml_input_scan_line /*SP*/
+-#define finalize_channel CAML_DEPRECATED("finalize_channel", "caml_finalize_channel") caml_finalize_channel
+-#define alloc_channel CAML_DEPRECATED("alloc_channel", "caml_alloc_channel") caml_alloc_channel
+-/*#define Val_file_offset caml_Val_file_offset   *** done in io.h as needed */
+-/*#define File_offset_val caml_File_offset_val   *** done in io.h as needed */
+-
+-/* **** lexing.c */
+-
+-/* **** main.c */
+-/* *** no change */
+-
+-/* **** major_gc.c */
+-#define heap_start CAML_DEPRECATED("heap_start", "caml_heap_start") caml_heap_start
+-#define page_table CAML_DEPRECATED("page_table", "caml_page_table") caml_page_table
+-
+-/* **** md5.c */
+-#define md5_string CAML_DEPRECATED("md5_string", "caml_md5_string") caml_md5_string
+-#define md5_chan CAML_DEPRECATED("md5_chan", "caml_md5_chan") caml_md5_chan
+-#define MD5Init CAML_DEPRECATED("MD5Init", "caml_MD5Init") caml_MD5Init
+-#define MD5Update CAML_DEPRECATED("MD5Update", "caml_MD5Update") caml_MD5Update
+-#define MD5Final CAML_DEPRECATED("MD5Final", "caml_MD5Final") caml_MD5Final
+-#define MD5Transform CAML_DEPRECATED("MD5Transform", "caml_MD5Transform") caml_MD5Transform
+-
+-/* **** memory.c */
+-#define alloc_shr CAML_DEPRECATED("alloc_shr", "caml_alloc_shr") caml_alloc_shr
+-#define initialize CAML_DEPRECATED("initialize", "caml_initialize") caml_initialize
+-#define modify CAML_DEPRECATED("modify", "caml_modify") caml_modify
+-#define stat_alloc CAML_DEPRECATED("stat_alloc", "caml_stat_alloc") caml_stat_alloc
+-#define stat_free CAML_DEPRECATED("stat_free", "caml_stat_free") caml_stat_free
+-#define stat_resize CAML_DEPRECATED("stat_resize", "caml_stat_resize") caml_stat_resize
+-
+-/* **** meta.c */
+-
+-/* **** minor_gc.c */
+-#define young_start CAML_DEPRECATED("young_start", "caml_young_start") caml_young_start
+-#define young_end CAML_DEPRECATED("young_end", "caml_young_end") caml_young_end
+-#define young_ptr CAML_DEPRECATED("young_ptr", "caml_young_ptr") caml_young_ptr
+-#define young_limit CAML_DEPRECATED("young_limit", "caml_young_limit") caml_young_limit
+-#define ref_table CAML_DEPRECATED("ref_table", "caml_ref_table") caml_ref_table
+-#define minor_collection CAML_DEPRECATED("minor_collection", "caml_minor_collection") caml_minor_collection
+-#define check_urgent_gc CAML_DEPRECATED("check_urgent_gc", "caml_check_urgent_gc") caml_check_urgent_gc
+-
+-/* **** misc.c */
+-
+-/* **** obj.c */
+-
+-/* **** parsing.c */
+-
+-/* **** prims.c */
+-
+-/* **** printexc.c */
+-#define format_caml_exception CAML_DEPRECATED("format_caml_exception", "caml_format_exception") caml_format_exception /*SP*/
+-
+-/* **** roots.c */
+-#define local_roots CAML_DEPRECATED("local_roots", "caml_local_roots") caml_local_roots
+-#define scan_roots_hook CAML_DEPRECATED("scan_roots_hook", "caml_scan_roots_hook") caml_scan_roots_hook
+-#define do_local_roots CAML_DEPRECATED("do_local_roots", "caml_do_local_roots") caml_do_local_roots
+-
+-/* **** signals.c */
+-#define pending_signals CAML_DEPRECATED("pending_signals", "caml_pending_signals") caml_pending_signals
+-#define something_to_do CAML_DEPRECATED("something_to_do", "caml_something_to_do") caml_something_to_do
+-#define enter_blocking_section_hook CAML_DEPRECATED("enter_blocking_section_hook", "caml_enter_blocking_section_hook") caml_enter_blocking_section_hook
+-#define leave_blocking_section_hook CAML_DEPRECATED("leave_blocking_section_hook", "caml_leave_blocking_section_hook") caml_leave_blocking_section_hook
+-#define enter_blocking_section CAML_DEPRECATED("enter_blocking_section", "caml_enter_blocking_section") caml_enter_blocking_section
+-#define leave_blocking_section CAML_DEPRECATED("leave_blocking_section", "caml_leave_blocking_section") caml_leave_blocking_section
+-#define convert_signal_number CAML_DEPRECATED("convert_signal_number", "caml_convert_signal_number") caml_convert_signal_number
+-
+-/* **** runtime/signals.c */
+-#define garbage_collection CAML_DEPRECATED("garbage_collection", "caml_garbage_collection") caml_garbage_collection
+-
+-/* **** stacks.c */
+-#define stack_low CAML_DEPRECATED("stack_low", "caml_stack_low") caml_stack_low
+-#define stack_high CAML_DEPRECATED("stack_high", "caml_stack_high") caml_stack_high
+-#define stack_threshold CAML_DEPRECATED("stack_threshold", "caml_stack_threshold") caml_stack_threshold
+-#define extern_sp CAML_DEPRECATED("extern_sp", "caml_extern_sp") caml_extern_sp
+-#define trapsp CAML_DEPRECATED("trapsp", "caml_trapsp") caml_trapsp
+-#define trap_barrier CAML_DEPRECATED("trap_barrier", "caml_trap_barrier") caml_trap_barrier
+-
+-/* **** startup.c */
+-#define atom_table CAML_DEPRECATED("atom_table", "caml_atom_table") caml_atom_table
+-/* **** runtime/startup_nat.c */
+-#define static_data_start CAML_DEPRECATED("static_data_start", "caml_static_data_start") caml_static_data_start
+-#define static_data_end CAML_DEPRECATED("static_data_end", "caml_static_data_end") caml_static_data_end
+-
+-/* **** str.c */
+-#define string_length CAML_DEPRECATED("string_length", "caml_string_length") caml_string_length
+-
+-/* **** sys.c */
+-#define sys_error CAML_DEPRECATED("sys_error", "caml_sys_error") caml_sys_error
+-
+-/* **** terminfo.c */
+-
+-/* **** unix.c  &  win32.c */
+-#define search_exe_in_path CAML_DEPRECATED("search_exe_in_path", "caml_search_exe_in_path") caml_search_exe_in_path
+-
+-/* **** weak.c */
+-
+-/* **** asmcomp/asmlink.ml */
+-
+-/* **** asmcomp/cmmgen.ml */
+-
+-/* **** asmcomp/asmlink.ml, asmcomp/cmmgen.ml, asmcomp/compilenv.ml */
+-
+-/* ************************************************************* */
+-
+-/* **** otherlibs/bigarray */
+-#define int8 caml_ba_int8
+-#define uint8 caml_ba_uint8
+-#define int16 caml_ba_int16
+-#define uint16 caml_ba_uint16
+-#define MAX_NUM_DIMS CAML_DEPRECATED("MAX_NUM_DIMS", "CAML_BA_MAX_NUM_DIMS") CAML_BA_MAX_NUM_DIMS
+-#define caml_bigarray_kind CAML_DEPRECATED("caml_bigarray_kind", "caml_ba_kind") caml_ba_kind
+-#define BIGARRAY_FLOAT32 CAML_DEPRECATED("BIGARRAY_FLOAT32", "CAML_BA_FLOAT32") CAML_BA_FLOAT32
+-#define BIGARRAY_FLOAT64 CAML_DEPRECATED("BIGARRAY_FLOAT64", "CAML_BA_FLOAT64") CAML_BA_FLOAT64
+-#define BIGARRAY_SINT8 CAML_DEPRECATED("BIGARRAY_SINT8", "CAML_BA_SINT8") CAML_BA_SINT8
+-#define BIGARRAY_UINT8 CAML_DEPRECATED("BIGARRAY_UINT8", "CAML_BA_UINT8") CAML_BA_UINT8
+-#define BIGARRAY_SINT16 CAML_DEPRECATED("BIGARRAY_SINT16", "CAML_BA_SINT16") CAML_BA_SINT16
+-#define BIGARRAY_UINT16 CAML_DEPRECATED("BIGARRAY_UINT16", "CAML_BA_UINT16") CAML_BA_UINT16
+-#define BIGARRAY_INT32 CAML_DEPRECATED("BIGARRAY_INT32", "CAML_BA_INT32") CAML_BA_INT32
+-#define BIGARRAY_INT64 CAML_DEPRECATED("BIGARRAY_INT64", "CAML_BA_INT64") CAML_BA_INT64
+-#define BIGARRAY_CAML_INT CAML_DEPRECATED("BIGARRAY_CAML_INT", "CAML_BA_CAML_INT") CAML_BA_CAML_INT
+-#define BIGARRAY_NATIVE_INT CAML_DEPRECATED("BIGARRAY_NATIVE_INT", "CAML_BA_NATIVE_INT") CAML_BA_NATIVE_INT
+-#define BIGARRAY_COMPLEX32 CAML_DEPRECATED("BIGARRAY_COMPLEX32", "CAML_BA_COMPLEX32") CAML_BA_COMPLEX32
+-#define BIGARRAY_COMPLEX64 CAML_DEPRECATED("BIGARRAY_COMPLEX64", "CAML_BA_COMPLEX64") CAML_BA_COMPLEX64
+-#define BIGARRAY_KIND_MASK CAML_DEPRECATED("BIGARRAY_KIND_MASK", "CAML_BA_KIND_MASK") CAML_BA_KIND_MASK
+-#define caml_bigarray_layout CAML_DEPRECATED("caml_bigarray_layout", "caml_ba_layout") caml_ba_layout
+-#define BIGARRAY_C_LAYOUT CAML_DEPRECATED("BIGARRAY_C_LAYOUT", "CAML_BA_C_LAYOUT") CAML_BA_C_LAYOUT
+-#define BIGARRAY_FORTRAN_LAYOUT CAML_DEPRECATED("BIGARRAY_FORTRAN_LAYOUT", "CAML_BA_FORTRAN_LAYOUT") CAML_BA_FORTRAN_LAYOUT
+-#define BIGARRAY_LAYOUT_MASK CAML_DEPRECATED("BIGARRAY_LAYOUT_MASK", "CAML_BA_LAYOUT_MASK") CAML_BA_LAYOUT_MASK
+-#define caml_bigarray_managed CAML_DEPRECATED("caml_bigarray_managed", "caml_ba_managed") caml_ba_managed
+-#define BIGARRAY_EXTERNAL CAML_DEPRECATED("BIGARRAY_EXTERNAL", "CAML_BA_EXTERNAL") CAML_BA_EXTERNAL
+-#define BIGARRAY_MANAGED CAML_DEPRECATED("BIGARRAY_MANAGED", "CAML_BA_MANAGED") CAML_BA_MANAGED
+-#define BIGARRAY_MAPPED_FILE CAML_DEPRECATED("BIGARRAY_MAPPED_FILE", "CAML_BA_MAPPED_FILE") CAML_BA_MAPPED_FILE
+-#define BIGARRAY_MANAGED_MASK CAML_DEPRECATED("BIGARRAY_MANAGED_MASK", "CAML_BA_MANAGED_MASK") CAML_BA_MANAGED_MASK
+-#define caml_bigarray_proxy CAML_DEPRECATED("caml_bigarray_proxy", "caml_ba_proxy") caml_ba_proxy
+-#define caml_bigarray CAML_DEPRECATED("caml_bigarray", "caml_ba_array") caml_ba_array
+-#define Bigarray_val CAML_DEPRECATED("Bigarray_val", "Caml_ba_array_val") Caml_ba_array_val
+-#define Data_bigarray_val CAML_DEPRECATED("Data_bigarray_val", "Caml_ba_data_val") Caml_ba_data_val
+-#define alloc_bigarray CAML_DEPRECATED("alloc_bigarray", "caml_ba_alloc") caml_ba_alloc
+-#define alloc_bigarray_dims CAML_DEPRECATED("alloc_bigarray_dims", "caml_ba_alloc_dims") caml_ba_alloc_dims
+-#define bigarray_map_file CAML_DEPRECATED("bigarray_map_file", "caml_ba_map_file") caml_ba_map_file
+-#define bigarray_unmap_file CAML_DEPRECATED("bigarray_unmap_file", "caml_ba_unmap_file") caml_ba_unmap_file
+-#define bigarray_element_size CAML_DEPRECATED("bigarray_element_size", "caml_ba_element_size") caml_ba_element_size
+-#define bigarray_byte_size CAML_DEPRECATED("bigarray_byte_size", "caml_ba_byte_size") caml_ba_byte_size
+-#define bigarray_deserialize CAML_DEPRECATED("bigarray_deserialize", "caml_ba_deserialize") caml_ba_deserialize
+-#define MAX_BIGARRAY_MEMORY CAML_DEPRECATED("MAX_BIGARRAY_MEMORY", "CAML_BA_MAX_MEMORY") CAML_BA_MAX_MEMORY
+-#define bigarray_create CAML_DEPRECATED("bigarray_create", "caml_ba_create") caml_ba_create
+-#define bigarray_get_N CAML_DEPRECATED("bigarray_get_N", "caml_ba_get_N") caml_ba_get_N
+-#define bigarray_get_1 CAML_DEPRECATED("bigarray_get_1", "caml_ba_get_1") caml_ba_get_1
+-#define bigarray_get_2 CAML_DEPRECATED("bigarray_get_2", "caml_ba_get_2") caml_ba_get_2
+-#define bigarray_get_3 CAML_DEPRECATED("bigarray_get_3", "caml_ba_get_3") caml_ba_get_3
+-#define bigarray_get_generic CAML_DEPRECATED("bigarray_get_generic", "caml_ba_get_generic") caml_ba_get_generic
+-#define bigarray_set_1 CAML_DEPRECATED("bigarray_set_1", "caml_ba_set_1") caml_ba_set_1
+-#define bigarray_set_2 CAML_DEPRECATED("bigarray_set_2", "caml_ba_set_2") caml_ba_set_2
+-#define bigarray_set_3 CAML_DEPRECATED("bigarray_set_3", "caml_ba_set_3") caml_ba_set_3
+-#define bigarray_set_N CAML_DEPRECATED("bigarray_set_N", "caml_ba_set_N") caml_ba_set_N
+-#define bigarray_set_generic CAML_DEPRECATED("bigarray_set_generic", "caml_ba_set_generic") caml_ba_set_generic
+-#define bigarray_num_dims CAML_DEPRECATED("bigarray_num_dims", "caml_ba_num_dims") caml_ba_num_dims
+-#define bigarray_dim CAML_DEPRECATED("bigarray_dim", "caml_ba_dim") caml_ba_dim
+-#define bigarray_kind CAML_DEPRECATED("bigarray_kind", "caml_ba_kind") caml_ba_kind
+-#define bigarray_layout CAML_DEPRECATED("bigarray_layout", "caml_ba_layout") caml_ba_layout
+-#define bigarray_slice CAML_DEPRECATED("bigarray_slice", "caml_ba_slice") caml_ba_slice
+-#define bigarray_sub CAML_DEPRECATED("bigarray_sub", "caml_ba_sub") caml_ba_sub
+-#define bigarray_blit CAML_DEPRECATED("bigarray_blit", "caml_ba_blit") caml_ba_blit
+-#define bigarray_fill CAML_DEPRECATED("bigarray_fill", "caml_ba_fill") caml_ba_fill
+-#define bigarray_reshape CAML_DEPRECATED("bigarray_reshape", "caml_ba_reshape") caml_ba_reshape
+-#define bigarray_init CAML_DEPRECATED("bigarray_init", "caml_ba_init") caml_ba_init
+-
+-#endif /* CAML_NAME_SPACE */
+-#endif /* CAML_COMPATIBILITY_H */
+diff --git a/runtime/caml/config.h b/runtime/caml/config.h
+index 471a6bc6f4..a7e56be8d9 100644
+--- a/runtime/caml/config.h
++++ b/runtime/caml/config.h
+@@ -16,6 +16,15 @@
+ #ifndef CAML_CONFIG_H
+ #define CAML_CONFIG_H
+ 
++/* CAML_NAME_SPACE was introduced in OCaml 3.08 to declare compatibility with
++   the newly caml_-prefixed names of C runtime functions and to disable the
++   definition of compatibility macros for the un-prefixed names. The
++   compatibility layer was removed in OCaml 5.00, so CAML_NAME_SPACE is the
++   default. */
++#ifndef CAML_NAME_SPACE
++#define CAML_NAME_SPACE
++#endif
++
+ #include "m.h"
+ 
+ /* If supported, tell gcc that we can use 32-bit code addresses for
+@@ -41,10 +50,6 @@
+ 
+ #include "s.h"
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+-
+ #ifndef CAML_CONFIG_H_NO_TYPEDEFS
+ 
+ #include <stddef.h>
+diff --git a/runtime/caml/custom.h b/runtime/caml/custom.h
+index 420121f43e..231019aef7 100644
+--- a/runtime/caml/custom.h
++++ b/runtime/caml/custom.h
+@@ -17,9 +17,6 @@
+ #define CAML_CUSTOM_H
+ 
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "mlvalues.h"
+ 
+ struct custom_fixed_length {
+diff --git a/runtime/caml/domain_state.h b/runtime/caml/domain_state.h
+index 84e677d041..2ee932459a 100644
+--- a/runtime/caml/domain_state.h
++++ b/runtime/caml/domain_state.h
+@@ -29,11 +29,7 @@ typedef value extra_params_area[NUM_EXTRA_PARAMS];
+  * via native code, which is why the indices are important */
+ 
+ typedef struct {
+-#ifdef CAML_NAME_SPACE
+ #define DOMAIN_STATE(type, name) CAMLalign(8) type name;
+-#else
+-#define DOMAIN_STATE(type, name) CAMLalign(8) type _##name;
+-#endif
+ #include "domain_state.tbl"
+ #undef DOMAIN_STATE
+ } caml_domain_state;
+@@ -45,11 +41,7 @@ enum {
+ #undef DOMAIN_STATE
+ };
+ 
+-#ifdef CAML_NAME_SPACE
+ #define LAST_DOMAIN_STATE_MEMBER extra_params
+-#else
+-#define LAST_DOMAIN_STATE_MEMBER _extra_params
+-#endif
+ 
+ /* Check that the structure was laid out without padding,
+    since the runtime assumes this in computing offsets */
+@@ -57,11 +49,8 @@ CAML_STATIC_ASSERT(
+     offsetof(caml_domain_state, LAST_DOMAIN_STATE_MEMBER) ==
+     (Domain_state_num_fields - 1) * 8);
+ 
+-CAMLextern caml_domain_state* Caml_state;
+-#ifdef CAML_NAME_SPACE
++CAMLextern caml_domain_state* caml_state;
++#define Caml_state caml_state
+ #define Caml_state_field(field) Caml_state->field
+-#else
+-#define Caml_state_field(field) Caml_state->_##field
+-#endif
+ 
+ #endif /* CAML_STATE_H */
+diff --git a/runtime/caml/fail.h b/runtime/caml/fail.h
+index 822c603260..887ef9c227 100644
+--- a/runtime/caml/fail.h
++++ b/runtime/caml/fail.h
+@@ -20,9 +20,6 @@
+ #include <setjmp.h>
+ #endif /* CAML_INTERNALS */
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "misc.h"
+ #include "mlvalues.h"
+ 
+diff --git a/runtime/caml/fix_code.h b/runtime/caml/fix_code.h
+index 2eafaa814b..83c393a17d 100644
+--- a/runtime/caml/fix_code.h
++++ b/runtime/caml/fix_code.h
+@@ -34,7 +34,8 @@ void caml_set_instruction (code_t pos, opcode_t instr);
+ int caml_is_instruction (opcode_t instr1, opcode_t instr2);
+ 
+ #ifdef THREADED_CODE
+-void caml_init_thread_code(void ** instr_table, void * instr_base);
++extern char ** caml_instr_table;
++extern char * caml_instr_base;
+ void caml_thread_code (code_t code, asize_t len);
+ #endif
+ 
+diff --git a/runtime/caml/intext.h b/runtime/caml/intext.h
+index a2a3fb8248..b68030aad8 100644
+--- a/runtime/caml/intext.h
++++ b/runtime/caml/intext.h
+@@ -18,9 +18,6 @@
+ #ifndef CAML_INTEXT_H
+ #define CAML_INTEXT_H
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "misc.h"
+ #include "mlvalues.h"
+ 
+diff --git a/runtime/caml/m.h.in b/runtime/caml/m.h.in
+index 1c3dee1779..ba0074318d 100644
+--- a/runtime/caml/m.h.in
++++ b/runtime/caml/m.h.in
+@@ -90,7 +90,7 @@
+ 
+ #undef CAML_WITH_FPIC
+ 
+-#undef CAML_SAFE_STRING
++#define CAML_SAFE_STRING 1
+ 
+ #undef FLAT_FLOAT_ARRAY
+ 
+diff --git a/runtime/caml/memory.h b/runtime/caml/memory.h
+index d9e58bc2d0..8837d33d25 100644
+--- a/runtime/caml/memory.h
++++ b/runtime/caml/memory.h
+@@ -18,9 +18,6 @@
+ #ifndef CAML_MEMORY_H
+ #define CAML_MEMORY_H
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "config.h"
+ #ifdef CAML_INTERNALS
+ #include "gc.h"
+@@ -329,7 +326,7 @@ struct caml__roots_block {
+   #define CAMLunused_start __attribute__ ((unused))
+   #define CAMLunused_end
+   #define CAMLunused __attribute__ ((unused))
+-#elif defined(_MSC_VER) && _MSC_VER >= 1500
++#elif _MSC_VER >= 1500
+   #define CAMLunused_start  __pragma( warning (push) )           \
+     __pragma( warning (disable:4189 ) )
+   #define CAMLunused_end __pragma( warning (pop))
+diff --git a/runtime/caml/misc.h b/runtime/caml/misc.h
+index c605f8711e..b97d20c2bd 100644
+--- a/runtime/caml/misc.h
++++ b/runtime/caml/misc.h
+@@ -18,9 +18,6 @@
+ #ifndef CAML_MISC_H
+ #define CAML_MISC_H
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "config.h"
+ 
+ /* Standard definitions */
+@@ -29,13 +26,15 @@
+ #include <stdlib.h>
+ #include <stdarg.h>
+ 
++#include "camlatomic.h"
++
+ /* Deprecation warnings */
+ 
+ #if defined(__GNUC__) || defined(__clang__)
+   /* Supported since at least GCC 3.1 */
+   #define CAMLdeprecated_typedef(name, type) \
+     typedef type name __attribute ((deprecated))
+-#elif defined(_MSC_VER) && _MSC_VER >= 1310
++#elif _MSC_VER >= 1310
+   /* NB deprecated("message") only supported from _MSC_VER >= 1400 */
+   #define CAMLdeprecated_typedef(name, type) \
+     typedef __declspec(deprecated) type name
+@@ -43,8 +42,7 @@
+   #define CAMLdeprecated_typedef(name, type) typedef type name
+ #endif
+ 
+-#if defined(__GNUC__) && __STDC_VERSION__ >= 199901L \
+- || defined(_MSC_VER) && _MSC_VER >= 1925
++#if defined(__GNUC__) && __STDC_VERSION__ >= 199901L || _MSC_VER >= 1925
+ 
+ #define CAML_STRINGIFY(x) #x
+ #ifdef _MSC_VER
+@@ -91,7 +89,7 @@ CAMLdeprecated_typedef(addr, char *);
+   #define CAMLnoreturn_start
+   #define CAMLnoreturn_end __attribute__ ((noreturn))
+   #define Noreturn __attribute__ ((noreturn))
+-#elif defined(_MSC_VER) && _MSC_VER >= 1500
++#elif _MSC_VER >= 1500
+   #define CAMLnoreturn_start __declspec(noreturn)
+   #define CAMLnoreturn_end
+   #define Noreturn
+@@ -139,12 +137,11 @@ CAMLdeprecated_typedef(addr, char *);
+ /* we need to be able to compute the exact offset of each member. */
+ #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
+ #define CAMLalign(n) _Alignas(n)
+-#elif defined(__cplusplus) \
+-   && (__cplusplus >= 201103L || defined(_MSC_VER) && _MSC_VER >= 1900)
++#elif defined(__cplusplus) && (__cplusplus >= 201103L || _MSC_VER >= 1900)
+ #define CAMLalign(n) alignas(n)
+ #elif defined(SUPPORTS_ALIGNED_ATTRIBUTE)
+ #define CAMLalign(n) __attribute__((aligned(n)))
+-#elif defined(_MSC_VER) && _MSC_VER >= 1500
++#elif _MSC_VER >= 1500
+ #define CAMLalign(n) __declspec(align(n))
+ #else
+ #error "How do I align values on this platform?"
+@@ -172,7 +169,7 @@ CAMLdeprecated_typedef(addr, char *);
+   #define CAMLunused_start __attribute__ ((unused))
+   #define CAMLunused_end
+   #define CAMLunused __attribute__ ((unused))
+-#elif defined(_MSC_VER) && _MSC_VER >= 1500
++#elif _MSC_VER >= 1500
+   #define CAMLunused_start  __pragma( warning (push) )           \
+     __pragma( warning (disable:4189 ) )
+   #define CAMLunused_end __pragma( warning (pop))
+diff --git a/runtime/caml/mlvalues.h b/runtime/caml/mlvalues.h
+index 677e44e183..00143e5ea0 100644
+--- a/runtime/caml/mlvalues.h
++++ b/runtime/caml/mlvalues.h
+@@ -16,9 +16,6 @@
+ #ifndef CAML_MLVALUES_H
+ #define CAML_MLVALUES_H
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "config.h"
+ #include "misc.h"
+ 
+@@ -286,11 +283,7 @@ CAMLextern value caml_hash_variant(char const * tag);
+ 
+ /* Strings. */
+ #define String_tag 252
+-#ifdef CAML_SAFE_STRING
+ #define String_val(x) ((const char *) Bp_val(x))
+-#else
+-#define String_val(x) ((char *) Bp_val(x))
+-#endif
+ #define Bytes_val(x) ((unsigned char *) Bp_val(x))
+ CAMLextern mlsize_t caml_string_length (value);   /* size in bytes */
+ CAMLextern int caml_string_is_c_safe (value);
+diff --git a/runtime/caml/s.h.in b/runtime/caml/s.h.in
+index 8e4efdcc72..9a5d9f4a91 100644
+--- a/runtime/caml/s.h.in
++++ b/runtime/caml/s.h.in
+@@ -60,6 +60,8 @@
+ /* Define HAS_WORKING_ROUND is the round function is correctly implemented. This
+    hatch exists primarily for https://sourceforge.net/p/mingw-w64/bugs/573/ */
+ 
++#undef HAS_GETENTROPY
++
+ #undef HAS_GETRUSAGE
+ 
+ #undef HAS_TIMES
+@@ -70,6 +72,8 @@
+ 
+ #undef HAS_ISSETUGID
+ 
++#undef HAS_STDATOMIC_H
++
+ /* 2. For the Unix library. */
+ 
+ #undef HAS_SOCKETS
+diff --git a/runtime/caml/signals.h b/runtime/caml/signals.h
+index 62b0e7fafa..3a3b86911c 100644
+--- a/runtime/caml/signals.h
++++ b/runtime/caml/signals.h
+@@ -20,9 +20,6 @@
+ #include<signal.h>
+ #endif
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "misc.h"
+ #include "mlvalues.h"
+ 
+@@ -87,8 +84,8 @@ value caml_do_pending_actions_exn (void);
+ value caml_process_pending_actions_with_root (value extra_root); // raises
+ value caml_process_pending_actions_with_root_exn (value extra_root);
+ int caml_set_signal_action(int signo, int action);
+-CAMLextern void * caml_setup_stack_overflow_detection(void);
+-CAMLextern int caml_stop_stack_overflow_detection(void *);
++CAMLextern int caml_setup_stack_overflow_detection(void);
++CAMLextern int caml_stop_stack_overflow_detection(void);
+ CAMLextern void caml_init_signals(void);
+ CAMLextern void caml_terminate_signals(void);
+ CAMLextern void (*caml_enter_blocking_section_hook)(void);
+diff --git a/runtime/caml/sys.h b/runtime/caml/sys.h
+index 75b97818c1..3b2d537ac4 100644
+--- a/runtime/caml/sys.h
++++ b/runtime/caml/sys.h
+@@ -24,6 +24,8 @@
+ extern "C" {
+ #endif
+ 
++CAMLextern char * caml_strerror(int errnum, char * buf, size_t buflen);
++
+ #define NO_ARG Val_int(0)
+ 
+ CAMLnoreturn_start
+diff --git a/runtime/debugger.c b/runtime/debugger.c
+index 97d22832a0..c10c7d0f8f 100644
+--- a/runtime/debugger.c
++++ b/runtime/debugger.c
+@@ -30,6 +30,7 @@
+ #include "caml/misc.h"
+ #include "caml/osdeps.h"
+ #include "caml/skiplist.h"
++#include "caml/sys.h"
+ 
+ int caml_debugger_in_use = 0;
+ uintnat caml_event_count;
+@@ -110,6 +111,7 @@ static struct skiplist event_points_table = SKIPLIST_STATIC_INITIALIZER;
+ 
+ static void open_connection(void)
+ {
++  char buf[1024];
+ #ifdef _WIN32
+   /* Set socket to synchronous mode (= non-overlapped) so that file
+      descriptor-oriented functions (read()/write() etc.) can be
+@@ -133,7 +135,7 @@ static void open_connection(void)
+     caml_fatal_error("cannot connect to debugger at %s\n"
+                      "error: %s",
+                      (dbg_addr ? dbg_addr : "(none)"),
+-                     strerror (errno));
++                     caml_strerror(errno, buf, sizeof(buf)));
+   dbg_in = caml_open_descriptor_in(dbg_socket);
+   dbg_out = caml_open_descriptor_out(dbg_socket);
+   /* The code in this file does not bracket channel I/O operations with
+diff --git a/runtime/domain.c b/runtime/domain.c
+index d4d8de53fc..a6f0a3028e 100644
+--- a/runtime/domain.c
++++ b/runtime/domain.c
+@@ -19,7 +19,7 @@
+ #include "caml/domain_state.h"
+ #include "caml/memory.h"
+ 
+-CAMLexport caml_domain_state* Caml_state;
++CAMLexport caml_domain_state* caml_state;
+ 
+ void caml_init_domain ()
+ {
+diff --git a/runtime/dune b/runtime/dune
+index 78c39300ed..23eb1d1e8a 100644
+--- a/runtime/dune
++++ b/runtime/dune
+@@ -21,7 +21,7 @@
+      interp.c ints.c io.c
+    lexing.c md5.c meta.c memprof.c obj.c parsing.c signals.c str.c sys.c
+      callback.c weak.c
+-   finalise.c stacks.c dynlink.c backtrace_byt.c backtrace.c
++   finalise.c dynlink.c backtrace_byt.c backtrace.c
+      afl.c
+    bigarray.c eventlog.c)
+  (action  (with-stdout-to %{targets} (run %{dep:gen_primitives.sh}))))
+@@ -36,7 +36,7 @@
+    ../Makefile.common Makefile
+    (glob_files caml/*.h)
+    ; matches the line structure of files in Makefile/BYTECODE_C_SOURCES
+-   interp.c misc.c stacks.c fix_code.c startup_aux.c startup_byt.c freelist.c
++   interp.c misc.c fix_code.c startup_aux.c startup_byt.c freelist.c
+      major_gc.c
+    minor_gc.c memory.c alloc.c roots_byt.c globroots.c fail_byt.c signals.c
+    signals_byt.c printexc.c backtrace_byt.c backtrace.c compare.c ints.c
+diff --git a/runtime/dynlink_nat.c b/runtime/dynlink_nat.c
+index dba30c3848..7eea86f8c0 100644
+--- a/runtime/dynlink_nat.c
++++ b/runtime/dynlink_nat.c
+@@ -118,7 +118,8 @@ CAMLprim value caml_natdynlink_run(value handle_v, value symbol) {
+ 
+   sym = optsym("__code_begin");
+   sym2 = optsym("__code_end");
+-  if (NULL != sym && NULL != sym2)
++  /* Do not register empty code fragments */
++  if (NULL != sym && NULL != sym2 && sym != sym2)
+     caml_register_code_fragment((char *) sym, (char *) sym2,
+                                 DIGEST_LATER, NULL);
+ 
+diff --git a/runtime/fix_code.c b/runtime/fix_code.c
+index 5584019867..aa059be5df 100644
+--- a/runtime/fix_code.c
++++ b/runtime/fix_code.c
+@@ -82,14 +82,8 @@ void caml_fixup_endianness(code_t code, asize_t len)
+ 
+ #ifdef THREADED_CODE
+ 
+-static char ** caml_instr_table;
+-static char * caml_instr_base;
+-
+-void caml_init_thread_code(void ** instr_table, void * instr_base)
+-{
+-  caml_instr_table = (char **) instr_table;
+-  caml_instr_base = (char *) instr_base;
+-}
++char ** caml_instr_table;
++char * caml_instr_base;
+ 
+ static int* opcode_nargs = NULL;
+ int* caml_init_opcode_nargs(void)
+diff --git a/runtime/gen_primitives.sh b/runtime/gen_primitives.sh
+index a727d5c25c..e76b3300b7 100755
+--- a/runtime/gen_primitives.sh
++++ b/runtime/gen_primitives.sh
+@@ -25,7 +25,7 @@ export LC_ALL=C
+       alloc array compare extern floats gc_ctrl hash intern interp ints io \
+       lexing md5 meta memprof obj parsing signals str sys callback weak \
+       finalise stacks dynlink backtrace_byt backtrace afl \
+-      bigarray eventlog
++      bigarray eventlog prng
+   do
+       sed -n -e 's/^CAMLprim value \([a-z0-9_][a-z0-9_]*\).*/\1/p' "$prim.c"
+   done
+diff --git a/runtime/i386.S b/runtime/i386.S
+index 4d273c9f04..06a9cf5fa7 100644
+--- a/runtime/i386.S
++++ b/runtime/i386.S
+@@ -116,7 +116,7 @@ FUNCTION(caml_call_gc)
+         CFI_STARTPROC
+ LBL(caml_call_gc):
+     /* Record lowest stack address and return address */
+-        movl    G(Caml_state), %ebx
++        movl    G(caml_state), %ebx
+         movl    (%esp), %eax
+         movl    %eax, CAML_STATE(last_return_address, %ebx)
+         leal    4(%esp), %eax
+@@ -128,7 +128,7 @@ LBL(caml_call_gc):
+         movl    %eax, 0(%esp)
+         addl    $(STACK_PROBE_SIZE), %esp; CFI_ADJUST(-STACK_PROBE_SIZE);
+ #endif
+-    /* Build array of registers, save it into Caml_state->gc_regs */
++    /* Build array of registers, save it into caml_state->gc_regs */
+         pushl   %ebp; CFI_ADJUST(4)
+         pushl   %edi; CFI_ADJUST(4)
+         pushl   %esi; CFI_ADJUST(4)
+@@ -156,7 +156,7 @@ LBL(caml_call_gc):
+ 
+ FUNCTION(caml_alloc1)
+         CFI_STARTPROC
+-        movl    G(Caml_state), %ebx
++        movl    G(caml_state), %ebx
+         movl    CAML_STATE(young_ptr, %ebx), %eax
+         subl    $8, %eax
+         movl    %eax, CAML_STATE(young_ptr, %ebx)
+@@ -168,7 +168,7 @@ FUNCTION(caml_alloc1)
+ 
+ FUNCTION(caml_alloc2)
+         CFI_STARTPROC
+-        movl    G(Caml_state), %ebx
++        movl    G(caml_state), %ebx
+         movl    CAML_STATE(young_ptr, %ebx), %eax
+         subl    $12, %eax
+         movl    %eax, CAML_STATE(young_ptr, %ebx)
+@@ -180,7 +180,7 @@ FUNCTION(caml_alloc2)
+ 
+ FUNCTION(caml_alloc3)
+         CFI_STARTPROC
+-        movl    G(Caml_state), %ebx
++        movl    G(caml_state), %ebx
+         movl    CAML_STATE(young_ptr, %ebx), %eax
+         subl    $16, %eax
+         movl    %eax, CAML_STATE(young_ptr, %ebx)
+@@ -192,10 +192,10 @@ FUNCTION(caml_alloc3)
+ 
+ FUNCTION(caml_allocN)
+         CFI_STARTPROC
+-        movl    G(Caml_state), %ebx
+-        /* eax = size - Caml_state->young_ptr */
++        movl    G(caml_state), %ebx
++        /* eax = size - caml_state->young_ptr */
+         subl    CAML_STATE(young_ptr, %ebx), %eax
+-        negl    %eax              /* eax = Caml_state->young_ptr - size */
++        negl    %eax              /* eax = caml_state->young_ptr - size */
+         movl    %eax, CAML_STATE(young_ptr, %ebx)
+         cmpl    CAML_STATE(young_limit, %ebx), %eax
+         jb      LBL(caml_call_gc)
+@@ -209,7 +209,7 @@ FUNCTION(caml_c_call)
+         CFI_STARTPROC
+     /* Record lowest stack address and return address */
+     /* ecx and edx are destroyed at C call. Use them as temp. */
+-        movl    G(Caml_state), %ecx
++        movl    G(caml_state), %ecx
+         movl    (%esp), %edx
+         movl    %edx, CAML_STATE(last_return_address, %ecx)
+         leal    4(%esp), %edx
+@@ -239,7 +239,7 @@ FUNCTION(caml_start_program)
+         movl    $ G(caml_program), %esi
+     /* Common code for caml_start_program and caml_callback* */
+ LBL(106):
+-        movl    G(Caml_state), %edi
++        movl    G(caml_state), %edi
+     /* Build a callback link */
+         pushl   CAML_STATE(gc_regs, %edi); CFI_ADJUST(4)
+         pushl   CAML_STATE(last_return_address, %edi); CFI_ADJUST(4)
+@@ -253,12 +253,12 @@ LBL(106):
+     /* Call the OCaml code */
+         call    *%esi
+ LBL(107):
+-        movl    G(Caml_state), %edi
++        movl    G(caml_state), %edi
+     /* Pop the exception handler */
+         popl    CAML_STATE(exception_pointer, %edi); CFI_ADJUST(-4)
+         addl    $12, %esp       ; CFI_ADJUST(-12)
+ LBL(109):
+-        movl    G(Caml_state), %edi /* Reload for LBL(109) entry */
++        movl    G(caml_state), %edi /* Reload for LBL(109) entry */
+     /* Pop the callback link, restoring the global variables */
+         popl    CAML_STATE(bottom_of_stack, %edi); CFI_ADJUST(-4)
+         popl    CAML_STATE(last_return_address, %edi); CFI_ADJUST(-4)
+@@ -282,7 +282,7 @@ LBL(108):
+ 
+ FUNCTION(caml_raise_exn)
+         CFI_STARTPROC
+-        movl    G(Caml_state), %ebx
++        movl    G(caml_state), %ebx
+         testl   $1, CAML_STATE(backtrace_active, %ebx)
+         jne     LBL(110)
+         movl    CAML_STATE(exception_pointer, %ebx), %esp
+@@ -312,7 +312,7 @@ LBL(110):
+ 
+ FUNCTION(caml_raise_exception)
+         CFI_STARTPROC
+-        movl    G(Caml_state), %ebx
++        movl    G(caml_state), %ebx
+         testl   $1, CAML_STATE(backtrace_active, %ebx)
+         jne     LBL(112)
+         movl    8(%esp), %eax
+@@ -405,7 +405,7 @@ FUNCTION(caml_ml_array_bound_error)
+         ffree   %st(6)
+         ffree   %st(7)
+     /* Record lowest stack address and return address */
+-        movl    G(Caml_state), %ebx
++        movl    G(caml_state), %ebx
+         movl    (%esp), %edx
+         movl    %edx, CAML_STATE(last_return_address, %ebx)
+         leal    4(%esp), %edx
+diff --git a/runtime/interp.c b/runtime/interp.c
+index e6700994bc..a59811c87d 100644
+--- a/runtime/interp.c
++++ b/runtime/interp.c
+@@ -50,9 +50,9 @@ sp is a local copy of the global variable Caml_state->extern_sp. */
+ #ifdef THREADED_CODE
+ #  define Instruct(name) lbl_##name
+ #  if defined(ARCH_SIXTYFOUR) && !defined(ARCH_CODE32)
+-#    define Jumptbl_base &&lbl_ACC0
++#    define Jumptbl_base ((char *) &&lbl_ACC0)
+ #  else
+-#    define Jumptbl_base 0
++#    define Jumptbl_base ((char *) 0)
+ #    define jumptbl_base ((char *) 0)
+ #  endif
+ #  ifdef DEBUG
+@@ -249,7 +249,8 @@ value caml_interprete(code_t prog, asize_t prog_size)
+ 
+   if (prog == NULL) {           /* Interpreter is initializing */
+ #ifdef THREADED_CODE
+-    caml_init_thread_code(jumptable, Jumptbl_base);
++    caml_instr_table = (char **) jumptable;
++    caml_instr_base = Jumptbl_base;
+ #endif
+     return Val_unit;
+   }
+diff --git a/runtime/prng.c b/runtime/prng.c
+new file mode 100644
+index 0000000000..4357afbbfb
+--- /dev/null
++++ b/runtime/prng.c
+@@ -0,0 +1,69 @@
++/**************************************************************************/
++/*                                                                        */
++/*                                 OCaml                                  */
++/*                                                                        */
++/*          Xavier Leroy, projet Cambium, College de France and Inria     */
++/*                                                                        */
++/*   Copyright 2021 Institut National de Recherche en Informatique et     */
++/*     en Automatique.                                                    */
++/*                                                                        */
++/*   All rights reserved.  This file is distributed under the terms of    */
++/*   the GNU Lesser General Public License version 2.1, with the          */
++/*   special exception on linking described in the file LICENSE.          */
++/*                                                                        */
++/**************************************************************************/
++
++#include <string.h>
++#include "caml/alloc.h"
++#include "caml/bigarray.h"
++#include "caml/mlvalues.h"
++
++/* The L64X128 member of the LXM family.  Taken from figure 1 in
++   "LXM: Better Splittable Pseudorandom Number Generators
++    (and Almost as Fast)" by Guy L. Steele Jr. and Sebastiano Vigna,
++    OOPSLA 2021.  */
++
++static const uint64_t M = 0xd1342543de82ef95;
++
++struct LXM_state {
++  uint64_t a;            /* per-instance additive parameter (odd) */
++  uint64_t s;            /* state of the LCG subgenerator */
++  uint64_t x[2];         /* state of the XBG subgenerator (not 0) */
++};
++
++/* In OCaml, states are represented as a 1D big array of 64-bit integers */
++
++#define LXM_val(v) ((struct LXM_state *) Caml_ba_data_val(v))
++
++Caml_inline uint64_t rotl(const uint64_t x, int k) {
++  return (x << k) | (x >> (64 - k));
++}
++
++CAMLprim uint64_t caml_lxm_next_unboxed(value v)
++{
++  uint64_t z, q0, q1;
++  struct LXM_state * st = LXM_val(v);
++
++  /* Combining operation */
++  z = st->s + st->x[0];
++  /* Mixing function */
++  z = (z ^ (z >> 32)) * 0xdaba0b6eb09322e3;
++  z = (z ^ (z >> 32)) * 0xdaba0b6eb09322e3;
++  z = (z ^ (z >> 32));
++  /* LCG update */
++  st->s = st->s * M + st->a;
++  /* XBG update */
++  q0 = st->x[0]; q1 = st->x[1];
++  q1 ^= q0;
++  q0 = rotl(q0, 24);
++  q0 = q0 ^ q1 ^ (q1 << 16);
++  q1 = rotl(q1, 37);
++  st->x[0] = q0; st->x[1] = q1;
++  /* Return result */
++  return z;
++}
++
++CAMLprim value caml_lxm_next(value v)
++{
++  return caml_copy_int64(caml_lxm_next_unboxed(v));
++}
+diff --git a/runtime/signals_byt.c b/runtime/signals_byt.c
+index 7cb461ac4d..439fb56404 100644
+--- a/runtime/signals_byt.c
++++ b/runtime/signals_byt.c
+@@ -81,7 +81,7 @@ int caml_set_signal_action(int signo, int action)
+     return 0;
+ }
+ 
+-CAMLexport void * caml_setup_stack_overflow_detection(void) { return NULL; }
+-CAMLexport int caml_stop_stack_overflow_detection(void * p) { return 0; }
++CAMLexport int caml_setup_stack_overflow_detection(void) { return 0; }
++CAMLexport int caml_stop_stack_overflow_detection(void) { return 0; }
+ CAMLexport void caml_init_signals(void) { }
+ CAMLexport void caml_terminate_signals(void) { }
+diff --git a/runtime/signals_nat.c b/runtime/signals_nat.c
+index 1dd8289c12..443f5d53b6 100644
+--- a/runtime/signals_nat.c
++++ b/runtime/signals_nat.c
+@@ -254,10 +254,6 @@ DECLARE_SIGNAL_HANDLER(segv_handler)
+ 
+ /* Initialization of signal stuff */
+ 
+-#ifdef HAS_STACK_OVERFLOW_DETECTION
+-static void * caml_signal_stack = NULL;
+-#endif
+-
+ void caml_init_signals(void)
+ {
+   /* Bound-check trap handling */
+@@ -282,8 +278,7 @@ void caml_init_signals(void)
+ #endif
+ 
+ #ifdef HAS_STACK_OVERFLOW_DETECTION
+-  caml_signal_stack = caml_setup_stack_overflow_detection();
+-  if (caml_signal_stack != NULL) {
++  if (caml_setup_stack_overflow_detection() != -1) {
+     struct sigaction act;
+     SET_SIGACT(act, segv_handler);
+     act.sa_flags |= SA_ONSTACK | SA_NODEFER;
+@@ -319,8 +314,7 @@ void caml_terminate_signals(void)
+ 
+ #ifdef HAS_STACK_OVERFLOW_DETECTION
+   set_signal_default(SIGSEGV);
+-  caml_stop_stack_overflow_detection(caml_signal_stack);
+-  caml_signal_stack = NULL;
++  caml_stop_stack_overflow_detection();
+ #endif
+ }
+ 
+@@ -329,44 +323,37 @@ void caml_terminate_signals(void)
+    Each thread needs its own alternate stack.
+    The alternate stack used to be statically-allocated for the main thread,
+    but this is incompatible with Glibc 2.34 and newer, where SIGSTKSZ
+-   may not be a compile-time constant (issue #10250).
+-   Return the dynamically-allocated alternate signal stack, or NULL
+-   if an error occurred.
+-   The returned pointer must be passed to [caml_stop_stack_overflow_detection].
+-*/
++   may not be a compile-time constant (issue #10250). */
+ 
+-CAMLexport void * caml_setup_stack_overflow_detection(void)
++CAMLexport int caml_setup_stack_overflow_detection(void)
+ {
+ #ifdef HAS_STACK_OVERFLOW_DETECTION
+   stack_t stk;
++  stk.ss_sp = malloc(SIGSTKSZ);
++  if (stk.ss_sp == NULL) return -1;
+   stk.ss_size = SIGSTKSZ;
+-  stk.ss_sp = malloc(stk.ss_size);
+-  if (stk.ss_sp == NULL) return NULL;
+   stk.ss_flags = 0;
+   if (sigaltstack(&stk, NULL) == -1) {
+     free(stk.ss_sp);
+-    return NULL;
++    return -1;
+   }
+-  return stk.ss_sp;
+-#else
+-  return NULL;
+ #endif
++  /* Success (or stack overflow detection not available) */
++  return 0;
+ }
+ 
+-CAMLexport int caml_stop_stack_overflow_detection(void * signal_stack)
++CAMLexport int caml_stop_stack_overflow_detection(void)
+ {
+ #ifdef HAS_STACK_OVERFLOW_DETECTION
+   stack_t oldstk, stk;
+   stk.ss_flags = SS_DISABLE;
+-  stk.ss_sp = NULL;  /* not required but avoids a valgrind false alarm */
+-  stk.ss_size = SIGSTKSZ; /* macOS wants a valid size here */
+   if (sigaltstack(&stk, &oldstk) == -1) return -1;
+-  /* Check whether someone else installed their own signal stack */
+-  if (!(oldstk.ss_flags & SS_DISABLE) && oldstk.ss_sp != signal_stack) {
+-    /* Re-activate their signal stack. */
+-    sigaltstack(&oldstk, NULL);
+-  }
+-  free(signal_stack);
+-#endif
++  /* If caml_setup_stack_overflow_detection failed, we are not using
++     an alternate signal stack.  SS_DISABLE will be set in oldstk,
++     and there is nothing to free in this case. */
++  if (! (oldstk.ss_flags & SS_DISABLE)) free(oldstk.ss_sp);
+   return 0;
++#else
++  return 0;
++#endif
+ }
+diff --git a/runtime/sys.c b/runtime/sys.c
+index a77fd9d1cf..f90d9ba2a8 100644
+--- a/runtime/sys.c
++++ b/runtime/sys.c
+@@ -45,6 +45,9 @@
+ #ifdef HAS_GETTIMEOFDAY
+ #include <sys/time.h>
+ #endif
++#ifdef __APPLE__
++#include <sys/random.h> /* for getentropy */
++#endif
+ #include "caml/alloc.h"
+ #include "caml/debugger.h"
+ #include "caml/fail.h"
+@@ -61,9 +64,21 @@
+ #include "caml/callback.h"
+ #include "caml/startup_aux.h"
+ 
+-static char * error_message(void)
++CAMLexport char * caml_strerror(int errnum, char * buf, size_t buflen)
+ {
+-  return strerror(errno);
++#ifdef _WIN32
++  /* Windows has a thread-safe strerror */
++  return strerror(errnum);
++#else
++  int res = strerror_r(errnum, buf, buflen);
++  /* glibc<2.13 returns -1/sets errno, >2.13 returns +ve errno.
++     We assume that buffer size is large enough not to get ERANGE,
++     so we assume we got EINVAL. */
++  if (res != 0) {
++    snprintf(buf, buflen, "Unknown error %d", errnum);
++  }
++  return buf;
++#endif
+ }
+ 
+ #ifndef EAGAIN
+@@ -77,9 +92,10 @@ CAMLexport void caml_sys_error(value arg)
+ {
+   CAMLparam1 (arg);
+   char * err;
++  char buf[1024];
+   CAMLlocal1 (str);
+ 
+-  err = error_message();
++  err = caml_strerror(errno, buf, sizeof(buf));
+   if (arg == NO_ARG) {
+     str = caml_copy_string(err);
+   } else {
+@@ -565,20 +581,27 @@ extern int caml_win32_random_seed (intnat data[16]);
+ #else
+ int caml_unix_random_seed(intnat data[16])
+ {
+-  int fd;
+   int n = 0;
+-
+-  /* Try /dev/urandom first */
+-  fd = open("/dev/urandom", O_RDONLY, 0);
+-  if (fd != -1) {
+-    unsigned char buffer[12];
+-    int nread = read(fd, buffer, 12);
+-    close(fd);
+-    while (nread > 0) data[n++] = buffer[--nread];
++  unsigned char buffer[12];
++  int nread = 0;
++
++  /* Try kernel entropy first */
++#if defined(HAS_GETENTROPY) || defined(__APPLE__)
++  if (getentropy(buffer, 12) != -1) {
++    nread = 12;
++  } else
++#endif
++  { int fd = open("/dev/urandom", O_RDONLY, 0);
++    if (fd != -1) {
++      nread = read(fd, buffer, 12);
++      close(fd);
++    }
+   }
+-  /* If the read from /dev/urandom fully succeeded, we now have 96 bits
++  while (nread > 0) data[n++] = buffer[--nread];
++  /* If the kernel provided enough entropy, we now have 96 bits
+      of good random data and can stop here. */
+   if (n >= 12) return n;
++
+   /* Otherwise, complement whatever we got (probably nothing)
+      with some not-very-random data. */
+   {
diff --git a/diff-against-trunk-support.diff b/diff-against-trunk-support.diff
new file mode 100644
index 0000000000..116f3b4e7a
--- /dev/null
+++ b/diff-against-trunk-support.diff
@@ -0,0 +1,3323 @@
+diff --git a/ocamltest/Makefile b/ocamltest/Makefile
+index 0aa5f92651..11782f7f9f 100644
+--- a/ocamltest/Makefile
++++ b/ocamltest/Makefile
+@@ -277,6 +277,7 @@ ocamltest_config.ml: ocamltest_config.ml.in Makefile ../Makefile.config
+ 	    $(call SUBST,DIFF_FLAGS) \
+ 	    $(call SUBST,WINDOWS_UNICODE) \
+ 	    $(call SUBST,FUNCTION_SECTIONS) \
++	    $(call SUBST,NAKED_POINTERS) \
+ 	    $< > $@
+ 
+ # Manual
+diff --git a/ocamltest/builtin_actions.ml b/ocamltest/builtin_actions.ml
+index 02a437db3a..0f2974d12a 100644
+--- a/ocamltest/builtin_actions.ml
++++ b/ocamltest/builtin_actions.ml
+@@ -181,6 +181,12 @@ let function_sections = make
+      "Target supports function sections"
+      "Target does not support function sections")
+ 
++let naked_pointers = make
++  "naked_pointers"
++  (Actions_helpers.pass_or_skip (Ocamltest_config.naked_pointers)
++     "Runtime system supports naked pointers"
++     "Runtime system does not support naked pointers")
++
+ let has_symlink = make
+   "has_symlink"
+   (Actions_helpers.pass_or_skip (Unix.has_symlink () )
+@@ -302,6 +308,7 @@ let _ =
+     arch_i386;
+     arch_power;
+     function_sections;
++    naked_pointers;
+     file_exists;
+     copy;
+   ]
+diff --git a/ocamltest/ocamltest_config.ml.in b/ocamltest/ocamltest_config.ml.in
+index 399d3c3cef..876d4ac79c 100644
+--- a/ocamltest/ocamltest_config.ml.in
++++ b/ocamltest/ocamltest_config.ml.in
+@@ -87,3 +87,5 @@ let windows_unicode = %%WINDOWS_UNICODE%% != 0
+ let function_sections = %%FUNCTION_SECTIONS%%
+ 
+ let instrumented_runtime = %%INSTRUMENTED_RUNTIME%%
++
++let naked_pointers = %%NAKED_POINTERS%%
+diff --git a/ocamltest/ocamltest_config.mli b/ocamltest/ocamltest_config.mli
+index 564ef7644e..92cf631912 100644
+--- a/ocamltest/ocamltest_config.mli
++++ b/ocamltest/ocamltest_config.mli
+@@ -124,3 +124,6 @@ val function_sections : bool
+ 
+ val instrumented_runtime : bool
+ (** Whether the instrumented runtime is available *)
++
++val naked_pointers : bool
++(** Whether the runtime system supports naked pointers outside the heap *)
+diff --git a/ocamltest/run_unix.c b/ocamltest/run_unix.c
+index 7b576135b7..5b2298e696 100644
+--- a/ocamltest/run_unix.c
++++ b/ocamltest/run_unix.c
+@@ -347,7 +347,9 @@ int run_command(const command_settings *settings)
+       myperror("fork");
+       return -1;
+     case 0: /* child process */
++#if 0
+       caml_atfork_hook();
++#endif
+       exit( run_command_child(settings) );
+     default:
+       return run_command_parent(settings, child_pid);
+diff --git a/testsuite/tests/asmcomp/is_in_static_data.c b/testsuite/tests/asmcomp/is_in_static_data.c
+new file mode 100644
+index 0000000000..ccf0582c0a
+--- /dev/null
++++ b/testsuite/tests/asmcomp/is_in_static_data.c
+@@ -0,0 +1,5 @@
++#include "caml/address_class.h"
++
++value caml_is_in_static_data(value v) {
++  return(Val_bool(Is_in_static_data(v)));
++}
+diff --git a/testsuite/tests/asmcomp/is_static.ml b/testsuite/tests/asmcomp/is_static.ml
+new file mode 100644
+index 0000000000..b8a3bef006
+--- /dev/null
++++ b/testsuite/tests/asmcomp/is_static.ml
+@@ -0,0 +1,40 @@
++(* TEST
++   modules = "is_in_static_data.c"
++   * naked_pointers
++   ** native
++*)
++
++(* Data that should be statically allocated by the compiler (all versions) *)
++
++external is_in_static_data : 'a -> bool = "caml_is_in_static_data"
++
++(* Basic constant blocks should be static *)
++let block1 = (1,2)
++let () = assert(is_in_static_data block1)
++
++(* as pattern shouldn't prevent it *)
++let (a, b) as block2 = (1,2)
++let () = assert(is_in_static_data block2)
++
++(* Also in functions *)
++let f () =
++  let block = (1,2) in
++  assert(is_in_static_data block)
++
++let () = (f [@inlined never]) ()
++
++(* Closed functions should be static *)
++let closed_function x = x + 1 (* + is a primitive, it cannot be in the closure*)
++let () = assert(is_in_static_data closed_function)
++
++(* And functions using closed functions *)
++let almost_closed_function x =
++  (closed_function [@inlined never]) x
++let () = assert(is_in_static_data almost_closed_function)
++
++(* Recursive constant functions should be static *)
++let rec f1 a = g1 a
++and g1 a = f1 a
++let () =
++  assert(is_in_static_data f1);
++  assert(is_in_static_data g1)
+diff --git a/testsuite/tests/asmcomp/is_static_flambda.ml b/testsuite/tests/asmcomp/is_static_flambda.ml
+new file mode 100644
+index 0000000000..63e53cfc42
+--- /dev/null
++++ b/testsuite/tests/asmcomp/is_static_flambda.ml
+@@ -0,0 +1,207 @@
++(* TEST
++   modules = "is_in_static_data.c is_static_flambda_dep.ml"
++   * flambda
++   ** naked_pointers
++   *** native
++*)
++
++(* Data that should be statically allocated by the compiler (flambda only) *)
++
++external is_in_static_data : 'a -> bool = "caml_is_in_static_data"
++
++(* Also after inlining *)
++let g x =
++  let block = (1,x) in
++  assert(is_in_static_data block)
++
++let () = (g [@inlined always]) 2
++
++(* Toplevel immutable blocks should be static *)
++let block3 = (Sys.opaque_identity 1, Sys.opaque_identity 2)
++let () = assert(is_in_static_data block3)
++
++(* Not being bound shouldn't prevent it *)
++let () =
++  assert(is_in_static_data (Sys.opaque_identity 1, Sys.opaque_identity 2))
++
++(* Only with rounds >= 2 currently !
++(* Also after inlining *)
++let h x =
++  let block = (Sys.opaque_identity 1,x) in
++  assert(is_in_static_data block)
++
++let () = (h [@inlined always]) (Sys.opaque_identity 2)
++*)
++
++(* Recursive constant values should be static *)
++let rec a = 1 :: b
++and b = 2 :: a
++let () =
++  assert(is_in_static_data a);
++  assert(is_in_static_data b)
++
++(* And a mix *)
++type e = E : 'a -> e
++
++let rec f1 a = E (g1 a, l1)
++and g1 a = E (f1 a, l2)
++and l1 = E (f1, l2)
++and l2 = E (g1, l1)
++
++let () =
++  assert(is_in_static_data f1);
++  assert(is_in_static_data g1);
++  assert(is_in_static_data l1);
++  assert(is_in_static_data l2)
++
++(* Also in functions *)
++let i () =
++  let rec f1 a = E (g1 a, l1)
++  and g1 a = E (f1 a, l2)
++  and l1 = E (f1, l2)
++  and l2 = E (g1, l1) in
++
++  assert(is_in_static_data f1);
++  assert(is_in_static_data g1);
++  assert(is_in_static_data l1);
++  assert(is_in_static_data l2)
++
++let () = (i [@inlined never]) ()
++
++module type P = module type of Stdlib
++(* Top-level modules should be static *)
++let () = assert(is_in_static_data (module Stdlib:P))
++
++(* Not constant let rec to test extraction to initialize_symbol *)
++let r = ref 0
++let rec a = (incr r; !r) :: b
++and b = (incr r; !r) :: a
++
++let next =
++  let r = ref 0 in
++  fun () -> incr r; !r
++
++let () =
++  assert(is_in_static_data next)
++
++(* Exceptions without arguments should be static *)
++exception No_argument
++let () = assert(is_in_static_data No_argument)
++
++(* And also with constant arguments *)
++exception Some_argument of string
++let () = assert(is_in_static_data (Some_argument "some string"))
++
++(* Even when exposed by inlining *)
++let () =
++  let exn =
++    try (failwith [@inlined always]) "some other string" with exn -> exn
++  in
++  assert(is_in_static_data exn)
++
++(* Verify that approximation intersection correctly loads exported
++   approximations.
++
++   Is_static_flambda_dep.pair is a pair with 1 as first element. The
++   intersection of approximations should return a block with
++   approximation: [tag 0: [tag 0: Int 1, Unknown], Unknown] *)
++let f x =
++  let pair =
++    if Sys.opaque_identity x then
++      (1, 2), 3
++    else
++      Is_static_flambda_dep.pair, 4
++  in
++  let n = fst (fst pair) in
++  let res = n, n in
++  assert(is_in_static_data res)
++  [@@inline never]
++
++let () =
++  f true;
++  f false
++
++(* Verify that physical equality/inequality is correctly propagated *)
++
++(* In these tests, tuple can be statically allocated only if it is a
++   known constant since the function is never inlined (hence this
++   code is never at toplevel) *)
++
++let () =
++  let f () =
++    let v = (1, 2) in
++    (* eq is supposed to be considered always true since v is a
++       constant, hence aliased to a symbol.
++       It is not yet optimized away if it is not constant *)
++    let eq = v == v in
++    let n = if eq then 1 else 2 in
++    let tuple = (n,n) in
++    assert(is_in_static_data tuple)
++  in
++  (f [@inlined never]) ()
++
++let () =
++  let f () =
++    let v = (1, 2) in
++    (* same with inequality *)
++    let eq = v != v in
++    let n = if eq then 1 else 2 in
++    let tuple = (n,n) in
++    assert(is_in_static_data tuple)
++  in
++  (f [@inlined never]) ()
++
++let () =
++  let f x =
++    let v1 = Some x in
++    let v2 = None in
++    let eq = v1 == v2 in
++    (* The values are structurally different, so must be physically
++       different *)
++    let n = if eq then 1 else 2 in
++    let tuple = (n,n) in
++    assert(is_in_static_data tuple)
++  in
++  (f [@inlined never]) ()
++
++let () =
++  let f x =
++    let v1 = Some x in
++    let v2 = None in
++    let eq = v1 != v2 in
++    (* same with inequality *)
++    let n = if eq then 1 else 2 in
++    let tuple = (n,n) in
++    assert(is_in_static_data tuple)
++  in
++  (f [@inlined never]) ()
++
++let () =
++  let f x =
++    let v1 = (1, 2) in
++    let v2 = (3, 2) in
++    let eq = v1 == v2 in
++    (* difference is deeper *)
++    let n = if eq then 1 else 2 in
++    let tuple = (n,n) in
++    assert(is_in_static_data tuple)
++  in
++  (f [@inlined never]) ()
++
++module Int = struct
++  type t = int
++  let compare (a:int) b = compare a b
++end
++module IntMap = Map.Make (Int)
++
++let () =
++  let f () =
++    let a = IntMap.empty in
++    let b = (IntMap.add [@inlined]) 1 (Some 1) a in
++    assert(is_in_static_data b);
++    let c = (IntMap.add [@inlined]) 1 (Some 2) b in
++    assert(is_in_static_data c);
++    let d = (IntMap.add [@inlined]) 1 (Some 2) c in
++    assert(is_in_static_data d);
++  in
++  (f [@inlined never]) ()
+diff --git a/testsuite/tests/asmcomp/is_static_flambda_dep.ml b/testsuite/tests/asmcomp/is_static_flambda_dep.ml
+new file mode 100644
+index 0000000000..3a50f7cad4
+--- /dev/null
++++ b/testsuite/tests/asmcomp/is_static_flambda_dep.ml
+@@ -0,0 +1 @@
++let pair = 1, 12
+diff --git a/testsuite/tests/asmcomp/polling.c b/testsuite/tests/asmcomp/polling.c
+index 93620c9bcc..4f6bf1dcab 100644
+--- a/testsuite/tests/asmcomp/polling.c
++++ b/testsuite/tests/asmcomp/polling.c
+@@ -12,7 +12,11 @@ CAMLprim value request_minor_gc(value v) {
+     tests are only run in a single domain, so we're probably
+     good.
+   */
++#if 0
+   Caml_state->young_limit = (uintnat)Caml_state->young_end;
++#endif
++  caml_something_to_do = 1;
++  Caml_state->young_limit = Caml_state->young_alloc_end;
+ 
+   return Val_unit;
+ }
+diff --git a/testsuite/tests/asmcomp/simple_float_const.ml b/testsuite/tests/asmcomp/simple_float_const.ml
+new file mode 100644
+index 0000000000..1aca414f7e
+--- /dev/null
++++ b/testsuite/tests/asmcomp/simple_float_const.ml
+@@ -0,0 +1 @@
++let f = 3.14
+diff --git a/testsuite/tests/asmcomp/simple_float_const_opaque.ml b/testsuite/tests/asmcomp/simple_float_const_opaque.ml
+new file mode 100644
+index 0000000000..1aca414f7e
+--- /dev/null
++++ b/testsuite/tests/asmcomp/simple_float_const_opaque.ml
+@@ -0,0 +1 @@
++let f = 3.14
+diff --git a/testsuite/tests/asmcomp/static_float_array_flambda.ml b/testsuite/tests/asmcomp/static_float_array_flambda.ml
+new file mode 100644
+index 0000000000..824a12ca89
+--- /dev/null
++++ b/testsuite/tests/asmcomp/static_float_array_flambda.ml
+@@ -0,0 +1,26 @@
++(* TEST
++   modules = "is_in_static_data.c simple_float_const.ml"
++   * flambda
++   ** flat-float-array
++   *** naked_pointers
++   **** native
++*)
++
++external is_in_static_data : 'a -> bool = "caml_is_in_static_data"
++
++let a = [|0.; 1.|]
++let f = 1.23
++let b = [|0.; f; f|]
++let g = Sys.opaque_identity 1.23
++let c = [|0.; g|]
++let d = [|0.; Simple_float_const.f|]
++
++let () = assert(is_in_static_data a)
++let () = assert(is_in_static_data f)
++let () = assert(is_in_static_data b)
++
++let () = assert(not (is_in_static_data c))
++(* In fact this one could be static by preallocating the array then
++   patching it when g is available *)
++
++let () = assert(is_in_static_data d)
+diff --git a/testsuite/tests/asmcomp/static_float_array_flambda_opaque.ml b/testsuite/tests/asmcomp/static_float_array_flambda_opaque.ml
+new file mode 100644
+index 0000000000..56ea9e1793
+--- /dev/null
++++ b/testsuite/tests/asmcomp/static_float_array_flambda_opaque.ml
+@@ -0,0 +1,30 @@
++(* TEST
++   modules = "is_in_static_data.c simple_float_const_opaque.ml"
++   flags = "-opaque"
++   * flambda
++   ** flat-float-array
++   *** naked_pointers
++   **** native
++*)
++
++external is_in_static_data : 'a -> bool = "caml_is_in_static_data"
++
++let a = [|0.; 1.|]
++let f = 1.23
++let b = [|0.; f; f|]
++let g = Sys.opaque_identity 1.23
++let c = [|0.; g|]
++let d = [|0.; Simple_float_const_opaque.f|]
++
++let () = assert(is_in_static_data a)
++let () = assert(is_in_static_data f)
++let () = assert(is_in_static_data b)
++
++let () = assert(not (is_in_static_data c))
++(* In fact this one could be static by preallocating the array then
++   patching it when g is available *)
++
++let () = assert(not (is_in_static_data d))
++(* The dependency Simple_float_const_opaque is built with opaque,
++   hence the value of Simple_float_const_opaque.f cannot be known
++   preventing the static allocation of d *)
+diff --git a/testsuite/tests/backtrace/backtrace2.reference b/testsuite/tests/backtrace/backtrace2.reference
+index 20ef708fe0..54c5ab7570 100644
+--- a/testsuite/tests/backtrace/backtrace2.reference
++++ b/testsuite/tests/backtrace/backtrace2.reference
+@@ -35,7 +35,7 @@ Uncaught exception Invalid_argument("index out of bounds")
+ Raised by primitive operation at Backtrace2.run in file "backtrace2.ml", line 62, characters 14-22
+ test_Not_found
+ Uncaught exception Not_found
+-Raised at Stdlib__Hashtbl.find in file "hashtbl.ml", line 541, characters 13-28
++Raised at Stdlib__Hashtbl.find in file "hashtbl.ml", line 549, characters 13-28
+ Called from Backtrace2.test_Not_found in file "backtrace2.ml", line 43, characters 9-42
+ Re-raised at Backtrace2.test_Not_found in file "backtrace2.ml", line 43, characters 61-70
+ Called from Backtrace2.run in file "backtrace2.ml", line 62, characters 11-23
+@@ -46,13 +46,13 @@ Called from Backtrace2.test_lazy.aux in file "backtrace2.ml", line 47, character
+ Called from Backtrace2.test_lazy.aux in file "backtrace2.ml", line 47, characters 43-52
+ Called from Backtrace2.test_lazy.aux in file "backtrace2.ml", line 47, characters 43-52
+ Called from Backtrace2.test_lazy.aux in file "backtrace2.ml", line 47, characters 43-52
+-Called from CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 49, characters 17-27
+-Re-raised at CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 56, characters 4-11
++Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 119, characters 17-27
++Re-raised at CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 124, characters 4-11
+ Called from Backtrace2.run in file "backtrace2.ml", line 62, characters 11-23
+ Uncaught exception Not_found
+-Raised at Stdlib__Hashtbl.find in file "hashtbl.ml", line 541, characters 13-28
++Raised at Stdlib__Hashtbl.find in file "hashtbl.ml", line 549, characters 13-28
+ Called from Backtrace2.test_lazy.exception_raised_internally in file "backtrace2.ml", line 50, characters 8-41
+-Re-raised at CamlinternalLazy.do_force_block.(fun) in file "camlinternalLazy.ml", line 54, characters 43-50
+-Called from CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 49, characters 17-27
+-Re-raised at CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 56, characters 4-11
++Re-raised at CamlinternalLazy.force_lazy_block.(fun) in file "camlinternalLazy.ml", line 123, characters 56-63
++Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 119, characters 17-27
++Re-raised at CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 124, characters 4-11
+ Called from Backtrace2.run in file "backtrace2.ml", line 62, characters 11-23
+diff --git a/testsuite/tests/backtrace/backtrace_c_exn.ml b/testsuite/tests/backtrace/backtrace_c_exn.ml
+index 9b0077d509..1680c23f7b 100644
+--- a/testsuite/tests/backtrace/backtrace_c_exn.ml
++++ b/testsuite/tests/backtrace/backtrace_c_exn.ml
+@@ -2,6 +2,8 @@
+    modules = "backtrace_c_exn_.c"
+    flags = "-g"
+    ocamlrunparam += ",b=1"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ (* https://github.com/ocaml-multicore/ocaml-multicore/issues/498 *)
+diff --git a/testsuite/tests/backtrace/backtrace_dynlink.flambda.reference b/testsuite/tests/backtrace/backtrace_dynlink.flambda.reference
+index b7907c99bd..d47343fbe9 100644
+--- a/testsuite/tests/backtrace/backtrace_dynlink.flambda.reference
++++ b/testsuite/tests/backtrace/backtrace_dynlink.flambda.reference
+@@ -2,19 +2,23 @@ Raised by primitive operation at Backtrace_dynlink_plugin in file "backtrace_dyn
+ Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
+ Called from Stdlib__List.iter in file "list.ml" (inlined), line 110, characters 12-15
+ Called from Dynlink.Native.run in file "otherlibs/dynlink/native/dynlink.ml", line 84, characters 4-273
+-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 363, characters 13-56
++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
+ Called from Stdlib__List.iter in file "list.ml" (inlined), line 110, characters 12-15
+-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
+-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
+ Called from Backtrace_dynlink in file "backtrace_dynlink.ml", line 39, characters 4-52
+ execution of module initializers in the shared library failed: Failure("SUCCESS")
+-Raised by primitive operation at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
++Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++Called from Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 3, characters 4-22
++Re-raised at Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 8, characters 5-12
++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
+ Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 87, characters 10-149
+ Called from Stdlib__List.iter in file "list.ml" (inlined), line 110, characters 12-15
+ Called from Dynlink.Native.run in file "otherlibs/dynlink/native/dynlink.ml", line 84, characters 4-273
+-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 363, characters 13-56
++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
+ Called from Stdlib__List.iter in file "list.ml" (inlined), line 110, characters 12-15
+-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
+-Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 8-17
+-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
++Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 381, characters 8-17
++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
+ Called from Backtrace_dynlink in file "backtrace_dynlink.ml", line 39, characters 4-52
+diff --git a/testsuite/tests/backtrace/backtrace_dynlink.reference b/testsuite/tests/backtrace/backtrace_dynlink.reference
+index 570aca891f..4c6999e85d 100644
+--- a/testsuite/tests/backtrace/backtrace_dynlink.reference
++++ b/testsuite/tests/backtrace/backtrace_dynlink.reference
+@@ -1,18 +1,22 @@
+ Raised by primitive operation at Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 6, characters 13-38
+ Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
+ Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 363, characters 13-56
++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
+ Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
+-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
+ Called from Backtrace_dynlink in file "backtrace_dynlink.ml", line 39, characters 4-52
+ execution of module initializers in the shared library failed: Failure("SUCCESS")
+-Raised by primitive operation at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
++Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++Called from Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 3, characters 4-22
++Re-raised at Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 8, characters 5-12
++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
+ Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 87, characters 10-149
+ Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 363, characters 13-56
++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
+ Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
+-Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 8-17
+-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
++Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 381, characters 8-17
++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
+ Called from Backtrace_dynlink in file "backtrace_dynlink.ml", line 39, characters 4-52
+diff --git a/testsuite/tests/backtrace/backtrace_effects.ml b/testsuite/tests/backtrace/backtrace_effects.ml
+index 352b32cbd7..bafd2259e8 100644
+--- a/testsuite/tests/backtrace/backtrace_effects.ml
++++ b/testsuite/tests/backtrace/backtrace_effects.ml
+@@ -2,6 +2,8 @@
+    flags = "-g"
+    ocamlrunparam += ",b=1"
+    exit_status = "2"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ open Effect
+diff --git a/testsuite/tests/backtrace/backtrace_effects_nested.ml b/testsuite/tests/backtrace/backtrace_effects_nested.ml
+index 37638a200a..2a2a630160 100644
+--- a/testsuite/tests/backtrace/backtrace_effects_nested.ml
++++ b/testsuite/tests/backtrace/backtrace_effects_nested.ml
+@@ -1,12 +1,14 @@
+ (* TEST
+ 
+ flags = "-g"
+-* bytecode
+-* no-flambda
+-** native
+-* flambda
++* skip
++reason = "OCaml 5 only"
++** bytecode
++** no-flambda
++*** native
++** flambda
+ reference = "${test_source_directory}/backtrace_effects_nested.flambda.reference"
+-** native
++*** native
+ 
+ *)
+ 
+diff --git a/testsuite/tests/backtrace/backtrace_systhreads.reference b/testsuite/tests/backtrace/backtrace_systhreads.reference
+index 78028c5752..815506e7ea 100644
+--- a/testsuite/tests/backtrace/backtrace_systhreads.reference
++++ b/testsuite/tests/backtrace/backtrace_systhreads.reference
+@@ -2,24 +2,24 @@ Thread 2 killed on uncaught exception Failure("0")
+ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+ Called from Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 14, characters 6-37
+ Re-raised at Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 18, characters 5-14
+-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+ Thread 3 killed on uncaught exception Failure("1")
+ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+ Called from Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 14, characters 6-37
+ Re-raised at Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 18, characters 5-14
+-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+ Thread 4 killed on uncaught exception Failure("2")
+ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+ Called from Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 14, characters 6-37
+ Re-raised at Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 18, characters 5-14
+-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+ Thread 5 killed on uncaught exception Failure("3")
+ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+ Called from Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 14, characters 6-37
+ Re-raised at Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 18, characters 5-14
+-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+ Thread 1 killed on uncaught exception Failure("backtrace")
+ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+ Called from Backtrace_systhreads.thread_backtrace in file "backtrace_systhreads.ml", line 22, characters 6-27
+ Re-raised at Backtrace_systhreads.thread_backtrace in file "backtrace_systhreads.ml", line 26, characters 5-14
+-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+diff --git a/testsuite/tests/backtrace/callstack.reference b/testsuite/tests/backtrace/callstack.reference
+index 05eacbbc81..8287432b20 100644
+--- a/testsuite/tests/backtrace/callstack.reference
++++ b/testsuite/tests/backtrace/callstack.reference
+@@ -12,4 +12,4 @@ Raised by primitive operation at Callstack.f0 in file "callstack.ml", line 11, c
+ Called from Callstack.f1 in file "callstack.ml", line 12, characters 27-32
+ Called from Callstack.f2 in file "callstack.ml", line 13, characters 27-32
+ Called from Callstack.f3 in file "callstack.ml", line 14, characters 27-32
+-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+diff --git a/testsuite/tests/backtrace/lazy.reference b/testsuite/tests/backtrace/lazy.reference
+index 5e8f53482f..af15509686 100644
+--- a/testsuite/tests/backtrace/lazy.reference
++++ b/testsuite/tests/backtrace/lazy.reference
+@@ -1,14 +1,12 @@
+ Uncaught exception Not_found
+ Raised at Lazy.l1 in file "lazy.ml", line 7, characters 28-45
+-Called from CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 49, characters 17-27
+-Re-raised at CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 56, characters 4-11
+-Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml" (inlined), line 78, characters 27-67
++Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 119, characters 17-27
++Re-raised at CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 124, characters 4-11
+ Called from Lazy.test1 in file "lazy.ml", line 10, characters 11-24
+ Called from Lazy.run in file "lazy.ml", line 19, characters 4-11
+ Uncaught exception Not_found
+ Raised at Lazy.l2 in file "lazy.ml", line 12, characters 28-45
+-Called from CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 49, characters 17-27
+-Re-raised at CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 56, characters 4-11
+-Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml" (inlined), line 78, characters 27-67
++Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 119, characters 17-27
++Re-raised at CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 124, characters 4-11
+ Called from Lazy.test2 in file "lazy.ml", line 15, characters 6-15
+ Called from Lazy.run in file "lazy.ml", line 19, characters 4-11
+diff --git a/testsuite/tests/basic/patmatch_for_multiple.ml b/testsuite/tests/basic/patmatch_for_multiple.ml
+index 6433f3d9a4..cbe78cdd0b 100644
+--- a/testsuite/tests/basic/patmatch_for_multiple.ml
++++ b/testsuite/tests/basic/patmatch_for_multiple.ml
+@@ -26,15 +26,15 @@ match (3, 2, 1) with
+ | _ -> false
+ ;;
+ [%%expect{|
+-(let (*match*/274 = 3 *match*/275 = 2 *match*/276 = 1)
++(let (*match*/269 = 3 *match*/270 = 2 *match*/271 = 1)
+   (catch
+     (catch
+-      (catch (if (!= *match*/275 3) (exit 3) (exit 1)) with (3)
+-        (if (!= *match*/274 1) (exit 2) (exit 1)))
++      (catch (if (!= *match*/270 3) (exit 3) (exit 1)) with (3)
++        (if (!= *match*/269 1) (exit 2) (exit 1)))
+      with (2) 0)
+    with (1) 1))
+-(let (*match*/274 = 3 *match*/275 = 2 *match*/276 = 1)
+-  (catch (if (!= *match*/275 3) (if (!= *match*/274 1) 0 (exit 1)) (exit 1))
++(let (*match*/269 = 3 *match*/270 = 2 *match*/271 = 1)
++  (catch (if (!= *match*/270 3) (if (!= *match*/269 1) 0 (exit 1)) (exit 1))
+    with (1) 1))
+ - : bool = false
+ |}];;
+@@ -47,26 +47,26 @@ match (3, 2, 1) with
+ | _ -> false
+ ;;
+ [%%expect{|
+-(let (*match*/279 = 3 *match*/280 = 2 *match*/281 = 1)
++(let (*match*/274 = 3 *match*/275 = 2 *match*/276 = 1)
+   (catch
+     (catch
+       (catch
+-        (if (!= *match*/280 3) (exit 6)
+-          (let (x/283 =a (makeblock 0 *match*/279 *match*/280 *match*/281))
+-            (exit 4 x/283)))
++        (if (!= *match*/275 3) (exit 6)
++          (let (x/278 =a (makeblock 0 *match*/274 *match*/275 *match*/276))
++            (exit 4 x/278)))
+        with (6)
+-        (if (!= *match*/279 1) (exit 5)
+-          (let (x/282 =a (makeblock 0 *match*/279 *match*/280 *match*/281))
+-            (exit 4 x/282))))
++        (if (!= *match*/274 1) (exit 5)
++          (let (x/277 =a (makeblock 0 *match*/274 *match*/275 *match*/276))
++            (exit 4 x/277))))
+      with (5) 0)
+-   with (4 x/277) (seq (ignore x/277) 1)))
+-(let (*match*/279 = 3 *match*/280 = 2 *match*/281 = 1)
++   with (4 x/272) (seq (ignore x/272) 1)))
++(let (*match*/274 = 3 *match*/275 = 2 *match*/276 = 1)
+   (catch
+-    (if (!= *match*/280 3)
+-      (if (!= *match*/279 1) 0
+-        (exit 4 (makeblock 0 *match*/279 *match*/280 *match*/281)))
+-      (exit 4 (makeblock 0 *match*/279 *match*/280 *match*/281)))
+-   with (4 x/277) (seq (ignore x/277) 1)))
++    (if (!= *match*/275 3)
++      (if (!= *match*/274 1) 0
++        (exit 4 (makeblock 0 *match*/274 *match*/275 *match*/276)))
++      (exit 4 (makeblock 0 *match*/274 *match*/275 *match*/276)))
++   with (4 x/272) (seq (ignore x/272) 1)))
+ - : bool = false
+ |}];;
+ 
+@@ -76,8 +76,8 @@ let _ = fun a b ->
+   | ((true, _) as _g)
+   | ((false, _) as _g) -> ()
+ [%%expect{|
+-(function a/284[int] b/285 : int 0)
+-(function a/284[int] b/285 : int 0)
++(function a/279[int] b/280 : int 0)
++(function a/279[int] b/280 : int 0)
+ - : bool -> 'a -> unit = <fun>
+ |}];;
+ 
+@@ -96,8 +96,8 @@ let _ = fun a b -> match a, b with
+ | (false, _) as p -> p
+ (* outside, trivial *)
+ [%%expect {|
+-(function a/288[int] b/289 (let (p/290 =a (makeblock 0 a/288 b/289)) p/290))
+-(function a/288[int] b/289 (makeblock 0 a/288 b/289))
++(function a/283[int] b/284 (let (p/285 =a (makeblock 0 a/283 b/284)) p/285))
++(function a/283[int] b/284 (makeblock 0 a/283 b/284))
+ - : bool -> 'a -> bool * 'a = <fun>
+ |}]
+ 
+@@ -106,8 +106,8 @@ let _ = fun a b -> match a, b with
+ | ((false, _) as p) -> p
+ (* inside, trivial *)
+ [%%expect{|
+-(function a/292[int] b/293 (let (p/294 =a (makeblock 0 a/292 b/293)) p/294))
+-(function a/292[int] b/293 (makeblock 0 a/292 b/293))
++(function a/287[int] b/288 (let (p/289 =a (makeblock 0 a/287 b/288)) p/289))
++(function a/287[int] b/288 (makeblock 0 a/287 b/288))
+ - : bool -> 'a -> bool * 'a = <fun>
+ |}];;
+ 
+@@ -116,11 +116,11 @@ let _ = fun a b -> match a, b with
+ | (false as x, _) as p -> x, p
+ (* outside, simple *)
+ [%%expect {|
+-(function a/298[int] b/299
+-  (let (x/300 =a[int] a/298 p/301 =a (makeblock 0 a/298 b/299))
+-    (makeblock 0 (int,*) x/300 p/301)))
+-(function a/298[int] b/299
+-  (makeblock 0 (int,*) a/298 (makeblock 0 a/298 b/299)))
++(function a/293[int] b/294
++  (let (x/295 =a[int] a/293 p/296 =a (makeblock 0 a/293 b/294))
++    (makeblock 0 (int,*) x/295 p/296)))
++(function a/293[int] b/294
++  (makeblock 0 (int,*) a/293 (makeblock 0 a/293 b/294)))
+ - : bool -> 'a -> bool * (bool * 'a) = <fun>
+ |}]
+ 
+@@ -129,11 +129,11 @@ let _ = fun a b -> match a, b with
+ | ((false as x, _) as p) -> x, p
+ (* inside, simple *)
+ [%%expect {|
+-(function a/304[int] b/305
+-  (let (x/306 =a[int] a/304 p/307 =a (makeblock 0 a/304 b/305))
+-    (makeblock 0 (int,*) x/306 p/307)))
+-(function a/304[int] b/305
+-  (makeblock 0 (int,*) a/304 (makeblock 0 a/304 b/305)))
++(function a/299[int] b/300
++  (let (x/301 =a[int] a/299 p/302 =a (makeblock 0 a/299 b/300))
++    (makeblock 0 (int,*) x/301 p/302)))
++(function a/299[int] b/300
++  (makeblock 0 (int,*) a/299 (makeblock 0 a/299 b/300)))
+ - : bool -> 'a -> bool * (bool * 'a) = <fun>
+ |}]
+ 
+@@ -142,15 +142,15 @@ let _ = fun a b -> match a, b with
+ | (false, x) as p -> x, p
+ (* outside, complex *)
+ [%%expect{|
+-(function a/314[int] b/315[int]
+-  (if a/314
+-    (let (x/316 =a[int] a/314 p/317 =a (makeblock 0 a/314 b/315))
+-      (makeblock 0 (int,*) x/316 p/317))
+-    (let (x/318 =a b/315 p/319 =a (makeblock 0 a/314 b/315))
+-      (makeblock 0 (int,*) x/318 p/319))))
+-(function a/314[int] b/315[int]
+-  (if a/314 (makeblock 0 (int,*) a/314 (makeblock 0 a/314 b/315))
+-    (makeblock 0 (int,*) b/315 (makeblock 0 a/314 b/315))))
++(function a/309[int] b/310[int]
++  (if a/309
++    (let (x/311 =a[int] a/309 p/312 =a (makeblock 0 a/309 b/310))
++      (makeblock 0 (int,*) x/311 p/312))
++    (let (x/313 =a b/310 p/314 =a (makeblock 0 a/309 b/310))
++      (makeblock 0 (int,*) x/313 p/314))))
++(function a/309[int] b/310[int]
++  (if a/309 (makeblock 0 (int,*) a/309 (makeblock 0 a/309 b/310))
++    (makeblock 0 (int,*) b/310 (makeblock 0 a/309 b/310))))
+ - : bool -> bool -> bool * (bool * bool) = <fun>
+ |}]
+ 
+@@ -160,19 +160,19 @@ let _ = fun a b -> match a, b with
+   -> x, p
+ (* inside, complex *)
+ [%%expect{|
+-(function a/320[int] b/321[int]
++(function a/315[int] b/316[int]
+   (catch
+-    (if a/320
+-      (let (x/328 =a[int] a/320 p/329 =a (makeblock 0 a/320 b/321))
+-        (exit 10 x/328 p/329))
+-      (let (x/326 =a b/321 p/327 =a (makeblock 0 a/320 b/321))
+-        (exit 10 x/326 p/327)))
+-   with (10 x/322[int] p/323) (makeblock 0 (int,*) x/322 p/323)))
+-(function a/320[int] b/321[int]
++    (if a/315
++      (let (x/323 =a[int] a/315 p/324 =a (makeblock 0 a/315 b/316))
++        (exit 10 x/323 p/324))
++      (let (x/321 =a b/316 p/322 =a (makeblock 0 a/315 b/316))
++        (exit 10 x/321 p/322)))
++   with (10 x/317[int] p/318) (makeblock 0 (int,*) x/317 p/318)))
++(function a/315[int] b/316[int]
+   (catch
+-    (if a/320 (exit 10 a/320 (makeblock 0 a/320 b/321))
+-      (exit 10 b/321 (makeblock 0 a/320 b/321)))
+-   with (10 x/322[int] p/323) (makeblock 0 (int,*) x/322 p/323)))
++    (if a/315 (exit 10 a/315 (makeblock 0 a/315 b/316))
++      (exit 10 b/316 (makeblock 0 a/315 b/316)))
++   with (10 x/317[int] p/318) (makeblock 0 (int,*) x/317 p/318)))
+ - : bool -> bool -> bool * (bool * bool) = <fun>
+ |}]
+ 
+@@ -185,15 +185,15 @@ let _ = fun a b -> match a, b with
+ | (false as x, _) as p -> x, p
+ (* outside, onecase *)
+ [%%expect {|
+-(function a/330[int] b/331[int]
+-  (if a/330
+-    (let (x/332 =a[int] a/330 _p/333 =a (makeblock 0 a/330 b/331))
+-      (makeblock 0 (int,*) x/332 [0: 1 1]))
+-    (let (x/334 =a[int] a/330 p/335 =a (makeblock 0 a/330 b/331))
+-      (makeblock 0 (int,*) x/334 p/335))))
+-(function a/330[int] b/331[int]
+-  (if a/330 (makeblock 0 (int,*) a/330 [0: 1 1])
+-    (makeblock 0 (int,*) a/330 (makeblock 0 a/330 b/331))))
++(function a/325[int] b/326[int]
++  (if a/325
++    (let (x/327 =a[int] a/325 _p/328 =a (makeblock 0 a/325 b/326))
++      (makeblock 0 (int,*) x/327 [0: 1 1]))
++    (let (x/329 =a[int] a/325 p/330 =a (makeblock 0 a/325 b/326))
++      (makeblock 0 (int,*) x/329 p/330))))
++(function a/325[int] b/326[int]
++  (if a/325 (makeblock 0 (int,*) a/325 [0: 1 1])
++    (makeblock 0 (int,*) a/325 (makeblock 0 a/325 b/326))))
+ - : bool -> bool -> bool * (bool * bool) = <fun>
+ |}]
+ 
+@@ -202,11 +202,11 @@ let _ = fun a b -> match a, b with
+ | ((false as x, _) as p) -> x, p
+ (* inside, onecase *)
+ [%%expect{|
+-(function a/336[int] b/337
+-  (let (x/338 =a[int] a/336 p/339 =a (makeblock 0 a/336 b/337))
+-    (makeblock 0 (int,*) x/338 p/339)))
+-(function a/336[int] b/337
+-  (makeblock 0 (int,*) a/336 (makeblock 0 a/336 b/337)))
++(function a/331[int] b/332
++  (let (x/333 =a[int] a/331 p/334 =a (makeblock 0 a/331 b/332))
++    (makeblock 0 (int,*) x/333 p/334)))
++(function a/331[int] b/332
++  (makeblock 0 (int,*) a/331 (makeblock 0 a/331 b/332)))
+ - : bool -> 'a -> bool * (bool * 'a) = <fun>
+ |}]
+ 
+@@ -223,14 +223,14 @@ let _ =fun a b -> match a, b with
+ | (_, _) as p -> p
+ (* outside, tuplist *)
+ [%%expect {|
+-(function a/349[int] b/350
++(function a/344[int] b/345
+   (catch
+-    (if a/349 (if b/350 (let (p/351 =a (field_imm 0 b/350)) p/351) (exit 12))
++    (if a/344 (if b/345 (let (p/346 =a (field_imm 0 b/345)) p/346) (exit 12))
+       (exit 12))
+-   with (12) (let (p/352 =a (makeblock 0 a/349 b/350)) p/352)))
+-(function a/349[int] b/350
+-  (catch (if a/349 (if b/350 (field_imm 0 b/350) (exit 12)) (exit 12))
+-   with (12) (makeblock 0 a/349 b/350)))
++   with (12) (let (p/347 =a (makeblock 0 a/344 b/345)) p/347)))
++(function a/344[int] b/345
++  (catch (if a/344 (if b/345 (field_imm 0 b/345) (exit 12)) (exit 12))
++   with (12) (makeblock 0 a/344 b/345)))
+ - : bool -> bool tuplist -> bool * bool tuplist = <fun>
+ |}]
+ 
+@@ -239,20 +239,20 @@ let _ = fun a b -> match a, b with
+ | ((_, _) as p) -> p
+ (* inside, tuplist *)
+ [%%expect{|
+-(function a/353[int] b/354
++(function a/348[int] b/349
+   (catch
+     (catch
+-      (if a/353
+-        (if b/354 (let (p/358 =a (field_imm 0 b/354)) (exit 13 p/358))
++      (if a/348
++        (if b/349 (let (p/353 =a (field_imm 0 b/349)) (exit 13 p/353))
+           (exit 14))
+         (exit 14))
+-     with (14) (let (p/357 =a (makeblock 0 a/353 b/354)) (exit 13 p/357)))
+-   with (13 p/355) p/355))
+-(function a/353[int] b/354
++     with (14) (let (p/352 =a (makeblock 0 a/348 b/349)) (exit 13 p/352)))
++   with (13 p/350) p/350))
++(function a/348[int] b/349
+   (catch
+     (catch
+-      (if a/353 (if b/354 (exit 13 (field_imm 0 b/354)) (exit 14)) (exit 14))
+-     with (14) (exit 13 (makeblock 0 a/353 b/354)))
+-   with (13 p/355) p/355))
++      (if a/348 (if b/349 (exit 13 (field_imm 0 b/349)) (exit 14)) (exit 14))
++     with (14) (exit 13 (makeblock 0 a/348 b/349)))
++   with (13 p/350) p/350))
+ - : bool -> bool tuplist -> bool * bool tuplist = <fun>
+ |}]
+diff --git a/testsuite/tests/c-api/alloc_async.ml b/testsuite/tests/c-api/alloc_async.ml
+index b8c99a4b07..0ed35acf16 100644
+--- a/testsuite/tests/c-api/alloc_async.ml
++++ b/testsuite/tests/c-api/alloc_async.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    modules = "alloc_async_stubs.c"
+-   * skip
+-   reason = "alloc async changes: https://github.com/ocaml/ocaml/pull/8897"
+ *)
+ 
+ external test : int ref -> unit = "stub"
+diff --git a/testsuite/tests/callback/nested_fiber.ml b/testsuite/tests/callback/nested_fiber.ml
+index 3786e455ef..77478728df 100644
+--- a/testsuite/tests/callback/nested_fiber.ml
++++ b/testsuite/tests/callback/nested_fiber.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+    include unix
+    modules = "nested_fiber_.c"
+-   * libunix
+-   ** bytecode
+-   ** native
++   * skip
++   reason = "OCaml 5 only"
++   ** libunix
++   *** bytecode
++   *** native
+ *)
+ 
+ external caml_to_c : (unit -> 'a) -> 'a = "caml_to_c"
+diff --git a/testsuite/tests/callback/stack_overflow.ml b/testsuite/tests/callback/stack_overflow.ml
+index 23691dcf6c..6281d76e2a 100644
+--- a/testsuite/tests/callback/stack_overflow.ml
++++ b/testsuite/tests/callback/stack_overflow.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+    include unix
+    modules = "stack_overflow_.c"
+-   * libunix
+-   ** bytecode
+-   ** native
++   * skip
++   reason = "OCaml 5 only"
++   ** libunix
++   *** bytecode
++   *** native
+ *)
+ 
+ external caml_to_c : (unit -> 'a) -> 'a = "caml_to_c"
+diff --git a/testsuite/tests/callback/test7.ml b/testsuite/tests/callback/test7.ml
+index 9419dd5c6f..e523ba85b7 100644
+--- a/testsuite/tests/callback/test7.ml
++++ b/testsuite/tests/callback/test7.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+    include unix
+    modules = "test7_.c"
+-   * libunix
+-   ** bytecode
+-   ** native
++   * skip
++   reason = "OCaml 5 only"
++   ** libunix
++   *** bytecode
++   *** native
+ *)
+ 
+ (* Tests nested calls from C (main C) to OCaml (main OCaml) to C (caml_to_c) to
+diff --git a/testsuite/tests/callback/test_signalhandler.ml b/testsuite/tests/callback/test_signalhandler.ml
+index a2bbacee72..9250395618 100644
+--- a/testsuite/tests/callback/test_signalhandler.ml
++++ b/testsuite/tests/callback/test_signalhandler.ml
+@@ -1,6 +1,6 @@
+ (* TEST
+    include unix
+-   modules = "test_signalhandler_.c"
++   modules = "callbackprim.c"
+    * libunix
+    ** bytecode
+    ** native
+@@ -52,17 +52,19 @@ let sighandler signo =
+   (* Thoroughly wipe the minor heap *)
+   ignore (tak (18, 12, 6))
+ 
+-external mykill : int -> int -> unit = "mykill" [@@noalloc]
++external raise_sigusr1 : unit -> unit = "raise_sigusr1" [@@noalloc]
++(*external mykill : int -> int -> unit = "mykill" [@@noalloc]*)
+ 
+ let callbacksig () =
+-  let pid = Unix.getpid () in
++  let _pid = Unix.getpid() in
+   (* Allocate a block in the minor heap *)
+   let s = String.make 5 'b' in
+   (* Send a signal to self.  We want s to remain in a register and
+      not be spilled on the stack, hence we use [mykill]
+      (which is [@@noalloc] and doesn't trigger signal handling)
+      instead of [Unix.kill]. *)
+-  mykill pid Sys.sigusr1;
++  (*mykill pid Sys.sigusr1;*)
++  raise_sigusr1 ();
+   (* Allocate some more so that the signal will be tested *)
+   let u = (s, s) in
+   fst u
+diff --git a/testsuite/tests/effects/backtrace.ml b/testsuite/tests/effects/backtrace.ml
+index 6257ba75c5..df6e11ac7a 100644
+--- a/testsuite/tests/effects/backtrace.ml
++++ b/testsuite/tests/effects/backtrace.ml
+@@ -1,6 +1,8 @@
+ (* TEST
+    flags = "-g"
+    ocamlrunparam += ",b=1"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/cmphash.ml b/testsuite/tests/effects/cmphash.ml
+index 78481d6404..a36d20cb8c 100644
+--- a/testsuite/tests/effects/cmphash.ml
++++ b/testsuite/tests/effects/cmphash.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/evenodd.ml b/testsuite/tests/effects/evenodd.ml
+index 07464edb7a..e9b2d5a2fb 100644
+--- a/testsuite/tests/effects/evenodd.ml
++++ b/testsuite/tests/effects/evenodd.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/issue479.ml b/testsuite/tests/effects/issue479.ml
+index 228e098d2e..c00b55c6ff 100644
+--- a/testsuite/tests/effects/issue479.ml
++++ b/testsuite/tests/effects/issue479.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+-   * toplevel
++   * skip
++   reason = "OCaml 5 only"
++   ** toplevel
+ *)
+ 
+ (* https://github.com/ocaml-multicore/ocaml-multicore/issues/479 *)
+diff --git a/testsuite/tests/effects/overflow.ml b/testsuite/tests/effects/overflow.ml
+index a187e9e10d..c12503863e 100644
+--- a/testsuite/tests/effects/overflow.ml
++++ b/testsuite/tests/effects/overflow.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/partial.ml b/testsuite/tests/effects/partial.ml
+index 50e4b53cfc..010741b9fc 100644
+--- a/testsuite/tests/effects/partial.ml
++++ b/testsuite/tests/effects/partial.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/reperform.ml b/testsuite/tests/effects/reperform.ml
+index 8aefdd0587..685b48b5dd 100644
+--- a/testsuite/tests/effects/reperform.ml
++++ b/testsuite/tests/effects/reperform.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/sched.ml b/testsuite/tests/effects/sched.ml
+index 3dc14a2cfc..6065d21c70 100644
+--- a/testsuite/tests/effects/sched.ml
++++ b/testsuite/tests/effects/sched.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/shallow_state.ml b/testsuite/tests/effects/shallow_state.ml
+index 56c61b0c3c..4d52362bc7 100644
+--- a/testsuite/tests/effects/shallow_state.ml
++++ b/testsuite/tests/effects/shallow_state.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/shallow_state_io.ml b/testsuite/tests/effects/shallow_state_io.ml
+index 6b1fa649a7..6ca4fef8b1 100644
+--- a/testsuite/tests/effects/shallow_state_io.ml
++++ b/testsuite/tests/effects/shallow_state_io.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/test1.ml b/testsuite/tests/effects/test1.ml
+index 5d05359f8a..65da5c8b90 100644
+--- a/testsuite/tests/effects/test1.ml
++++ b/testsuite/tests/effects/test1.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/test10.ml b/testsuite/tests/effects/test10.ml
+index 29c5f47f25..9b10559cfd 100644
+--- a/testsuite/tests/effects/test10.ml
++++ b/testsuite/tests/effects/test10.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/test11.ml b/testsuite/tests/effects/test11.ml
+index 6714473e0e..303cdd03c5 100644
+--- a/testsuite/tests/effects/test11.ml
++++ b/testsuite/tests/effects/test11.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ (* Tests RESUMETERM with extra_args != 0 in bytecode,
+diff --git a/testsuite/tests/effects/test2.ml b/testsuite/tests/effects/test2.ml
+index e9b8289bb2..f4e805f1d0 100644
+--- a/testsuite/tests/effects/test2.ml
++++ b/testsuite/tests/effects/test2.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Printf
+diff --git a/testsuite/tests/effects/test3.ml b/testsuite/tests/effects/test3.ml
+index d76130eaaa..2828f933a7 100644
+--- a/testsuite/tests/effects/test3.ml
++++ b/testsuite/tests/effects/test3.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/test4.ml b/testsuite/tests/effects/test4.ml
+index f5cf78cbda..77320a1ab5 100644
+--- a/testsuite/tests/effects/test4.ml
++++ b/testsuite/tests/effects/test4.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/test5.ml b/testsuite/tests/effects/test5.ml
+index 33ed2c23ca..98802a934e 100644
+--- a/testsuite/tests/effects/test5.ml
++++ b/testsuite/tests/effects/test5.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/test6.ml b/testsuite/tests/effects/test6.ml
+index ddfb83a5b6..6d4842f9fa 100644
+--- a/testsuite/tests/effects/test6.ml
++++ b/testsuite/tests/effects/test6.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/test_lazy.ml b/testsuite/tests/effects/test_lazy.ml
+index 24f457f0af..036c7d5038 100644
+--- a/testsuite/tests/effects/test_lazy.ml
++++ b/testsuite/tests/effects/test_lazy.ml
+@@ -1,4 +1,7 @@
+-(* TEST *)
++(* TEST
++   * skip
++   reason = "OCaml 5 only"
++*)
+ 
+ open Effect
+ open Effect.Deep
+diff --git a/testsuite/tests/effects/used_cont.ml b/testsuite/tests/effects/used_cont.ml
+index 71a33388ec..7972d000b7 100644
+--- a/testsuite/tests/effects/used_cont.ml
++++ b/testsuite/tests/effects/used_cont.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/ephe-c-api/test.ml b/testsuite/tests/ephe-c-api/test.ml
+index ff1646835a..a29cd8516b 100644
+--- a/testsuite/tests/ephe-c-api/test.ml
++++ b/testsuite/tests/ephe-c-api/test.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    modules = "stubs.c"
+-   * skip
+-   reason = "port the new Ephemeron C-api to multicore : https://github.com/ocaml/ocaml/pull/676"
+ *)
+ 
+ (* C version of ephetest.ml *)
+diff --git a/testsuite/tests/gc-roots/globroots.ml b/testsuite/tests/gc-roots/globroots.ml
+index 56d1586331..6bdb7fdaf3 100644
+--- a/testsuite/tests/gc-roots/globroots.ml
++++ b/testsuite/tests/gc-roots/globroots.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    modules = "globrootsprim.c"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ module type GLOBREF = sig
+diff --git a/testsuite/tests/gc-roots/globroots_parallel.ml b/testsuite/tests/gc-roots/globroots_parallel.ml
+index 4c3e36d140..fabbaa8ec6 100644
+--- a/testsuite/tests/gc-roots/globroots_parallel.ml
++++ b/testsuite/tests/gc-roots/globroots_parallel.ml
+@@ -1,6 +1,8 @@
+ (* TEST
+    flags += " -w a "
+    modules = "globrootsprim.c globroots.ml"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ open Globroots
+diff --git a/testsuite/tests/gc-roots/globroots_parallel_spawn_burn.ml b/testsuite/tests/gc-roots/globroots_parallel_spawn_burn.ml
+index bf392c13b0..cf932d9491 100644
+--- a/testsuite/tests/gc-roots/globroots_parallel_spawn_burn.ml
++++ b/testsuite/tests/gc-roots/globroots_parallel_spawn_burn.ml
+@@ -1,6 +1,8 @@
+ (* TEST
+    flags += " -w a "
+    modules = "globrootsprim.c globroots.ml"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ open Globroots
+diff --git a/testsuite/tests/gc-roots/globroots_sequential.ml b/testsuite/tests/gc-roots/globroots_sequential.ml
+index 6bf995bf96..dc732ce6a3 100644
+--- a/testsuite/tests/gc-roots/globroots_sequential.ml
++++ b/testsuite/tests/gc-roots/globroots_sequential.ml
+@@ -1,6 +1,8 @@
+ (* TEST
+    flags += " -w a "
+    modules = "globrootsprim.c globroots.ml"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ open Globroots
+ 
+diff --git a/testsuite/tests/generalized-open/gpr1506.ml b/testsuite/tests/generalized-open/gpr1506.ml
+index bd72ed302f..6d21977529 100644
+--- a/testsuite/tests/generalized-open/gpr1506.ml
++++ b/testsuite/tests/generalized-open/gpr1506.ml
+@@ -103,9 +103,9 @@ include struct open struct type t = T end let x = T end
+ Line 1, characters 15-41:
+ 1 | include struct open struct type t = T end let x = T end
+                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
+-Error: The type t/337 introduced by this open appears in the signature
++Error: The type t/332 introduced by this open appears in the signature
+        Line 1, characters 46-47:
+-         The value x has no valid type if t/337 is hidden
++         The value x has no valid type if t/332 is hidden
+ |}];;
+ 
+ module A = struct
+@@ -123,9 +123,9 @@ Lines 3-6, characters 4-7:
+ 4 |       type t = T
+ 5 |       let x = T
+ 6 |     end
+-Error: The type t/342 introduced by this open appears in the signature
++Error: The type t/337 introduced by this open appears in the signature
+        Line 7, characters 8-9:
+-         The value y has no valid type if t/342 is hidden
++         The value y has no valid type if t/337 is hidden
+ |}];;
+ 
+ module A = struct
+@@ -142,9 +142,9 @@ Lines 3-5, characters 4-7:
+ 3 | ....open struct
+ 4 |       type t = T
+ 5 |     end
+-Error: The type t/347 introduced by this open appears in the signature
++Error: The type t/342 introduced by this open appears in the signature
+        Line 6, characters 8-9:
+-         The value y has no valid type if t/347 is hidden
++         The value y has no valid type if t/342 is hidden
+ |}]
+ 
+ (* It was decided to not allow this anymore. *)
+diff --git a/testsuite/tests/instrumented-runtime/main.ml b/testsuite/tests/instrumented-runtime/main.ml
+index 084ceb03ca..94200ec67f 100644
+--- a/testsuite/tests/instrumented-runtime/main.ml
++++ b/testsuite/tests/instrumented-runtime/main.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+   * instrumented-runtime
+-  * skip
+-  reason = "instrumented runtime test is not very useful and broken on multicore. (#9413)"
+   ** native
+     flags = "-runtime-variant=i"
+ *)
+diff --git a/testsuite/tests/lazy/lazy2.ml b/testsuite/tests/lazy/lazy2.ml
+index cccbd96d71..35dd7fd85b 100644
+--- a/testsuite/tests/lazy/lazy2.ml
++++ b/testsuite/tests/lazy/lazy2.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    ocamlopt_flags += " -O3 "
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ open Domain
+diff --git a/testsuite/tests/lazy/lazy3.ml b/testsuite/tests/lazy/lazy3.ml
+index a22a0893b9..737791b7db 100644
+--- a/testsuite/tests/lazy/lazy3.ml
++++ b/testsuite/tests/lazy/lazy3.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    ocamlopt_flags += " -O3 "
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ let f count =
+diff --git a/testsuite/tests/lazy/lazy5.ml b/testsuite/tests/lazy/lazy5.ml
+index 217b84175e..e37b499268 100644
+--- a/testsuite/tests/lazy/lazy5.ml
++++ b/testsuite/tests/lazy/lazy5.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    ocamlopt_flags += " -O3 "
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ let rec safe_force l =
+   try Lazy.force l with
+diff --git a/testsuite/tests/lazy/lazy6.ml b/testsuite/tests/lazy/lazy6.ml
+index 098848769a..29067f1a41 100644
+--- a/testsuite/tests/lazy/lazy6.ml
++++ b/testsuite/tests/lazy/lazy6.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    ocamlopt_flags += " -O3 "
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ let flag1 = Atomic.make false
+diff --git a/testsuite/tests/lazy/lazy7.ml b/testsuite/tests/lazy/lazy7.ml
+index 6c96f32907..d9c9b82127 100644
+--- a/testsuite/tests/lazy/lazy7.ml
++++ b/testsuite/tests/lazy/lazy7.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    ocamlopt_flags += " -O3 "
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ let num_domains = 4
+diff --git a/testsuite/tests/lazy/lazy8.ml b/testsuite/tests/lazy/lazy8.ml
+index c9b5781617..ddadf48a1b 100644
+--- a/testsuite/tests/lazy/lazy8.ml
++++ b/testsuite/tests/lazy/lazy8.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    ocamlopt_flags += " -O3 "
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ exception E
+diff --git a/testsuite/tests/lazy/minor_major_force.ml b/testsuite/tests/lazy/minor_major_force.ml
+index b18fe44a9b..d7497f986d 100644
+--- a/testsuite/tests/lazy/minor_major_force.ml
++++ b/testsuite/tests/lazy/minor_major_force.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    ocamlopt_flags += " -O3 "
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ (*
+diff --git a/testsuite/tests/lf_skiplist/test.ml b/testsuite/tests/lf_skiplist/test.ml
+index f3b11bf411..4dcffc523d 100644
+--- a/testsuite/tests/lf_skiplist/test.ml
++++ b/testsuite/tests/lf_skiplist/test.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    modules = "stubs.c"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ external test_skiplist_serial : unit -> unit = "test_skiplist_serial"
+diff --git a/testsuite/tests/lf_skiplist/test_parallel.ml b/testsuite/tests/lf_skiplist/test_parallel.ml
+index ac02717889..c882a8dac7 100644
+--- a/testsuite/tests/lf_skiplist/test_parallel.ml
++++ b/testsuite/tests/lf_skiplist/test_parallel.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    modules = "stubs.c"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ external init_skiplist : unit -> unit = "init_skiplist"
+diff --git a/testsuite/tests/lib-dynlink-domains/main.ml b/testsuite/tests/lib-dynlink-domains/main.ml
+index 1feeb3918a..781d82300a 100644
+--- a/testsuite/tests/lib-dynlink-domains/main.ml
++++ b/testsuite/tests/lib-dynlink-domains/main.ml
+@@ -4,168 +4,170 @@ include dynlink
+ libraries = ""
+ readonly_files = "store.ml main.ml Plugin_0.ml Plugin_0_0.ml Plugin_0_0_0.ml Plugin_0_0_0_0.ml Plugin_0_0_0_1.ml Plugin_0_0_0_2.ml Plugin_1.ml Plugin_1_0.ml Plugin_1_0_0.ml Plugin_1_0_0_0.ml Plugin_1_1.ml Plugin_1_2.ml Plugin_1_2_0.ml Plugin_1_2_0_0.ml Plugin_1_2_1.ml Plugin_1_2_2.ml Plugin_1_2_2_0.ml Plugin_1_2_3.ml Plugin_1_2_3_0.ml"
+ 
+-*01 shared-libraries
+-*02 setup-ocamlc.byte-build-env
+-*03 ocamlc.byte
++* skip
++reason = "OCaml 5 only"
++**01 shared-libraries
++**02 setup-ocamlc.byte-build-env
++**03 ocamlc.byte
+ module = "store.ml"
+-*04 ocamlc.byte
++**04 ocamlc.byte
+ module = "Plugin_0.ml"
+-*05 ocamlc.byte
++**05 ocamlc.byte
+ module = "Plugin_0_0.ml"
+-*06 ocamlc.byte
++**06 ocamlc.byte
+ module = "Plugin_0_0_0.ml"
+-*07 ocamlc.byte
++**07 ocamlc.byte
+ module = "Plugin_0_0_0_0.ml"
+-*08 ocamlc.byte
++**08 ocamlc.byte
+ module = "Plugin_0_0_0_1.ml"
+-*09 ocamlc.byte
++**09 ocamlc.byte
+ module = "Plugin_0_0_0_2.ml"
+-*10 ocamlc.byte
++**10 ocamlc.byte
+ module = "Plugin_1.ml"
+-*11 ocamlc.byte
++**11 ocamlc.byte
+ module = "Plugin_1_0.ml"
+-*12 ocamlc.byte
++**12 ocamlc.byte
+ module = "Plugin_1_0_0.ml"
+-*13 ocamlc.byte
++**13 ocamlc.byte
+ module = "Plugin_1_0_0_0.ml"
+-*14 ocamlc.byte
++**14 ocamlc.byte
+ module = "Plugin_1_1.ml"
+-*15 ocamlc.byte
++**15 ocamlc.byte
+ module = "Plugin_1_2.ml"
+-*16 ocamlc.byte
++**16 ocamlc.byte
+ module = "Plugin_1_2_0.ml"
+-*17 ocamlc.byte
++**17 ocamlc.byte
+ module = "Plugin_1_2_0_0.ml"
+-*18 ocamlc.byte
++**18 ocamlc.byte
+ module = "Plugin_1_2_1.ml"
+-*19 ocamlc.byte
++**19 ocamlc.byte
+ module = "Plugin_1_2_2.ml"
+-*20 ocamlc.byte
++**20 ocamlc.byte
+ module = "Plugin_1_2_2_0.ml"
+-*21 ocamlc.byte
++**21 ocamlc.byte
+ module = "Plugin_1_2_3.ml"
+-*22 ocamlc.byte
++**22 ocamlc.byte
+ module = "Plugin_1_2_3_0.ml"
+-*23 ocamlc.byte
++**23 ocamlc.byte
+ module = "main.ml"
+-*24 ocamlc.byte
++**24 ocamlc.byte
+ program = "./main.byte.exe"
+ libraries= "dynlink"
+ all_modules = "store.cmo main.cmo"
+ module = ""
+-*25 run
+-*26 check-program-output
++**25 run
++**26 check-program-output
+ 
+-*02 native-dynlink
+-*03 setup-ocamlopt.byte-build-env
+-*04 ocamlopt.byte
++**02 native-dynlink
++**03 setup-ocamlopt.byte-build-env
++**04 ocamlopt.byte
+ flags = ""
+ module = "store.ml"
+-*05 ocamlopt.byte
++**05 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_0.cmxs"
+ module = ""
+ all_modules = "Plugin_0.ml"
+-*06 ocamlopt.byte
++**06 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_0_0.cmxs"
+ module = ""
+ all_modules = "Plugin_0_0.ml"
+-*07 ocamlopt.byte
++**07 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_0_0_0.cmxs"
+ module = ""
+ all_modules = "Plugin_0_0_0.ml"
+-*08 ocamlopt.byte
++**08 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_0_0_0_0.cmxs"
+ module = ""
+ all_modules = "Plugin_0_0_0_0.ml"
+-*09 ocamlopt.byte
++**09 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_0_0_0_1.cmxs"
+ module = ""
+ all_modules = "Plugin_0_0_0_1.ml"
+-*10 ocamlopt.byte
++**10 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_0_0_0_2.cmxs"
+ module = ""
+ all_modules = "Plugin_0_0_0_2.ml"
+-*11 ocamlopt.byte
++**11 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1.cmxs"
+ module = ""
+ all_modules = "Plugin_1.ml"
+-*12 ocamlopt.byte
++**12 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_0.cmxs"
+ module = ""
+ all_modules = "Plugin_1_0.ml"
+-*13 ocamlopt.byte
++**13 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_0_0.cmxs"
+ module = ""
+ all_modules = "Plugin_1_0_0.ml"
+-*14 ocamlopt.byte
++**14 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_0_0_0.cmxs"
+ module = ""
+ all_modules = "Plugin_1_0_0_0.ml"
+-*15 ocamlopt.byte
++**15 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_1.cmxs"
+ module = ""
+ all_modules = "Plugin_1_1.ml"
+-*16 ocamlopt.byte
++**16 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_2.cmxs"
+ module = ""
+ all_modules = "Plugin_1_2.ml"
+-*17 ocamlopt.byte
++**17 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_2_0.cmxs"
+ module = ""
+ all_modules = "Plugin_1_2_0.ml"
+-*18 ocamlopt.byte
++**18 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_2_0_0.cmxs"
+ module = ""
+ all_modules = "Plugin_1_2_0_0.ml"
+-*19 ocamlopt.byte
++**19 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_2_1.cmxs"
+ module = ""
+ all_modules = "Plugin_1_2_1.ml"
+-*20 ocamlopt.byte
++**20 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_2_2.cmxs"
+ module = ""
+ all_modules = "Plugin_1_2_2.ml"
+-*21 ocamlopt.byte
++**21 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_2_2_0.cmxs"
+ module = ""
+ all_modules = "Plugin_1_2_2_0.ml"
+-*22 ocamlopt.byte
++**22 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_2_3.cmxs"
+ module = ""
+ all_modules = "Plugin_1_2_3.ml"
+-*23 ocamlopt.byte
++**23 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_2_3_0.cmxs"
+ module = ""
+ all_modules = "Plugin_1_2_3_0.ml"
+-*24 ocamlopt.byte
++**24 ocamlopt.byte
+ flags = ""
+ module = "main.ml"
+-*25 ocamlopt.byte
++**25 ocamlopt.byte
+ program = "./main.exe"
+ libraries="dynlink"
+ all_modules = "store.cmx main.cmx"
+ module = ""
+-*26 run
+-*27 check-program-output
++**26 run
++**27 check-program-output
+ *)
+ 
+ (*  This module and all plugin modules are generated by a call to test_generator.ml with parameters:
+diff --git a/testsuite/tests/lib-dynlink-initializers/test10_main.byte.reference b/testsuite/tests/lib-dynlink-initializers/test10_main.byte.reference
+index 7b948d4878..2850bc02d2 100755
+--- a/testsuite/tests/lib-dynlink-initializers/test10_main.byte.reference
++++ b/testsuite/tests/lib-dynlink-initializers/test10_main.byte.reference
+@@ -3,10 +3,10 @@ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+ Called from Test10_plugin.g in file "test10_plugin.ml", line 3, characters 2-21
+ Called from Test10_plugin.f in file "test10_plugin.ml", line 6, characters 2-6
+ Called from Test10_plugin in file "test10_plugin.ml", line 10, characters 2-6
+-Called from Dynlink.Bytecode.run in file "otherlibs/dynlink/dynlink.ml", line 149, characters 16-25
+-Re-raised at Dynlink.Bytecode.run in file "otherlibs/dynlink/dynlink.ml", line 151, characters 6-137
+-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 363, characters 13-56
++Called from Dynlink.Bytecode.run in file "otherlibs/dynlink/dynlink.ml", line 152, characters 16-25
++Re-raised at Dynlink.Bytecode.run in file "otherlibs/dynlink/dynlink.ml", line 154, characters 6-137
++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
+ Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
+-Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 8-17
++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
++Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 381, characters 8-17
+ Called from Test10_main in file "test10_main.ml", line 51, characters 13-69
+diff --git a/testsuite/tests/lib-dynlink-initializers/test10_main.native.reference b/testsuite/tests/lib-dynlink-initializers/test10_main.native.reference
+index 26ef5fb57e..0ae204cce9 100755
+--- a/testsuite/tests/lib-dynlink-initializers/test10_main.native.reference
++++ b/testsuite/tests/lib-dynlink-initializers/test10_main.native.reference
+@@ -1,10 +1,14 @@
+ Error: Failure("Plugin error")
+-Raised by primitive operation at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
++Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++Called from Test10_plugin.g in file "test10_plugin.ml", line 2, characters 15-38
++Called from Test10_plugin in file "test10_plugin.ml", line 10, characters 2-6
++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
+ Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 87, characters 10-149
+ Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 363, characters 13-56
++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
+ Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
+-Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 8-17
+-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
++Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 381, characters 8-17
++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
+ Called from Test10_main in file "test10_main.ml", line 49, characters 30-87
+diff --git a/testsuite/tests/lib-format/mc_pr586_par.ml b/testsuite/tests/lib-format/mc_pr586_par.ml
+index 456a306ce7..da5c148416 100644
+--- a/testsuite/tests/lib-format/mc_pr586_par.ml
++++ b/testsuite/tests/lib-format/mc_pr586_par.ml
+@@ -1,4 +1,7 @@
+-(* TEST *)
++(* TEST
++   * skip
++   reason = "OCaml 5 only"
++*)
+ 
+ let () =
+   let domains = Array.init 7 (fun i ->
+diff --git a/testsuite/tests/lib-format/mc_pr586_par2.ml b/testsuite/tests/lib-format/mc_pr586_par2.ml
+index 0ead3627b5..8a96be1456 100644
+--- a/testsuite/tests/lib-format/mc_pr586_par2.ml
++++ b/testsuite/tests/lib-format/mc_pr586_par2.ml
+@@ -1,4 +1,7 @@
+-(* TEST *)
++(* TEST
++   * skip
++   reason = "OCaml 5 only"
++*)
+ 
+ let () =
+   let fmt_key = Format.synchronized_formatter_of_out_channel stdout in
+diff --git a/testsuite/tests/lib-marshal/intext_par.ml b/testsuite/tests/lib-marshal/intext_par.ml
+index 2efb846665..68ad0e1edb 100644
+--- a/testsuite/tests/lib-marshal/intext_par.ml
++++ b/testsuite/tests/lib-marshal/intext_par.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    modules = "intextaux_par.c"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ (* Test for output_value / input_value *)
+diff --git a/testsuite/tests/lib-obj/reachable_words_np.ml b/testsuite/tests/lib-obj/reachable_words_np.ml
+new file mode 100644
+index 0000000000..8a50268d20
+--- /dev/null
++++ b/testsuite/tests/lib-obj/reachable_words_np.ml
+@@ -0,0 +1,21 @@
++(* TEST
++ * naked_pointers
++ ** bytecode
++ ** native
++*)
++
++let native =
++  match Sys.backend_type with
++  | Sys.Native -> true
++  | Sys.Bytecode -> false
++  | Sys.Other s -> print_endline s; assert false
++
++let size x = Obj.reachable_words (Obj.repr x)
++
++let expect_size s x =
++  let i = size x in
++  if i <> s then
++    Printf.printf "size = %i; expected = %i\n%!" i s
++
++let () =
++  expect_size (if native then 0 else 3) (1, 2)
+diff --git a/testsuite/tests/lib-random/parallel.ml b/testsuite/tests/lib-random/parallel.ml
+index 68f567abec..90a78e2250 100644
+--- a/testsuite/tests/lib-random/parallel.ml
++++ b/testsuite/tests/lib-random/parallel.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+    include unix
+-   * libunix
+-   ** bytecode
+-   ** native
++   * skip
++   reason = "OCaml 5 only"
++   ** libunix
++   *** bytecode
++   *** native
+  *)
+ 
+ let () = Random.init 42
+diff --git a/testsuite/tests/lib-str/parallel.ml b/testsuite/tests/lib-str/parallel.ml
+index 23f2a5f7de..08055698e7 100644
+--- a/testsuite/tests/lib-str/parallel.ml
++++ b/testsuite/tests/lib-str/parallel.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasstr
++* skip
++reason = "OCaml 5 only"
++** hasstr
+ include str
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ let total = Atomic.make 0
+diff --git a/testsuite/tests/lib-sync/prodcons.ml b/testsuite/tests/lib-sync/prodcons.ml
+index 2e2c09756c..093d8740be 100644
+--- a/testsuite/tests/lib-sync/prodcons.ml
++++ b/testsuite/tests/lib-sync/prodcons.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ (* Classic producer-consumer *)
+diff --git a/testsuite/tests/lib-sync/trylock.ml b/testsuite/tests/lib-sync/trylock.ml
+index 314f1142ca..b4719fff04 100644
+--- a/testsuite/tests/lib-sync/trylock.ml
++++ b/testsuite/tests/lib-sync/trylock.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ (* Test Mutex.try_lock *)
+diff --git a/testsuite/tests/lib-sync/trylock2.ml b/testsuite/tests/lib-sync/trylock2.ml
+index b31ace08b5..e29ee93f9e 100644
+--- a/testsuite/tests/lib-sync/trylock2.ml
++++ b/testsuite/tests/lib-sync/trylock2.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ (* Test Mutex.try_lock *)
+diff --git a/testsuite/tests/lib-systhreads/multicore_lifecycle.ml b/testsuite/tests/lib-systhreads/multicore_lifecycle.ml
+index f481464906..0138046146 100644
+--- a/testsuite/tests/lib-systhreads/multicore_lifecycle.ml
++++ b/testsuite/tests/lib-systhreads/multicore_lifecycle.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hassysthreads
++* skip
++reason = "OCaml 5 only"
++** hassysthreads
+ include systhreads
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ let _ =
+diff --git a/testsuite/tests/lib-systhreads/test_c_thread_register.ml b/testsuite/tests/lib-systhreads/test_c_thread_register.ml
+index a8ec98aa9a..784fe6945f 100644
+--- a/testsuite/tests/lib-systhreads/test_c_thread_register.ml
++++ b/testsuite/tests/lib-systhreads/test_c_thread_register.ml
+@@ -2,9 +2,10 @@
+    modules = "test_c_thread_register_cstubs.c"
+    * hassysthreads
+    include systhreads
+-   ** not-bsd
+-   *** bytecode
+-   *** native
++   ** not-windows
++   *** not-bsd
++   **** bytecode
++   **** native
+ *)
+ 
+ (* spins a external thread from C and register it to the OCaml runtime *)
+diff --git a/testsuite/tests/lib-threads/uncaught_exception_handler.reference b/testsuite/tests/lib-threads/uncaught_exception_handler.reference
+index 31b97ca50a..cd68534b54 100644
+--- a/testsuite/tests/lib-threads/uncaught_exception_handler.reference
++++ b/testsuite/tests/lib-threads/uncaught_exception_handler.reference
+@@ -1,15 +1,15 @@
+ Thread 1 killed on uncaught exception Uncaught_exception_handler.CallbackExn
+ Raised at Uncaught_exception_handler.fn in file "uncaught_exception_handler.ml", line 28, characters 12-113
+-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+ [thread 2] caught Uncaught_exception_handler.CallbackExn
+ Raised at Uncaught_exception_handler.fn in file "uncaught_exception_handler.ml", line 28, characters 12-113
+-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+ Thread 2 killed on uncaught exception Uncaught_exception_handler.CallbackExn
+ Raised at Uncaught_exception_handler.fn in file "uncaught_exception_handler.ml", line 28, characters 12-113
+-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+ Thread 2 uncaught exception handler raised Uncaught_exception_handler.UncaughtHandlerExn
+ Raised at Uncaught_exception_handler.handler in file "uncaught_exception_handler.ml", line 26, characters 2-17
+-Called from Thread.create.(fun) in file "thread.ml", line 59, characters 10-41
++Called from Thread.create.(fun) in file "thread.ml", line 64, characters 10-41
+ [thread 3] caught Uncaught_exception_handler.CallbackExn
+ Raised at Uncaught_exception_handler.fn in file "uncaught_exception_handler.ml", line 28, characters 12-113
+-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+diff --git a/testsuite/tests/lib-unix/common/multicore_fork_domain_alone.ml b/testsuite/tests/lib-unix/common/multicore_fork_domain_alone.ml
+index 077a3dba66..78112d293e 100644
+--- a/testsuite/tests/lib-unix/common/multicore_fork_domain_alone.ml
++++ b/testsuite/tests/lib-unix/common/multicore_fork_domain_alone.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+ include unix
+-* hasunix
+-** not-windows
+-*** bytecode
+-*** native
++* skip
++reason = "OCaml 5 only"
++** hasunix
++*** not-windows
++**** bytecode
++**** native
+ *)
+ 
+ (* on Multicore, fork is not allowed is another domain is, and was running. *)
+diff --git a/testsuite/tests/lib-unix/common/multicore_fork_domain_alone2.ml b/testsuite/tests/lib-unix/common/multicore_fork_domain_alone2.ml
+index 929ed5ecf7..61f75dce4a 100644
+--- a/testsuite/tests/lib-unix/common/multicore_fork_domain_alone2.ml
++++ b/testsuite/tests/lib-unix/common/multicore_fork_domain_alone2.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+ include unix
+-* hasunix
+-** not-windows
+-*** bytecode
+-*** native
++* skip
++reason = "OCaml 5 only"
++** hasunix
++*** not-windows
++**** bytecode
++**** native
+ *)
+ 
+ (* on Multicore, fork is not allowed is another domain is, and was running. *)
+diff --git a/testsuite/tests/memory-model/forbidden.ml b/testsuite/tests/memory-model/forbidden.ml
+index afaa814ca5..d696a26e82 100644
+--- a/testsuite/tests/memory-model/forbidden.ml
++++ b/testsuite/tests/memory-model/forbidden.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+   modules="opt.ml barrier.ml hist.ml shared.ml run.ml outcome.ml"
++  * skip
++  reason = "OCaml 5 only"
+ *)
+ 
+ (* Memory model test:
+diff --git a/testsuite/tests/memory-model/publish.ml b/testsuite/tests/memory-model/publish.ml
+index 38fe83e57e..1c2737d8b6 100644
+--- a/testsuite/tests/memory-model/publish.ml
++++ b/testsuite/tests/memory-model/publish.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+   modules="opt.ml barrier.ml hist.ml shared.ml run.ml outcome.ml"
++  * skip
++  reason = "OCaml 5 only"
+ *)
+ 
+ (* Memory model: test the _publish idiom *)
+diff --git a/testsuite/tests/parallel/atomics.ml b/testsuite/tests/parallel/atomics.ml
+index 9c1d0a3cf2..b1f5813b4a 100644
+--- a/testsuite/tests/parallel/atomics.ml
++++ b/testsuite/tests/parallel/atomics.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ type u = U of unit
+diff --git a/testsuite/tests/parallel/backup_thread.ml b/testsuite/tests/parallel/backup_thread.ml
+index 05b06cc47c..c69f164ce7 100644
+--- a/testsuite/tests/parallel/backup_thread.ml
++++ b/testsuite/tests/parallel/backup_thread.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ 
+diff --git a/testsuite/tests/parallel/backup_thread_pipe.ml b/testsuite/tests/parallel/backup_thread_pipe.ml
+index 41fd101c1f..d0c5bb6e35 100644
+--- a/testsuite/tests/parallel/backup_thread_pipe.ml
++++ b/testsuite/tests/parallel/backup_thread_pipe.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ 
+diff --git a/testsuite/tests/parallel/constpromote.ml b/testsuite/tests/parallel/constpromote.ml
+index fc9fd65ff6..466c846ed1 100644
+--- a/testsuite/tests/parallel/constpromote.ml
++++ b/testsuite/tests/parallel/constpromote.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ (* when run with the bytecode debug runtime, this test
+diff --git a/testsuite/tests/parallel/deadcont.ml b/testsuite/tests/parallel/deadcont.ml
+index 6006323f45..bf6d7658a1 100644
+--- a/testsuite/tests/parallel/deadcont.ml
++++ b/testsuite/tests/parallel/deadcont.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ (*
+diff --git a/testsuite/tests/parallel/domain_dls.ml b/testsuite/tests/parallel/domain_dls.ml
+index db4ebe0c56..82d8f55e5a 100644
+--- a/testsuite/tests/parallel/domain_dls.ml
++++ b/testsuite/tests/parallel/domain_dls.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ let check_dls () =
+diff --git a/testsuite/tests/parallel/domain_dls2.ml b/testsuite/tests/parallel/domain_dls2.ml
+index 6c79145ba7..279f178774 100644
+--- a/testsuite/tests/parallel/domain_dls2.ml
++++ b/testsuite/tests/parallel/domain_dls2.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ let _ =
+diff --git a/testsuite/tests/parallel/domain_id.ml b/testsuite/tests/parallel/domain_id.ml
+index cc583ff508..f3baa3dde0 100644
+--- a/testsuite/tests/parallel/domain_id.ml
++++ b/testsuite/tests/parallel/domain_id.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ open Domain
+diff --git a/testsuite/tests/parallel/domain_parallel_spawn_burn.ml b/testsuite/tests/parallel/domain_parallel_spawn_burn.ml
+index 8a8a115141..20fd12d705 100644
+--- a/testsuite/tests/parallel/domain_parallel_spawn_burn.ml
++++ b/testsuite/tests/parallel/domain_parallel_spawn_burn.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ open Domain
+diff --git a/testsuite/tests/parallel/domain_serial_spawn_burn.ml b/testsuite/tests/parallel/domain_serial_spawn_burn.ml
+index e853c25865..30fa17d116 100644
+--- a/testsuite/tests/parallel/domain_serial_spawn_burn.ml
++++ b/testsuite/tests/parallel/domain_serial_spawn_burn.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ open Domain
+diff --git a/testsuite/tests/parallel/fib_threads.ml b/testsuite/tests/parallel/fib_threads.ml
+index f6005729b7..3ab3dde90d 100644
+--- a/testsuite/tests/parallel/fib_threads.ml
++++ b/testsuite/tests/parallel/fib_threads.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hassysthreads
++* skip
++reason = "OCaml 5 only"
++** hassysthreads
+ include systhreads
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ 
+diff --git a/testsuite/tests/parallel/join.ml b/testsuite/tests/parallel/join.ml
+index d270cca9bc..5a5c5b2464 100644
+--- a/testsuite/tests/parallel/join.ml
++++ b/testsuite/tests/parallel/join.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ let test_size =
+diff --git a/testsuite/tests/parallel/major_gc_wait_backup.ml b/testsuite/tests/parallel/major_gc_wait_backup.ml
+index e418500774..f11190aee3 100644
+--- a/testsuite/tests/parallel/major_gc_wait_backup.ml
++++ b/testsuite/tests/parallel/major_gc_wait_backup.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** native
+-** bytecode
++*** native
++*** bytecode
+ *)
+ 
+ type 'a tree = Empty | Node of 'a tree * 'a tree
+diff --git a/testsuite/tests/parallel/mctest.ml b/testsuite/tests/parallel/mctest.ml
+index c5d82d2dbd..bbebf9d4b8 100644
+--- a/testsuite/tests/parallel/mctest.ml
++++ b/testsuite/tests/parallel/mctest.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ (*
+diff --git a/testsuite/tests/parallel/multicore_systhreads.ml b/testsuite/tests/parallel/multicore_systhreads.ml
+index 2f0fcf20b0..5ce5ea86ea 100644
+--- a/testsuite/tests/parallel/multicore_systhreads.ml
++++ b/testsuite/tests/parallel/multicore_systhreads.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hassysthreads
++* skip
++reason = "OCaml 5 only"
++** hassysthreads
+ include systhreads
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ 
+diff --git a/testsuite/tests/parallel/pingpong.ml b/testsuite/tests/parallel/pingpong.ml
+index 30fb9eee71..6113340ccf 100644
+--- a/testsuite/tests/parallel/pingpong.ml
++++ b/testsuite/tests/parallel/pingpong.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ let r = ref (Some 0)
+diff --git a/testsuite/tests/parallel/poll.ml b/testsuite/tests/parallel/poll.ml
+index f07c0e0804..dd7a94f3cf 100644
+--- a/testsuite/tests/parallel/poll.ml
++++ b/testsuite/tests/parallel/poll.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ let continue = Atomic.make true
+diff --git a/testsuite/tests/parallel/prodcons_domains.ml b/testsuite/tests/parallel/prodcons_domains.ml
+index 67499d342a..e8e9d736f3 100644
+--- a/testsuite/tests/parallel/prodcons_domains.ml
++++ b/testsuite/tests/parallel/prodcons_domains.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+ 
+-* hassysthreads
++* skip
++reason = "OCaml 5 only"
++** hassysthreads
+ include systhreads
+-** bytecode
+-** native
++*** bytecode
++*** native
+ 
+ *)
+ 
+diff --git a/testsuite/tests/parallel/tak.ml b/testsuite/tests/parallel/tak.ml
+index a9b6874c4f..bdc4173266 100644
+--- a/testsuite/tests/parallel/tak.ml
++++ b/testsuite/tests/parallel/tak.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ (* filling minor heaps in parallel to trigger
+diff --git a/testsuite/tests/parallel/test_c_thread_register.ml b/testsuite/tests/parallel/test_c_thread_register.ml
+index 352424a377..9e2073c4ef 100644
+--- a/testsuite/tests/parallel/test_c_thread_register.ml
++++ b/testsuite/tests/parallel/test_c_thread_register.ml
+@@ -1,9 +1,11 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+    modules = "test_c_thread_register_cstubs.c"
+-   * hassysthreads
++   ** hassysthreads
+    include systhreads
+-   ** bytecode
+-   ** native
++   *** bytecode
++   *** native
+ *)
+ 
+ (* spins a external thread from C and register it to the OCaml runtime *)
+diff --git a/testsuite/tests/parallel/test_issue_11094.ml b/testsuite/tests/parallel/test_issue_11094.ml
+index ffc6d4bedd..8b9fb98c50 100644
+--- a/testsuite/tests/parallel/test_issue_11094.ml
++++ b/testsuite/tests/parallel/test_issue_11094.ml
+@@ -1,6 +1,8 @@
+ (* TEST
+-* bytecode
+-* native
++* skip
++reason = "OCaml 5 only"
++** bytecode
++** native
+ *)
+ 
+ open Effect
+diff --git a/testsuite/tests/regression/pr9326/gc_set.ml b/testsuite/tests/regression/pr9326/gc_set.ml
+index 2570aec28e..e9d7dbcd4c 100644
+--- a/testsuite/tests/regression/pr9326/gc_set.ml
++++ b/testsuite/tests/regression/pr9326/gc_set.ml
+@@ -4,35 +4,32 @@
+ open Gc
+ 
+ let min_heap_sz = 524288 (* 512k *)
+-let space_overhead = 70
+-let stack_limit = 4194304 (* 4M *)
+-let custom_major_ratio = 40
+-let custom_minor_ratio = 99
+-let custom_minor_max_size = 4096
++let maj_heap_inc = 4194304 (* 4M *)
+ 
+ let _ =
+   let g1 = Gc.get() in
+   (* Do not use { g1 with ... }, so that the code will break if more fields
+      are added to the Gc.control record type *)
+   Gc.set { minor_heap_size = min_heap_sz;
+-           major_heap_increment = g1.major_heap_increment;
+-           space_overhead = space_overhead;
++           major_heap_increment = maj_heap_inc;
++           space_overhead = g1.space_overhead;
+            verbose = g1.verbose;
+            max_overhead = g1.max_overhead;
+-           stack_limit = stack_limit;
++           stack_limit = g1.stack_limit;
+            allocation_policy = g1.allocation_policy;
+            window_size = g1.window_size;
+-           custom_major_ratio = custom_major_ratio;
+-           custom_minor_ratio = custom_minor_ratio;
+-           custom_minor_max_size = custom_minor_max_size };
++           custom_major_ratio = g1.custom_major_ratio;
++           custom_minor_ratio = g1.custom_minor_ratio;
++           custom_minor_max_size = g1.custom_minor_max_size };
+   let g2 = Gc.get() in
+   assert (g2.minor_heap_size = min_heap_sz);
+-  assert (g2.space_overhead = space_overhead);
++  assert (g2.major_heap_increment = maj_heap_inc);
++  assert (g2.space_overhead = g1.space_overhead);
+   assert (g2.verbose = g1.verbose);
+   assert (g2.max_overhead = g1.max_overhead);
+-  assert (g2.stack_limit = stack_limit);
++  assert (g2.stack_limit = g1.stack_limit);
+   assert (g2.allocation_policy = g1.allocation_policy);
+   assert (g2.window_size = g1.window_size);
+-  assert (g2.custom_major_ratio = custom_major_ratio);
+-  assert (g2.custom_minor_ratio = custom_minor_ratio);
+-  assert (g2.custom_minor_max_size = custom_minor_max_size)
++  assert (g2.custom_major_ratio = g1.custom_major_ratio);
++  assert (g2.custom_minor_ratio = g1.custom_minor_ratio);
++  assert (g2.custom_minor_max_size = g1.custom_minor_max_size)
+diff --git a/testsuite/tests/runtime-naked-pointers/cstubs.c b/testsuite/tests/runtime-naked-pointers/cstubs.c
+new file mode 100644
+index 0000000000..e9315f3aea
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/cstubs.c
+@@ -0,0 +1,20 @@
++#include <string.h>
++#include "caml/mlvalues.h"
++#include "caml/gc.h"
++#include "caml/memory.h"
++
++static int colors[4] = { Caml_white, Caml_gray, Caml_blue, Caml_black };
++
++value make_block(value header_size, value color, value size)
++{
++  intnat sz = Nativeint_val(size);
++  value * p = caml_stat_alloc((1 + sz) * sizeof(value));
++  p[0] = Make_header(Nativeint_val(header_size), 0, colors[Int_val(color)]);
++  memset(p + 1, 0x80, sz * sizeof(value));
++  return (value) (p + 1);
++}
++
++value make_raw_pointer (value v)
++{
++  return (value) Nativeint_val(v);
++}
+diff --git a/testsuite/tests/runtime-naked-pointers/np.ml b/testsuite/tests/runtime-naked-pointers/np.ml
+new file mode 100644
+index 0000000000..1738934ff0
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/np.ml
+@@ -0,0 +1,11 @@
++type color = White | Gray | Blue | Black
++
++external make_block: nativeint -> color -> nativeint -> Obj.t
++         = "make_block"
++
++external make_raw_pointer: nativeint -> Obj.t
++         = "make_raw_pointer"
++
++let do_gc root =
++  Gc.compact();   (* full major + compaction *)
++  root
+diff --git a/testsuite/tests/runtime-naked-pointers/np1.ml b/testsuite/tests/runtime-naked-pointers/np1.ml
+new file mode 100644
+index 0000000000..be4c677a23
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/np1.ml
+@@ -0,0 +1,12 @@
++(* TEST
++   modules = "cstubs.c np.ml"
++   * bytecode
++   * native
++*)
++
++open Np
++
++(* Out-of-heap object with black header is accepted even in no-naked-pointers
++   mode.  GC doesn't scan black objects. *)
++
++let x = do_gc [ make_block 100n Black 100n ]
+diff --git a/testsuite/tests/runtime-naked-pointers/np2.ml b/testsuite/tests/runtime-naked-pointers/np2.ml
+new file mode 100644
+index 0000000000..f24c813c2b
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/np2.ml
+@@ -0,0 +1,13 @@
++(* TEST
++   modules = "cstubs.c np.ml"
++   * bytecode
++   * native
++*)
++
++open Np
++
++(* Out-of-heap object with black header is accepted even in no-naked-pointers
++   mode.  GC doesn't scan black objects.  However, if the size in the
++   head is crazily big, the naked pointer detector will warn. *)
++
++let x = do_gc [ make_block (-1n) Black 100n ]
+diff --git a/testsuite/tests/runtime-naked-pointers/np2.run b/testsuite/tests/runtime-naked-pointers/np2.run
+new file mode 100755
+index 0000000000..c03f6f688d
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/np2.run
+@@ -0,0 +1,3 @@
++#!/bin/sh
++
++exec ${test_source_directory}/runtest.sh
+diff --git a/testsuite/tests/runtime-naked-pointers/np3.ml b/testsuite/tests/runtime-naked-pointers/np3.ml
+new file mode 100644
+index 0000000000..d207279df1
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/np3.ml
+@@ -0,0 +1,15 @@
++(* TEST
++   modules = "cstubs.c np.ml"
++   * naked_pointers
++   ** bytecode
++   ** native
++*)
++
++open Np
++
++(* Out-of-heap object with non-black header is OK in naked pointers mode only *)
++(* Note that the header size can be wrong as it should not be used by the GC *)
++
++let x = do_gc [ make_block 10000n White 10n;
++                make_block 1n Blue 0n;
++                make_block (-1n) Gray 5n ]
+diff --git a/testsuite/tests/runtime-naked-pointers/np3.run b/testsuite/tests/runtime-naked-pointers/np3.run
+new file mode 100755
+index 0000000000..c03f6f688d
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/np3.run
+@@ -0,0 +1,3 @@
++#!/bin/sh
++
++exec ${test_source_directory}/runtest.sh
+diff --git a/testsuite/tests/runtime-naked-pointers/np4.ml b/testsuite/tests/runtime-naked-pointers/np4.ml
+new file mode 100644
+index 0000000000..98966ddffc
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/np4.ml
+@@ -0,0 +1,13 @@
++(* TEST
++   modules = "cstubs.c np.ml"
++   * naked_pointers
++   ** bytecode
++   ** native
++*)
++
++open Np
++
++(* Null pointers and bad pointers outside the heap are OK
++   in naked pointers mode only *)
++
++let x = do_gc [ make_raw_pointer 0n; make_raw_pointer 42n ]
+diff --git a/testsuite/tests/runtime-naked-pointers/np4.run b/testsuite/tests/runtime-naked-pointers/np4.run
+new file mode 100755
+index 0000000000..c03f6f688d
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/np4.run
+@@ -0,0 +1,3 @@
++#!/bin/sh
++
++exec ${test_source_directory}/runtest.sh
+diff --git a/testsuite/tests/runtime-naked-pointers/runtest.sh b/testsuite/tests/runtime-naked-pointers/runtest.sh
+new file mode 100755
+index 0000000000..f5d4df561c
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/runtest.sh
+@@ -0,0 +1,10 @@
++#!/bin/sh
++
++if grep -q "#define NAKED_POINTERS_CHECKER" ${ocamlsrcdir}/runtime/caml/m.h \
++&& (echo ${program} | grep -q '\.opt')
++then
++  (${program} > ${output}) 2>&1 | grep -q '^Out-of-heap '
++  exit $?
++else
++  exec ${program} > ${output}
++fi
+diff --git a/testsuite/tests/shapes/comp_units.ml b/testsuite/tests/shapes/comp_units.ml
+index 1de07d7fcd..648f840099 100644
+--- a/testsuite/tests/shapes/comp_units.ml
++++ b/testsuite/tests/shapes/comp_units.ml
+@@ -25,7 +25,7 @@ module Mproj = Unit
+ module F (X : sig type t end) = X
+ [%%expect{|
+ {
+- "F"[module] -> Abs<.4>(X/277, X/277<.3>);
++ "F"[module] -> Abs<.4>(X/272, X/272<.3>);
+  }
+ module F : functor (X : sig type t end) -> sig type t = X.t end
+ |}]
+diff --git a/testsuite/tests/shapes/functors.ml b/testsuite/tests/shapes/functors.ml
+index a909d53ebb..09709b6bfe 100644
+--- a/testsuite/tests/shapes/functors.ml
++++ b/testsuite/tests/shapes/functors.ml
+@@ -17,7 +17,7 @@ module type S = sig type t val x : t end
+ module Falias (X : S) = X
+ [%%expect{|
+ {
+- "Falias"[module] -> Abs<.4>(X/279, X/279<.3>);
++ "Falias"[module] -> Abs<.4>(X/274, X/274<.3>);
+  }
+ module Falias : functor (X : S) -> sig type t = X.t val x : t end
+ |}]
+@@ -29,10 +29,10 @@ end
+ {
+  "Finclude"[module] ->
+      Abs<.6>
+-        (X/283,
++        (X/278,
+          {
+-          "t"[type] -> X/283<.5> . "t"[type];
+-          "x"[value] -> X/283<.5> . "x"[value];
++          "t"[type] -> X/278<.5> . "t"[type];
++          "x"[value] -> X/278<.5> . "x"[value];
+           });
+  }
+ module Finclude : functor (X : S) -> sig type t = X.t val x : t end
+@@ -45,7 +45,7 @@ end
+ [%%expect{|
+ {
+  "Fredef"[module] ->
+-     Abs<.10>(X/290, {
++     Abs<.10>(X/285, {
+                       "t"[type] -> <.8>;
+                       "x"[value] -> <.9>;
+                       });
+@@ -223,8 +223,8 @@ module Big_to_small1 : B2S = functor (X : Big) -> X
+ [%%expect{|
+ {
+  "Big_to_small1"[module] ->
+-     Abs<.40>(X/385, {<.39>
+-                      "t"[type] -> X/385<.39> . "t"[type];
++     Abs<.40>(X/380, {<.39>
++                      "t"[type] -> X/380<.39> . "t"[type];
+                       });
+  }
+ module Big_to_small1 : B2S
+@@ -234,8 +234,8 @@ module Big_to_small2 : B2S = functor (X : Big) -> struct include X end
+ [%%expect{|
+ {
+  "Big_to_small2"[module] ->
+-     Abs<.42>(X/388, {
+-                      "t"[type] -> X/388<.41> . "t"[type];
++     Abs<.42>(X/383, {
++                      "t"[type] -> X/383<.41> . "t"[type];
+                       });
+  }
+ module Big_to_small2 : B2S
+diff --git a/testsuite/tests/shapes/open_arg.ml b/testsuite/tests/shapes/open_arg.ml
+index e0c5025234..ffd3256e07 100644
+--- a/testsuite/tests/shapes/open_arg.ml
++++ b/testsuite/tests/shapes/open_arg.ml
+@@ -22,7 +22,7 @@ end = struct end
+ 
+ [%%expect{|
+ {
+- "Make"[module] -> Abs<.3>(I/279, {
++ "Make"[module] -> Abs<.3>(I/274, {
+                                    });
+  }
+ module Make : functor (I : sig end) -> sig end
+diff --git a/testsuite/tests/shapes/recmodules.ml b/testsuite/tests/shapes/recmodules.ml
+index 1911efd4fc..a889dba47b 100644
+--- a/testsuite/tests/shapes/recmodules.ml
++++ b/testsuite/tests/shapes/recmodules.ml
+@@ -43,8 +43,8 @@ and B : sig
+ end = B
+ [%%expect{|
+ {
+- "A"[module] -> A/302<.11>;
+- "B"[module] -> B/303<.12>;
++ "A"[module] -> A/297<.11>;
++ "B"[module] -> B/298<.12>;
+  }
+ module rec A : sig type t = Leaf of B.t end
+ and B : sig type t = int end
+@@ -82,13 +82,13 @@ end = Set.Make(A)
+  "ASet"[module] ->
+      {
+       "compare"[value] ->
+-          CU Stdlib . "Set"[module] . "Make"[module](A/324<.19>) .
++          CU Stdlib . "Set"[module] . "Make"[module](A/319<.19>) .
+           "compare"[value];
+       "elt"[type] ->
+-          CU Stdlib . "Set"[module] . "Make"[module](A/324<.19>) .
++          CU Stdlib . "Set"[module] . "Make"[module](A/319<.19>) .
+           "elt"[type];
+       "t"[type] ->
+-          CU Stdlib . "Set"[module] . "Make"[module](A/324<.19>) . "t"[type];
++          CU Stdlib . "Set"[module] . "Make"[module](A/319<.19>) . "t"[type];
+       };
+  }
+ module rec A :
+diff --git a/testsuite/tests/shapes/rotor_example.ml b/testsuite/tests/shapes/rotor_example.ml
+index e8f96a6c39..f02190e34a 100644
+--- a/testsuite/tests/shapes/rotor_example.ml
++++ b/testsuite/tests/shapes/rotor_example.ml
+@@ -26,7 +26,7 @@ end
+ {
+  "Pair"[module] ->
+      Abs<.9>
+-        (X/279, Abs(Y/280, {
++        (X/274, Abs(Y/275, {
+                             "t"[type] -> <.5>;
+                             "to_string"[value] -> <.6>;
+                             }));
+diff --git a/testsuite/tests/statmemprof/alloc_counts.ml b/testsuite/tests/statmemprof/alloc_counts.ml
+index de0d1e9e49..f8cbb5658d 100644
+--- a/testsuite/tests/statmemprof/alloc_counts.ml
++++ b/testsuite/tests/statmemprof/alloc_counts.ml
+@@ -1,7 +1,4 @@
+-(* TEST
+-* skip
+-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+-*)
++(* TEST *)
+ module MP = Gc.Memprof
+ 
+ let allocs_by_memprof f =
+diff --git a/testsuite/tests/statmemprof/arrays_in_major.ml b/testsuite/tests/statmemprof/arrays_in_major.ml
+index eb627324ba..78907a18e3 100644
+--- a/testsuite/tests/statmemprof/arrays_in_major.ml
++++ b/testsuite/tests/statmemprof/arrays_in_major.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    flags = "-g"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ *)
+ 
+ open Gc.Memprof
+diff --git a/testsuite/tests/statmemprof/arrays_in_major.reference b/testsuite/tests/statmemprof/arrays_in_major.reference
+new file mode 100644
+index 0000000000..1f34ad8ec8
+--- /dev/null
++++ b/testsuite/tests/statmemprof/arrays_in_major.reference
+@@ -0,0 +1,11 @@
++check_nosample
++check_counts_full_major
++check_counts_full_major
++check_no_nested
++check_distrib 300 3000 3 0.000010
++check_distrib 300 3000 1 0.000100
++check_distrib 300 3000 1 0.010000
++check_distrib 300 3000 1 0.900000
++check_distrib 300 300 100000 0.100000
++check_distrib 300000 300000 30 0.100000
++OK !
+diff --git a/testsuite/tests/statmemprof/arrays_in_minor.ml b/testsuite/tests/statmemprof/arrays_in_minor.ml
+index 4359642d0e..432f8b1d09 100644
+--- a/testsuite/tests/statmemprof/arrays_in_minor.ml
++++ b/testsuite/tests/statmemprof/arrays_in_minor.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    flags = "-g"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ *)
+ 
+ open Gc.Memprof
+diff --git a/testsuite/tests/statmemprof/arrays_in_minor.reference b/testsuite/tests/statmemprof/arrays_in_minor.reference
+new file mode 100644
+index 0000000000..1dad91939c
+--- /dev/null
++++ b/testsuite/tests/statmemprof/arrays_in_minor.reference
+@@ -0,0 +1,11 @@
++check_nosample
++check_counts_full_major
++check_counts_full_major
++check_no_nested
++check_distrib 1 250 1000 0.000010
++check_distrib 1 250 1000 0.000100
++check_distrib 1 250 1000 0.010000
++check_distrib 1 250 1000 0.900000
++check_distrib 1 1 10000000 0.010000
++check_distrib 250 250 100000 0.100000
++OK !
+diff --git a/testsuite/tests/statmemprof/blocking_in_callback.ml b/testsuite/tests/statmemprof/blocking_in_callback.ml
+index e1e40f1fb6..00f49cfc74 100644
+--- a/testsuite/tests/statmemprof/blocking_in_callback.ml
++++ b/testsuite/tests/statmemprof/blocking_in_callback.ml
+@@ -1,8 +1,6 @@
+ (* TEST
+ * hassysthreads
+ include systhreads
+-* skip
+-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ ** bytecode
+ ** native
+ *)
+diff --git a/testsuite/tests/statmemprof/callstacks.ml b/testsuite/tests/statmemprof/callstacks.ml
+index e864a50019..ec5a4199f0 100644
+--- a/testsuite/tests/statmemprof/callstacks.ml
++++ b/testsuite/tests/statmemprof/callstacks.ml
+@@ -3,15 +3,11 @@
+ 
+    * flat-float-array
+      reference = "${test_source_directory}/callstacks.flat-float-array.reference"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+    ** native
+    ** bytecode
+ 
+    * no-flat-float-array
+      reference = "${test_source_directory}/callstacks.no-flat-float-array.reference"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+    ** native
+    ** bytecode
+ *)
+diff --git a/testsuite/tests/statmemprof/comballoc.ml b/testsuite/tests/statmemprof/comballoc.ml
+index 60ca4a0123..22b2547101 100644
+--- a/testsuite/tests/statmemprof/comballoc.ml
++++ b/testsuite/tests/statmemprof/comballoc.ml
+@@ -1,10 +1,8 @@
+ (* TEST
+    flags = "-g"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+-   ** bytecode
++   * bytecode
+      reference = "${test_source_directory}/comballoc.byte.reference"
+-   ** native
++   * native
+      reference = "${test_source_directory}/comballoc.opt.reference"
+ *)
+ 
+diff --git a/testsuite/tests/statmemprof/custom.ml b/testsuite/tests/statmemprof/custom.ml
+index 41cf902ec8..f0ddfa7eed 100644
+--- a/testsuite/tests/statmemprof/custom.ml
++++ b/testsuite/tests/statmemprof/custom.ml
+@@ -1,7 +1,4 @@
+-(* TEST
+-* skip
+-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+-*)
++(* TEST *)
+ 
+ open Gc.Memprof
+ 
+diff --git a/testsuite/tests/statmemprof/exception_callback.ml b/testsuite/tests/statmemprof/exception_callback.ml
+index f9f02f690f..e1589372ab 100644
+--- a/testsuite/tests/statmemprof/exception_callback.ml
++++ b/testsuite/tests/statmemprof/exception_callback.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    exit_status = "2"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ *)
+ 
+ open Gc.Memprof
+diff --git a/testsuite/tests/statmemprof/exception_callback_minor.ml b/testsuite/tests/statmemprof/exception_callback_minor.ml
+index 0bb37782be..f514123276 100644
+--- a/testsuite/tests/statmemprof/exception_callback_minor.ml
++++ b/testsuite/tests/statmemprof/exception_callback_minor.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    exit_status = "2"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ *)
+ 
+ open Gc.Memprof
+diff --git a/testsuite/tests/statmemprof/intern.ml b/testsuite/tests/statmemprof/intern.ml
+index bebcc3c8ff..bce6f89c5c 100644
+--- a/testsuite/tests/statmemprof/intern.ml
++++ b/testsuite/tests/statmemprof/intern.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    flags = "-g"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ *)
+ 
+ open Gc.Memprof
+diff --git a/testsuite/tests/statmemprof/intern.reference b/testsuite/tests/statmemprof/intern.reference
+new file mode 100644
+index 0000000000..d83e8d6d50
+--- /dev/null
++++ b/testsuite/tests/statmemprof/intern.reference
+@@ -0,0 +1,10 @@
++check_nosample
++check_counts_full_major
++check_counts_full_major
++check_no_nested
++check_distrib 2 3000 3 0.000010
++check_distrib 2 3000 1 0.000100
++check_distrib 2 2000 1 0.010000
++check_distrib 2 2000 1 0.900000
++check_distrib 300000 300000 20 0.100000
++OK !
+diff --git a/testsuite/tests/statmemprof/lists_in_minor.ml b/testsuite/tests/statmemprof/lists_in_minor.ml
+index d08716c71b..ebd434857e 100644
+--- a/testsuite/tests/statmemprof/lists_in_minor.ml
++++ b/testsuite/tests/statmemprof/lists_in_minor.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    flags = "-g"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ *)
+ 
+ open Gc.Memprof
+diff --git a/testsuite/tests/statmemprof/lists_in_minor.reference b/testsuite/tests/statmemprof/lists_in_minor.reference
+new file mode 100644
+index 0000000000..11cfe0ca12
+--- /dev/null
++++ b/testsuite/tests/statmemprof/lists_in_minor.reference
+@@ -0,0 +1,8 @@
++check_distrib 10 1000000 0.010000
++check_distrib 1000000 10 0.000010
++check_distrib 1000000 10 0.000100
++check_distrib 1000000 10 0.001000
++check_distrib 1000000 10 0.010000
++check_distrib 100000 10 0.100000
++check_distrib 100000 10 0.900000
++OK !
+diff --git a/testsuite/tests/statmemprof/minor_no_postpone.ml b/testsuite/tests/statmemprof/minor_no_postpone.ml
+index 21c8bfb244..fcb94cf81d 100644
+--- a/testsuite/tests/statmemprof/minor_no_postpone.ml
++++ b/testsuite/tests/statmemprof/minor_no_postpone.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    modules = "minor_no_postpone_stub.c"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ *)
+ 
+ open Gc.Memprof
+diff --git a/testsuite/tests/statmemprof/moved_while_blocking.ml b/testsuite/tests/statmemprof/moved_while_blocking.ml
+index bb8dfc9848..8efc172aea 100644
+--- a/testsuite/tests/statmemprof/moved_while_blocking.ml
++++ b/testsuite/tests/statmemprof/moved_while_blocking.ml
+@@ -1,8 +1,6 @@
+ (* TEST
+ * hassysthreads
+ include systhreads
+-* skip
+-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ ** bytecode
+ ** native
+ *)
+diff --git a/testsuite/tests/statmemprof/thread_exit_in_callback.ml b/testsuite/tests/statmemprof/thread_exit_in_callback.ml
+index 28e2aabb8b..563be966a8 100644
+--- a/testsuite/tests/statmemprof/thread_exit_in_callback.ml
++++ b/testsuite/tests/statmemprof/thread_exit_in_callback.ml
+@@ -1,8 +1,6 @@
+ (* TEST
+ * hassysthreads
+ include systhreads
+-* skip
+-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ ** bytecode
+ ** native
+ *)
+@@ -12,7 +10,7 @@ let _ =
+   Gc.Memprof.(start ~callstack_size:10 ~sampling_rate:1.
+                 { null_tracker with alloc_minor = fun _ ->
+                       if Thread.id (Thread.self ()) <> main_thread then
+-                        Thread.exit ();
++                        raise Thread.Exit;
+                       None });
+   let t = Thread.create (fun () ->
+       ignore (Sys.opaque_identity (ref 1));
+@@ -21,6 +19,8 @@ let _ =
+   Thread.join t;
+   Gc.Memprof.stop ()
+ 
++[@@@ocaml.alert "-deprecated"]
++
+ let _ =
+   Gc.Memprof.(start ~callstack_size:10 ~sampling_rate:1.
+     { null_tracker with alloc_minor = fun _ -> Thread.exit (); None });
+diff --git a/testsuite/tests/tool-debugger/basic/debuggee.ml b/testsuite/tests/tool-debugger/basic/debuggee.ml
+index 8604edf239..91ad3c21dc 100644
+--- a/testsuite/tests/tool-debugger/basic/debuggee.ml
++++ b/testsuite/tests/tool-debugger/basic/debuggee.ml
+@@ -2,15 +2,13 @@
+ set foo = "bar"
+ flags += " -g "
+ ocamldebug_script = "${test_source_directory}/input_script"
+-* skip
+-reason = "ocamldebug is broken (#34)"
+-** debugger
+-*** shared-libraries
+-**** setup-ocamlc.byte-build-env
+-***** ocamlc.byte
+-****** check-ocamlc.byte-output
+-******* ocamldebug
+-******** check-program-output
++* debugger
++** shared-libraries
++*** setup-ocamlc.byte-build-env
++**** ocamlc.byte
++***** check-ocamlc.byte-output
++****** ocamldebug
++******* check-program-output
+ *)
+ 
+ print_endline Sys.argv.(1);;
+diff --git a/testsuite/tests/tool-debugger/dynlink/host.ml b/testsuite/tests/tool-debugger/dynlink/host.ml
+index c445c8acd3..f46ef8a022 100644
+--- a/testsuite/tests/tool-debugger/dynlink/host.ml
++++ b/testsuite/tests/tool-debugger/dynlink/host.ml
+@@ -7,29 +7,27 @@ libraries = ""
+ flags += " -g "
+ ocamldebug_script = "${test_source_directory}/input_script"
+ 
+-* skip
+-reason = "ocamldebug is broken (#34)"
+-** debugger
+-*** shared-libraries
+-**** setup-ocamlc.byte-build-env
+-***** ocamlc.byte
++* debugger
++** shared-libraries
++*** setup-ocamlc.byte-build-env
++**** ocamlc.byte
+ module = "host.ml"
+-****** ocamlc.byte
++***** ocamlc.byte
+ module = "plugin.ml"
+-******* ocamlc.byte
++****** ocamlc.byte
+ module = ""
+ all_modules = "host.cmo"
+ program = "${test_build_directory}/host.byte"
+ libraries = "dynlink"
+ 
+-******** run
++******* run
+ output = "host.output"
+-********* check-program-output
++******** check-program-output
+ reference = "${test_source_directory}/host.reference"
+ 
+-********* ocamldebug
++******** ocamldebug
+ output = "host.debug.output"
+-********** check-program-output
++********* check-program-output
+ reference = "${test_source_directory}/host.debug.reference"
+ 
+ *)
+diff --git a/testsuite/tests/tool-debugger/find-artifacts/debuggee.ml b/testsuite/tests/tool-debugger/find-artifacts/debuggee.ml
+index 7c6f00c70f..70aee3ff04 100644
+--- a/testsuite/tests/tool-debugger/find-artifacts/debuggee.ml
++++ b/testsuite/tests/tool-debugger/find-artifacts/debuggee.ml
+@@ -1,27 +1,25 @@
+ (* TEST
+ ocamldebug_script = "${test_source_directory}/input_script"
+-* skip
+-reason = "ocamldebug is broken (#34)"
+-** debugger
+-*** shared-libraries
+-**** setup-ocamlc.byte-build-env
+-***** script
++* debugger
++** shared-libraries
++*** setup-ocamlc.byte-build-env
++**** script
+ script = "mkdir out"
+-****** ocamlc.byte
++***** ocamlc.byte
+ flags = "-g -c"
+ all_modules = "${test_source_directory}/in/blah.ml"
+ program = "out/blah.cmo"
+-******* ocamlc.byte
++****** ocamlc.byte
+ program = "out/foo.cmo"
+ flags = "-I out -g -c"
+ all_modules = "${test_source_directory}/in/foo.ml"
+-******** ocamlc.byte
++******* ocamlc.byte
+ all_modules = "out/blah.cmo out/foo.cmo"
+ flags = " -g "
+ program = "debuggee.exe"
+-********* check-ocamlc.byte-output
+-********** ocamldebug
+-*********** check-program-output
++******** check-ocamlc.byte-output
++********* ocamldebug
++********** check-program-output
+ *)
+ 
+ (* This file only contains the specification of how to run the test *)
+diff --git a/testsuite/tests/tool-debugger/module_named_main/main.ml b/testsuite/tests/tool-debugger/module_named_main/main.ml
+index e31c16391e..25eebe7c02 100644
+--- a/testsuite/tests/tool-debugger/module_named_main/main.ml
++++ b/testsuite/tests/tool-debugger/module_named_main/main.ml
+@@ -1,15 +1,13 @@
+ (* TEST
+ flags += " -g "
+ ocamldebug_script = "${test_source_directory}/input_script"
+-* skip
+-reason = "ocamldebug is broken (#34)"
+-** debugger
+-*** shared-libraries
+-**** setup-ocamlc.byte-build-env
+-***** ocamlc.byte
+-****** check-ocamlc.byte-output
+-******* ocamldebug
+-******** check-program-output
++* debugger
++** shared-libraries
++*** setup-ocamlc.byte-build-env
++**** ocamlc.byte
++***** check-ocamlc.byte-output
++****** ocamldebug
++******* check-program-output
+ *)
+ 
+ module Submodule = struct
+diff --git a/testsuite/tests/tool-debugger/no_debug_event/noev.ml b/testsuite/tests/tool-debugger/no_debug_event/noev.ml
+index f06c14a117..4eb334ea84 100644
+--- a/testsuite/tests/tool-debugger/no_debug_event/noev.ml
++++ b/testsuite/tests/tool-debugger/no_debug_event/noev.ml
+@@ -1,30 +1,28 @@
+ (* TEST
+ readonly_files = "a.ml b.ml"
+ ocamldebug_script = "${test_source_directory}/input_script"
+-* skip
+-reason = "ocamldebug is broken (#34)"
+-** debugger
+-*** shared-libraries
+-**** setup-ocamlc.byte-build-env
+-***** ocamlc.byte
++* debugger
++** shared-libraries
++*** setup-ocamlc.byte-build-env
++**** ocamlc.byte
+ module = "a.ml"
+ flags = "-g -for-pack foo"
+-****** ocamlc.byte
++***** ocamlc.byte
+ module = ""
+ all_modules = "a.cmo"
+ program = "foo.cmo"
+ flags = "-g -pack"
+-******* ocamlc.byte
++****** ocamlc.byte
+ module = "b.ml"
+ flags = " -g "
+-******** ocamlc.byte
++******* ocamlc.byte
+ module = ""
+ flags = " -g "
+ all_modules = "foo.cmo b.cmo"
+ program = "${test_build_directory}/noev.exe"
+-********* check-ocamlc.byte-output
+-********** ocamldebug
+-*********** check-program-output
++******** check-ocamlc.byte-output
++********* ocamldebug
++********** check-program-output
+ *)
+ 
+ (* This file only contains the specification of how to run the test *)
+diff --git a/testsuite/tests/tool-debugger/printer/debuggee.ml b/testsuite/tests/tool-debugger/printer/debuggee.ml
+index b2d6e6e7c5..f22a4bd50f 100644
+--- a/testsuite/tests/tool-debugger/printer/debuggee.ml
++++ b/testsuite/tests/tool-debugger/printer/debuggee.ml
+@@ -3,17 +3,15 @@ flags += " -g "
+ ocamldebug_script = "${test_source_directory}/input_script"
+ readonly_files = "printer.ml"
+ include debugger
+-* skip
+-reason = "ocamldebug is broken (#34)"
+-** debugger
+-*** shared-libraries
+-**** setup-ocamlc.byte-build-env
+-***** ocamlc.byte
++* debugger
++** shared-libraries
++*** setup-ocamlc.byte-build-env
++**** ocamlc.byte
+ module = "printer.ml"
+-***** ocamlc.byte
+-****** check-ocamlc.byte-output
+-******* ocamldebug
+-******** check-program-output
++**** ocamlc.byte
++***** check-ocamlc.byte-output
++****** ocamldebug
++******* check-program-output
+ *)
+ 
+ let f x =
+diff --git a/testsuite/tests/typing-sigsubst/sigsubst.ml b/testsuite/tests/typing-sigsubst/sigsubst.ml
+index 5636e9abe2..53e430713c 100644
+--- a/testsuite/tests/typing-sigsubst/sigsubst.ml
++++ b/testsuite/tests/typing-sigsubst/sigsubst.ml
+@@ -24,11 +24,11 @@ end
+ Line 3, characters 2-36:
+ 3 |   include Comparable with type t = t
+       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+-Error: Illegal shadowing of included type t/284 by t/289
++Error: Illegal shadowing of included type t/279 by t/284
+        Line 2, characters 2-19:
+-         Type t/284 came from this include
++         Type t/279 came from this include
+        Line 3, characters 2-23:
+-         The value print has no valid type if t/284 is shadowed
++         The value print has no valid type if t/279 is shadowed
+ |}]
+ 
+ module type Sunderscore = sig
+diff --git a/testsuite/tests/unwind/unwind_test.reference b/testsuite/tests/unwind/unwind_test.reference
+index fbcd16e8e1..56a5f30733 100644
+--- a/testsuite/tests/unwind/unwind_test.reference
++++ b/testsuite/tests/unwind/unwind_test.reference
+@@ -1,5 +1,4 @@
+ ml_perform_stack_walk
+-caml_c_call
+ Mylib.baz
+ Driver.entry
+ caml_program
+diff --git a/testsuite/tests/weak-ephe-final/ephetest_par.ml b/testsuite/tests/weak-ephe-final/ephetest_par.ml
+index 744c4e844d..621d7292ff 100644
+--- a/testsuite/tests/weak-ephe-final/ephetest_par.ml
++++ b/testsuite/tests/weak-ephe-final/ephetest_par.ml
+@@ -1,4 +1,7 @@
+-(* TEST *)
++(* TEST
++   * skip
++   reason = "OCaml 5 only"
++ *)
+ 
+ (* Due to GCs running at non-deterministic places, the output from these tests
+  * are unreliable except the bad value checks and as a check for catastrophic
+diff --git a/testsuite/tests/weak-ephe-final/finaliser2.ml b/testsuite/tests/weak-ephe-final/finaliser2.ml
+index e8ab88e807..5cf871e7ac 100644
+--- a/testsuite/tests/weak-ephe-final/finaliser2.ml
++++ b/testsuite/tests/weak-ephe-final/finaliser2.ml
+@@ -1,4 +1,7 @@
+-(* TEST *)
++(* TEST
++   * skip
++   reason = "OCaml 5 only"
++*)
+ 
+ let[@inline never][@local never] test1 () =
+   let r' = ref 0 in
+diff --git a/testsuite/tests/weak-ephe-final/finaliser_handover.ml b/testsuite/tests/weak-ephe-final/finaliser_handover.ml
+index fa2d2efc43..752a7eeabf 100644
+--- a/testsuite/tests/weak-ephe-final/finaliser_handover.ml
++++ b/testsuite/tests/weak-ephe-final/finaliser_handover.ml
+@@ -1,4 +1,7 @@
+-(* TEST *)
++(* TEST
++   * skip
++   reason = "OCaml 5 only"
++*)
+ 
+ (* ocaml-multicore issues 528 and 468 *)
+ 
+diff --git a/testsuite/tests/weak-ephe-final/weaklifetime_par.ml b/testsuite/tests/weak-ephe-final/weaklifetime_par.ml
+index 7f80b8ab26..0791f4e53f 100644
+--- a/testsuite/tests/weak-ephe-final/weaklifetime_par.ml
++++ b/testsuite/tests/weak-ephe-final/weaklifetime_par.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ let size = 1000;;
+diff --git a/testsuite/tools/asmgen_i386.S b/testsuite/tools/asmgen_i386.S
+index 1d16b72d4e..956ec369ab 100644
+--- a/testsuite/tools/asmgen_i386.S
++++ b/testsuite/tools/asmgen_i386.S
+@@ -49,7 +49,7 @@ G(call_gen_code):
+ G(caml_c_call):
+         jmp     *%eax
+ 
+-        .comm   G(Caml_state), 4
++        .comm   G(caml_state), 4
+ 
+ /* Some tests are designed to cause registers to spill; on
+  * x86 we require the caml_extra_params symbol from the RTS. */
diff --git a/diff-against-trunk-system.diff b/diff-against-trunk-system.diff
new file mode 100644
index 0000000000..d60e2c3224
--- /dev/null
+++ b/diff-against-trunk-system.diff
@@ -0,0 +1,5827 @@
+diff --git a/.Diff-of-diff.diff b/.Diff-of-diff.diff
+new file mode 100644
+index 0000000000..e69de29bb2
+diff --git a/Changes b/Changes
+index a8b35ccf67..9a41022525 100644
+--- a/Changes
++++ b/Changes
+@@ -253,13 +253,13 @@ OCaml 4.14.0
+ - #10549: Stack overflow detection and naked pointers checking for ARM64
+   (Xavier Leroy, review by Stephen Dolan)
+ 
+-* #10675: Emit deprecation warnings when old C runtime function names
++* #10675, #10937: Emit deprecation warnings when old C runtime function names
+   are used.  This will break C stub code that uses these old names and
+   treats warnings as errors.  The workaround is to use the new names.
+   (Xavier Leroy and David Allsopp, review by Sébastien Hinderer and
+    Damien Doligez)
+ 
+-- #10698, #10726: Free the alternate signal stack when the main OCaml
++- #10698, #10726, #10891: Free the alternate signal stack when the main OCaml
+    code or an OCaml thread stops
+   (Xavier Leroy, review by David Allsopp and Damien Doligez)
+ 
+@@ -359,6 +359,9 @@ OCaml 4.14.0
+ - #10786: The implementation of Complex.norm now uses Float.hypot.
+   (Christophe Troestler, review by David Allsopp and Xavier Leroy)
+ 
++* #10922: Add deprecation warnings on {Int32,Int64,Nativeint}.format.
++  (Nicolás Ojeda Bär, review by Xavier Leroy and Florian Angeletti)
++
+ ### Other libraries:
+ 
+ - #10192: Add support for Unix domain sockets on Windows and use them
+@@ -607,6 +610,9 @@ OCaml 4.14.0
+ 
+ ### Build system:
+ 
++- #10828 Build native-code compilers on OpenBSD/aarch64
++  (Christopher Zimmermann)
++
+ - #10835 Disable DT_TEXTREL warnings on x86 32 bit architecture by passing
+   -Wl,-z,notext in mksharedlib and mkmaindll. Fixes relocation issues, reported
+   in #9800, making local patches in Debian, Alpine, and FreeBSD superfluous.
+diff --git a/Makefile.config.in b/Makefile.config.in
+index 6ee1453d88..97cca9a733 100644
+--- a/Makefile.config.in
++++ b/Makefile.config.in
+@@ -252,7 +252,7 @@ FLAT_FLOAT_ARRAY=@flat_float_array@
+ FUNCTION_SECTIONS=@function_sections@
+ AWK=@AWK@
+ STDLIB_MANPAGES=@stdlib_manpages@
+-NAKED_POINTERS=false
++NAKED_POINTERS=@naked_pointers@
+ 
+ ### Native command to build ocamlrun.exe
+ 
+diff --git a/VERSION b/VERSION
+index 8dfc6cf83f..4ef434f979 100644
+--- a/VERSION
++++ b/VERSION
+@@ -1,4 +1,4 @@
+-5.0.0+dev0-2021-11-05
++5.0.0+jst-backport
+ 
+ # Starting with OCaml 4.14, although the version string that appears above is
+ # still correct and this file can thus still be used to figure it out,
+diff --git a/api_docgen/Makefile.docfiles b/api_docgen/Makefile.docfiles
+index d85ccfb1a2..201f1e75c1 100644
+--- a/api_docgen/Makefile.docfiles
++++ b/api_docgen/Makefile.docfiles
+@@ -35,7 +35,8 @@ str_MLIS := str.mli
+ unix_MLIS := unix.mli unixLabels.mli
+ dynlink_MLIS := dynlink.mli
+ thread_MLIS := \
+-  thread.mli event.mli
++  thread.mli condition.mli mutex.mli event.mli \
++  semaphore.mli
+ 
+ STDLIB=$(STDLIB_MODULES)
+ 
+diff --git a/asmcomp/amd64/emit.mlp b/asmcomp/amd64/emit.mlp
+index 2e03adf10d..22a45aa904 100644
+--- a/asmcomp/amd64/emit.mlp
++++ b/asmcomp/amd64/emit.mlp
+@@ -63,6 +63,7 @@ let cfi_endproc () =
+ let cfi_adjust_cfa_offset n =
+   if Config.asm_cfi_supported then D.cfi_adjust_cfa_offset n
+ 
++(* BACKPORT
+ let cfi_remember_state () =
+   if Config.asm_cfi_supported then D.cfi_remember_state ()
+ 
+@@ -71,13 +72,16 @@ let cfi_restore_state () =
+ 
+ let cfi_def_cfa_register reg =
+   if Config.asm_cfi_supported then D.cfi_def_cfa_register reg
++*)
+ 
+ let emit_debug_info dbg =
+   emit_debug_info_gen dbg D.file D.loc
+ 
+ let fp = Config.with_frame_pointers
+ 
++(* BACKPORT
+ let stack_threshold_size = Config.stack_threshold * 8 (* bytes *)
++*)
+ 
+ let frame_size env =                     (* includes return address *)
+   if env.f.fun_frame_required then begin
+@@ -536,8 +540,9 @@ let emit_instr env fallthrough i =
+           end
+         end
+       end
+-  | Lop(Iextcall { func; alloc; stack_ofs }) ->
++  | Lop(Iextcall { func; alloc; stack_ofs = _ }) ->
+       add_used_symbol func;
++(* BACKPORT
+       let base_stack_size =
+         if Arch.win64 then
+           32 (* Windows x64 rcx+rdx+r8+r9 shadow stack *)
+@@ -549,11 +554,26 @@ let emit_instr env fallthrough i =
+         load_symbol_addr func rax;
+         emit_call "caml_c_call_stack_args";
+         record_frame env i.live (Dbg_other i.dbg);
+-      end else if alloc then begin
++      end else*) if alloc then begin
+         load_symbol_addr func rax;
+         emit_call "caml_c_call";
+         record_frame env i.live (Dbg_other i.dbg);
++(* BACKPORT BEGIN *)
++        if system <> S_win64 then begin
++
++          (* In amd64.S, "caml_c_call" tail-calls the C function (in order to
++             produce nicer backtraces), so we need to restore r15 manually after
++             it returns (note that this increases code size).
++
++             In amd64nt.asm (used for Win64), "caml_c_call" invokes the C
++             function via a regular call, and restores r15 itself, thus avoiding
++             the code size increase. *)
++
++          I.mov (domain_field Domainstate.Domain_young_ptr) r15
++        end
++(* BACKPORT END *)
+       end else begin
++(* BACKPORT
+         I.mov rsp rbp;
+         cfi_remember_state ();
+         cfi_def_cfa_register "rbp";
+@@ -561,10 +581,12 @@ let emit_instr env fallthrough i =
+            will not unwind through this unless we were to tag this
+            calling frame with cfi_signal_frame in it's definition. *)
+         I.mov (domain_field Domainstate.Domain_c_stack) rsp;
+-
++*)
+         emit_call func;
++(* BACKPORT
+         I.mov rbp rsp;
+         cfi_restore_state ();
++*)
+       end
+   | Lop(Istackoffset n) ->
+       if n < 0
+@@ -741,7 +763,10 @@ let emit_instr env fallthrough i =
+   | Lop(Ispecific(Izextend32)) ->
+       I.mov (arg32 i 0) (res32 i 0)
+   | Lop (Idls_get) ->
++      assert false
++(* BACKPORT
+       I.mov (domain_field Domainstate.Domain_dls_root) (res i 0)
++*)
+   | Lreloadretaddr ->
+       ()
+   | Lreturn ->
+@@ -845,12 +870,24 @@ let emit_instr env fallthrough i =
+       load_label_addr lbl_handler r11;
+       I.push r11;
+       cfi_adjust_cfa_offset 8;
++(* BACKPORT BEGIN
+       I.push (domain_field Domainstate.Domain_exn_handler);
++*)
++      I.push (domain_field Domainstate.Domain_exception_pointer);
++(* BACKPORT END *)
+       cfi_adjust_cfa_offset 8;
++(* BACKPORT BEGIN
+       I.mov rsp (domain_field Domainstate.Domain_exn_handler);
++*)
++      I.mov rsp (domain_field Domainstate.Domain_exception_pointer);
++(* BACKPORT END *)
+       env.stack_offset <- env.stack_offset + 16;
+   | Lpoptrap ->
++(* BACKPORT BEGIN
+       I.pop (domain_field Domainstate.Domain_exn_handler);
++*)
++      I.pop (domain_field Domainstate.Domain_exception_pointer);
++(* BACKPORT END *)
+       cfi_adjust_cfa_offset (-8);
+       I.add (int 8) rsp;
+       cfi_adjust_cfa_offset (-8);
+@@ -858,14 +895,26 @@ let emit_instr env fallthrough i =
+   | Lraise k ->
+       begin match k with
+       | Lambda.Raise_regular ->
++(* BACKPORT BEGIN *)
++          I.mov (int 0) (domain_field Domainstate.Domain_backtrace_pos);
++(* BACKPORT END *)
+           emit_call "caml_raise_exn";
+           record_frame env Reg.Set.empty (Dbg_raise i.dbg)
+       | Lambda.Raise_reraise ->
++(* BACKPORT BEGIN
+           emit_call "caml_reraise_exn";
++*)
++          emit_call "caml_raise_exn";
++(* BACKPORT END *)
+           record_frame env Reg.Set.empty (Dbg_raise i.dbg)
+       | Lambda.Raise_notrace ->
++(* BACKPORT BEGIN
+           I.mov (domain_field Domainstate.Domain_exn_handler) rsp;
+           I.pop (domain_field Domainstate.Domain_exn_handler);
++*)
++          I.mov (domain_field Domainstate.Domain_exception_pointer) rsp;
++          I.pop (domain_field Domainstate.Domain_exception_pointer);
++(* BACKPORT END *)
+           I.pop r11;
+           I.jmp r11
+       end
+@@ -898,6 +947,7 @@ let fundecl fundecl =
+   D.label (emit_symbol fundecl.fun_name);
+   emit_debug_info fundecl.fun_dbg;
+   cfi_startproc ();
++(* BACKPORT
+   if !Clflags.runtime_variant = "d" then
+     emit_call "caml_assert_stack_invariants";
+   let { max_frame_size; contains_nontail_calls} =
+@@ -914,9 +964,11 @@ let fundecl fundecl =
+     def_label ret;
+     handle_overflow := Some (overflow, ret)
+   end;
++*)
+   emit_all env true fundecl.fun_body;
+   List.iter emit_call_gc env.call_gc_sites;
+   emit_call_bound_errors env;
++(* BACKPORT
+   begin match !handle_overflow with
+   | None -> ()
+   | Some (overflow,ret) -> begin
+@@ -931,6 +983,7 @@ let fundecl fundecl =
+       I.jmp (label ret)
+     end
+   end;
++*)
+   if fundecl.fun_frame_required then begin
+     let n = (frame_size env) - 8 - (if fp then 8 else 0) in
+     if n <> 0
+diff --git a/asmcomp/amd64/proc.ml b/asmcomp/amd64/proc.ml
+index 64b05a95c8..dbeaff0cbe 100644
+--- a/asmcomp/amd64/proc.ml
++++ b/asmcomp/amd64/proc.ml
+@@ -297,12 +297,20 @@ let destroyed_at_c_call =
+   if win64 then
+     (* Win64: rbx, rsi, rdi, r12-r15, xmm6-xmm15 preserved *)
+     Array.of_list(List.map phys_reg
++(* BACKPORT BEGIN
+       [0;4;5;6;7;10;11;12;
++*)
++      [0;4;5;6;7;10;11;
++(* BACKPORT END *)
+        100;101;102;103;104;105])
+   else
+     (* Unix: rbx, r12-r15 preserved *)
+     Array.of_list(List.map phys_reg
++(* BACKPORT BEGIN
+       [0;2;3;4;5;6;7;10;11;12;
++*)
++      [0;2;3;4;5;6;7;10;11;
++(* BACKPORT END *)
+        100;101;102;103;104;105;106;107;
+        108;109;110;111;112;113;114;115])
+ 
+diff --git a/asmcomp/arm64/emit.mlp b/asmcomp/arm64/emit.mlp
+index 3a3a9e5d0a..b338424dad 100644
+--- a/asmcomp/arm64/emit.mlp
++++ b/asmcomp/arm64/emit.mlp
+@@ -35,8 +35,10 @@ let reg_trap_ptr = phys_reg 23 (* x26 *)
+ let reg_alloc_ptr = phys_reg 24 (* x27 *)
+ let reg_tmp1 = phys_reg 26 (* x16 *)
+ let reg_x8 = phys_reg 8 (* x8 *)
++(* BACKPORT
+ let reg_stack_arg_begin = phys_reg 17  (* x20 *)
+ let reg_stack_arg_end  = phys_reg 18 (* x21 *)
++*)
+ 
+ (* Output a label *)
+ 
+@@ -462,24 +464,38 @@ module BR = Branch_relaxation.Make (struct
+     | Lop (Itailcall_ind) -> epilogue_size f
+     | Lop (Itailcall_imm { func; _ }) ->
+       if func = f.fun_name then 1 else epilogue_size f
+-    | Lop (Iextcall {alloc; stack_ofs} ) ->
++    | Lop (Iextcall {alloc; stack_ofs = _} ) ->
++(* BACKPORT
+       if stack_ofs > 0 then 5
+-      else if alloc then 3
++      else*) if alloc then 3
++(* BACKPORT BEGIN
+       else 5
++*)
++      else 1
++(* BACKPORT END *)
+     | Lop (Istackoffset _) -> 2
++(* BACKPORT BEGIN
+     | Lop (Iload  { memory_chunk; addressing_mode; is_atomic }) ->
+       let based = match addressing_mode with Iindexed _ -> 0 | Ibased _ -> 1
+       and barrier = if is_atomic then 1 else 0
+       and single = match memory_chunk with Single -> 2 | _ -> 1 in
+       based + barrier + single
+     | Lop (Istore (memory_chunk, addressing_mode, assignment)) ->
++*)
++    | Lop (Iload  { memory_chunk; addressing_mode })
++    | Lop (Istore (memory_chunk, addressing_mode, _)) ->
++(* BACKPORT END *)
+       let based = match addressing_mode with Iindexed _ -> 0 | Ibased _ -> 1
++      in
++      based + begin match memory_chunk with Single -> 2 | _ -> 1 end
++(* BACKPORT
+       and barrier =
+         match memory_chunk, assignment with
+         | (Word_int | Word_val), true -> 1
+         | _ -> 0
+       and single = match memory_chunk with Single -> 2 | _ -> 1 in
+       based + barrier + single
++*)
+     | Lop (Ialloc _) when f.fun_fast -> 5
+     | Lop (Ispecific (Ifar_alloc _)) when f.fun_fast -> 6
+     | Lop (Ipoll _) -> 3
+@@ -538,7 +554,11 @@ module BR = Branch_relaxation.Make (struct
+     | Lpoptrap -> 1
+     | Lraise k ->
+       begin match k with
++(* BACKPORT BEGIN
+       | Lambda.Raise_regular -> 1
++*)
++      | Lambda.Raise_regular -> 2
++(* BACKPORT END *)
+       | Lambda.Raise_reraise -> 1
+       | Lambda.Raise_notrace -> 4
+       end
+@@ -726,7 +746,8 @@ let emit_instr env i =
+           `	b	{emit_label env.f.fun_tailrec_entry_point_label}\n`
+         else
+           output_epilogue env (fun () -> `	b	{emit_symbol func}\n`)
+-    | Lop(Iextcall {func; alloc; stack_ofs}) ->
++    | Lop(Iextcall {func; alloc; stack_ofs = _}) ->
++(* BACKPORT BEGIN
+         if stack_ofs > 0 then begin
+           ` mov {emit_reg reg_stack_arg_begin}, sp\n`;
+           ` add {emit_reg reg_stack_arg_end}, sp, #{emit_int (Misc.align stack_ofs 16)}\n`;
+@@ -734,9 +755,18 @@ let emit_instr env i =
+           ` bl  {emit_symbol "caml_c_call_stack_args"}\n`;
+           `{record_frame env i.live (Dbg_other i.dbg)}\n`
+         end else if alloc then begin
++*)
++        if not alloc then
++        `	bl	{emit_symbol func}\n`
++        else begin
++(* BACKPORT END *)
+           emit_load_symbol_addr reg_x8 func;
+           ` bl  {emit_symbol "caml_c_call"}\n`;
+           `{record_frame env i.live (Dbg_other i.dbg)}\n`
++(* BACKPORT BEGIN *)
++        end
++(* BACKPORT END *)
++(* BACKPORT
+         end else begin
+           (* store ocaml stack in the frame pointer register
+              NB: no need to store previous x29 because OCaml frames don't
+@@ -751,6 +781,7 @@ let emit_instr env i =
+           ` mov sp, x29\n`;
+           cfi_restore_state ()
+         end
++*)
+     | Lop(Istackoffset n) ->
+         assert (n mod 16 = 0);
+         emit_stack_adjustment (-n);
+@@ -791,7 +822,11 @@ let emit_instr env i =
+         | Double ->
+             `	ldr	{emit_reg dst}, {emit_addressing addressing_mode base}\n`
+         end
++(* BACKPORT BEGIN
+     | Lop(Istore(size, addr, assignment)) ->
++*)
++    | Lop(Istore(size, addr, _)) ->
++(* BACKPORT END *)
+         (* NB: assignments other than Word_int and Word_val do not follow the
+         Multicore OCaml memory model and so do not emit a barrier *)
+         let src = i.arg.(0) in
+@@ -814,7 +849,9 @@ let emit_instr env i =
+             `	str	s7, {emit_addressing addr base}\n`;
+         | Word_int | Word_val ->
+             (* memory model barrier for non-initializing store *)
++(* BACKPORT
+             if assignment then ` dmb ishld\n`;
++*)
+             `	str	{emit_reg src}, {emit_addressing addr base}\n`
+         | Double ->
+             `	str	{emit_reg src}, {emit_addressing addr base}\n`
+@@ -939,8 +976,13 @@ let emit_instr env i =
+     | Lop(Ispecific(Isignext size)) ->
+         `	sbfm	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, #0, #{emit_int (size - 1)}\n`
+     | Lop(Idls_get) ->
++(* BACKPORT BEGIN *)
++        assert false
++(* BACKPORT END *)
++(* BACKPORT
+         let offset = Domainstate.(idx_of_field Domain_dls_root) * 8 in
+         ` ldr {emit_reg i.res.(0)}, [{emit_reg reg_domain_state_ptr}, {emit_int offset}]\n`
++*)
+     | Lreloadretaddr ->
+         ()
+     | Lreturn ->
+@@ -1039,10 +1081,18 @@ let emit_instr env i =
+     | Lraise k ->
+         begin match k with
+         | Lambda.Raise_regular ->
++(* BACKPORT BEGIN *)
++          let offset = Domainstate.(idx_of_field Domain_backtrace_pos) * 8 in
++          `	str	xzr, [{emit_reg reg_domain_state_ptr}, {emit_int offset}]\n`;
++(* BACKPORT END *)
+           `	bl	{emit_symbol "caml_raise_exn"}\n`;
+           `{record_frame env Reg.Set.empty (Dbg_raise i.dbg)}\n`
+         | Lambda.Raise_reraise ->
++(* BACKPORT BEGIN
+           `	bl	{emit_symbol "caml_reraise_exn"}\n`;
++*)
++          `	bl	{emit_symbol "caml_raise_exn"}\n`;
++(* BACKPORT END *)
+           `{record_frame env Reg.Set.empty (Dbg_raise i.dbg)}\n`
+         | Lambda.Raise_notrace ->
+           `	mov	sp, {emit_reg reg_trap_ptr}\n`;
+@@ -1071,6 +1121,7 @@ let fundecl fundecl =
+     num_call_gc_and_check_bound_points env
+   in
+ 
++(* BACKPORT
+   (* Dynamic stack checking *)
+   let stack_threshold_size = Config.stack_threshold * 8 in (* bytes *)
+   let { max_frame_size; contains_nontail_calls} =
+@@ -1092,9 +1143,12 @@ let fundecl fundecl =
+     handle_overflow := Some (overflow, ret);
+     stack_check_size := 5
+   end;
++*)
+ 
+   let max_out_of_line_code_offset =
++(* BACKPORT
+     !stack_check_size +
++*)
+     max_out_of_line_code_offset ~num_call_gc
+       ~num_check_bound
+   in
+@@ -1107,6 +1161,7 @@ let fundecl fundecl =
+   assert (List.length env.call_gc_sites = num_call_gc);
+   assert (List.length env.bound_error_sites = num_check_bound);
+ 
++(* BACKPORT
+   begin match !handle_overflow with
+   | None -> ()
+   | Some (overflow,ret) -> begin
+@@ -1121,6 +1176,7 @@ let fundecl fundecl =
+       `  b {emit_label ret}\n`
+     end
+   end;
++*)
+ 
+   cfi_endproc();
+   emit_symbol_type emit_symbol fundecl.fun_name "function";
+diff --git a/asmcomp/cmm_helpers.ml b/asmcomp/cmm_helpers.ml
+index f92ec296a1..7fe7ef5c96 100644
+--- a/asmcomp/cmm_helpers.ml
++++ b/asmcomp/cmm_helpers.ml
+@@ -2203,8 +2203,13 @@ let assignment_kind
+     (init: Lambda.initialization_or_assignment) =
+   match init, ptr with
+   | Assignment, Pointer -> Caml_modify
++(* BACKPORT BEGIN
+   | Heap_initialization, Pointer
+   | Root_initialization, Pointer -> Caml_initialize
++*)
++  | Heap_initialization, Pointer -> Caml_initialize
++  | Root_initialization, Pointer -> Simple
++(* BACKPORT END *)
+   | Assignment, Immediate
+   | Heap_initialization, Immediate
+   | Root_initialization, Immediate -> Simple
+diff --git a/asmcomp/i386/emit.mlp b/asmcomp/i386/emit.mlp
+index b76af3687d..e3e85fe1b6 100644
+--- a/asmcomp/i386/emit.mlp
++++ b/asmcomp/i386/emit.mlp
+@@ -137,7 +137,7 @@ let domain_field f r =
+   mem32 DWORD (Domainstate.idx_of_field f * 8) r
+ 
+ let load_domain_state r =
+-  I.mov (sym32 "Caml_state") r
++  I.mov (sym32 "caml_state") r
+ 
+ let x86_data_type_for_stack_slot = function
+   | Float -> REAL8
+@@ -962,7 +962,7 @@ let begin_assembly() =
+     D.extrn "_caml_alloc3" PROC;
+     D.extrn "_caml_ml_array_bound_error" PROC;
+     D.extrn "_caml_raise_exn" PROC;
+-    D.extrn "_Caml_state" DWORD;
++    D.extrn "_caml_state" DWORD;
+   end;
+ 
+   D.data ();
+diff --git a/boot/ocamlc b/boot/ocamlc
+index c5bcc5dba3..804880e707 100755
+Binary files a/boot/ocamlc and b/boot/ocamlc differ
+diff --git a/boot/ocamllex b/boot/ocamllex
+index 13c44be1f3..9c4fe66628 100755
+Binary files a/boot/ocamllex and b/boot/ocamllex differ
+diff --git a/build-aux/ocaml_version.m4 b/build-aux/ocaml_version.m4
+index 2c66a918a3..0a59107ea8 100644
+--- a/build-aux/ocaml_version.m4
++++ b/build-aux/ocaml_version.m4
+@@ -36,7 +36,7 @@ m4_define([OCAML__VERSION_MINOR], [0])
+ m4_define([OCAML__VERSION_PATCHLEVEL], [0])
+ # Note that the OCAML__VERSION_EXTRA string defined below is always empty
+ # for officially-released versions of OCaml.
+-m4_define([OCAML__VERSION_EXTRA], [dev0-2021-11-05])
++m4_define([OCAML__VERSION_EXTRA], [jst-backport])
+ 
+ # The OCAML__VERSION_EXTRA_PREFIX macro defined below should be a
+ # single character:
+diff --git a/bytecomp/emitcode.ml b/bytecomp/emitcode.ml
+index ea423e50b7..bd961633a9 100644
+--- a/bytecomp/emitcode.ml
++++ b/bytecomp/emitcode.ml
+@@ -300,10 +300,14 @@ let emit_instr = function
+   | Kgetpubmet tag -> out opGETPUBMET; out_int tag; out_int 0
+   | Kgetdynmet -> out opGETDYNMET
+   | Kevent ev -> record_event ev
++(* BACKPORT BEGIN
+   | Kperform -> out opPERFORM
+   | Kresume -> out opRESUME
+   | Kresumeterm n -> out opRESUMETERM; out_int n
+   | Kreperformterm n -> out opREPERFORMTERM; out_int n
++*)
++  | Kperform | Kresume | Kresumeterm _ | Kreperformterm _ -> assert false
++(* BACKPORT END *)
+   | Kstop -> out opSTOP
+ 
+ (* Emission of a list of instructions. Include some peephole optimization. *)
+diff --git a/configure b/configure
+index c399043b88..bcea9b6884 100755
+Binary files a/configure and b/configure differ
+diff --git a/configure.ac b/configure.ac
+index dd7fc9a80c..940de94b1b 100644
+--- a/configure.ac
++++ b/configure.ac
+@@ -168,6 +168,8 @@ AC_SUBST([flexlink_flags])
+ AC_SUBST([PACKLD])
+ AC_SUBST([stdlib_manpages])
+ AC_SUBST([compute_deps])
++AC_SUBST([naked_pointers])
++AC_SUBST([naked_pointers_checker])
+ AC_SUBST([force_instrumented_runtime])
+ 
+ ## Generated files
+@@ -201,10 +203,10 @@ AC_CANONICAL_TARGET
+ # Systems that are known not to work, even in bytecode only.
+ 
+ AS_CASE([$host],
+-  [*-pc-windows],
+-    [AC_MSG_ERROR([the MSVC compiler is not supported currently], 69)],
+-  [*-*-cygwin*],
+-    [AC_MSG_ERROR([Cygwin is not supported currently], 69)],
++dnl   [*-pc-windows],
++dnl     [AC_MSG_ERROR([the MSVC compiler is not supported currently], 69)],
++dnl   [*-*-cygwin*],
++dnl    [AC_MSG_ERROR([Cygwin is not supported currently], 69)],
+   [i386-*-solaris*],
+     [AC_MSG_ERROR([Building for 32 bits target is not supported. \
+ If your host is 64 bits, you can try with './configure CC="gcc -m64"' \
+@@ -313,15 +315,23 @@ AC_ARG_ENABLE([frame-pointers],
+   [AS_HELP_STRING([--enable-frame-pointers],
+     [use frame pointers in runtime and generated code])])
+ 
+-AC_ARG_ENABLE([naked-pointers], [],
+-  [AS_IF([test "x$enableval" != 'xno'],
+-    [AC_MSG_ERROR([Naked pointers were prohibited in OCaml 5.0.])])],
+-  [])
++dnl AC_ARG_ENABLE([naked-pointers], [],
++dnl   [AS_IF([test "x$enableval" != 'xno'],
++dnl     [AC_MSG_ERROR([Naked pointers were prohibited in OCaml 5.0.])])],
++dnl   [])
+ 
+-AC_ARG_ENABLE([naked-pointers-checker], [],
+-  [AS_IF([test "x$enableval" != 'xno'],
+-    [AC_MSG_ERROR([The naked pointers checker was removed in OCaml 5.0.])])],
+-  [])
++dnl AC_ARG_ENABLE([naked-pointers-checker], [],
++dnl   [AS_IF([test "x$enableval" != 'xno'],
++dnl     [AC_MSG_ERROR(m4_normalize([The naked pointers checker was removed in
++dnl       OCaml 5.0.]))])],
++dnl   [])
++AC_ARG_ENABLE([naked-pointers],
++  [AS_HELP_STRING([--disable-naked-pointers],
++    [do not allow naked pointers])])
++
++AC_ARG_ENABLE([naked-pointers-checker],
++  [AS_HELP_STRING([--enable-naked-pointers-checker],
++    [enable the naked pointers checker])])
+ 
+ AC_ARG_ENABLE([spacetime], [],
+   [AS_IF([test "x$enableval" != 'xno'],
+@@ -1050,77 +1060,77 @@ model=default
+ system=unknown
+ 
+ AS_CASE([$host],
+-dnl [[i[3456]86-*-linux*]],
+-dnl   [arch=i386; system=linux_elf],
+-dnl [[i[3456]86-*-*bsd*]],
+-dnl   [arch=i386; system=bsd_elf],
+-dnl [[i[3456]86-*-haiku*]],
+-dnl   [arch=i386; system=beos],
+-dnl [[i[3456]86-*-cygwin]],
+-dnl   [arch=i386; system=cygwin],
+-dnl [[i[3456]86-*-gnu*]],
+-dnl   [arch=i386; system=gnu],
+-dnl [[i[3456]86-*-mingw32]],
+-dnl   [arch=i386; system=mingw],
+-dnl [i686-pc-windows],
+-dnl   [arch=i386; system=win32],
+-dnl [x86_64-pc-windows],
+-dnl   [arch=amd64; system=win64],
+-dnl [[powerpc64le*-*-linux*]],
+-dnl   [arch=power; model=ppc64le; system=elf],
+-dnl [[powerpc*-*-linux*]],
+-dnl   [arch=power; AS_IF([$arch64],[model=ppc64],[model=ppc]); system=elf],
+-dnl [[s390x*-*-linux*]],
+-dnl   [arch=s390x; model=z10; system=elf],
+-dnl # expected to match "gnueabihf" as well as "musleabihf"
+-dnl [armv6*-*-linux-*eabihf],
+-dnl   [arch=arm; model=armv6; system=linux_eabihf],
+-dnl [armv7*-*-linux-*eabihf],
+-dnl   [arch=arm; model=armv7; system=linux_eabihf],
+-dnl [armv8*-*-linux-*eabihf],
+-dnl   [arch=arm; model=armv8; system=linux_eabihf],
+-dnl [armv8*-*-linux-*eabi],
+-dnl   [arch=arm; model=armv8; system=linux_eabi],
+-dnl [armv7*-*-linux-*eabi],
+-dnl   [arch=arm; model=armv7; system=linux_eabi],
+-dnl [armv6t2*-*-linux-*eabi],
+-dnl   [arch=arm; model=armv6t2; system=linux_eabi],
+-dnl [armv6*-*-linux-*eabi],
+-dnl   [arch=arm; model=armv6; system=linux_eabi],
+-dnl [armv6*-*-freebsd*],
+-dnl   [arch=arm; model=armv6; system=freebsd],
+-dnl [earmv6*-*-netbsd*],
+-dnl   [arch=arm; model=armv6; system=netbsd],
+-dnl [earmv7*-*-netbsd*],
+-dnl   [arch=arm; model=armv7; system=netbsd],
+-dnl [armv5te*-*-linux-*eabi],
+-dnl   [arch=arm; model=armv5te; system=linux_eabi],
+-dnl [armv5*-*-linux-*eabi],
+-dnl   [arch=arm; model=armv5; system=linux_eabi],
+-dnl [arm*-*-linux-*eabihf],
+-dnl   [arch=arm; system=linux_eabihf],
+-dnl [arm*-*-linux-*eabi],
+-dnl   [arch=arm; system=linux_eabi],
+-dnl [arm*-*-openbsd*],
+-dnl   [arch=arm; system=bsd],
+-dnl [zaurus*-*-openbsd*],
+-dnl   [arch=arm; system=bsd],
++  [[i[3456]86-*-linux*]],
++    [arch=i386; system=linux_elf],
++  [[i[3456]86-*-*bsd*]],
++    [arch=i386; system=bsd_elf],
++  [[i[3456]86-*-haiku*]],
++    [arch=i386; system=beos],
++  [[i[3456]86-*-cygwin]],
++    [arch=i386; system=cygwin],
++  [[i[3456]86-*-gnu*]],
++    [arch=i386; system=gnu],
++  [[i[3456]86-*-mingw32]],
++    [arch=i386; system=mingw],
++  [i686-pc-windows],
++    [arch=i386; system=win32],
++  [x86_64-pc-windows],
++    [arch=amd64; system=win64],
++  [[powerpc64le*-*-linux*]],
++    [arch=power; model=ppc64le; system=elf],
++  [[powerpc*-*-linux*]],
++    [arch=power; AS_IF([$arch64],[model=ppc64],[model=ppc]); system=elf],
++  [[s390x*-*-linux*]],
++    [arch=s390x; model=z10; system=elf],
++  # expected to match "gnueabihf" as well as "musleabihf"
++  [armv6*-*-linux-*eabihf],
++    [arch=arm; model=armv6; system=linux_eabihf],
++  [armv7*-*-linux-*eabihf],
++    [arch=arm; model=armv7; system=linux_eabihf],
++  [armv8*-*-linux-*eabihf],
++    [arch=arm; model=armv8; system=linux_eabihf],
++  [armv8*-*-linux-*eabi],
++    [arch=arm; model=armv8; system=linux_eabi],
++  [armv7*-*-linux-*eabi],
++    [arch=arm; model=armv7; system=linux_eabi],
++  [armv6t2*-*-linux-*eabi],
++    [arch=arm; model=armv6t2; system=linux_eabi],
++  [armv6*-*-linux-*eabi],
++    [arch=arm; model=armv6; system=linux_eabi],
++  [armv6*-*-freebsd*],
++    [arch=arm; model=armv6; system=freebsd],
++  [earmv6*-*-netbsd*],
++    [arch=arm; model=armv6; system=netbsd],
++  [earmv7*-*-netbsd*],
++    [arch=arm; model=armv7; system=netbsd],
++  [armv5te*-*-linux-*eabi],
++    [arch=arm; model=armv5te; system=linux_eabi],
++  [armv5*-*-linux-*eabi],
++    [arch=arm; model=armv5; system=linux_eabi],
++  [arm*-*-linux-*eabihf],
++    [arch=arm; system=linux_eabihf],
++  [arm*-*-linux-*eabi],
++    [arch=arm; system=linux_eabi],
++  [arm*-*-openbsd*],
++    [arch=arm; system=bsd],
++  [zaurus*-*-openbsd*],
++    [arch=arm; system=bsd],
+   [x86_64-*-linux*],
+     [arch=amd64; system=linux],
+-dnl [x86_64-*-gnu*],
+-dnl   [arch=amd64; system=gnu],
+-dnl [x86_64-*-dragonfly*],
+-dnl   [arch=amd64; system=dragonfly],
+-dnl [x86_64-*-solaris*],
+-dnl   [arch=amd64; system=solaris],
++  [x86_64-*-gnu*],
++    [arch=amd64; system=gnu],
++  [x86_64-*-dragonfly*],
++    [arch=amd64; system=dragonfly],
++  [x86_64-*-solaris*],
++    [arch=amd64; system=solaris],
+   [x86_64-*-freebsd*],
+     [arch=amd64; system=freebsd],
+   [x86_64-*-netbsd*],
+     [arch=amd64; system=netbsd],
+   [x86_64-*-openbsd*],
+     [arch=amd64; system=openbsd],
+-dnl [x86_64-*-haiku*],
+-dnl   [arch=amd64; system=beos],
++  [x86_64-*-haiku*],
++    [arch=amd64; system=beos],
+   [arm64-*-darwin*],
+     [arch=arm64; system=macosx],
+   [aarch64-*-darwin*],
+@@ -1131,14 +1141,14 @@ dnl   [arch=amd64; system=beos],
+     [arch=amd64; system=mingw64],
+   [aarch64-*-linux*],
+     [arch=arm64; system=linux],
+-dnl [aarch64-*-freebsd*],
+-dnl   [arch=arm64; system=freebsd],
++  [aarch64-*-freebsd*],
++    [arch=arm64; system=freebsd],
+   [aarch64-*-openbsd*],
+     [arch=arm64; system=openbsd],
+-dnl [x86_64-*-cygwin*],
+-dnl   [arch=amd64; system=cygwin],
+-dnl [riscv64-*-linux*],
+-dnl   [arch=riscv; model=riscv64; system=linux]
++  [x86_64-*-cygwin*],
++    [arch=amd64; system=cygwin],
++  [riscv64-*-linux*],
++    [arch=riscv; model=riscv64; system=linux]
+ )
+ 
+ AS_CASE([$enable_native_compiler,$arch],
+@@ -1810,7 +1820,8 @@ AS_CASE([$arch,$system],
+ 
+ AS_CASE([$host],
+   [*-*-mingw32|*-pc-windows],
+-    [PTHREAD_LIBS="-lpthread"],
++dnl    [PTHREAD_LIBS="-lpthread"],
++    [PTHREAD_LIBS=''],
+   [AX_PTHREAD(
+     [common_cflags="$common_cflags $PTHREAD_CFLAGS"
+     saved_CFLAGS="$CFLAGS"
+@@ -1859,6 +1870,30 @@ AS_IF([test x"$enable_frame_pointers" = "xyes"],
+   [AC_MSG_NOTICE([not using frame pointers])
+   frame_pointers=false])
+ 
++## No naked pointers
++
++AS_IF([test x"$enable_naked_pointers" = "xno" ],
++  [naked_pointers=false
++   AC_DEFINE([NO_NAKED_POINTERS])],
++  [naked_pointers=true])
++
++AS_IF([test x"$enable_naked_pointers_checker" = "xyes" ],
++  [AS_IF([test x"$enable_naked_pointers" = "xno" ],
++         [AC_MSG_ERROR(m4_normalize([
++               --enable-naked-pointers-checker and --disable-naked-pointers
++               are incompatible]))])
++   AS_CASE(["$arch","$system"],
++    [amd64,linux|amd64,macosx \
++    |amd64,openbsd|amd64,win64 \
++    |amd64,freebsd|amd64,solaris \
++    |arm64,linux|arm64,macosx],
++      [naked_pointers_checker=true
++      AC_DEFINE([NAKED_POINTERS_CHECKER])],
++    [*],
++      [AC_MSG_ERROR([naked pointers checker not supported on this platform])]
++  )],
++  [naked_pointers_checker=false])
++
+ ## Check for mmap support for huge pages and contiguous heap
+ OCAML_MMAP_SUPPORTS_HUGE_PAGES
+ 
+@@ -1994,8 +2029,10 @@ AC_CHECK_LIB(execinfo, backtrace, cclibs="$cclibs -lexecinfo",[])
+ 
+ AS_CASE([$host],
+   [*-*-mingw32],
+-    [bytecclibs="-lws2_32 -lversion -lpthread -lgcc_eh -lDbgHelp"
+-    nativecclibs="-lws2_32 -lversion -lpthread -lgcc_eh -lDbgHelp"],
++dnl    [bytecclibs="-lws2_32 -lversion -lpthread -lgcc_eh -lDbgHelp"
++dnl    nativecclibs="-lws2_32 -lversion -lpthread -lgcc_eh -lDbgHelp"],
++    [bytecclibs="-lws2_32 -lversion -lgcc_eh -lDbgHelp"
++    nativecclibs="-lws2_32 -lversion -lgcc_eh -lDbgHelp"],
+   [*-pc-windows],
+     [bytecclibs="advapi32.lib ws2_32.lib version.lib"
+     nativecclibs="advapi32.lib ws2_32.lib version.lib"],
+diff --git a/diff-against-4.14-runtime.diff b/diff-against-4.14-runtime.diff
+new file mode 100644
+index 0000000000..d9e135d7b5
+--- /dev/null
++++ b/diff-against-4.14-runtime.diff
+@@ -0,0 +1,1672 @@
++diff --git a/otherlibs/systhreads/st_posix.h b/otherlibs/systhreads/st_posix.h
++index 957f4717b6..09b243f6a5 100644
++--- a/otherlibs/systhreads/st_posix.h
+++++ b/otherlibs/systhreads/st_posix.h
++@@ -446,7 +446,7 @@ static value st_encode_sigset(sigset_t * set)
++ 
++ static int sigmask_cmd[3] = { SIG_SETMASK, SIG_BLOCK, SIG_UNBLOCK };
++ 
++-value caml_thread_sigmask(value cmd, value sigs) /* ML */
+++value caml_thread_sigmask(value cmd, value sigs)
++ {
++   int how;
++   sigset_t set, oldset;
++@@ -463,7 +463,7 @@ value caml_thread_sigmask(value cmd, value sigs) /* ML */
++   return st_encode_sigset(&oldset);
++ }
++ 
++-value caml_wait_signal(value sigs) /* ML */
+++value caml_wait_signal(value sigs)
++ {
++ #ifdef HAS_SIGWAIT
++   sigset_t set;
++diff --git a/otherlibs/systhreads/st_stubs.c b/otherlibs/systhreads/st_stubs.c
++index 043e07031e..c1d8358e93 100644
++--- a/otherlibs/systhreads/st_stubs.c
+++++ b/otherlibs/systhreads/st_stubs.c
++@@ -430,7 +430,7 @@ static void caml_thread_reinitialize(void)
++ 
++ /* Initialize the thread machinery */
++ 
++-CAMLprim value caml_thread_initialize(value unit)   /* ML */
+++CAMLprim value caml_thread_initialize(value unit)
++ {
++   /* Protect against repeated initialization (PR#3532) */
++   if (curr_thread != NULL) return Val_unit;
++@@ -483,7 +483,7 @@ CAMLprim value caml_thread_initialize(value unit)   /* ML */
++    thread take 25ms on average / 50ms in the worst case, so we don't do it on
++    program exit. */
++ 
++-CAMLprim value caml_thread_cleanup(value unit)   /* ML */
+++CAMLprim value caml_thread_cleanup(value unit)
++ {
++   if (caml_tick_thread_running){
++     caml_tick_thread_stop = 1;
++@@ -524,7 +524,6 @@ static ST_THREAD_FUNCTION caml_thread_start(void * arg)
++ {
++   caml_thread_t th = (caml_thread_t) arg;
++   value clos;
++-  void * signal_stack;
++ #ifdef NATIVE_CODE
++   struct longjmp_buffer termination_buf;
++   char tos;
++@@ -537,7 +536,7 @@ static ST_THREAD_FUNCTION caml_thread_start(void * arg)
++   /* Acquire the global mutex */
++   caml_leave_blocking_section();
++   st_thread_set_id(Ident(th->descr));
++-  signal_stack = caml_setup_stack_overflow_detection();
+++  caml_setup_stack_overflow_detection();
++ #ifdef NATIVE_CODE
++   /* Setup termination handler (for caml_thread_exit) */
++   if (sigsetjmp(termination_buf.buf, 0) == 0) {
++@@ -551,12 +550,12 @@ static ST_THREAD_FUNCTION caml_thread_start(void * arg)
++ #ifdef NATIVE_CODE
++   }
++ #endif
++-  caml_stop_stack_overflow_detection(signal_stack);
+++  caml_stop_stack_overflow_detection();
++   /* The thread now stops running */
++   return 0;
++ }
++ 
++-CAMLprim value caml_thread_new(value clos)          /* ML */
+++CAMLprim value caml_thread_new(value clos)
++ {
++   caml_thread_t th;
++   st_retcode err;
++@@ -663,7 +662,7 @@ CAMLexport int caml_c_thread_unregister(void)
++ 
++ /* Return the current thread */
++ 
++-CAMLprim value caml_thread_self(value unit)         /* ML */
+++CAMLprim value caml_thread_self(value unit)
++ {
++   if (curr_thread == NULL)
++     caml_invalid_argument("Thread.self: not initialized");
++@@ -672,14 +671,14 @@ CAMLprim value caml_thread_self(value unit)         /* ML */
++ 
++ /* Return the identifier of a thread */
++ 
++-CAMLprim value caml_thread_id(value th)          /* ML */
+++CAMLprim value caml_thread_id(value th)
++ {
++   return Ident(th);
++ }
++ 
++ /* Print uncaught exception and backtrace */
++ 
++-CAMLprim value caml_thread_uncaught_exception(value exn)  /* ML */
+++CAMLprim value caml_thread_uncaught_exception(value exn)
++ {
++   char * msg = caml_format_exception(exn);
++   fprintf(stderr, "Thread %d killed on uncaught exception %s\n",
++@@ -692,7 +691,7 @@ CAMLprim value caml_thread_uncaught_exception(value exn)  /* ML */
++ 
++ /* Terminate current thread */
++ 
++-CAMLprim value caml_thread_exit(value unit)   /* ML */
+++CAMLprim value caml_thread_exit(value unit)
++ {
++   struct longjmp_buffer * exit_buf = NULL;
++ 
++@@ -723,7 +722,7 @@ CAMLprim value caml_thread_exit(value unit)   /* ML */
++ 
++ /* Allow re-scheduling */
++ 
++-CAMLprim value caml_thread_yield(value unit)        /* ML */
+++CAMLprim value caml_thread_yield(value unit)
++ {
++   if (st_masterlock_waiters(&caml_master_lock) == 0) return Val_unit;
++ 
++@@ -744,7 +743,7 @@ CAMLprim value caml_thread_yield(value unit)        /* ML */
++ 
++ /* Suspend the current thread until another thread terminates */
++ 
++-CAMLprim value caml_thread_join(value th)          /* ML */
+++CAMLprim value caml_thread_join(value th)
++ {
++   st_retcode rc = caml_threadstatus_wait(Terminated(th));
++   st_check_error(rc, "Thread.join");
++@@ -783,7 +782,7 @@ static struct custom_operations caml_mutex_ops = {
++   custom_fixed_length_default
++ };
++ 
++-CAMLprim value caml_mutex_new(value unit)        /* ML */
+++CAMLprim value caml_mutex_new(value unit)
++ {
++   st_mutex mut = NULL;          /* suppress warning */
++   value wrapper;
++@@ -794,7 +793,7 @@ CAMLprim value caml_mutex_new(value unit)        /* ML */
++   return wrapper;
++ }
++ 
++-CAMLprim value caml_mutex_lock(value wrapper)     /* ML */
+++CAMLprim value caml_mutex_lock(value wrapper)
++ {
++   st_mutex mut = Mutex_val(wrapper);
++   st_retcode retcode;
++@@ -811,7 +810,7 @@ CAMLprim value caml_mutex_lock(value wrapper)     /* ML */
++   return Val_unit;
++ }
++ 
++-CAMLprim value caml_mutex_unlock(value wrapper)           /* ML */
+++CAMLprim value caml_mutex_unlock(value wrapper)
++ {
++   st_mutex mut = Mutex_val(wrapper);
++   st_retcode retcode;
++@@ -821,7 +820,7 @@ CAMLprim value caml_mutex_unlock(value wrapper)           /* ML */
++   return Val_unit;
++ }
++ 
++-CAMLprim value caml_mutex_try_lock(value wrapper)           /* ML */
+++CAMLprim value caml_mutex_try_lock(value wrapper)
++ {
++   st_mutex mut = Mutex_val(wrapper);
++   st_retcode retcode;
++@@ -863,7 +862,7 @@ static struct custom_operations caml_condition_ops = {
++   custom_fixed_length_default
++ };
++ 
++-CAMLprim value caml_condition_new(value unit)        /* ML */
+++CAMLprim value caml_condition_new(value unit)
++ {
++   st_condvar cond = NULL;       /* suppress warning */
++   value wrapper;
++@@ -874,7 +873,7 @@ CAMLprim value caml_condition_new(value unit)        /* ML */
++   return wrapper;
++ }
++ 
++-CAMLprim value caml_condition_wait(value wcond, value wmut)           /* ML */
+++CAMLprim value caml_condition_wait(value wcond, value wmut)
++ {
++   st_condvar cond = Condition_val(wcond);
++   st_mutex mut = Mutex_val(wmut);
++@@ -889,14 +888,14 @@ CAMLprim value caml_condition_wait(value wcond, value wmut)           /* ML */
++   return Val_unit;
++ }
++ 
++-CAMLprim value caml_condition_signal(value wrapper)           /* ML */
+++CAMLprim value caml_condition_signal(value wrapper)
++ {
++   st_check_error(st_condvar_signal(Condition_val(wrapper)),
++                  "Condition.signal");
++   return Val_unit;
++ }
++ 
++-CAMLprim value caml_condition_broadcast(value wrapper)           /* ML */
+++CAMLprim value caml_condition_broadcast(value wrapper)
++ {
++   st_check_error(st_condvar_broadcast(Condition_val(wrapper)),
++                  "Condition.broadcast");
++diff --git a/otherlibs/systhreads/st_win32.h b/otherlibs/systhreads/st_win32.h
++index 3f598a715d..21eb674fc5 100644
++--- a/otherlibs/systhreads/st_win32.h
+++++ b/otherlibs/systhreads/st_win32.h
++@@ -525,13 +525,13 @@ static DWORD st_atfork(void (*fn)(void))
++ 
++ /* Signal handling -- none under Win32 */
++ 
++-value caml_thread_sigmask(value cmd, value sigs) /* ML */
+++value caml_thread_sigmask(value cmd, value sigs)
++ {
++   caml_invalid_argument("Thread.sigmask not implemented");
++   return Val_int(0);            /* not reached */
++ }
++ 
++-value caml_wait_signal(value sigs) /* ML */
+++value caml_wait_signal(value sigs)
++ {
++   caml_invalid_argument("Thread.wait_signal not implemented");
++   return Val_int(0);            /* not reached */
++diff --git a/runtime/Makefile b/runtime/Makefile
++index f5c08d8798..dee25dc02a 100644
++--- a/runtime/Makefile
+++++ b/runtime/Makefile
++@@ -26,7 +26,7 @@ BYTECODE_C_SOURCES := $(addsuffix .c, \
++   floats str array io extern intern hash sys meta parsing gc_ctrl md5 obj \
++   lexing callback debugger weak compact finalise custom dynlink \
++   afl $(UNIX_OR_WIN32) bigarray main memprof domain \
++-  skiplist codefrag)
+++  skiplist codefrag prng)
++ 
++ NATIVE_C_SOURCES := $(addsuffix .c, \
++   startup_aux startup_nat main fail_nat roots_nat signals \
++@@ -35,7 +35,7 @@ NATIVE_C_SOURCES := $(addsuffix .c, \
++   lexing $(UNIX_OR_WIN32) printexc callback weak compact finalise custom \
++   globroots backtrace_nat backtrace dynlink_nat debugger meta \
++   dynlink clambda_checks afl bigarray \
++-  memprof domain skiplist codefrag)
+++  memprof domain skiplist codefrag prng)
++ 
++ # Header files generated by configure
++ CONFIGURED_HEADERS := caml/m.h caml/s.h caml/version.h
++@@ -199,9 +199,9 @@ ld.conf: $(ROOTDIR)/Makefile.config
++ # CAMLprim value caml_foo() ...
++ # #else
++ # CAMLprim value caml_foo() ...
++-# end), horrible things will happen (duplicated entries in Runtimedef ->
+++# #endif), horrible things will happen: duplicated entries in Runtimedef ->
++ # double registration in Symtable -> empty entry in the PRIM table ->
++-# the bytecode interpreter is confused).
+++# the bytecode interpreter is confused.
++ # We sort the primitive file and remove duplicates to avoid this problem.
++ 
++ # Warning: we use "sort | uniq" instead of "sort -u" because in the MSVC
++diff --git a/runtime/bigarray.c b/runtime/bigarray.c
++index ed4ff67d21..03151f6946 100644
++--- a/runtime/bigarray.c
+++++ b/runtime/bigarray.c
++@@ -89,7 +89,7 @@ CAMLexport value
++ caml_ba_alloc(int flags, int num_dims, void * data, intnat * dim)
++ {
++   uintnat num_elts, asize, size;
++-  int i;
+++  int i, is_managed;
++   value res;
++   struct caml_ba_array * b;
++   intnat dimcopy[CAML_BA_MAX_NUM_DIMS];
++@@ -97,23 +97,23 @@ caml_ba_alloc(int flags, int num_dims, void * data, intnat * dim)
++   CAMLassert(num_dims >= 0 && num_dims <= CAML_BA_MAX_NUM_DIMS);
++   CAMLassert((flags & CAML_BA_KIND_MASK) <= CAML_BA_CHAR);
++   for (i = 0; i < num_dims; i++) dimcopy[i] = dim[i];
++-  size = 0;
++-  if (data == NULL) {
++-    num_elts = 1;
++-    for (i = 0; i < num_dims; i++) {
++-      if (caml_umul_overflow(num_elts, dimcopy[i], &num_elts))
++-        caml_raise_out_of_memory();
++-    }
++-    if (caml_umul_overflow(num_elts,
++-                           caml_ba_element_size[flags & CAML_BA_KIND_MASK],
++-                           &size))
+++  num_elts = 1;
+++  for (i = 0; i < num_dims; i++) {
+++    if (caml_umul_overflow(num_elts, dimcopy[i], &num_elts))
++       caml_raise_out_of_memory();
+++  }
+++  if (caml_umul_overflow(num_elts,
+++                         caml_ba_element_size[flags & CAML_BA_KIND_MASK],
+++                         &size))
+++    caml_raise_out_of_memory();
+++  if (data == NULL) {
++     data = malloc(size);
++     if (data == NULL && size != 0) caml_raise_out_of_memory();
++     flags |= CAML_BA_MANAGED;
++   }
++   asize = SIZEOF_BA_ARRAY + num_dims * sizeof(intnat);
++-  res = caml_alloc_custom_mem(&caml_ba_ops, asize, size);
+++  is_managed = ((flags & CAML_BA_MANAGED_MASK) == CAML_BA_MANAGED);
+++  res = caml_alloc_custom_mem(&caml_ba_ops, asize, is_managed ? size : 0);
++   b = Caml_ba_array_val(res);
++   b->data = data;
++   b->num_dims = num_dims;
++diff --git a/runtime/caml/alloc.h b/runtime/caml/alloc.h
++index 13f0fac2fb..816da799bb 100644
++--- a/runtime/caml/alloc.h
+++++ b/runtime/caml/alloc.h
++@@ -17,9 +17,6 @@
++ #define CAML_ALLOC_H
++ 
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "misc.h"
++ #include "mlvalues.h"
++ 
++diff --git a/runtime/caml/bigarray.h b/runtime/caml/bigarray.h
++index fc1fb14570..1664ae3f6e 100644
++--- a/runtime/caml/bigarray.h
+++++ b/runtime/caml/bigarray.h
++@@ -16,9 +16,6 @@
++ #ifndef CAML_BIGARRAY_H
++ #define CAML_BIGARRAY_H
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "config.h"
++ #include "mlvalues.h"
++ 
++diff --git a/runtime/caml/callback.h b/runtime/caml/callback.h
++index eef3342ec7..5c45995b8a 100644
++--- a/runtime/caml/callback.h
+++++ b/runtime/caml/callback.h
++@@ -18,9 +18,6 @@
++ #ifndef CAML_CALLBACK_H
++ #define CAML_CALLBACK_H
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "mlvalues.h"
++ 
++ #ifdef __cplusplus
++diff --git a/runtime/caml/camlatomic.h b/runtime/caml/camlatomic.h
++new file mode 100644
++index 0000000000..7206f0579a
++--- /dev/null
+++++ b/runtime/caml/camlatomic.h
++@@ -0,0 +1,85 @@
+++/**************************************************************************/
+++/*                                                                        */
+++/*                                 OCaml                                  */
+++/*                                                                        */
+++/*      KC Sivaramakrishnan, Indian Institute of Technology, Madras       */
+++/*                Stephen Dolan, University of Cambridge                  */
+++/*                                                                        */
+++/*   Copyright 2018 Indian Institute of Technology, Madras                */
+++/*   Copyright 2018 University of Cambridge                               */
+++/*                                                                        */
+++/*   All rights reserved.  This file is distributed under the terms of    */
+++/*   the GNU Lesser General Public License version 2.1, with the          */
+++/*   special exception on linking described in the file LICENSE.          */
+++/*                                                                        */
+++/**************************************************************************/
+++#ifndef CAML_ATOMIC_H
+++#define CAML_ATOMIC_H
+++
+++#include "config.h"
+++
+++/* On platforms supporting C11 atomics, this file just includes <stdatomic.h>.
+++
+++   On other platforms, this file includes platform-specific stubs for
+++   the subset of C11 atomics needed by the OCaml runtime
+++ */
+++
+++#ifdef __cplusplus
+++
+++extern "C++" {
+++#include <atomic>
+++#define ATOMIC_UINTNAT_INIT(x) (x)
+++typedef std::atomic<uintnat> atomic_uintnat;
+++typedef std::atomic<intnat> atomic_intnat;
+++using std::memory_order_relaxed;
+++using std::memory_order_acquire;
+++using std::memory_order_release;
+++using std::memory_order_acq_rel;
+++using std::memory_order_seq_cst;
+++}
+++
+++#elif defined(HAS_STDATOMIC_H)
+++
+++#include <stdatomic.h>
+++#define ATOMIC_UINTNAT_INIT(x) (x)
+++typedef _Atomic uintnat atomic_uintnat;
+++typedef _Atomic intnat atomic_intnat;
+++
+++#elif defined(__GNUC__)
+++
+++/* Support for versions of gcc which have built-in atomics but do not
+++   expose stdatomic.h (e.g. gcc 4.8) */
+++typedef enum memory_order {
+++  memory_order_relaxed = __ATOMIC_RELAXED,
+++  memory_order_acquire = __ATOMIC_ACQUIRE,
+++  memory_order_release = __ATOMIC_RELEASE,
+++  memory_order_acq_rel = __ATOMIC_ACQ_REL,
+++  memory_order_seq_cst = __ATOMIC_SEQ_CST
+++} memory_order;
+++
+++#define ATOMIC_UINTNAT_INIT(x) { (x) }
+++typedef struct { uintnat repr; } atomic_uintnat;
+++typedef struct { intnat repr; } atomic_intnat;
+++
+++#define atomic_load_explicit(x, m) __atomic_load_n(&(x)->repr, (m))
+++#define atomic_load(x) atomic_load_explicit((x), memory_order_seq_cst)
+++#define atomic_store_explicit(x, v, m) __atomic_store_n(&(x)->repr, (v), (m))
+++#define atomic_store(x, v) atomic_store_explicit((x), (v), memory_order_seq_cst)
+++#define atomic_compare_exchange_strong(x, oldv, newv) \
+++  __atomic_compare_exchange_n( \
+++    &(x)->repr, \
+++    (oldv), (newv), 0, \
+++    memory_order_seq_cst, memory_order_seq_cst)
+++#define atomic_exchange(x, newv) \
+++  __atomic_exchange_n(&(x)->repr, (newv), memory_order_seq_cst)
+++#define atomic_fetch_add(x, n) \
+++  __atomic_fetch_add(&(x)->repr, (n), memory_order_seq_cst)
+++#define atomic_fetch_or(x, n) \
+++  __atomic_fetch_or(&(x)->repr, (n), memory_order_seq_cst)
+++#define atomic_thread_fence __atomic_thread_fence
+++
+++#else
+++#error "C11 atomics are unavailable on this platform. See camlatomic.h"
+++#endif
+++
+++#endif /* CAML_ATOMIC_H */
++diff --git a/runtime/caml/compatibility.h b/runtime/caml/compatibility.h
++deleted file mode 100644
++index 1c109aa470..0000000000
++--- a/runtime/caml/compatibility.h
+++++ /dev/null
++@@ -1,373 +0,0 @@
++-/**************************************************************************/
++-/*                                                                        */
++-/*                                 OCaml                                  */
++-/*                                                                        */
++-/*           Damien Doligez, projet Moscova, INRIA Rocquencourt           */
++-/*                                                                        */
++-/*   Copyright 2003 Institut National de Recherche en Informatique et     */
++-/*     en Automatique.                                                    */
++-/*                                                                        */
++-/*   All rights reserved.  This file is distributed under the terms of    */
++-/*   the GNU Lesser General Public License version 2.1, with the          */
++-/*   special exception on linking described in the file LICENSE.          */
++-/*                                                                        */
++-/**************************************************************************/
++-
++-/* definitions for compatibility with old identifiers */
++-
++-#ifndef CAML_COMPATIBILITY_H
++-#define CAML_COMPATIBILITY_H
++-
++-/* internal global variables renamed between 4.02.1 and 4.03.0 */
++-#define caml_stat_top_heap_size Bsize_wsize(caml_stat_top_heap_wsz)
++-#define caml_stat_heap_size Bsize_wsize(caml_stat_heap_wsz)
++-
++-#ifndef CAML_NAME_SPACE
++-
++-/*
++-   #define --> CAMLextern  (defined with CAMLexport or CAMLprim)
++-   (rien)  --> CAMLprim
++-   g       --> global C identifier
++-   x       --> special case
++-
++-   SP* signals the special cases:
++-   - when the identifier was not simply prefixed with [caml_]
++-   - when the [caml_] version was already used for something else, and
++-     was renamed out of the way (watch out for [caml_alloc] and
++-     [caml_array_bound_error] in *.s)
++-*/
++-
++-/* a faire:
++-   - ui_*   (reverifier que win32.c n'en depend pas)
++-*/
++-
++-
++-/* **** alloc.c */
++-#define alloc CAML_DEPRECATED("alloc", "caml_alloc") caml_alloc /*SP*/
++-#define alloc_small CAML_DEPRECATED("alloc_small", "caml_alloc_small") caml_alloc_small
++-#define alloc_tuple CAML_DEPRECATED("alloc_tuple", "caml_alloc_tuple") caml_alloc_tuple
++-#define alloc_string CAML_DEPRECATED("alloc_string", "caml_alloc_string") caml_alloc_string
++-#define alloc_final CAML_DEPRECATED("alloc_final", "caml_alloc_final") caml_alloc_final
++-#define copy_string CAML_DEPRECATED("copy_string", "caml_copy_string") caml_copy_string
++-#define alloc_array CAML_DEPRECATED("alloc_array", "caml_alloc_array") caml_alloc_array
++-#define copy_string_array CAML_DEPRECATED("copy_string_array", "caml_copy_string_array") caml_copy_string_array
++-#define convert_flag_list CAML_DEPRECATED("convert_flag_list", "caml_convert_flag_list") caml_convert_flag_list
++-
++-/* **** array.c */
++-
++-/* **** backtrace.c */
++-#define backtrace_active CAML_DEPRECATED("backtrace_active", "caml_backtrace_active") caml_backtrace_active
++-#define backtrace_pos CAML_DEPRECATED("backtrace_pos", "caml_backtrace_pos") caml_backtrace_pos
++-#define backtrace_buffer CAML_DEPRECATED("backtrace_buffer", "caml_backtrace_buffer") caml_backtrace_buffer
++-#define backtrace_last_exn CAML_DEPRECATED("backtrace_last_exn", "caml_backtrace_last_exn") caml_backtrace_last_exn
++-#define print_exception_backtrace CAML_DEPRECATED("print_exception_backtrace", "caml_print_exception_backtrace") caml_print_exception_backtrace
++-
++-/* **** callback.c */
++-#define callback_depth CAML_DEPRECATED("callback_depth", "caml_callback_depth") caml_callback_depth
++-#define callbackN_exn CAML_DEPRECATED("callbackN_exn", "caml_callbackN_exn") caml_callbackN_exn
++-#define callback_exn CAML_DEPRECATED("callback_exn", "caml_callback_exn") caml_callback_exn
++-#define callback2_exn CAML_DEPRECATED("callback2_exn", "caml_callback2_exn") caml_callback2_exn
++-#define callback3_exn CAML_DEPRECATED("callback3_exn", "caml_callback3_exn") caml_callback3_exn
++-#define callback CAML_DEPRECATED("callback", "caml_callback") caml_callback
++-#define callback2 CAML_DEPRECATED("callback2", "caml_callback2") caml_callback2
++-#define callback3 CAML_DEPRECATED("callback3", "caml_callback3") caml_callback3
++-#define callbackN CAML_DEPRECATED("callbackN", "caml_callbackN") caml_callbackN
++-
++-/* **** compact.c */
++-
++-/* **** compare.c */
++-#define compare_unordered CAML_DEPRECATED("compare_unordered", "caml_compare_unordered") caml_compare_unordered
++-
++-/* **** custom.c */
++-#define alloc_custom CAML_DEPRECATED("alloc_custom", "caml_alloc_custom") caml_alloc_custom
++-#define register_custom_operations CAML_DEPRECATED("register_custom_operations", "caml_register_custom_operations") caml_register_custom_operations
++-
++-/* **** debugger.c */
++-
++-/* **** dynlink.c */
++-
++-/* **** extern.c */
++-#define output_val CAML_DEPRECATED("output_val", "caml_output_val") caml_output_val
++-#define output_value_to_malloc CAML_DEPRECATED("output_value_to_malloc", "caml_output_value_to_malloc") caml_output_value_to_malloc
++-#define output_value_to_block CAML_DEPRECATED("output_value_to_block", "caml_output_value_to_block") caml_output_value_to_block
++-#define serialize_int_1 CAML_DEPRECATED("serialize_int_1", "caml_serialize_int_1") caml_serialize_int_1
++-#define serialize_int_2 CAML_DEPRECATED("serialize_int_2", "caml_serialize_int_2") caml_serialize_int_2
++-#define serialize_int_4 CAML_DEPRECATED("serialize_int_4", "caml_serialize_int_4") caml_serialize_int_4
++-#define serialize_int_8 CAML_DEPRECATED("serialize_int_8", "caml_serialize_int_8") caml_serialize_int_8
++-#define serialize_float_4 CAML_DEPRECATED("serialize_float_4", "caml_serialize_float_4") caml_serialize_float_4
++-#define serialize_float_8 CAML_DEPRECATED("serialize_float_8", "caml_serialize_float_8") caml_serialize_float_8
++-#define serialize_block_1 CAML_DEPRECATED("serialize_block_1", "caml_serialize_block_1") caml_serialize_block_1
++-#define serialize_block_2 CAML_DEPRECATED("serialize_block_2", "caml_serialize_block_2") caml_serialize_block_2
++-#define serialize_block_4 CAML_DEPRECATED("serialize_block_4", "caml_serialize_block_4") caml_serialize_block_4
++-#define serialize_block_8 CAML_DEPRECATED("serialize_block_8", "caml_serialize_block_8") caml_serialize_block_8
++-#define serialize_block_float_8 CAML_DEPRECATED("serialize_block_float_8", "caml_serialize_block_float_8") caml_serialize_block_float_8
++-
++-/* **** fail.c */
++-#define external_raise CAML_DEPRECATED("external_raise", "caml_external_raise") caml_external_raise
++-#define mlraise CAML_DEPRECATED("mlraise", "caml_raise") caml_raise /*SP*/
++-#define raise_constant CAML_DEPRECATED("raise_constant", "caml_raise_constant") caml_raise_constant
++-#define raise_with_arg CAML_DEPRECATED("raise_with_arg", "caml_raise_with_arg") caml_raise_with_arg
++-#define raise_with_string CAML_DEPRECATED("raise_with_string", "caml_raise_with_string") caml_raise_with_string
++-#define failwith CAML_DEPRECATED("failwith", "caml_failwith") caml_failwith
++-#define invalid_argument CAML_DEPRECATED("invalid_argument", "caml_invalid_argument") caml_invalid_argument
++-#define array_bound_error CAML_DEPRECATED("array_bound_error", "caml_array_bound_error") caml_array_bound_error /*SP*/
++-#define raise_out_of_memory CAML_DEPRECATED("raise_out_of_memory", "caml_raise_out_of_memory") caml_raise_out_of_memory
++-#define raise_stack_overflow CAML_DEPRECATED("raise_stack_overflow", "caml_raise_stack_overflow") caml_raise_stack_overflow
++-#define raise_sys_error CAML_DEPRECATED("raise_sys_error", "caml_raise_sys_error") caml_raise_sys_error
++-#define raise_end_of_file CAML_DEPRECATED("raise_end_of_file", "caml_raise_end_of_file") caml_raise_end_of_file
++-#define raise_zero_divide CAML_DEPRECATED("raise_zero_divide", "caml_raise_zero_divide") caml_raise_zero_divide
++-#define raise_not_found CAML_DEPRECATED("raise_not_found", "caml_raise_not_found") caml_raise_not_found
++-#define raise_sys_blocked_io CAML_DEPRECATED("raise_sys_blocked_io", "caml_raise_sys_blocked_io") caml_raise_sys_blocked_io
++-/* **** runtime/fail_nat.c */
++-/* **** runtime/<arch>.s */
++-
++-/* **** finalise.c */
++-
++-/* **** fix_code.c */
++-
++-/* **** floats.c */
++-/*#define Double_val caml_Double_val             done in mlvalues.h as needed */
++-/*#define Store_double_val caml_Store_double_val done in mlvalues.h as needed */
++-#define copy_double CAML_DEPRECATED("copy_double", "caml_copy_double") caml_copy_double
++-
++-/* **** freelist.c */
++-
++-/* **** gc_ctrl.c */
++-
++-/* **** globroots.c */
++-#define register_global_root CAML_DEPRECATED("register_global_root", "caml_register_global_root") caml_register_global_root
++-#define remove_global_root CAML_DEPRECATED("remove_global_root", "caml_remove_global_root") caml_remove_global_root
++-
++-/* **** hash.c */
++-#define hash_variant CAML_DEPRECATED("hash_variant", "caml_hash_variant") caml_hash_variant
++-
++-/* **** instrtrace.c */
++-
++-/* **** intern.c */
++-#define input_val CAML_DEPRECATED("input_val", "caml_input_val") caml_input_val
++-#define input_val_from_string CAML_DEPRECATED("input_val_from_string", "caml_input_val_from_string") caml_input_val_from_string
++-#define input_value_from_malloc CAML_DEPRECATED("input_value_from_malloc", "caml_input_value_from_malloc") caml_input_value_from_malloc
++-#define input_value_from_block CAML_DEPRECATED("input_value_from_block", "caml_input_value_from_block") caml_input_value_from_block
++-#define deserialize_uint_1 CAML_DEPRECATED("deserialize_uint_1", "caml_deserialize_uint_1") caml_deserialize_uint_1
++-#define deserialize_sint_1 CAML_DEPRECATED("deserialize_sint_1", "caml_deserialize_sint_1") caml_deserialize_sint_1
++-#define deserialize_uint_2 CAML_DEPRECATED("deserialize_uint_2", "caml_deserialize_uint_2") caml_deserialize_uint_2
++-#define deserialize_sint_2 CAML_DEPRECATED("deserialize_sint_2", "caml_deserialize_sint_2") caml_deserialize_sint_2
++-#define deserialize_uint_4 CAML_DEPRECATED("deserialize_uint_4", "caml_deserialize_uint_4") caml_deserialize_uint_4
++-#define deserialize_sint_4 CAML_DEPRECATED("deserialize_sint_4", "caml_deserialize_sint_4") caml_deserialize_sint_4
++-#define deserialize_uint_8 CAML_DEPRECATED("deserialize_uint_8", "caml_deserialize_uint_8") caml_deserialize_uint_8
++-#define deserialize_sint_8 CAML_DEPRECATED("deserialize_sint_8", "caml_deserialize_sint_8") caml_deserialize_sint_8
++-#define deserialize_float_4 CAML_DEPRECATED("deserialize_float_4", "caml_deserialize_float_4") caml_deserialize_float_4
++-#define deserialize_float_8 CAML_DEPRECATED("deserialize_float_8", "caml_deserialize_float_8") caml_deserialize_float_8
++-#define deserialize_block_1 CAML_DEPRECATED("deserialize_block_1", "caml_deserialize_block_1") caml_deserialize_block_1
++-#define deserialize_block_2 CAML_DEPRECATED("deserialize_block_2", "caml_deserialize_block_2") caml_deserialize_block_2
++-#define deserialize_block_4 CAML_DEPRECATED("deserialize_block_4", "caml_deserialize_block_4") caml_deserialize_block_4
++-#define deserialize_block_8 CAML_DEPRECATED("deserialize_block_8", "caml_deserialize_block_8") caml_deserialize_block_8
++-#define deserialize_block_float_8 CAML_DEPRECATED("deserialize_block_float_8", "caml_deserialize_block_float_8") caml_deserialize_block_float_8
++-#define deserialize_error CAML_DEPRECATED("deserialize_error", "caml_deserialize_error") caml_deserialize_error
++-
++-/* **** interp.c */
++-
++-/* **** ints.c */
++-#define int32_ops CAML_DEPRECATED("int32_ops", "caml_int32_ops") caml_int32_ops
++-#define copy_int32 CAML_DEPRECATED("copy_int32", "caml_copy_int32") caml_copy_int32
++-/*#define Int64_val caml_Int64_val   *** done in mlvalues.h as needed */
++-#define int64_ops CAML_DEPRECATED("int64_ops", "caml_int64_ops") caml_int64_ops
++-#define copy_int64 CAML_DEPRECATED("copy_int64", "caml_copy_int64") caml_copy_int64
++-#define nativeint_ops CAML_DEPRECATED("nativeint_ops", "caml_nativeint_ops") caml_nativeint_ops
++-#define copy_nativeint CAML_DEPRECATED("copy_nativeint", "caml_copy_nativeint") caml_copy_nativeint
++-
++-/* **** io.c */
++-#define channel_mutex_free CAML_DEPRECATED("channel_mutex_free", "caml_channel_mutex_free") caml_channel_mutex_free
++-#define channel_mutex_lock CAML_DEPRECATED("channel_mutex_lock", "caml_channel_mutex_lock") caml_channel_mutex_lock
++-#define channel_mutex_unlock CAML_DEPRECATED("channel_mutex_unlock", "caml_channel_mutex_unlock") caml_channel_mutex_unlock
++-#define channel_mutex_unlock_exn CAML_DEPRECATED("channel_mutex_unlock_exn", "caml_channel_mutex_unlock_exn") caml_channel_mutex_unlock_exn
++-#define all_opened_channels CAML_DEPRECATED("all_opened_channels", "caml_all_opened_channels") caml_all_opened_channels
++-#define open_descriptor_in CAML_DEPRECATED("open_descriptor_in", "caml_open_descriptor_in") caml_open_descriptor_in /*SP*/
++-#define open_descriptor_out CAML_DEPRECATED("open_descriptor_out", "caml_open_descriptor_out") caml_open_descriptor_out /*SP*/
++-#define close_channel CAML_DEPRECATED("close_channel", "caml_close_channel") caml_close_channel /*SP*/
++-#define channel_size CAML_DEPRECATED("channel_size", "caml_channel_size") caml_channel_size /*SP*/
++-#define channel_binary_mode CAML_DEPRECATED("channel_binary_mode", "caml_channel_binary_mode") caml_channel_binary_mode
++-#define flush_partial CAML_DEPRECATED("flush_partial", "caml_flush_partial") caml_flush_partial /*SP*/
++-#define flush CAML_DEPRECATED("flush", "caml_flush") caml_flush /*SP*/
++-#define putword CAML_DEPRECATED("putword", "caml_putword") caml_putword
++-#define putblock CAML_DEPRECATED("putblock", "caml_putblock") caml_putblock
++-#define really_putblock CAML_DEPRECATED("really_putblock", "caml_really_putblock") caml_really_putblock
++-#define seek_out CAML_DEPRECATED("seek_out", "caml_seek_out") caml_seek_out /*SP*/
++-#define pos_out CAML_DEPRECATED("pos_out", "caml_pos_out") caml_pos_out /*SP*/
++-#define do_read CAML_DEPRECATED("do_read", "caml_do_read") caml_do_read
++-#define refill CAML_DEPRECATED("refill", "caml_refill") caml_refill
++-#define getword CAML_DEPRECATED("getword", "caml_getword") caml_getword
++-#define getblock CAML_DEPRECATED("getblock", "caml_getblock") caml_getblock
++-#define really_getblock CAML_DEPRECATED("really_getblock", "caml_really_getblock") caml_really_getblock
++-#define seek_in CAML_DEPRECATED("seek_in", "caml_seek_in") caml_seek_in /*SP*/
++-#define pos_in CAML_DEPRECATED("pos_in", "caml_pos_in") caml_pos_in /*SP*/
++-#define input_scan_line CAML_DEPRECATED("input_scan_line", "caml_input_scan_line") caml_input_scan_line /*SP*/
++-#define finalize_channel CAML_DEPRECATED("finalize_channel", "caml_finalize_channel") caml_finalize_channel
++-#define alloc_channel CAML_DEPRECATED("alloc_channel", "caml_alloc_channel") caml_alloc_channel
++-/*#define Val_file_offset caml_Val_file_offset   *** done in io.h as needed */
++-/*#define File_offset_val caml_File_offset_val   *** done in io.h as needed */
++-
++-/* **** lexing.c */
++-
++-/* **** main.c */
++-/* *** no change */
++-
++-/* **** major_gc.c */
++-#define heap_start CAML_DEPRECATED("heap_start", "caml_heap_start") caml_heap_start
++-#define page_table CAML_DEPRECATED("page_table", "caml_page_table") caml_page_table
++-
++-/* **** md5.c */
++-#define md5_string CAML_DEPRECATED("md5_string", "caml_md5_string") caml_md5_string
++-#define md5_chan CAML_DEPRECATED("md5_chan", "caml_md5_chan") caml_md5_chan
++-#define MD5Init CAML_DEPRECATED("MD5Init", "caml_MD5Init") caml_MD5Init
++-#define MD5Update CAML_DEPRECATED("MD5Update", "caml_MD5Update") caml_MD5Update
++-#define MD5Final CAML_DEPRECATED("MD5Final", "caml_MD5Final") caml_MD5Final
++-#define MD5Transform CAML_DEPRECATED("MD5Transform", "caml_MD5Transform") caml_MD5Transform
++-
++-/* **** memory.c */
++-#define alloc_shr CAML_DEPRECATED("alloc_shr", "caml_alloc_shr") caml_alloc_shr
++-#define initialize CAML_DEPRECATED("initialize", "caml_initialize") caml_initialize
++-#define modify CAML_DEPRECATED("modify", "caml_modify") caml_modify
++-#define stat_alloc CAML_DEPRECATED("stat_alloc", "caml_stat_alloc") caml_stat_alloc
++-#define stat_free CAML_DEPRECATED("stat_free", "caml_stat_free") caml_stat_free
++-#define stat_resize CAML_DEPRECATED("stat_resize", "caml_stat_resize") caml_stat_resize
++-
++-/* **** meta.c */
++-
++-/* **** minor_gc.c */
++-#define young_start CAML_DEPRECATED("young_start", "caml_young_start") caml_young_start
++-#define young_end CAML_DEPRECATED("young_end", "caml_young_end") caml_young_end
++-#define young_ptr CAML_DEPRECATED("young_ptr", "caml_young_ptr") caml_young_ptr
++-#define young_limit CAML_DEPRECATED("young_limit", "caml_young_limit") caml_young_limit
++-#define ref_table CAML_DEPRECATED("ref_table", "caml_ref_table") caml_ref_table
++-#define minor_collection CAML_DEPRECATED("minor_collection", "caml_minor_collection") caml_minor_collection
++-#define check_urgent_gc CAML_DEPRECATED("check_urgent_gc", "caml_check_urgent_gc") caml_check_urgent_gc
++-
++-/* **** misc.c */
++-
++-/* **** obj.c */
++-
++-/* **** parsing.c */
++-
++-/* **** prims.c */
++-
++-/* **** printexc.c */
++-#define format_caml_exception CAML_DEPRECATED("format_caml_exception", "caml_format_exception") caml_format_exception /*SP*/
++-
++-/* **** roots.c */
++-#define local_roots CAML_DEPRECATED("local_roots", "caml_local_roots") caml_local_roots
++-#define scan_roots_hook CAML_DEPRECATED("scan_roots_hook", "caml_scan_roots_hook") caml_scan_roots_hook
++-#define do_local_roots CAML_DEPRECATED("do_local_roots", "caml_do_local_roots") caml_do_local_roots
++-
++-/* **** signals.c */
++-#define pending_signals CAML_DEPRECATED("pending_signals", "caml_pending_signals") caml_pending_signals
++-#define something_to_do CAML_DEPRECATED("something_to_do", "caml_something_to_do") caml_something_to_do
++-#define enter_blocking_section_hook CAML_DEPRECATED("enter_blocking_section_hook", "caml_enter_blocking_section_hook") caml_enter_blocking_section_hook
++-#define leave_blocking_section_hook CAML_DEPRECATED("leave_blocking_section_hook", "caml_leave_blocking_section_hook") caml_leave_blocking_section_hook
++-#define enter_blocking_section CAML_DEPRECATED("enter_blocking_section", "caml_enter_blocking_section") caml_enter_blocking_section
++-#define leave_blocking_section CAML_DEPRECATED("leave_blocking_section", "caml_leave_blocking_section") caml_leave_blocking_section
++-#define convert_signal_number CAML_DEPRECATED("convert_signal_number", "caml_convert_signal_number") caml_convert_signal_number
++-
++-/* **** runtime/signals.c */
++-#define garbage_collection CAML_DEPRECATED("garbage_collection", "caml_garbage_collection") caml_garbage_collection
++-
++-/* **** stacks.c */
++-#define stack_low CAML_DEPRECATED("stack_low", "caml_stack_low") caml_stack_low
++-#define stack_high CAML_DEPRECATED("stack_high", "caml_stack_high") caml_stack_high
++-#define stack_threshold CAML_DEPRECATED("stack_threshold", "caml_stack_threshold") caml_stack_threshold
++-#define extern_sp CAML_DEPRECATED("extern_sp", "caml_extern_sp") caml_extern_sp
++-#define trapsp CAML_DEPRECATED("trapsp", "caml_trapsp") caml_trapsp
++-#define trap_barrier CAML_DEPRECATED("trap_barrier", "caml_trap_barrier") caml_trap_barrier
++-
++-/* **** startup.c */
++-#define atom_table CAML_DEPRECATED("atom_table", "caml_atom_table") caml_atom_table
++-/* **** runtime/startup_nat.c */
++-#define static_data_start CAML_DEPRECATED("static_data_start", "caml_static_data_start") caml_static_data_start
++-#define static_data_end CAML_DEPRECATED("static_data_end", "caml_static_data_end") caml_static_data_end
++-
++-/* **** str.c */
++-#define string_length CAML_DEPRECATED("string_length", "caml_string_length") caml_string_length
++-
++-/* **** sys.c */
++-#define sys_error CAML_DEPRECATED("sys_error", "caml_sys_error") caml_sys_error
++-
++-/* **** terminfo.c */
++-
++-/* **** unix.c  &  win32.c */
++-#define search_exe_in_path CAML_DEPRECATED("search_exe_in_path", "caml_search_exe_in_path") caml_search_exe_in_path
++-
++-/* **** weak.c */
++-
++-/* **** asmcomp/asmlink.ml */
++-
++-/* **** asmcomp/cmmgen.ml */
++-
++-/* **** asmcomp/asmlink.ml, asmcomp/cmmgen.ml, asmcomp/compilenv.ml */
++-
++-/* ************************************************************* */
++-
++-/* **** otherlibs/bigarray */
++-#define int8 caml_ba_int8
++-#define uint8 caml_ba_uint8
++-#define int16 caml_ba_int16
++-#define uint16 caml_ba_uint16
++-#define MAX_NUM_DIMS CAML_DEPRECATED("MAX_NUM_DIMS", "CAML_BA_MAX_NUM_DIMS") CAML_BA_MAX_NUM_DIMS
++-#define caml_bigarray_kind CAML_DEPRECATED("caml_bigarray_kind", "caml_ba_kind") caml_ba_kind
++-#define BIGARRAY_FLOAT32 CAML_DEPRECATED("BIGARRAY_FLOAT32", "CAML_BA_FLOAT32") CAML_BA_FLOAT32
++-#define BIGARRAY_FLOAT64 CAML_DEPRECATED("BIGARRAY_FLOAT64", "CAML_BA_FLOAT64") CAML_BA_FLOAT64
++-#define BIGARRAY_SINT8 CAML_DEPRECATED("BIGARRAY_SINT8", "CAML_BA_SINT8") CAML_BA_SINT8
++-#define BIGARRAY_UINT8 CAML_DEPRECATED("BIGARRAY_UINT8", "CAML_BA_UINT8") CAML_BA_UINT8
++-#define BIGARRAY_SINT16 CAML_DEPRECATED("BIGARRAY_SINT16", "CAML_BA_SINT16") CAML_BA_SINT16
++-#define BIGARRAY_UINT16 CAML_DEPRECATED("BIGARRAY_UINT16", "CAML_BA_UINT16") CAML_BA_UINT16
++-#define BIGARRAY_INT32 CAML_DEPRECATED("BIGARRAY_INT32", "CAML_BA_INT32") CAML_BA_INT32
++-#define BIGARRAY_INT64 CAML_DEPRECATED("BIGARRAY_INT64", "CAML_BA_INT64") CAML_BA_INT64
++-#define BIGARRAY_CAML_INT CAML_DEPRECATED("BIGARRAY_CAML_INT", "CAML_BA_CAML_INT") CAML_BA_CAML_INT
++-#define BIGARRAY_NATIVE_INT CAML_DEPRECATED("BIGARRAY_NATIVE_INT", "CAML_BA_NATIVE_INT") CAML_BA_NATIVE_INT
++-#define BIGARRAY_COMPLEX32 CAML_DEPRECATED("BIGARRAY_COMPLEX32", "CAML_BA_COMPLEX32") CAML_BA_COMPLEX32
++-#define BIGARRAY_COMPLEX64 CAML_DEPRECATED("BIGARRAY_COMPLEX64", "CAML_BA_COMPLEX64") CAML_BA_COMPLEX64
++-#define BIGARRAY_KIND_MASK CAML_DEPRECATED("BIGARRAY_KIND_MASK", "CAML_BA_KIND_MASK") CAML_BA_KIND_MASK
++-#define caml_bigarray_layout CAML_DEPRECATED("caml_bigarray_layout", "caml_ba_layout") caml_ba_layout
++-#define BIGARRAY_C_LAYOUT CAML_DEPRECATED("BIGARRAY_C_LAYOUT", "CAML_BA_C_LAYOUT") CAML_BA_C_LAYOUT
++-#define BIGARRAY_FORTRAN_LAYOUT CAML_DEPRECATED("BIGARRAY_FORTRAN_LAYOUT", "CAML_BA_FORTRAN_LAYOUT") CAML_BA_FORTRAN_LAYOUT
++-#define BIGARRAY_LAYOUT_MASK CAML_DEPRECATED("BIGARRAY_LAYOUT_MASK", "CAML_BA_LAYOUT_MASK") CAML_BA_LAYOUT_MASK
++-#define caml_bigarray_managed CAML_DEPRECATED("caml_bigarray_managed", "caml_ba_managed") caml_ba_managed
++-#define BIGARRAY_EXTERNAL CAML_DEPRECATED("BIGARRAY_EXTERNAL", "CAML_BA_EXTERNAL") CAML_BA_EXTERNAL
++-#define BIGARRAY_MANAGED CAML_DEPRECATED("BIGARRAY_MANAGED", "CAML_BA_MANAGED") CAML_BA_MANAGED
++-#define BIGARRAY_MAPPED_FILE CAML_DEPRECATED("BIGARRAY_MAPPED_FILE", "CAML_BA_MAPPED_FILE") CAML_BA_MAPPED_FILE
++-#define BIGARRAY_MANAGED_MASK CAML_DEPRECATED("BIGARRAY_MANAGED_MASK", "CAML_BA_MANAGED_MASK") CAML_BA_MANAGED_MASK
++-#define caml_bigarray_proxy CAML_DEPRECATED("caml_bigarray_proxy", "caml_ba_proxy") caml_ba_proxy
++-#define caml_bigarray CAML_DEPRECATED("caml_bigarray", "caml_ba_array") caml_ba_array
++-#define Bigarray_val CAML_DEPRECATED("Bigarray_val", "Caml_ba_array_val") Caml_ba_array_val
++-#define Data_bigarray_val CAML_DEPRECATED("Data_bigarray_val", "Caml_ba_data_val") Caml_ba_data_val
++-#define alloc_bigarray CAML_DEPRECATED("alloc_bigarray", "caml_ba_alloc") caml_ba_alloc
++-#define alloc_bigarray_dims CAML_DEPRECATED("alloc_bigarray_dims", "caml_ba_alloc_dims") caml_ba_alloc_dims
++-#define bigarray_map_file CAML_DEPRECATED("bigarray_map_file", "caml_ba_map_file") caml_ba_map_file
++-#define bigarray_unmap_file CAML_DEPRECATED("bigarray_unmap_file", "caml_ba_unmap_file") caml_ba_unmap_file
++-#define bigarray_element_size CAML_DEPRECATED("bigarray_element_size", "caml_ba_element_size") caml_ba_element_size
++-#define bigarray_byte_size CAML_DEPRECATED("bigarray_byte_size", "caml_ba_byte_size") caml_ba_byte_size
++-#define bigarray_deserialize CAML_DEPRECATED("bigarray_deserialize", "caml_ba_deserialize") caml_ba_deserialize
++-#define MAX_BIGARRAY_MEMORY CAML_DEPRECATED("MAX_BIGARRAY_MEMORY", "CAML_BA_MAX_MEMORY") CAML_BA_MAX_MEMORY
++-#define bigarray_create CAML_DEPRECATED("bigarray_create", "caml_ba_create") caml_ba_create
++-#define bigarray_get_N CAML_DEPRECATED("bigarray_get_N", "caml_ba_get_N") caml_ba_get_N
++-#define bigarray_get_1 CAML_DEPRECATED("bigarray_get_1", "caml_ba_get_1") caml_ba_get_1
++-#define bigarray_get_2 CAML_DEPRECATED("bigarray_get_2", "caml_ba_get_2") caml_ba_get_2
++-#define bigarray_get_3 CAML_DEPRECATED("bigarray_get_3", "caml_ba_get_3") caml_ba_get_3
++-#define bigarray_get_generic CAML_DEPRECATED("bigarray_get_generic", "caml_ba_get_generic") caml_ba_get_generic
++-#define bigarray_set_1 CAML_DEPRECATED("bigarray_set_1", "caml_ba_set_1") caml_ba_set_1
++-#define bigarray_set_2 CAML_DEPRECATED("bigarray_set_2", "caml_ba_set_2") caml_ba_set_2
++-#define bigarray_set_3 CAML_DEPRECATED("bigarray_set_3", "caml_ba_set_3") caml_ba_set_3
++-#define bigarray_set_N CAML_DEPRECATED("bigarray_set_N", "caml_ba_set_N") caml_ba_set_N
++-#define bigarray_set_generic CAML_DEPRECATED("bigarray_set_generic", "caml_ba_set_generic") caml_ba_set_generic
++-#define bigarray_num_dims CAML_DEPRECATED("bigarray_num_dims", "caml_ba_num_dims") caml_ba_num_dims
++-#define bigarray_dim CAML_DEPRECATED("bigarray_dim", "caml_ba_dim") caml_ba_dim
++-#define bigarray_kind CAML_DEPRECATED("bigarray_kind", "caml_ba_kind") caml_ba_kind
++-#define bigarray_layout CAML_DEPRECATED("bigarray_layout", "caml_ba_layout") caml_ba_layout
++-#define bigarray_slice CAML_DEPRECATED("bigarray_slice", "caml_ba_slice") caml_ba_slice
++-#define bigarray_sub CAML_DEPRECATED("bigarray_sub", "caml_ba_sub") caml_ba_sub
++-#define bigarray_blit CAML_DEPRECATED("bigarray_blit", "caml_ba_blit") caml_ba_blit
++-#define bigarray_fill CAML_DEPRECATED("bigarray_fill", "caml_ba_fill") caml_ba_fill
++-#define bigarray_reshape CAML_DEPRECATED("bigarray_reshape", "caml_ba_reshape") caml_ba_reshape
++-#define bigarray_init CAML_DEPRECATED("bigarray_init", "caml_ba_init") caml_ba_init
++-
++-#endif /* CAML_NAME_SPACE */
++-#endif /* CAML_COMPATIBILITY_H */
++diff --git a/runtime/caml/config.h b/runtime/caml/config.h
++index 471a6bc6f4..a7e56be8d9 100644
++--- a/runtime/caml/config.h
+++++ b/runtime/caml/config.h
++@@ -16,6 +16,15 @@
++ #ifndef CAML_CONFIG_H
++ #define CAML_CONFIG_H
++ 
+++/* CAML_NAME_SPACE was introduced in OCaml 3.08 to declare compatibility with
+++   the newly caml_-prefixed names of C runtime functions and to disable the
+++   definition of compatibility macros for the un-prefixed names. The
+++   compatibility layer was removed in OCaml 5.00, so CAML_NAME_SPACE is the
+++   default. */
+++#ifndef CAML_NAME_SPACE
+++#define CAML_NAME_SPACE
+++#endif
+++
++ #include "m.h"
++ 
++ /* If supported, tell gcc that we can use 32-bit code addresses for
++@@ -41,10 +50,6 @@
++ 
++ #include "s.h"
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++-
++ #ifndef CAML_CONFIG_H_NO_TYPEDEFS
++ 
++ #include <stddef.h>
++diff --git a/runtime/caml/custom.h b/runtime/caml/custom.h
++index 420121f43e..231019aef7 100644
++--- a/runtime/caml/custom.h
+++++ b/runtime/caml/custom.h
++@@ -17,9 +17,6 @@
++ #define CAML_CUSTOM_H
++ 
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "mlvalues.h"
++ 
++ struct custom_fixed_length {
++diff --git a/runtime/caml/domain_state.h b/runtime/caml/domain_state.h
++index 84e677d041..2ee932459a 100644
++--- a/runtime/caml/domain_state.h
+++++ b/runtime/caml/domain_state.h
++@@ -29,11 +29,7 @@ typedef value extra_params_area[NUM_EXTRA_PARAMS];
++  * via native code, which is why the indices are important */
++ 
++ typedef struct {
++-#ifdef CAML_NAME_SPACE
++ #define DOMAIN_STATE(type, name) CAMLalign(8) type name;
++-#else
++-#define DOMAIN_STATE(type, name) CAMLalign(8) type _##name;
++-#endif
++ #include "domain_state.tbl"
++ #undef DOMAIN_STATE
++ } caml_domain_state;
++@@ -45,11 +41,7 @@ enum {
++ #undef DOMAIN_STATE
++ };
++ 
++-#ifdef CAML_NAME_SPACE
++ #define LAST_DOMAIN_STATE_MEMBER extra_params
++-#else
++-#define LAST_DOMAIN_STATE_MEMBER _extra_params
++-#endif
++ 
++ /* Check that the structure was laid out without padding,
++    since the runtime assumes this in computing offsets */
++@@ -57,11 +49,8 @@ CAML_STATIC_ASSERT(
++     offsetof(caml_domain_state, LAST_DOMAIN_STATE_MEMBER) ==
++     (Domain_state_num_fields - 1) * 8);
++ 
++-CAMLextern caml_domain_state* Caml_state;
++-#ifdef CAML_NAME_SPACE
+++CAMLextern caml_domain_state* caml_state;
+++#define Caml_state caml_state
++ #define Caml_state_field(field) Caml_state->field
++-#else
++-#define Caml_state_field(field) Caml_state->_##field
++-#endif
++ 
++ #endif /* CAML_STATE_H */
++diff --git a/runtime/caml/fail.h b/runtime/caml/fail.h
++index 822c603260..887ef9c227 100644
++--- a/runtime/caml/fail.h
+++++ b/runtime/caml/fail.h
++@@ -20,9 +20,6 @@
++ #include <setjmp.h>
++ #endif /* CAML_INTERNALS */
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "misc.h"
++ #include "mlvalues.h"
++ 
++diff --git a/runtime/caml/fix_code.h b/runtime/caml/fix_code.h
++index 2eafaa814b..83c393a17d 100644
++--- a/runtime/caml/fix_code.h
+++++ b/runtime/caml/fix_code.h
++@@ -34,7 +34,8 @@ void caml_set_instruction (code_t pos, opcode_t instr);
++ int caml_is_instruction (opcode_t instr1, opcode_t instr2);
++ 
++ #ifdef THREADED_CODE
++-void caml_init_thread_code(void ** instr_table, void * instr_base);
+++extern char ** caml_instr_table;
+++extern char * caml_instr_base;
++ void caml_thread_code (code_t code, asize_t len);
++ #endif
++ 
++diff --git a/runtime/caml/intext.h b/runtime/caml/intext.h
++index a2a3fb8248..b68030aad8 100644
++--- a/runtime/caml/intext.h
+++++ b/runtime/caml/intext.h
++@@ -18,9 +18,6 @@
++ #ifndef CAML_INTEXT_H
++ #define CAML_INTEXT_H
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "misc.h"
++ #include "mlvalues.h"
++ 
++diff --git a/runtime/caml/m.h.in b/runtime/caml/m.h.in
++index 1c3dee1779..ba0074318d 100644
++--- a/runtime/caml/m.h.in
+++++ b/runtime/caml/m.h.in
++@@ -90,7 +90,7 @@
++ 
++ #undef CAML_WITH_FPIC
++ 
++-#undef CAML_SAFE_STRING
+++#define CAML_SAFE_STRING 1
++ 
++ #undef FLAT_FLOAT_ARRAY
++ 
++diff --git a/runtime/caml/memory.h b/runtime/caml/memory.h
++index d9e58bc2d0..8837d33d25 100644
++--- a/runtime/caml/memory.h
+++++ b/runtime/caml/memory.h
++@@ -18,9 +18,6 @@
++ #ifndef CAML_MEMORY_H
++ #define CAML_MEMORY_H
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "config.h"
++ #ifdef CAML_INTERNALS
++ #include "gc.h"
++@@ -329,7 +326,7 @@ struct caml__roots_block {
++   #define CAMLunused_start __attribute__ ((unused))
++   #define CAMLunused_end
++   #define CAMLunused __attribute__ ((unused))
++-#elif defined(_MSC_VER) && _MSC_VER >= 1500
+++#elif _MSC_VER >= 1500
++   #define CAMLunused_start  __pragma( warning (push) )           \
++     __pragma( warning (disable:4189 ) )
++   #define CAMLunused_end __pragma( warning (pop))
++diff --git a/runtime/caml/misc.h b/runtime/caml/misc.h
++index c605f8711e..b97d20c2bd 100644
++--- a/runtime/caml/misc.h
+++++ b/runtime/caml/misc.h
++@@ -18,9 +18,6 @@
++ #ifndef CAML_MISC_H
++ #define CAML_MISC_H
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "config.h"
++ 
++ /* Standard definitions */
++@@ -29,13 +26,15 @@
++ #include <stdlib.h>
++ #include <stdarg.h>
++ 
+++#include "camlatomic.h"
+++
++ /* Deprecation warnings */
++ 
++ #if defined(__GNUC__) || defined(__clang__)
++   /* Supported since at least GCC 3.1 */
++   #define CAMLdeprecated_typedef(name, type) \
++     typedef type name __attribute ((deprecated))
++-#elif defined(_MSC_VER) && _MSC_VER >= 1310
+++#elif _MSC_VER >= 1310
++   /* NB deprecated("message") only supported from _MSC_VER >= 1400 */
++   #define CAMLdeprecated_typedef(name, type) \
++     typedef __declspec(deprecated) type name
++@@ -43,8 +42,7 @@
++   #define CAMLdeprecated_typedef(name, type) typedef type name
++ #endif
++ 
++-#if defined(__GNUC__) && __STDC_VERSION__ >= 199901L \
++- || defined(_MSC_VER) && _MSC_VER >= 1925
+++#if defined(__GNUC__) && __STDC_VERSION__ >= 199901L || _MSC_VER >= 1925
++ 
++ #define CAML_STRINGIFY(x) #x
++ #ifdef _MSC_VER
++@@ -91,7 +89,7 @@ CAMLdeprecated_typedef(addr, char *);
++   #define CAMLnoreturn_start
++   #define CAMLnoreturn_end __attribute__ ((noreturn))
++   #define Noreturn __attribute__ ((noreturn))
++-#elif defined(_MSC_VER) && _MSC_VER >= 1500
+++#elif _MSC_VER >= 1500
++   #define CAMLnoreturn_start __declspec(noreturn)
++   #define CAMLnoreturn_end
++   #define Noreturn
++@@ -139,12 +137,11 @@ CAMLdeprecated_typedef(addr, char *);
++ /* we need to be able to compute the exact offset of each member. */
++ #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
++ #define CAMLalign(n) _Alignas(n)
++-#elif defined(__cplusplus) \
++-   && (__cplusplus >= 201103L || defined(_MSC_VER) && _MSC_VER >= 1900)
+++#elif defined(__cplusplus) && (__cplusplus >= 201103L || _MSC_VER >= 1900)
++ #define CAMLalign(n) alignas(n)
++ #elif defined(SUPPORTS_ALIGNED_ATTRIBUTE)
++ #define CAMLalign(n) __attribute__((aligned(n)))
++-#elif defined(_MSC_VER) && _MSC_VER >= 1500
+++#elif _MSC_VER >= 1500
++ #define CAMLalign(n) __declspec(align(n))
++ #else
++ #error "How do I align values on this platform?"
++@@ -172,7 +169,7 @@ CAMLdeprecated_typedef(addr, char *);
++   #define CAMLunused_start __attribute__ ((unused))
++   #define CAMLunused_end
++   #define CAMLunused __attribute__ ((unused))
++-#elif defined(_MSC_VER) && _MSC_VER >= 1500
+++#elif _MSC_VER >= 1500
++   #define CAMLunused_start  __pragma( warning (push) )           \
++     __pragma( warning (disable:4189 ) )
++   #define CAMLunused_end __pragma( warning (pop))
++diff --git a/runtime/caml/mlvalues.h b/runtime/caml/mlvalues.h
++index 677e44e183..00143e5ea0 100644
++--- a/runtime/caml/mlvalues.h
+++++ b/runtime/caml/mlvalues.h
++@@ -16,9 +16,6 @@
++ #ifndef CAML_MLVALUES_H
++ #define CAML_MLVALUES_H
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "config.h"
++ #include "misc.h"
++ 
++@@ -286,11 +283,7 @@ CAMLextern value caml_hash_variant(char const * tag);
++ 
++ /* Strings. */
++ #define String_tag 252
++-#ifdef CAML_SAFE_STRING
++ #define String_val(x) ((const char *) Bp_val(x))
++-#else
++-#define String_val(x) ((char *) Bp_val(x))
++-#endif
++ #define Bytes_val(x) ((unsigned char *) Bp_val(x))
++ CAMLextern mlsize_t caml_string_length (value);   /* size in bytes */
++ CAMLextern int caml_string_is_c_safe (value);
++diff --git a/runtime/caml/s.h.in b/runtime/caml/s.h.in
++index 8e4efdcc72..9a5d9f4a91 100644
++--- a/runtime/caml/s.h.in
+++++ b/runtime/caml/s.h.in
++@@ -60,6 +60,8 @@
++ /* Define HAS_WORKING_ROUND is the round function is correctly implemented. This
++    hatch exists primarily for https://sourceforge.net/p/mingw-w64/bugs/573/ */
++ 
+++#undef HAS_GETENTROPY
+++
++ #undef HAS_GETRUSAGE
++ 
++ #undef HAS_TIMES
++@@ -70,6 +72,8 @@
++ 
++ #undef HAS_ISSETUGID
++ 
+++#undef HAS_STDATOMIC_H
+++
++ /* 2. For the Unix library. */
++ 
++ #undef HAS_SOCKETS
++diff --git a/runtime/caml/signals.h b/runtime/caml/signals.h
++index 62b0e7fafa..3a3b86911c 100644
++--- a/runtime/caml/signals.h
+++++ b/runtime/caml/signals.h
++@@ -20,9 +20,6 @@
++ #include<signal.h>
++ #endif
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "misc.h"
++ #include "mlvalues.h"
++ 
++@@ -87,8 +84,8 @@ value caml_do_pending_actions_exn (void);
++ value caml_process_pending_actions_with_root (value extra_root); // raises
++ value caml_process_pending_actions_with_root_exn (value extra_root);
++ int caml_set_signal_action(int signo, int action);
++-CAMLextern void * caml_setup_stack_overflow_detection(void);
++-CAMLextern int caml_stop_stack_overflow_detection(void *);
+++CAMLextern int caml_setup_stack_overflow_detection(void);
+++CAMLextern int caml_stop_stack_overflow_detection(void);
++ CAMLextern void caml_init_signals(void);
++ CAMLextern void caml_terminate_signals(void);
++ CAMLextern void (*caml_enter_blocking_section_hook)(void);
++diff --git a/runtime/caml/sys.h b/runtime/caml/sys.h
++index 75b97818c1..3b2d537ac4 100644
++--- a/runtime/caml/sys.h
+++++ b/runtime/caml/sys.h
++@@ -24,6 +24,8 @@
++ extern "C" {
++ #endif
++ 
+++CAMLextern char * caml_strerror(int errnum, char * buf, size_t buflen);
+++
++ #define NO_ARG Val_int(0)
++ 
++ CAMLnoreturn_start
++diff --git a/runtime/debugger.c b/runtime/debugger.c
++index 97d22832a0..c10c7d0f8f 100644
++--- a/runtime/debugger.c
+++++ b/runtime/debugger.c
++@@ -30,6 +30,7 @@
++ #include "caml/misc.h"
++ #include "caml/osdeps.h"
++ #include "caml/skiplist.h"
+++#include "caml/sys.h"
++ 
++ int caml_debugger_in_use = 0;
++ uintnat caml_event_count;
++@@ -110,6 +111,7 @@ static struct skiplist event_points_table = SKIPLIST_STATIC_INITIALIZER;
++ 
++ static void open_connection(void)
++ {
+++  char buf[1024];
++ #ifdef _WIN32
++   /* Set socket to synchronous mode (= non-overlapped) so that file
++      descriptor-oriented functions (read()/write() etc.) can be
++@@ -133,7 +135,7 @@ static void open_connection(void)
++     caml_fatal_error("cannot connect to debugger at %s\n"
++                      "error: %s",
++                      (dbg_addr ? dbg_addr : "(none)"),
++-                     strerror (errno));
+++                     caml_strerror(errno, buf, sizeof(buf)));
++   dbg_in = caml_open_descriptor_in(dbg_socket);
++   dbg_out = caml_open_descriptor_out(dbg_socket);
++   /* The code in this file does not bracket channel I/O operations with
++diff --git a/runtime/domain.c b/runtime/domain.c
++index d4d8de53fc..a6f0a3028e 100644
++--- a/runtime/domain.c
+++++ b/runtime/domain.c
++@@ -19,7 +19,7 @@
++ #include "caml/domain_state.h"
++ #include "caml/memory.h"
++ 
++-CAMLexport caml_domain_state* Caml_state;
+++CAMLexport caml_domain_state* caml_state;
++ 
++ void caml_init_domain ()
++ {
++diff --git a/runtime/dune b/runtime/dune
++index 78c39300ed..23eb1d1e8a 100644
++--- a/runtime/dune
+++++ b/runtime/dune
++@@ -21,7 +21,7 @@
++      interp.c ints.c io.c
++    lexing.c md5.c meta.c memprof.c obj.c parsing.c signals.c str.c sys.c
++      callback.c weak.c
++-   finalise.c stacks.c dynlink.c backtrace_byt.c backtrace.c
+++   finalise.c dynlink.c backtrace_byt.c backtrace.c
++      afl.c
++    bigarray.c eventlog.c)
++  (action  (with-stdout-to %{targets} (run %{dep:gen_primitives.sh}))))
++@@ -36,7 +36,7 @@
++    ../Makefile.common Makefile
++    (glob_files caml/*.h)
++    ; matches the line structure of files in Makefile/BYTECODE_C_SOURCES
++-   interp.c misc.c stacks.c fix_code.c startup_aux.c startup_byt.c freelist.c
+++   interp.c misc.c fix_code.c startup_aux.c startup_byt.c freelist.c
++      major_gc.c
++    minor_gc.c memory.c alloc.c roots_byt.c globroots.c fail_byt.c signals.c
++    signals_byt.c printexc.c backtrace_byt.c backtrace.c compare.c ints.c
++diff --git a/runtime/dynlink_nat.c b/runtime/dynlink_nat.c
++index dba30c3848..7eea86f8c0 100644
++--- a/runtime/dynlink_nat.c
+++++ b/runtime/dynlink_nat.c
++@@ -118,7 +118,8 @@ CAMLprim value caml_natdynlink_run(value handle_v, value symbol) {
++ 
++   sym = optsym("__code_begin");
++   sym2 = optsym("__code_end");
++-  if (NULL != sym && NULL != sym2)
+++  /* Do not register empty code fragments */
+++  if (NULL != sym && NULL != sym2 && sym != sym2)
++     caml_register_code_fragment((char *) sym, (char *) sym2,
++                                 DIGEST_LATER, NULL);
++ 
++diff --git a/runtime/fix_code.c b/runtime/fix_code.c
++index 5584019867..aa059be5df 100644
++--- a/runtime/fix_code.c
+++++ b/runtime/fix_code.c
++@@ -82,14 +82,8 @@ void caml_fixup_endianness(code_t code, asize_t len)
++ 
++ #ifdef THREADED_CODE
++ 
++-static char ** caml_instr_table;
++-static char * caml_instr_base;
++-
++-void caml_init_thread_code(void ** instr_table, void * instr_base)
++-{
++-  caml_instr_table = (char **) instr_table;
++-  caml_instr_base = (char *) instr_base;
++-}
+++char ** caml_instr_table;
+++char * caml_instr_base;
++ 
++ static int* opcode_nargs = NULL;
++ int* caml_init_opcode_nargs(void)
++diff --git a/runtime/gen_primitives.sh b/runtime/gen_primitives.sh
++index a727d5c25c..e76b3300b7 100755
++--- a/runtime/gen_primitives.sh
+++++ b/runtime/gen_primitives.sh
++@@ -25,7 +25,7 @@ export LC_ALL=C
++       alloc array compare extern floats gc_ctrl hash intern interp ints io \
++       lexing md5 meta memprof obj parsing signals str sys callback weak \
++       finalise stacks dynlink backtrace_byt backtrace afl \
++-      bigarray eventlog
+++      bigarray eventlog prng
++   do
++       sed -n -e 's/^CAMLprim value \([a-z0-9_][a-z0-9_]*\).*/\1/p' "$prim.c"
++   done
++diff --git a/runtime/i386.S b/runtime/i386.S
++index 4d273c9f04..06a9cf5fa7 100644
++--- a/runtime/i386.S
+++++ b/runtime/i386.S
++@@ -116,7 +116,7 @@ FUNCTION(caml_call_gc)
++         CFI_STARTPROC
++ LBL(caml_call_gc):
++     /* Record lowest stack address and return address */
++-        movl    G(Caml_state), %ebx
+++        movl    G(caml_state), %ebx
++         movl    (%esp), %eax
++         movl    %eax, CAML_STATE(last_return_address, %ebx)
++         leal    4(%esp), %eax
++@@ -128,7 +128,7 @@ LBL(caml_call_gc):
++         movl    %eax, 0(%esp)
++         addl    $(STACK_PROBE_SIZE), %esp; CFI_ADJUST(-STACK_PROBE_SIZE);
++ #endif
++-    /* Build array of registers, save it into Caml_state->gc_regs */
+++    /* Build array of registers, save it into caml_state->gc_regs */
++         pushl   %ebp; CFI_ADJUST(4)
++         pushl   %edi; CFI_ADJUST(4)
++         pushl   %esi; CFI_ADJUST(4)
++@@ -156,7 +156,7 @@ LBL(caml_call_gc):
++ 
++ FUNCTION(caml_alloc1)
++         CFI_STARTPROC
++-        movl    G(Caml_state), %ebx
+++        movl    G(caml_state), %ebx
++         movl    CAML_STATE(young_ptr, %ebx), %eax
++         subl    $8, %eax
++         movl    %eax, CAML_STATE(young_ptr, %ebx)
++@@ -168,7 +168,7 @@ FUNCTION(caml_alloc1)
++ 
++ FUNCTION(caml_alloc2)
++         CFI_STARTPROC
++-        movl    G(Caml_state), %ebx
+++        movl    G(caml_state), %ebx
++         movl    CAML_STATE(young_ptr, %ebx), %eax
++         subl    $12, %eax
++         movl    %eax, CAML_STATE(young_ptr, %ebx)
++@@ -180,7 +180,7 @@ FUNCTION(caml_alloc2)
++ 
++ FUNCTION(caml_alloc3)
++         CFI_STARTPROC
++-        movl    G(Caml_state), %ebx
+++        movl    G(caml_state), %ebx
++         movl    CAML_STATE(young_ptr, %ebx), %eax
++         subl    $16, %eax
++         movl    %eax, CAML_STATE(young_ptr, %ebx)
++@@ -192,10 +192,10 @@ FUNCTION(caml_alloc3)
++ 
++ FUNCTION(caml_allocN)
++         CFI_STARTPROC
++-        movl    G(Caml_state), %ebx
++-        /* eax = size - Caml_state->young_ptr */
+++        movl    G(caml_state), %ebx
+++        /* eax = size - caml_state->young_ptr */
++         subl    CAML_STATE(young_ptr, %ebx), %eax
++-        negl    %eax              /* eax = Caml_state->young_ptr - size */
+++        negl    %eax              /* eax = caml_state->young_ptr - size */
++         movl    %eax, CAML_STATE(young_ptr, %ebx)
++         cmpl    CAML_STATE(young_limit, %ebx), %eax
++         jb      LBL(caml_call_gc)
++@@ -209,7 +209,7 @@ FUNCTION(caml_c_call)
++         CFI_STARTPROC
++     /* Record lowest stack address and return address */
++     /* ecx and edx are destroyed at C call. Use them as temp. */
++-        movl    G(Caml_state), %ecx
+++        movl    G(caml_state), %ecx
++         movl    (%esp), %edx
++         movl    %edx, CAML_STATE(last_return_address, %ecx)
++         leal    4(%esp), %edx
++@@ -239,7 +239,7 @@ FUNCTION(caml_start_program)
++         movl    $ G(caml_program), %esi
++     /* Common code for caml_start_program and caml_callback* */
++ LBL(106):
++-        movl    G(Caml_state), %edi
+++        movl    G(caml_state), %edi
++     /* Build a callback link */
++         pushl   CAML_STATE(gc_regs, %edi); CFI_ADJUST(4)
++         pushl   CAML_STATE(last_return_address, %edi); CFI_ADJUST(4)
++@@ -253,12 +253,12 @@ LBL(106):
++     /* Call the OCaml code */
++         call    *%esi
++ LBL(107):
++-        movl    G(Caml_state), %edi
+++        movl    G(caml_state), %edi
++     /* Pop the exception handler */
++         popl    CAML_STATE(exception_pointer, %edi); CFI_ADJUST(-4)
++         addl    $12, %esp       ; CFI_ADJUST(-12)
++ LBL(109):
++-        movl    G(Caml_state), %edi /* Reload for LBL(109) entry */
+++        movl    G(caml_state), %edi /* Reload for LBL(109) entry */
++     /* Pop the callback link, restoring the global variables */
++         popl    CAML_STATE(bottom_of_stack, %edi); CFI_ADJUST(-4)
++         popl    CAML_STATE(last_return_address, %edi); CFI_ADJUST(-4)
++@@ -282,7 +282,7 @@ LBL(108):
++ 
++ FUNCTION(caml_raise_exn)
++         CFI_STARTPROC
++-        movl    G(Caml_state), %ebx
+++        movl    G(caml_state), %ebx
++         testl   $1, CAML_STATE(backtrace_active, %ebx)
++         jne     LBL(110)
++         movl    CAML_STATE(exception_pointer, %ebx), %esp
++@@ -312,7 +312,7 @@ LBL(110):
++ 
++ FUNCTION(caml_raise_exception)
++         CFI_STARTPROC
++-        movl    G(Caml_state), %ebx
+++        movl    G(caml_state), %ebx
++         testl   $1, CAML_STATE(backtrace_active, %ebx)
++         jne     LBL(112)
++         movl    8(%esp), %eax
++@@ -405,7 +405,7 @@ FUNCTION(caml_ml_array_bound_error)
++         ffree   %st(6)
++         ffree   %st(7)
++     /* Record lowest stack address and return address */
++-        movl    G(Caml_state), %ebx
+++        movl    G(caml_state), %ebx
++         movl    (%esp), %edx
++         movl    %edx, CAML_STATE(last_return_address, %ebx)
++         leal    4(%esp), %edx
++diff --git a/runtime/interp.c b/runtime/interp.c
++index e6700994bc..a59811c87d 100644
++--- a/runtime/interp.c
+++++ b/runtime/interp.c
++@@ -50,9 +50,9 @@ sp is a local copy of the global variable Caml_state->extern_sp. */
++ #ifdef THREADED_CODE
++ #  define Instruct(name) lbl_##name
++ #  if defined(ARCH_SIXTYFOUR) && !defined(ARCH_CODE32)
++-#    define Jumptbl_base &&lbl_ACC0
+++#    define Jumptbl_base ((char *) &&lbl_ACC0)
++ #  else
++-#    define Jumptbl_base 0
+++#    define Jumptbl_base ((char *) 0)
++ #    define jumptbl_base ((char *) 0)
++ #  endif
++ #  ifdef DEBUG
++@@ -249,7 +249,8 @@ value caml_interprete(code_t prog, asize_t prog_size)
++ 
++   if (prog == NULL) {           /* Interpreter is initializing */
++ #ifdef THREADED_CODE
++-    caml_init_thread_code(jumptable, Jumptbl_base);
+++    caml_instr_table = (char **) jumptable;
+++    caml_instr_base = Jumptbl_base;
++ #endif
++     return Val_unit;
++   }
++diff --git a/runtime/prng.c b/runtime/prng.c
++new file mode 100644
++index 0000000000..4357afbbfb
++--- /dev/null
+++++ b/runtime/prng.c
++@@ -0,0 +1,69 @@
+++/**************************************************************************/
+++/*                                                                        */
+++/*                                 OCaml                                  */
+++/*                                                                        */
+++/*          Xavier Leroy, projet Cambium, College de France and Inria     */
+++/*                                                                        */
+++/*   Copyright 2021 Institut National de Recherche en Informatique et     */
+++/*     en Automatique.                                                    */
+++/*                                                                        */
+++/*   All rights reserved.  This file is distributed under the terms of    */
+++/*   the GNU Lesser General Public License version 2.1, with the          */
+++/*   special exception on linking described in the file LICENSE.          */
+++/*                                                                        */
+++/**************************************************************************/
+++
+++#include <string.h>
+++#include "caml/alloc.h"
+++#include "caml/bigarray.h"
+++#include "caml/mlvalues.h"
+++
+++/* The L64X128 member of the LXM family.  Taken from figure 1 in
+++   "LXM: Better Splittable Pseudorandom Number Generators
+++    (and Almost as Fast)" by Guy L. Steele Jr. and Sebastiano Vigna,
+++    OOPSLA 2021.  */
+++
+++static const uint64_t M = 0xd1342543de82ef95;
+++
+++struct LXM_state {
+++  uint64_t a;            /* per-instance additive parameter (odd) */
+++  uint64_t s;            /* state of the LCG subgenerator */
+++  uint64_t x[2];         /* state of the XBG subgenerator (not 0) */
+++};
+++
+++/* In OCaml, states are represented as a 1D big array of 64-bit integers */
+++
+++#define LXM_val(v) ((struct LXM_state *) Caml_ba_data_val(v))
+++
+++Caml_inline uint64_t rotl(const uint64_t x, int k) {
+++  return (x << k) | (x >> (64 - k));
+++}
+++
+++CAMLprim uint64_t caml_lxm_next_unboxed(value v)
+++{
+++  uint64_t z, q0, q1;
+++  struct LXM_state * st = LXM_val(v);
+++
+++  /* Combining operation */
+++  z = st->s + st->x[0];
+++  /* Mixing function */
+++  z = (z ^ (z >> 32)) * 0xdaba0b6eb09322e3;
+++  z = (z ^ (z >> 32)) * 0xdaba0b6eb09322e3;
+++  z = (z ^ (z >> 32));
+++  /* LCG update */
+++  st->s = st->s * M + st->a;
+++  /* XBG update */
+++  q0 = st->x[0]; q1 = st->x[1];
+++  q1 ^= q0;
+++  q0 = rotl(q0, 24);
+++  q0 = q0 ^ q1 ^ (q1 << 16);
+++  q1 = rotl(q1, 37);
+++  st->x[0] = q0; st->x[1] = q1;
+++  /* Return result */
+++  return z;
+++}
+++
+++CAMLprim value caml_lxm_next(value v)
+++{
+++  return caml_copy_int64(caml_lxm_next_unboxed(v));
+++}
++diff --git a/runtime/signals_byt.c b/runtime/signals_byt.c
++index 7cb461ac4d..439fb56404 100644
++--- a/runtime/signals_byt.c
+++++ b/runtime/signals_byt.c
++@@ -81,7 +81,7 @@ int caml_set_signal_action(int signo, int action)
++     return 0;
++ }
++ 
++-CAMLexport void * caml_setup_stack_overflow_detection(void) { return NULL; }
++-CAMLexport int caml_stop_stack_overflow_detection(void * p) { return 0; }
+++CAMLexport int caml_setup_stack_overflow_detection(void) { return 0; }
+++CAMLexport int caml_stop_stack_overflow_detection(void) { return 0; }
++ CAMLexport void caml_init_signals(void) { }
++ CAMLexport void caml_terminate_signals(void) { }
++diff --git a/runtime/signals_nat.c b/runtime/signals_nat.c
++index 1dd8289c12..443f5d53b6 100644
++--- a/runtime/signals_nat.c
+++++ b/runtime/signals_nat.c
++@@ -254,10 +254,6 @@ DECLARE_SIGNAL_HANDLER(segv_handler)
++ 
++ /* Initialization of signal stuff */
++ 
++-#ifdef HAS_STACK_OVERFLOW_DETECTION
++-static void * caml_signal_stack = NULL;
++-#endif
++-
++ void caml_init_signals(void)
++ {
++   /* Bound-check trap handling */
++@@ -282,8 +278,7 @@ void caml_init_signals(void)
++ #endif
++ 
++ #ifdef HAS_STACK_OVERFLOW_DETECTION
++-  caml_signal_stack = caml_setup_stack_overflow_detection();
++-  if (caml_signal_stack != NULL) {
+++  if (caml_setup_stack_overflow_detection() != -1) {
++     struct sigaction act;
++     SET_SIGACT(act, segv_handler);
++     act.sa_flags |= SA_ONSTACK | SA_NODEFER;
++@@ -319,8 +314,7 @@ void caml_terminate_signals(void)
++ 
++ #ifdef HAS_STACK_OVERFLOW_DETECTION
++   set_signal_default(SIGSEGV);
++-  caml_stop_stack_overflow_detection(caml_signal_stack);
++-  caml_signal_stack = NULL;
+++  caml_stop_stack_overflow_detection();
++ #endif
++ }
++ 
++@@ -329,44 +323,37 @@ void caml_terminate_signals(void)
++    Each thread needs its own alternate stack.
++    The alternate stack used to be statically-allocated for the main thread,
++    but this is incompatible with Glibc 2.34 and newer, where SIGSTKSZ
++-   may not be a compile-time constant (issue #10250).
++-   Return the dynamically-allocated alternate signal stack, or NULL
++-   if an error occurred.
++-   The returned pointer must be passed to [caml_stop_stack_overflow_detection].
++-*/
+++   may not be a compile-time constant (issue #10250). */
++ 
++-CAMLexport void * caml_setup_stack_overflow_detection(void)
+++CAMLexport int caml_setup_stack_overflow_detection(void)
++ {
++ #ifdef HAS_STACK_OVERFLOW_DETECTION
++   stack_t stk;
+++  stk.ss_sp = malloc(SIGSTKSZ);
+++  if (stk.ss_sp == NULL) return -1;
++   stk.ss_size = SIGSTKSZ;
++-  stk.ss_sp = malloc(stk.ss_size);
++-  if (stk.ss_sp == NULL) return NULL;
++   stk.ss_flags = 0;
++   if (sigaltstack(&stk, NULL) == -1) {
++     free(stk.ss_sp);
++-    return NULL;
+++    return -1;
++   }
++-  return stk.ss_sp;
++-#else
++-  return NULL;
++ #endif
+++  /* Success (or stack overflow detection not available) */
+++  return 0;
++ }
++ 
++-CAMLexport int caml_stop_stack_overflow_detection(void * signal_stack)
+++CAMLexport int caml_stop_stack_overflow_detection(void)
++ {
++ #ifdef HAS_STACK_OVERFLOW_DETECTION
++   stack_t oldstk, stk;
++   stk.ss_flags = SS_DISABLE;
++-  stk.ss_sp = NULL;  /* not required but avoids a valgrind false alarm */
++-  stk.ss_size = SIGSTKSZ; /* macOS wants a valid size here */
++   if (sigaltstack(&stk, &oldstk) == -1) return -1;
++-  /* Check whether someone else installed their own signal stack */
++-  if (!(oldstk.ss_flags & SS_DISABLE) && oldstk.ss_sp != signal_stack) {
++-    /* Re-activate their signal stack. */
++-    sigaltstack(&oldstk, NULL);
++-  }
++-  free(signal_stack);
++-#endif
+++  /* If caml_setup_stack_overflow_detection failed, we are not using
+++     an alternate signal stack.  SS_DISABLE will be set in oldstk,
+++     and there is nothing to free in this case. */
+++  if (! (oldstk.ss_flags & SS_DISABLE)) free(oldstk.ss_sp);
++   return 0;
+++#else
+++  return 0;
+++#endif
++ }
++diff --git a/runtime/sys.c b/runtime/sys.c
++index a77fd9d1cf..f90d9ba2a8 100644
++--- a/runtime/sys.c
+++++ b/runtime/sys.c
++@@ -45,6 +45,9 @@
++ #ifdef HAS_GETTIMEOFDAY
++ #include <sys/time.h>
++ #endif
+++#ifdef __APPLE__
+++#include <sys/random.h> /* for getentropy */
+++#endif
++ #include "caml/alloc.h"
++ #include "caml/debugger.h"
++ #include "caml/fail.h"
++@@ -61,9 +64,21 @@
++ #include "caml/callback.h"
++ #include "caml/startup_aux.h"
++ 
++-static char * error_message(void)
+++CAMLexport char * caml_strerror(int errnum, char * buf, size_t buflen)
++ {
++-  return strerror(errno);
+++#ifdef _WIN32
+++  /* Windows has a thread-safe strerror */
+++  return strerror(errnum);
+++#else
+++  int res = strerror_r(errnum, buf, buflen);
+++  /* glibc<2.13 returns -1/sets errno, >2.13 returns +ve errno.
+++     We assume that buffer size is large enough not to get ERANGE,
+++     so we assume we got EINVAL. */
+++  if (res != 0) {
+++    snprintf(buf, buflen, "Unknown error %d", errnum);
+++  }
+++  return buf;
+++#endif
++ }
++ 
++ #ifndef EAGAIN
++@@ -77,9 +92,10 @@ CAMLexport void caml_sys_error(value arg)
++ {
++   CAMLparam1 (arg);
++   char * err;
+++  char buf[1024];
++   CAMLlocal1 (str);
++ 
++-  err = error_message();
+++  err = caml_strerror(errno, buf, sizeof(buf));
++   if (arg == NO_ARG) {
++     str = caml_copy_string(err);
++   } else {
++@@ -565,20 +581,27 @@ extern int caml_win32_random_seed (intnat data[16]);
++ #else
++ int caml_unix_random_seed(intnat data[16])
++ {
++-  int fd;
++   int n = 0;
++-
++-  /* Try /dev/urandom first */
++-  fd = open("/dev/urandom", O_RDONLY, 0);
++-  if (fd != -1) {
++-    unsigned char buffer[12];
++-    int nread = read(fd, buffer, 12);
++-    close(fd);
++-    while (nread > 0) data[n++] = buffer[--nread];
+++  unsigned char buffer[12];
+++  int nread = 0;
+++
+++  /* Try kernel entropy first */
+++#if defined(HAS_GETENTROPY) || defined(__APPLE__)
+++  if (getentropy(buffer, 12) != -1) {
+++    nread = 12;
+++  } else
+++#endif
+++  { int fd = open("/dev/urandom", O_RDONLY, 0);
+++    if (fd != -1) {
+++      nread = read(fd, buffer, 12);
+++      close(fd);
+++    }
++   }
++-  /* If the read from /dev/urandom fully succeeded, we now have 96 bits
+++  while (nread > 0) data[n++] = buffer[--nread];
+++  /* If the kernel provided enough entropy, we now have 96 bits
++      of good random data and can stop here. */
++   if (n >= 12) return n;
+++
++   /* Otherwise, complement whatever we got (probably nothing)
++      with some not-very-random data. */
++   {
+diff --git a/diff-against-trunk-support.diff b/diff-against-trunk-support.diff
+new file mode 100644
+index 0000000000..116f3b4e7a
+--- /dev/null
++++ b/diff-against-trunk-support.diff
+@@ -0,0 +1,3323 @@
++diff --git a/ocamltest/Makefile b/ocamltest/Makefile
++index 0aa5f92651..11782f7f9f 100644
++--- a/ocamltest/Makefile
+++++ b/ocamltest/Makefile
++@@ -277,6 +277,7 @@ ocamltest_config.ml: ocamltest_config.ml.in Makefile ../Makefile.config
++ 	    $(call SUBST,DIFF_FLAGS) \
++ 	    $(call SUBST,WINDOWS_UNICODE) \
++ 	    $(call SUBST,FUNCTION_SECTIONS) \
+++	    $(call SUBST,NAKED_POINTERS) \
++ 	    $< > $@
++ 
++ # Manual
++diff --git a/ocamltest/builtin_actions.ml b/ocamltest/builtin_actions.ml
++index 02a437db3a..0f2974d12a 100644
++--- a/ocamltest/builtin_actions.ml
+++++ b/ocamltest/builtin_actions.ml
++@@ -181,6 +181,12 @@ let function_sections = make
++      "Target supports function sections"
++      "Target does not support function sections")
++ 
+++let naked_pointers = make
+++  "naked_pointers"
+++  (Actions_helpers.pass_or_skip (Ocamltest_config.naked_pointers)
+++     "Runtime system supports naked pointers"
+++     "Runtime system does not support naked pointers")
+++
++ let has_symlink = make
++   "has_symlink"
++   (Actions_helpers.pass_or_skip (Unix.has_symlink () )
++@@ -302,6 +308,7 @@ let _ =
++     arch_i386;
++     arch_power;
++     function_sections;
+++    naked_pointers;
++     file_exists;
++     copy;
++   ]
++diff --git a/ocamltest/ocamltest_config.ml.in b/ocamltest/ocamltest_config.ml.in
++index 399d3c3cef..876d4ac79c 100644
++--- a/ocamltest/ocamltest_config.ml.in
+++++ b/ocamltest/ocamltest_config.ml.in
++@@ -87,3 +87,5 @@ let windows_unicode = %%WINDOWS_UNICODE%% != 0
++ let function_sections = %%FUNCTION_SECTIONS%%
++ 
++ let instrumented_runtime = %%INSTRUMENTED_RUNTIME%%
+++
+++let naked_pointers = %%NAKED_POINTERS%%
++diff --git a/ocamltest/ocamltest_config.mli b/ocamltest/ocamltest_config.mli
++index 564ef7644e..92cf631912 100644
++--- a/ocamltest/ocamltest_config.mli
+++++ b/ocamltest/ocamltest_config.mli
++@@ -124,3 +124,6 @@ val function_sections : bool
++ 
++ val instrumented_runtime : bool
++ (** Whether the instrumented runtime is available *)
+++
+++val naked_pointers : bool
+++(** Whether the runtime system supports naked pointers outside the heap *)
++diff --git a/ocamltest/run_unix.c b/ocamltest/run_unix.c
++index 7b576135b7..5b2298e696 100644
++--- a/ocamltest/run_unix.c
+++++ b/ocamltest/run_unix.c
++@@ -347,7 +347,9 @@ int run_command(const command_settings *settings)
++       myperror("fork");
++       return -1;
++     case 0: /* child process */
+++#if 0
++       caml_atfork_hook();
+++#endif
++       exit( run_command_child(settings) );
++     default:
++       return run_command_parent(settings, child_pid);
++diff --git a/testsuite/tests/asmcomp/is_in_static_data.c b/testsuite/tests/asmcomp/is_in_static_data.c
++new file mode 100644
++index 0000000000..ccf0582c0a
++--- /dev/null
+++++ b/testsuite/tests/asmcomp/is_in_static_data.c
++@@ -0,0 +1,5 @@
+++#include "caml/address_class.h"
+++
+++value caml_is_in_static_data(value v) {
+++  return(Val_bool(Is_in_static_data(v)));
+++}
++diff --git a/testsuite/tests/asmcomp/is_static.ml b/testsuite/tests/asmcomp/is_static.ml
++new file mode 100644
++index 0000000000..b8a3bef006
++--- /dev/null
+++++ b/testsuite/tests/asmcomp/is_static.ml
++@@ -0,0 +1,40 @@
+++(* TEST
+++   modules = "is_in_static_data.c"
+++   * naked_pointers
+++   ** native
+++*)
+++
+++(* Data that should be statically allocated by the compiler (all versions) *)
+++
+++external is_in_static_data : 'a -> bool = "caml_is_in_static_data"
+++
+++(* Basic constant blocks should be static *)
+++let block1 = (1,2)
+++let () = assert(is_in_static_data block1)
+++
+++(* as pattern shouldn't prevent it *)
+++let (a, b) as block2 = (1,2)
+++let () = assert(is_in_static_data block2)
+++
+++(* Also in functions *)
+++let f () =
+++  let block = (1,2) in
+++  assert(is_in_static_data block)
+++
+++let () = (f [@inlined never]) ()
+++
+++(* Closed functions should be static *)
+++let closed_function x = x + 1 (* + is a primitive, it cannot be in the closure*)
+++let () = assert(is_in_static_data closed_function)
+++
+++(* And functions using closed functions *)
+++let almost_closed_function x =
+++  (closed_function [@inlined never]) x
+++let () = assert(is_in_static_data almost_closed_function)
+++
+++(* Recursive constant functions should be static *)
+++let rec f1 a = g1 a
+++and g1 a = f1 a
+++let () =
+++  assert(is_in_static_data f1);
+++  assert(is_in_static_data g1)
++diff --git a/testsuite/tests/asmcomp/is_static_flambda.ml b/testsuite/tests/asmcomp/is_static_flambda.ml
++new file mode 100644
++index 0000000000..63e53cfc42
++--- /dev/null
+++++ b/testsuite/tests/asmcomp/is_static_flambda.ml
++@@ -0,0 +1,207 @@
+++(* TEST
+++   modules = "is_in_static_data.c is_static_flambda_dep.ml"
+++   * flambda
+++   ** naked_pointers
+++   *** native
+++*)
+++
+++(* Data that should be statically allocated by the compiler (flambda only) *)
+++
+++external is_in_static_data : 'a -> bool = "caml_is_in_static_data"
+++
+++(* Also after inlining *)
+++let g x =
+++  let block = (1,x) in
+++  assert(is_in_static_data block)
+++
+++let () = (g [@inlined always]) 2
+++
+++(* Toplevel immutable blocks should be static *)
+++let block3 = (Sys.opaque_identity 1, Sys.opaque_identity 2)
+++let () = assert(is_in_static_data block3)
+++
+++(* Not being bound shouldn't prevent it *)
+++let () =
+++  assert(is_in_static_data (Sys.opaque_identity 1, Sys.opaque_identity 2))
+++
+++(* Only with rounds >= 2 currently !
+++(* Also after inlining *)
+++let h x =
+++  let block = (Sys.opaque_identity 1,x) in
+++  assert(is_in_static_data block)
+++
+++let () = (h [@inlined always]) (Sys.opaque_identity 2)
+++*)
+++
+++(* Recursive constant values should be static *)
+++let rec a = 1 :: b
+++and b = 2 :: a
+++let () =
+++  assert(is_in_static_data a);
+++  assert(is_in_static_data b)
+++
+++(* And a mix *)
+++type e = E : 'a -> e
+++
+++let rec f1 a = E (g1 a, l1)
+++and g1 a = E (f1 a, l2)
+++and l1 = E (f1, l2)
+++and l2 = E (g1, l1)
+++
+++let () =
+++  assert(is_in_static_data f1);
+++  assert(is_in_static_data g1);
+++  assert(is_in_static_data l1);
+++  assert(is_in_static_data l2)
+++
+++(* Also in functions *)
+++let i () =
+++  let rec f1 a = E (g1 a, l1)
+++  and g1 a = E (f1 a, l2)
+++  and l1 = E (f1, l2)
+++  and l2 = E (g1, l1) in
+++
+++  assert(is_in_static_data f1);
+++  assert(is_in_static_data g1);
+++  assert(is_in_static_data l1);
+++  assert(is_in_static_data l2)
+++
+++let () = (i [@inlined never]) ()
+++
+++module type P = module type of Stdlib
+++(* Top-level modules should be static *)
+++let () = assert(is_in_static_data (module Stdlib:P))
+++
+++(* Not constant let rec to test extraction to initialize_symbol *)
+++let r = ref 0
+++let rec a = (incr r; !r) :: b
+++and b = (incr r; !r) :: a
+++
+++let next =
+++  let r = ref 0 in
+++  fun () -> incr r; !r
+++
+++let () =
+++  assert(is_in_static_data next)
+++
+++(* Exceptions without arguments should be static *)
+++exception No_argument
+++let () = assert(is_in_static_data No_argument)
+++
+++(* And also with constant arguments *)
+++exception Some_argument of string
+++let () = assert(is_in_static_data (Some_argument "some string"))
+++
+++(* Even when exposed by inlining *)
+++let () =
+++  let exn =
+++    try (failwith [@inlined always]) "some other string" with exn -> exn
+++  in
+++  assert(is_in_static_data exn)
+++
+++(* Verify that approximation intersection correctly loads exported
+++   approximations.
+++
+++   Is_static_flambda_dep.pair is a pair with 1 as first element. The
+++   intersection of approximations should return a block with
+++   approximation: [tag 0: [tag 0: Int 1, Unknown], Unknown] *)
+++let f x =
+++  let pair =
+++    if Sys.opaque_identity x then
+++      (1, 2), 3
+++    else
+++      Is_static_flambda_dep.pair, 4
+++  in
+++  let n = fst (fst pair) in
+++  let res = n, n in
+++  assert(is_in_static_data res)
+++  [@@inline never]
+++
+++let () =
+++  f true;
+++  f false
+++
+++(* Verify that physical equality/inequality is correctly propagated *)
+++
+++(* In these tests, tuple can be statically allocated only if it is a
+++   known constant since the function is never inlined (hence this
+++   code is never at toplevel) *)
+++
+++let () =
+++  let f () =
+++    let v = (1, 2) in
+++    (* eq is supposed to be considered always true since v is a
+++       constant, hence aliased to a symbol.
+++       It is not yet optimized away if it is not constant *)
+++    let eq = v == v in
+++    let n = if eq then 1 else 2 in
+++    let tuple = (n,n) in
+++    assert(is_in_static_data tuple)
+++  in
+++  (f [@inlined never]) ()
+++
+++let () =
+++  let f () =
+++    let v = (1, 2) in
+++    (* same with inequality *)
+++    let eq = v != v in
+++    let n = if eq then 1 else 2 in
+++    let tuple = (n,n) in
+++    assert(is_in_static_data tuple)
+++  in
+++  (f [@inlined never]) ()
+++
+++let () =
+++  let f x =
+++    let v1 = Some x in
+++    let v2 = None in
+++    let eq = v1 == v2 in
+++    (* The values are structurally different, so must be physically
+++       different *)
+++    let n = if eq then 1 else 2 in
+++    let tuple = (n,n) in
+++    assert(is_in_static_data tuple)
+++  in
+++  (f [@inlined never]) ()
+++
+++let () =
+++  let f x =
+++    let v1 = Some x in
+++    let v2 = None in
+++    let eq = v1 != v2 in
+++    (* same with inequality *)
+++    let n = if eq then 1 else 2 in
+++    let tuple = (n,n) in
+++    assert(is_in_static_data tuple)
+++  in
+++  (f [@inlined never]) ()
+++
+++let () =
+++  let f x =
+++    let v1 = (1, 2) in
+++    let v2 = (3, 2) in
+++    let eq = v1 == v2 in
+++    (* difference is deeper *)
+++    let n = if eq then 1 else 2 in
+++    let tuple = (n,n) in
+++    assert(is_in_static_data tuple)
+++  in
+++  (f [@inlined never]) ()
+++
+++module Int = struct
+++  type t = int
+++  let compare (a:int) b = compare a b
+++end
+++module IntMap = Map.Make (Int)
+++
+++let () =
+++  let f () =
+++    let a = IntMap.empty in
+++    let b = (IntMap.add [@inlined]) 1 (Some 1) a in
+++    assert(is_in_static_data b);
+++    let c = (IntMap.add [@inlined]) 1 (Some 2) b in
+++    assert(is_in_static_data c);
+++    let d = (IntMap.add [@inlined]) 1 (Some 2) c in
+++    assert(is_in_static_data d);
+++  in
+++  (f [@inlined never]) ()
++diff --git a/testsuite/tests/asmcomp/is_static_flambda_dep.ml b/testsuite/tests/asmcomp/is_static_flambda_dep.ml
++new file mode 100644
++index 0000000000..3a50f7cad4
++--- /dev/null
+++++ b/testsuite/tests/asmcomp/is_static_flambda_dep.ml
++@@ -0,0 +1 @@
+++let pair = 1, 12
++diff --git a/testsuite/tests/asmcomp/polling.c b/testsuite/tests/asmcomp/polling.c
++index 93620c9bcc..4f6bf1dcab 100644
++--- a/testsuite/tests/asmcomp/polling.c
+++++ b/testsuite/tests/asmcomp/polling.c
++@@ -12,7 +12,11 @@ CAMLprim value request_minor_gc(value v) {
++     tests are only run in a single domain, so we're probably
++     good.
++   */
+++#if 0
++   Caml_state->young_limit = (uintnat)Caml_state->young_end;
+++#endif
+++  caml_something_to_do = 1;
+++  Caml_state->young_limit = Caml_state->young_alloc_end;
++ 
++   return Val_unit;
++ }
++diff --git a/testsuite/tests/asmcomp/simple_float_const.ml b/testsuite/tests/asmcomp/simple_float_const.ml
++new file mode 100644
++index 0000000000..1aca414f7e
++--- /dev/null
+++++ b/testsuite/tests/asmcomp/simple_float_const.ml
++@@ -0,0 +1 @@
+++let f = 3.14
++diff --git a/testsuite/tests/asmcomp/simple_float_const_opaque.ml b/testsuite/tests/asmcomp/simple_float_const_opaque.ml
++new file mode 100644
++index 0000000000..1aca414f7e
++--- /dev/null
+++++ b/testsuite/tests/asmcomp/simple_float_const_opaque.ml
++@@ -0,0 +1 @@
+++let f = 3.14
++diff --git a/testsuite/tests/asmcomp/static_float_array_flambda.ml b/testsuite/tests/asmcomp/static_float_array_flambda.ml
++new file mode 100644
++index 0000000000..824a12ca89
++--- /dev/null
+++++ b/testsuite/tests/asmcomp/static_float_array_flambda.ml
++@@ -0,0 +1,26 @@
+++(* TEST
+++   modules = "is_in_static_data.c simple_float_const.ml"
+++   * flambda
+++   ** flat-float-array
+++   *** naked_pointers
+++   **** native
+++*)
+++
+++external is_in_static_data : 'a -> bool = "caml_is_in_static_data"
+++
+++let a = [|0.; 1.|]
+++let f = 1.23
+++let b = [|0.; f; f|]
+++let g = Sys.opaque_identity 1.23
+++let c = [|0.; g|]
+++let d = [|0.; Simple_float_const.f|]
+++
+++let () = assert(is_in_static_data a)
+++let () = assert(is_in_static_data f)
+++let () = assert(is_in_static_data b)
+++
+++let () = assert(not (is_in_static_data c))
+++(* In fact this one could be static by preallocating the array then
+++   patching it when g is available *)
+++
+++let () = assert(is_in_static_data d)
++diff --git a/testsuite/tests/asmcomp/static_float_array_flambda_opaque.ml b/testsuite/tests/asmcomp/static_float_array_flambda_opaque.ml
++new file mode 100644
++index 0000000000..56ea9e1793
++--- /dev/null
+++++ b/testsuite/tests/asmcomp/static_float_array_flambda_opaque.ml
++@@ -0,0 +1,30 @@
+++(* TEST
+++   modules = "is_in_static_data.c simple_float_const_opaque.ml"
+++   flags = "-opaque"
+++   * flambda
+++   ** flat-float-array
+++   *** naked_pointers
+++   **** native
+++*)
+++
+++external is_in_static_data : 'a -> bool = "caml_is_in_static_data"
+++
+++let a = [|0.; 1.|]
+++let f = 1.23
+++let b = [|0.; f; f|]
+++let g = Sys.opaque_identity 1.23
+++let c = [|0.; g|]
+++let d = [|0.; Simple_float_const_opaque.f|]
+++
+++let () = assert(is_in_static_data a)
+++let () = assert(is_in_static_data f)
+++let () = assert(is_in_static_data b)
+++
+++let () = assert(not (is_in_static_data c))
+++(* In fact this one could be static by preallocating the array then
+++   patching it when g is available *)
+++
+++let () = assert(not (is_in_static_data d))
+++(* The dependency Simple_float_const_opaque is built with opaque,
+++   hence the value of Simple_float_const_opaque.f cannot be known
+++   preventing the static allocation of d *)
++diff --git a/testsuite/tests/backtrace/backtrace2.reference b/testsuite/tests/backtrace/backtrace2.reference
++index 20ef708fe0..54c5ab7570 100644
++--- a/testsuite/tests/backtrace/backtrace2.reference
+++++ b/testsuite/tests/backtrace/backtrace2.reference
++@@ -35,7 +35,7 @@ Uncaught exception Invalid_argument("index out of bounds")
++ Raised by primitive operation at Backtrace2.run in file "backtrace2.ml", line 62, characters 14-22
++ test_Not_found
++ Uncaught exception Not_found
++-Raised at Stdlib__Hashtbl.find in file "hashtbl.ml", line 541, characters 13-28
+++Raised at Stdlib__Hashtbl.find in file "hashtbl.ml", line 549, characters 13-28
++ Called from Backtrace2.test_Not_found in file "backtrace2.ml", line 43, characters 9-42
++ Re-raised at Backtrace2.test_Not_found in file "backtrace2.ml", line 43, characters 61-70
++ Called from Backtrace2.run in file "backtrace2.ml", line 62, characters 11-23
++@@ -46,13 +46,13 @@ Called from Backtrace2.test_lazy.aux in file "backtrace2.ml", line 47, character
++ Called from Backtrace2.test_lazy.aux in file "backtrace2.ml", line 47, characters 43-52
++ Called from Backtrace2.test_lazy.aux in file "backtrace2.ml", line 47, characters 43-52
++ Called from Backtrace2.test_lazy.aux in file "backtrace2.ml", line 47, characters 43-52
++-Called from CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 49, characters 17-27
++-Re-raised at CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 56, characters 4-11
+++Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 119, characters 17-27
+++Re-raised at CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 124, characters 4-11
++ Called from Backtrace2.run in file "backtrace2.ml", line 62, characters 11-23
++ Uncaught exception Not_found
++-Raised at Stdlib__Hashtbl.find in file "hashtbl.ml", line 541, characters 13-28
+++Raised at Stdlib__Hashtbl.find in file "hashtbl.ml", line 549, characters 13-28
++ Called from Backtrace2.test_lazy.exception_raised_internally in file "backtrace2.ml", line 50, characters 8-41
++-Re-raised at CamlinternalLazy.do_force_block.(fun) in file "camlinternalLazy.ml", line 54, characters 43-50
++-Called from CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 49, characters 17-27
++-Re-raised at CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 56, characters 4-11
+++Re-raised at CamlinternalLazy.force_lazy_block.(fun) in file "camlinternalLazy.ml", line 123, characters 56-63
+++Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 119, characters 17-27
+++Re-raised at CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 124, characters 4-11
++ Called from Backtrace2.run in file "backtrace2.ml", line 62, characters 11-23
++diff --git a/testsuite/tests/backtrace/backtrace_c_exn.ml b/testsuite/tests/backtrace/backtrace_c_exn.ml
++index 9b0077d509..1680c23f7b 100644
++--- a/testsuite/tests/backtrace/backtrace_c_exn.ml
+++++ b/testsuite/tests/backtrace/backtrace_c_exn.ml
++@@ -2,6 +2,8 @@
++    modules = "backtrace_c_exn_.c"
++    flags = "-g"
++    ocamlrunparam += ",b=1"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ (* https://github.com/ocaml-multicore/ocaml-multicore/issues/498 *)
++diff --git a/testsuite/tests/backtrace/backtrace_dynlink.flambda.reference b/testsuite/tests/backtrace/backtrace_dynlink.flambda.reference
++index b7907c99bd..d47343fbe9 100644
++--- a/testsuite/tests/backtrace/backtrace_dynlink.flambda.reference
+++++ b/testsuite/tests/backtrace/backtrace_dynlink.flambda.reference
++@@ -2,19 +2,23 @@ Raised by primitive operation at Backtrace_dynlink_plugin in file "backtrace_dyn
++ Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
++ Called from Stdlib__List.iter in file "list.ml" (inlined), line 110, characters 12-15
++ Called from Dynlink.Native.run in file "otherlibs/dynlink/native/dynlink.ml", line 84, characters 4-273
++-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 363, characters 13-56
+++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
++ Called from Stdlib__List.iter in file "list.ml" (inlined), line 110, characters 12-15
++-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
++-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
+++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
+++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
++ Called from Backtrace_dynlink in file "backtrace_dynlink.ml", line 39, characters 4-52
++ execution of module initializers in the shared library failed: Failure("SUCCESS")
++-Raised by primitive operation at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
+++Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+++Called from Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 3, characters 4-22
+++Re-raised at Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 8, characters 5-12
+++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
+++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
++ Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 87, characters 10-149
++ Called from Stdlib__List.iter in file "list.ml" (inlined), line 110, characters 12-15
++ Called from Dynlink.Native.run in file "otherlibs/dynlink/native/dynlink.ml", line 84, characters 4-273
++-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 363, characters 13-56
+++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
++ Called from Stdlib__List.iter in file "list.ml" (inlined), line 110, characters 12-15
++-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
++-Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 8-17
++-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
+++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
+++Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 381, characters 8-17
+++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
++ Called from Backtrace_dynlink in file "backtrace_dynlink.ml", line 39, characters 4-52
++diff --git a/testsuite/tests/backtrace/backtrace_dynlink.reference b/testsuite/tests/backtrace/backtrace_dynlink.reference
++index 570aca891f..4c6999e85d 100644
++--- a/testsuite/tests/backtrace/backtrace_dynlink.reference
+++++ b/testsuite/tests/backtrace/backtrace_dynlink.reference
++@@ -1,18 +1,22 @@
++ Raised by primitive operation at Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 6, characters 13-38
++ Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
++ Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 363, characters 13-56
+++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
++ Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
++-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
+++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
+++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
++ Called from Backtrace_dynlink in file "backtrace_dynlink.ml", line 39, characters 4-52
++ execution of module initializers in the shared library failed: Failure("SUCCESS")
++-Raised by primitive operation at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
+++Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+++Called from Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 3, characters 4-22
+++Re-raised at Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 8, characters 5-12
+++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
+++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
++ Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 87, characters 10-149
++ Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 363, characters 13-56
+++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
++ Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
++-Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 8-17
++-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
+++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
+++Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 381, characters 8-17
+++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
++ Called from Backtrace_dynlink in file "backtrace_dynlink.ml", line 39, characters 4-52
++diff --git a/testsuite/tests/backtrace/backtrace_effects.ml b/testsuite/tests/backtrace/backtrace_effects.ml
++index 352b32cbd7..bafd2259e8 100644
++--- a/testsuite/tests/backtrace/backtrace_effects.ml
+++++ b/testsuite/tests/backtrace/backtrace_effects.ml
++@@ -2,6 +2,8 @@
++    flags = "-g"
++    ocamlrunparam += ",b=1"
++    exit_status = "2"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ open Effect
++diff --git a/testsuite/tests/backtrace/backtrace_effects_nested.ml b/testsuite/tests/backtrace/backtrace_effects_nested.ml
++index 37638a200a..2a2a630160 100644
++--- a/testsuite/tests/backtrace/backtrace_effects_nested.ml
+++++ b/testsuite/tests/backtrace/backtrace_effects_nested.ml
++@@ -1,12 +1,14 @@
++ (* TEST
++ 
++ flags = "-g"
++-* bytecode
++-* no-flambda
++-** native
++-* flambda
+++* skip
+++reason = "OCaml 5 only"
+++** bytecode
+++** no-flambda
+++*** native
+++** flambda
++ reference = "${test_source_directory}/backtrace_effects_nested.flambda.reference"
++-** native
+++*** native
++ 
++ *)
++ 
++diff --git a/testsuite/tests/backtrace/backtrace_systhreads.reference b/testsuite/tests/backtrace/backtrace_systhreads.reference
++index 78028c5752..815506e7ea 100644
++--- a/testsuite/tests/backtrace/backtrace_systhreads.reference
+++++ b/testsuite/tests/backtrace/backtrace_systhreads.reference
++@@ -2,24 +2,24 @@ Thread 2 killed on uncaught exception Failure("0")
++ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++ Called from Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 14, characters 6-37
++ Re-raised at Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 18, characters 5-14
++-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++ Thread 3 killed on uncaught exception Failure("1")
++ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++ Called from Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 14, characters 6-37
++ Re-raised at Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 18, characters 5-14
++-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++ Thread 4 killed on uncaught exception Failure("2")
++ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++ Called from Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 14, characters 6-37
++ Re-raised at Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 18, characters 5-14
++-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++ Thread 5 killed on uncaught exception Failure("3")
++ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++ Called from Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 14, characters 6-37
++ Re-raised at Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 18, characters 5-14
++-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++ Thread 1 killed on uncaught exception Failure("backtrace")
++ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++ Called from Backtrace_systhreads.thread_backtrace in file "backtrace_systhreads.ml", line 22, characters 6-27
++ Re-raised at Backtrace_systhreads.thread_backtrace in file "backtrace_systhreads.ml", line 26, characters 5-14
++-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++diff --git a/testsuite/tests/backtrace/callstack.reference b/testsuite/tests/backtrace/callstack.reference
++index 05eacbbc81..8287432b20 100644
++--- a/testsuite/tests/backtrace/callstack.reference
+++++ b/testsuite/tests/backtrace/callstack.reference
++@@ -12,4 +12,4 @@ Raised by primitive operation at Callstack.f0 in file "callstack.ml", line 11, c
++ Called from Callstack.f1 in file "callstack.ml", line 12, characters 27-32
++ Called from Callstack.f2 in file "callstack.ml", line 13, characters 27-32
++ Called from Callstack.f3 in file "callstack.ml", line 14, characters 27-32
++-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++diff --git a/testsuite/tests/backtrace/lazy.reference b/testsuite/tests/backtrace/lazy.reference
++index 5e8f53482f..af15509686 100644
++--- a/testsuite/tests/backtrace/lazy.reference
+++++ b/testsuite/tests/backtrace/lazy.reference
++@@ -1,14 +1,12 @@
++ Uncaught exception Not_found
++ Raised at Lazy.l1 in file "lazy.ml", line 7, characters 28-45
++-Called from CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 49, characters 17-27
++-Re-raised at CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 56, characters 4-11
++-Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml" (inlined), line 78, characters 27-67
+++Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 119, characters 17-27
+++Re-raised at CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 124, characters 4-11
++ Called from Lazy.test1 in file "lazy.ml", line 10, characters 11-24
++ Called from Lazy.run in file "lazy.ml", line 19, characters 4-11
++ Uncaught exception Not_found
++ Raised at Lazy.l2 in file "lazy.ml", line 12, characters 28-45
++-Called from CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 49, characters 17-27
++-Re-raised at CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 56, characters 4-11
++-Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml" (inlined), line 78, characters 27-67
+++Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 119, characters 17-27
+++Re-raised at CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 124, characters 4-11
++ Called from Lazy.test2 in file "lazy.ml", line 15, characters 6-15
++ Called from Lazy.run in file "lazy.ml", line 19, characters 4-11
++diff --git a/testsuite/tests/basic/patmatch_for_multiple.ml b/testsuite/tests/basic/patmatch_for_multiple.ml
++index 6433f3d9a4..cbe78cdd0b 100644
++--- a/testsuite/tests/basic/patmatch_for_multiple.ml
+++++ b/testsuite/tests/basic/patmatch_for_multiple.ml
++@@ -26,15 +26,15 @@ match (3, 2, 1) with
++ | _ -> false
++ ;;
++ [%%expect{|
++-(let (*match*/274 = 3 *match*/275 = 2 *match*/276 = 1)
+++(let (*match*/269 = 3 *match*/270 = 2 *match*/271 = 1)
++   (catch
++     (catch
++-      (catch (if (!= *match*/275 3) (exit 3) (exit 1)) with (3)
++-        (if (!= *match*/274 1) (exit 2) (exit 1)))
+++      (catch (if (!= *match*/270 3) (exit 3) (exit 1)) with (3)
+++        (if (!= *match*/269 1) (exit 2) (exit 1)))
++      with (2) 0)
++    with (1) 1))
++-(let (*match*/274 = 3 *match*/275 = 2 *match*/276 = 1)
++-  (catch (if (!= *match*/275 3) (if (!= *match*/274 1) 0 (exit 1)) (exit 1))
+++(let (*match*/269 = 3 *match*/270 = 2 *match*/271 = 1)
+++  (catch (if (!= *match*/270 3) (if (!= *match*/269 1) 0 (exit 1)) (exit 1))
++    with (1) 1))
++ - : bool = false
++ |}];;
++@@ -47,26 +47,26 @@ match (3, 2, 1) with
++ | _ -> false
++ ;;
++ [%%expect{|
++-(let (*match*/279 = 3 *match*/280 = 2 *match*/281 = 1)
+++(let (*match*/274 = 3 *match*/275 = 2 *match*/276 = 1)
++   (catch
++     (catch
++       (catch
++-        (if (!= *match*/280 3) (exit 6)
++-          (let (x/283 =a (makeblock 0 *match*/279 *match*/280 *match*/281))
++-            (exit 4 x/283)))
+++        (if (!= *match*/275 3) (exit 6)
+++          (let (x/278 =a (makeblock 0 *match*/274 *match*/275 *match*/276))
+++            (exit 4 x/278)))
++        with (6)
++-        (if (!= *match*/279 1) (exit 5)
++-          (let (x/282 =a (makeblock 0 *match*/279 *match*/280 *match*/281))
++-            (exit 4 x/282))))
+++        (if (!= *match*/274 1) (exit 5)
+++          (let (x/277 =a (makeblock 0 *match*/274 *match*/275 *match*/276))
+++            (exit 4 x/277))))
++      with (5) 0)
++-   with (4 x/277) (seq (ignore x/277) 1)))
++-(let (*match*/279 = 3 *match*/280 = 2 *match*/281 = 1)
+++   with (4 x/272) (seq (ignore x/272) 1)))
+++(let (*match*/274 = 3 *match*/275 = 2 *match*/276 = 1)
++   (catch
++-    (if (!= *match*/280 3)
++-      (if (!= *match*/279 1) 0
++-        (exit 4 (makeblock 0 *match*/279 *match*/280 *match*/281)))
++-      (exit 4 (makeblock 0 *match*/279 *match*/280 *match*/281)))
++-   with (4 x/277) (seq (ignore x/277) 1)))
+++    (if (!= *match*/275 3)
+++      (if (!= *match*/274 1) 0
+++        (exit 4 (makeblock 0 *match*/274 *match*/275 *match*/276)))
+++      (exit 4 (makeblock 0 *match*/274 *match*/275 *match*/276)))
+++   with (4 x/272) (seq (ignore x/272) 1)))
++ - : bool = false
++ |}];;
++ 
++@@ -76,8 +76,8 @@ let _ = fun a b ->
++   | ((true, _) as _g)
++   | ((false, _) as _g) -> ()
++ [%%expect{|
++-(function a/284[int] b/285 : int 0)
++-(function a/284[int] b/285 : int 0)
+++(function a/279[int] b/280 : int 0)
+++(function a/279[int] b/280 : int 0)
++ - : bool -> 'a -> unit = <fun>
++ |}];;
++ 
++@@ -96,8 +96,8 @@ let _ = fun a b -> match a, b with
++ | (false, _) as p -> p
++ (* outside, trivial *)
++ [%%expect {|
++-(function a/288[int] b/289 (let (p/290 =a (makeblock 0 a/288 b/289)) p/290))
++-(function a/288[int] b/289 (makeblock 0 a/288 b/289))
+++(function a/283[int] b/284 (let (p/285 =a (makeblock 0 a/283 b/284)) p/285))
+++(function a/283[int] b/284 (makeblock 0 a/283 b/284))
++ - : bool -> 'a -> bool * 'a = <fun>
++ |}]
++ 
++@@ -106,8 +106,8 @@ let _ = fun a b -> match a, b with
++ | ((false, _) as p) -> p
++ (* inside, trivial *)
++ [%%expect{|
++-(function a/292[int] b/293 (let (p/294 =a (makeblock 0 a/292 b/293)) p/294))
++-(function a/292[int] b/293 (makeblock 0 a/292 b/293))
+++(function a/287[int] b/288 (let (p/289 =a (makeblock 0 a/287 b/288)) p/289))
+++(function a/287[int] b/288 (makeblock 0 a/287 b/288))
++ - : bool -> 'a -> bool * 'a = <fun>
++ |}];;
++ 
++@@ -116,11 +116,11 @@ let _ = fun a b -> match a, b with
++ | (false as x, _) as p -> x, p
++ (* outside, simple *)
++ [%%expect {|
++-(function a/298[int] b/299
++-  (let (x/300 =a[int] a/298 p/301 =a (makeblock 0 a/298 b/299))
++-    (makeblock 0 (int,*) x/300 p/301)))
++-(function a/298[int] b/299
++-  (makeblock 0 (int,*) a/298 (makeblock 0 a/298 b/299)))
+++(function a/293[int] b/294
+++  (let (x/295 =a[int] a/293 p/296 =a (makeblock 0 a/293 b/294))
+++    (makeblock 0 (int,*) x/295 p/296)))
+++(function a/293[int] b/294
+++  (makeblock 0 (int,*) a/293 (makeblock 0 a/293 b/294)))
++ - : bool -> 'a -> bool * (bool * 'a) = <fun>
++ |}]
++ 
++@@ -129,11 +129,11 @@ let _ = fun a b -> match a, b with
++ | ((false as x, _) as p) -> x, p
++ (* inside, simple *)
++ [%%expect {|
++-(function a/304[int] b/305
++-  (let (x/306 =a[int] a/304 p/307 =a (makeblock 0 a/304 b/305))
++-    (makeblock 0 (int,*) x/306 p/307)))
++-(function a/304[int] b/305
++-  (makeblock 0 (int,*) a/304 (makeblock 0 a/304 b/305)))
+++(function a/299[int] b/300
+++  (let (x/301 =a[int] a/299 p/302 =a (makeblock 0 a/299 b/300))
+++    (makeblock 0 (int,*) x/301 p/302)))
+++(function a/299[int] b/300
+++  (makeblock 0 (int,*) a/299 (makeblock 0 a/299 b/300)))
++ - : bool -> 'a -> bool * (bool * 'a) = <fun>
++ |}]
++ 
++@@ -142,15 +142,15 @@ let _ = fun a b -> match a, b with
++ | (false, x) as p -> x, p
++ (* outside, complex *)
++ [%%expect{|
++-(function a/314[int] b/315[int]
++-  (if a/314
++-    (let (x/316 =a[int] a/314 p/317 =a (makeblock 0 a/314 b/315))
++-      (makeblock 0 (int,*) x/316 p/317))
++-    (let (x/318 =a b/315 p/319 =a (makeblock 0 a/314 b/315))
++-      (makeblock 0 (int,*) x/318 p/319))))
++-(function a/314[int] b/315[int]
++-  (if a/314 (makeblock 0 (int,*) a/314 (makeblock 0 a/314 b/315))
++-    (makeblock 0 (int,*) b/315 (makeblock 0 a/314 b/315))))
+++(function a/309[int] b/310[int]
+++  (if a/309
+++    (let (x/311 =a[int] a/309 p/312 =a (makeblock 0 a/309 b/310))
+++      (makeblock 0 (int,*) x/311 p/312))
+++    (let (x/313 =a b/310 p/314 =a (makeblock 0 a/309 b/310))
+++      (makeblock 0 (int,*) x/313 p/314))))
+++(function a/309[int] b/310[int]
+++  (if a/309 (makeblock 0 (int,*) a/309 (makeblock 0 a/309 b/310))
+++    (makeblock 0 (int,*) b/310 (makeblock 0 a/309 b/310))))
++ - : bool -> bool -> bool * (bool * bool) = <fun>
++ |}]
++ 
++@@ -160,19 +160,19 @@ let _ = fun a b -> match a, b with
++   -> x, p
++ (* inside, complex *)
++ [%%expect{|
++-(function a/320[int] b/321[int]
+++(function a/315[int] b/316[int]
++   (catch
++-    (if a/320
++-      (let (x/328 =a[int] a/320 p/329 =a (makeblock 0 a/320 b/321))
++-        (exit 10 x/328 p/329))
++-      (let (x/326 =a b/321 p/327 =a (makeblock 0 a/320 b/321))
++-        (exit 10 x/326 p/327)))
++-   with (10 x/322[int] p/323) (makeblock 0 (int,*) x/322 p/323)))
++-(function a/320[int] b/321[int]
+++    (if a/315
+++      (let (x/323 =a[int] a/315 p/324 =a (makeblock 0 a/315 b/316))
+++        (exit 10 x/323 p/324))
+++      (let (x/321 =a b/316 p/322 =a (makeblock 0 a/315 b/316))
+++        (exit 10 x/321 p/322)))
+++   with (10 x/317[int] p/318) (makeblock 0 (int,*) x/317 p/318)))
+++(function a/315[int] b/316[int]
++   (catch
++-    (if a/320 (exit 10 a/320 (makeblock 0 a/320 b/321))
++-      (exit 10 b/321 (makeblock 0 a/320 b/321)))
++-   with (10 x/322[int] p/323) (makeblock 0 (int,*) x/322 p/323)))
+++    (if a/315 (exit 10 a/315 (makeblock 0 a/315 b/316))
+++      (exit 10 b/316 (makeblock 0 a/315 b/316)))
+++   with (10 x/317[int] p/318) (makeblock 0 (int,*) x/317 p/318)))
++ - : bool -> bool -> bool * (bool * bool) = <fun>
++ |}]
++ 
++@@ -185,15 +185,15 @@ let _ = fun a b -> match a, b with
++ | (false as x, _) as p -> x, p
++ (* outside, onecase *)
++ [%%expect {|
++-(function a/330[int] b/331[int]
++-  (if a/330
++-    (let (x/332 =a[int] a/330 _p/333 =a (makeblock 0 a/330 b/331))
++-      (makeblock 0 (int,*) x/332 [0: 1 1]))
++-    (let (x/334 =a[int] a/330 p/335 =a (makeblock 0 a/330 b/331))
++-      (makeblock 0 (int,*) x/334 p/335))))
++-(function a/330[int] b/331[int]
++-  (if a/330 (makeblock 0 (int,*) a/330 [0: 1 1])
++-    (makeblock 0 (int,*) a/330 (makeblock 0 a/330 b/331))))
+++(function a/325[int] b/326[int]
+++  (if a/325
+++    (let (x/327 =a[int] a/325 _p/328 =a (makeblock 0 a/325 b/326))
+++      (makeblock 0 (int,*) x/327 [0: 1 1]))
+++    (let (x/329 =a[int] a/325 p/330 =a (makeblock 0 a/325 b/326))
+++      (makeblock 0 (int,*) x/329 p/330))))
+++(function a/325[int] b/326[int]
+++  (if a/325 (makeblock 0 (int,*) a/325 [0: 1 1])
+++    (makeblock 0 (int,*) a/325 (makeblock 0 a/325 b/326))))
++ - : bool -> bool -> bool * (bool * bool) = <fun>
++ |}]
++ 
++@@ -202,11 +202,11 @@ let _ = fun a b -> match a, b with
++ | ((false as x, _) as p) -> x, p
++ (* inside, onecase *)
++ [%%expect{|
++-(function a/336[int] b/337
++-  (let (x/338 =a[int] a/336 p/339 =a (makeblock 0 a/336 b/337))
++-    (makeblock 0 (int,*) x/338 p/339)))
++-(function a/336[int] b/337
++-  (makeblock 0 (int,*) a/336 (makeblock 0 a/336 b/337)))
+++(function a/331[int] b/332
+++  (let (x/333 =a[int] a/331 p/334 =a (makeblock 0 a/331 b/332))
+++    (makeblock 0 (int,*) x/333 p/334)))
+++(function a/331[int] b/332
+++  (makeblock 0 (int,*) a/331 (makeblock 0 a/331 b/332)))
++ - : bool -> 'a -> bool * (bool * 'a) = <fun>
++ |}]
++ 
++@@ -223,14 +223,14 @@ let _ =fun a b -> match a, b with
++ | (_, _) as p -> p
++ (* outside, tuplist *)
++ [%%expect {|
++-(function a/349[int] b/350
+++(function a/344[int] b/345
++   (catch
++-    (if a/349 (if b/350 (let (p/351 =a (field_imm 0 b/350)) p/351) (exit 12))
+++    (if a/344 (if b/345 (let (p/346 =a (field_imm 0 b/345)) p/346) (exit 12))
++       (exit 12))
++-   with (12) (let (p/352 =a (makeblock 0 a/349 b/350)) p/352)))
++-(function a/349[int] b/350
++-  (catch (if a/349 (if b/350 (field_imm 0 b/350) (exit 12)) (exit 12))
++-   with (12) (makeblock 0 a/349 b/350)))
+++   with (12) (let (p/347 =a (makeblock 0 a/344 b/345)) p/347)))
+++(function a/344[int] b/345
+++  (catch (if a/344 (if b/345 (field_imm 0 b/345) (exit 12)) (exit 12))
+++   with (12) (makeblock 0 a/344 b/345)))
++ - : bool -> bool tuplist -> bool * bool tuplist = <fun>
++ |}]
++ 
++@@ -239,20 +239,20 @@ let _ = fun a b -> match a, b with
++ | ((_, _) as p) -> p
++ (* inside, tuplist *)
++ [%%expect{|
++-(function a/353[int] b/354
+++(function a/348[int] b/349
++   (catch
++     (catch
++-      (if a/353
++-        (if b/354 (let (p/358 =a (field_imm 0 b/354)) (exit 13 p/358))
+++      (if a/348
+++        (if b/349 (let (p/353 =a (field_imm 0 b/349)) (exit 13 p/353))
++           (exit 14))
++         (exit 14))
++-     with (14) (let (p/357 =a (makeblock 0 a/353 b/354)) (exit 13 p/357)))
++-   with (13 p/355) p/355))
++-(function a/353[int] b/354
+++     with (14) (let (p/352 =a (makeblock 0 a/348 b/349)) (exit 13 p/352)))
+++   with (13 p/350) p/350))
+++(function a/348[int] b/349
++   (catch
++     (catch
++-      (if a/353 (if b/354 (exit 13 (field_imm 0 b/354)) (exit 14)) (exit 14))
++-     with (14) (exit 13 (makeblock 0 a/353 b/354)))
++-   with (13 p/355) p/355))
+++      (if a/348 (if b/349 (exit 13 (field_imm 0 b/349)) (exit 14)) (exit 14))
+++     with (14) (exit 13 (makeblock 0 a/348 b/349)))
+++   with (13 p/350) p/350))
++ - : bool -> bool tuplist -> bool * bool tuplist = <fun>
++ |}]
++diff --git a/testsuite/tests/c-api/alloc_async.ml b/testsuite/tests/c-api/alloc_async.ml
++index b8c99a4b07..0ed35acf16 100644
++--- a/testsuite/tests/c-api/alloc_async.ml
+++++ b/testsuite/tests/c-api/alloc_async.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    modules = "alloc_async_stubs.c"
++-   * skip
++-   reason = "alloc async changes: https://github.com/ocaml/ocaml/pull/8897"
++ *)
++ 
++ external test : int ref -> unit = "stub"
++diff --git a/testsuite/tests/callback/nested_fiber.ml b/testsuite/tests/callback/nested_fiber.ml
++index 3786e455ef..77478728df 100644
++--- a/testsuite/tests/callback/nested_fiber.ml
+++++ b/testsuite/tests/callback/nested_fiber.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++    include unix
++    modules = "nested_fiber_.c"
++-   * libunix
++-   ** bytecode
++-   ** native
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** libunix
+++   *** bytecode
+++   *** native
++ *)
++ 
++ external caml_to_c : (unit -> 'a) -> 'a = "caml_to_c"
++diff --git a/testsuite/tests/callback/stack_overflow.ml b/testsuite/tests/callback/stack_overflow.ml
++index 23691dcf6c..6281d76e2a 100644
++--- a/testsuite/tests/callback/stack_overflow.ml
+++++ b/testsuite/tests/callback/stack_overflow.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++    include unix
++    modules = "stack_overflow_.c"
++-   * libunix
++-   ** bytecode
++-   ** native
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** libunix
+++   *** bytecode
+++   *** native
++ *)
++ 
++ external caml_to_c : (unit -> 'a) -> 'a = "caml_to_c"
++diff --git a/testsuite/tests/callback/test7.ml b/testsuite/tests/callback/test7.ml
++index 9419dd5c6f..e523ba85b7 100644
++--- a/testsuite/tests/callback/test7.ml
+++++ b/testsuite/tests/callback/test7.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++    include unix
++    modules = "test7_.c"
++-   * libunix
++-   ** bytecode
++-   ** native
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** libunix
+++   *** bytecode
+++   *** native
++ *)
++ 
++ (* Tests nested calls from C (main C) to OCaml (main OCaml) to C (caml_to_c) to
++diff --git a/testsuite/tests/callback/test_signalhandler.ml b/testsuite/tests/callback/test_signalhandler.ml
++index a2bbacee72..9250395618 100644
++--- a/testsuite/tests/callback/test_signalhandler.ml
+++++ b/testsuite/tests/callback/test_signalhandler.ml
++@@ -1,6 +1,6 @@
++ (* TEST
++    include unix
++-   modules = "test_signalhandler_.c"
+++   modules = "callbackprim.c"
++    * libunix
++    ** bytecode
++    ** native
++@@ -52,17 +52,19 @@ let sighandler signo =
++   (* Thoroughly wipe the minor heap *)
++   ignore (tak (18, 12, 6))
++ 
++-external mykill : int -> int -> unit = "mykill" [@@noalloc]
+++external raise_sigusr1 : unit -> unit = "raise_sigusr1" [@@noalloc]
+++(*external mykill : int -> int -> unit = "mykill" [@@noalloc]*)
++ 
++ let callbacksig () =
++-  let pid = Unix.getpid () in
+++  let _pid = Unix.getpid() in
++   (* Allocate a block in the minor heap *)
++   let s = String.make 5 'b' in
++   (* Send a signal to self.  We want s to remain in a register and
++      not be spilled on the stack, hence we use [mykill]
++      (which is [@@noalloc] and doesn't trigger signal handling)
++      instead of [Unix.kill]. *)
++-  mykill pid Sys.sigusr1;
+++  (*mykill pid Sys.sigusr1;*)
+++  raise_sigusr1 ();
++   (* Allocate some more so that the signal will be tested *)
++   let u = (s, s) in
++   fst u
++diff --git a/testsuite/tests/effects/backtrace.ml b/testsuite/tests/effects/backtrace.ml
++index 6257ba75c5..df6e11ac7a 100644
++--- a/testsuite/tests/effects/backtrace.ml
+++++ b/testsuite/tests/effects/backtrace.ml
++@@ -1,6 +1,8 @@
++ (* TEST
++    flags = "-g"
++    ocamlrunparam += ",b=1"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/cmphash.ml b/testsuite/tests/effects/cmphash.ml
++index 78481d6404..a36d20cb8c 100644
++--- a/testsuite/tests/effects/cmphash.ml
+++++ b/testsuite/tests/effects/cmphash.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/evenodd.ml b/testsuite/tests/effects/evenodd.ml
++index 07464edb7a..e9b2d5a2fb 100644
++--- a/testsuite/tests/effects/evenodd.ml
+++++ b/testsuite/tests/effects/evenodd.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/issue479.ml b/testsuite/tests/effects/issue479.ml
++index 228e098d2e..c00b55c6ff 100644
++--- a/testsuite/tests/effects/issue479.ml
+++++ b/testsuite/tests/effects/issue479.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++-   * toplevel
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** toplevel
++ *)
++ 
++ (* https://github.com/ocaml-multicore/ocaml-multicore/issues/479 *)
++diff --git a/testsuite/tests/effects/overflow.ml b/testsuite/tests/effects/overflow.ml
++index a187e9e10d..c12503863e 100644
++--- a/testsuite/tests/effects/overflow.ml
+++++ b/testsuite/tests/effects/overflow.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/partial.ml b/testsuite/tests/effects/partial.ml
++index 50e4b53cfc..010741b9fc 100644
++--- a/testsuite/tests/effects/partial.ml
+++++ b/testsuite/tests/effects/partial.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/reperform.ml b/testsuite/tests/effects/reperform.ml
++index 8aefdd0587..685b48b5dd 100644
++--- a/testsuite/tests/effects/reperform.ml
+++++ b/testsuite/tests/effects/reperform.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/sched.ml b/testsuite/tests/effects/sched.ml
++index 3dc14a2cfc..6065d21c70 100644
++--- a/testsuite/tests/effects/sched.ml
+++++ b/testsuite/tests/effects/sched.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/shallow_state.ml b/testsuite/tests/effects/shallow_state.ml
++index 56c61b0c3c..4d52362bc7 100644
++--- a/testsuite/tests/effects/shallow_state.ml
+++++ b/testsuite/tests/effects/shallow_state.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/shallow_state_io.ml b/testsuite/tests/effects/shallow_state_io.ml
++index 6b1fa649a7..6ca4fef8b1 100644
++--- a/testsuite/tests/effects/shallow_state_io.ml
+++++ b/testsuite/tests/effects/shallow_state_io.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/test1.ml b/testsuite/tests/effects/test1.ml
++index 5d05359f8a..65da5c8b90 100644
++--- a/testsuite/tests/effects/test1.ml
+++++ b/testsuite/tests/effects/test1.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/test10.ml b/testsuite/tests/effects/test10.ml
++index 29c5f47f25..9b10559cfd 100644
++--- a/testsuite/tests/effects/test10.ml
+++++ b/testsuite/tests/effects/test10.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/test11.ml b/testsuite/tests/effects/test11.ml
++index 6714473e0e..303cdd03c5 100644
++--- a/testsuite/tests/effects/test11.ml
+++++ b/testsuite/tests/effects/test11.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ (* Tests RESUMETERM with extra_args != 0 in bytecode,
++diff --git a/testsuite/tests/effects/test2.ml b/testsuite/tests/effects/test2.ml
++index e9b8289bb2..f4e805f1d0 100644
++--- a/testsuite/tests/effects/test2.ml
+++++ b/testsuite/tests/effects/test2.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Printf
++diff --git a/testsuite/tests/effects/test3.ml b/testsuite/tests/effects/test3.ml
++index d76130eaaa..2828f933a7 100644
++--- a/testsuite/tests/effects/test3.ml
+++++ b/testsuite/tests/effects/test3.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/test4.ml b/testsuite/tests/effects/test4.ml
++index f5cf78cbda..77320a1ab5 100644
++--- a/testsuite/tests/effects/test4.ml
+++++ b/testsuite/tests/effects/test4.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/test5.ml b/testsuite/tests/effects/test5.ml
++index 33ed2c23ca..98802a934e 100644
++--- a/testsuite/tests/effects/test5.ml
+++++ b/testsuite/tests/effects/test5.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/test6.ml b/testsuite/tests/effects/test6.ml
++index ddfb83a5b6..6d4842f9fa 100644
++--- a/testsuite/tests/effects/test6.ml
+++++ b/testsuite/tests/effects/test6.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/test_lazy.ml b/testsuite/tests/effects/test_lazy.ml
++index 24f457f0af..036c7d5038 100644
++--- a/testsuite/tests/effects/test_lazy.ml
+++++ b/testsuite/tests/effects/test_lazy.ml
++@@ -1,4 +1,7 @@
++-(* TEST *)
+++(* TEST
+++   * skip
+++   reason = "OCaml 5 only"
+++*)
++ 
++ open Effect
++ open Effect.Deep
++diff --git a/testsuite/tests/effects/used_cont.ml b/testsuite/tests/effects/used_cont.ml
++index 71a33388ec..7972d000b7 100644
++--- a/testsuite/tests/effects/used_cont.ml
+++++ b/testsuite/tests/effects/used_cont.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/ephe-c-api/test.ml b/testsuite/tests/ephe-c-api/test.ml
++index ff1646835a..a29cd8516b 100644
++--- a/testsuite/tests/ephe-c-api/test.ml
+++++ b/testsuite/tests/ephe-c-api/test.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    modules = "stubs.c"
++-   * skip
++-   reason = "port the new Ephemeron C-api to multicore : https://github.com/ocaml/ocaml/pull/676"
++ *)
++ 
++ (* C version of ephetest.ml *)
++diff --git a/testsuite/tests/gc-roots/globroots.ml b/testsuite/tests/gc-roots/globroots.ml
++index 56d1586331..6bdb7fdaf3 100644
++--- a/testsuite/tests/gc-roots/globroots.ml
+++++ b/testsuite/tests/gc-roots/globroots.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    modules = "globrootsprim.c"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ module type GLOBREF = sig
++diff --git a/testsuite/tests/gc-roots/globroots_parallel.ml b/testsuite/tests/gc-roots/globroots_parallel.ml
++index 4c3e36d140..fabbaa8ec6 100644
++--- a/testsuite/tests/gc-roots/globroots_parallel.ml
+++++ b/testsuite/tests/gc-roots/globroots_parallel.ml
++@@ -1,6 +1,8 @@
++ (* TEST
++    flags += " -w a "
++    modules = "globrootsprim.c globroots.ml"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ open Globroots
++diff --git a/testsuite/tests/gc-roots/globroots_parallel_spawn_burn.ml b/testsuite/tests/gc-roots/globroots_parallel_spawn_burn.ml
++index bf392c13b0..cf932d9491 100644
++--- a/testsuite/tests/gc-roots/globroots_parallel_spawn_burn.ml
+++++ b/testsuite/tests/gc-roots/globroots_parallel_spawn_burn.ml
++@@ -1,6 +1,8 @@
++ (* TEST
++    flags += " -w a "
++    modules = "globrootsprim.c globroots.ml"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ open Globroots
++diff --git a/testsuite/tests/gc-roots/globroots_sequential.ml b/testsuite/tests/gc-roots/globroots_sequential.ml
++index 6bf995bf96..dc732ce6a3 100644
++--- a/testsuite/tests/gc-roots/globroots_sequential.ml
+++++ b/testsuite/tests/gc-roots/globroots_sequential.ml
++@@ -1,6 +1,8 @@
++ (* TEST
++    flags += " -w a "
++    modules = "globrootsprim.c globroots.ml"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ open Globroots
++ 
++diff --git a/testsuite/tests/generalized-open/gpr1506.ml b/testsuite/tests/generalized-open/gpr1506.ml
++index bd72ed302f..6d21977529 100644
++--- a/testsuite/tests/generalized-open/gpr1506.ml
+++++ b/testsuite/tests/generalized-open/gpr1506.ml
++@@ -103,9 +103,9 @@ include struct open struct type t = T end let x = T end
++ Line 1, characters 15-41:
++ 1 | include struct open struct type t = T end let x = T end
++                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
++-Error: The type t/337 introduced by this open appears in the signature
+++Error: The type t/332 introduced by this open appears in the signature
++        Line 1, characters 46-47:
++-         The value x has no valid type if t/337 is hidden
+++         The value x has no valid type if t/332 is hidden
++ |}];;
++ 
++ module A = struct
++@@ -123,9 +123,9 @@ Lines 3-6, characters 4-7:
++ 4 |       type t = T
++ 5 |       let x = T
++ 6 |     end
++-Error: The type t/342 introduced by this open appears in the signature
+++Error: The type t/337 introduced by this open appears in the signature
++        Line 7, characters 8-9:
++-         The value y has no valid type if t/342 is hidden
+++         The value y has no valid type if t/337 is hidden
++ |}];;
++ 
++ module A = struct
++@@ -142,9 +142,9 @@ Lines 3-5, characters 4-7:
++ 3 | ....open struct
++ 4 |       type t = T
++ 5 |     end
++-Error: The type t/347 introduced by this open appears in the signature
+++Error: The type t/342 introduced by this open appears in the signature
++        Line 6, characters 8-9:
++-         The value y has no valid type if t/347 is hidden
+++         The value y has no valid type if t/342 is hidden
++ |}]
++ 
++ (* It was decided to not allow this anymore. *)
++diff --git a/testsuite/tests/instrumented-runtime/main.ml b/testsuite/tests/instrumented-runtime/main.ml
++index 084ceb03ca..94200ec67f 100644
++--- a/testsuite/tests/instrumented-runtime/main.ml
+++++ b/testsuite/tests/instrumented-runtime/main.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++   * instrumented-runtime
++-  * skip
++-  reason = "instrumented runtime test is not very useful and broken on multicore. (#9413)"
++   ** native
++     flags = "-runtime-variant=i"
++ *)
++diff --git a/testsuite/tests/lazy/lazy2.ml b/testsuite/tests/lazy/lazy2.ml
++index cccbd96d71..35dd7fd85b 100644
++--- a/testsuite/tests/lazy/lazy2.ml
+++++ b/testsuite/tests/lazy/lazy2.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    ocamlopt_flags += " -O3 "
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ open Domain
++diff --git a/testsuite/tests/lazy/lazy3.ml b/testsuite/tests/lazy/lazy3.ml
++index a22a0893b9..737791b7db 100644
++--- a/testsuite/tests/lazy/lazy3.ml
+++++ b/testsuite/tests/lazy/lazy3.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    ocamlopt_flags += " -O3 "
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ let f count =
++diff --git a/testsuite/tests/lazy/lazy5.ml b/testsuite/tests/lazy/lazy5.ml
++index 217b84175e..e37b499268 100644
++--- a/testsuite/tests/lazy/lazy5.ml
+++++ b/testsuite/tests/lazy/lazy5.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    ocamlopt_flags += " -O3 "
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ let rec safe_force l =
++   try Lazy.force l with
++diff --git a/testsuite/tests/lazy/lazy6.ml b/testsuite/tests/lazy/lazy6.ml
++index 098848769a..29067f1a41 100644
++--- a/testsuite/tests/lazy/lazy6.ml
+++++ b/testsuite/tests/lazy/lazy6.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    ocamlopt_flags += " -O3 "
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ let flag1 = Atomic.make false
++diff --git a/testsuite/tests/lazy/lazy7.ml b/testsuite/tests/lazy/lazy7.ml
++index 6c96f32907..d9c9b82127 100644
++--- a/testsuite/tests/lazy/lazy7.ml
+++++ b/testsuite/tests/lazy/lazy7.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    ocamlopt_flags += " -O3 "
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ let num_domains = 4
++diff --git a/testsuite/tests/lazy/lazy8.ml b/testsuite/tests/lazy/lazy8.ml
++index c9b5781617..ddadf48a1b 100644
++--- a/testsuite/tests/lazy/lazy8.ml
+++++ b/testsuite/tests/lazy/lazy8.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    ocamlopt_flags += " -O3 "
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ exception E
++diff --git a/testsuite/tests/lazy/minor_major_force.ml b/testsuite/tests/lazy/minor_major_force.ml
++index b18fe44a9b..d7497f986d 100644
++--- a/testsuite/tests/lazy/minor_major_force.ml
+++++ b/testsuite/tests/lazy/minor_major_force.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    ocamlopt_flags += " -O3 "
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ (*
++diff --git a/testsuite/tests/lf_skiplist/test.ml b/testsuite/tests/lf_skiplist/test.ml
++index f3b11bf411..4dcffc523d 100644
++--- a/testsuite/tests/lf_skiplist/test.ml
+++++ b/testsuite/tests/lf_skiplist/test.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    modules = "stubs.c"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ external test_skiplist_serial : unit -> unit = "test_skiplist_serial"
++diff --git a/testsuite/tests/lf_skiplist/test_parallel.ml b/testsuite/tests/lf_skiplist/test_parallel.ml
++index ac02717889..c882a8dac7 100644
++--- a/testsuite/tests/lf_skiplist/test_parallel.ml
+++++ b/testsuite/tests/lf_skiplist/test_parallel.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    modules = "stubs.c"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ external init_skiplist : unit -> unit = "init_skiplist"
++diff --git a/testsuite/tests/lib-dynlink-domains/main.ml b/testsuite/tests/lib-dynlink-domains/main.ml
++index 1feeb3918a..781d82300a 100644
++--- a/testsuite/tests/lib-dynlink-domains/main.ml
+++++ b/testsuite/tests/lib-dynlink-domains/main.ml
++@@ -4,168 +4,170 @@ include dynlink
++ libraries = ""
++ readonly_files = "store.ml main.ml Plugin_0.ml Plugin_0_0.ml Plugin_0_0_0.ml Plugin_0_0_0_0.ml Plugin_0_0_0_1.ml Plugin_0_0_0_2.ml Plugin_1.ml Plugin_1_0.ml Plugin_1_0_0.ml Plugin_1_0_0_0.ml Plugin_1_1.ml Plugin_1_2.ml Plugin_1_2_0.ml Plugin_1_2_0_0.ml Plugin_1_2_1.ml Plugin_1_2_2.ml Plugin_1_2_2_0.ml Plugin_1_2_3.ml Plugin_1_2_3_0.ml"
++ 
++-*01 shared-libraries
++-*02 setup-ocamlc.byte-build-env
++-*03 ocamlc.byte
+++* skip
+++reason = "OCaml 5 only"
+++**01 shared-libraries
+++**02 setup-ocamlc.byte-build-env
+++**03 ocamlc.byte
++ module = "store.ml"
++-*04 ocamlc.byte
+++**04 ocamlc.byte
++ module = "Plugin_0.ml"
++-*05 ocamlc.byte
+++**05 ocamlc.byte
++ module = "Plugin_0_0.ml"
++-*06 ocamlc.byte
+++**06 ocamlc.byte
++ module = "Plugin_0_0_0.ml"
++-*07 ocamlc.byte
+++**07 ocamlc.byte
++ module = "Plugin_0_0_0_0.ml"
++-*08 ocamlc.byte
+++**08 ocamlc.byte
++ module = "Plugin_0_0_0_1.ml"
++-*09 ocamlc.byte
+++**09 ocamlc.byte
++ module = "Plugin_0_0_0_2.ml"
++-*10 ocamlc.byte
+++**10 ocamlc.byte
++ module = "Plugin_1.ml"
++-*11 ocamlc.byte
+++**11 ocamlc.byte
++ module = "Plugin_1_0.ml"
++-*12 ocamlc.byte
+++**12 ocamlc.byte
++ module = "Plugin_1_0_0.ml"
++-*13 ocamlc.byte
+++**13 ocamlc.byte
++ module = "Plugin_1_0_0_0.ml"
++-*14 ocamlc.byte
+++**14 ocamlc.byte
++ module = "Plugin_1_1.ml"
++-*15 ocamlc.byte
+++**15 ocamlc.byte
++ module = "Plugin_1_2.ml"
++-*16 ocamlc.byte
+++**16 ocamlc.byte
++ module = "Plugin_1_2_0.ml"
++-*17 ocamlc.byte
+++**17 ocamlc.byte
++ module = "Plugin_1_2_0_0.ml"
++-*18 ocamlc.byte
+++**18 ocamlc.byte
++ module = "Plugin_1_2_1.ml"
++-*19 ocamlc.byte
+++**19 ocamlc.byte
++ module = "Plugin_1_2_2.ml"
++-*20 ocamlc.byte
+++**20 ocamlc.byte
++ module = "Plugin_1_2_2_0.ml"
++-*21 ocamlc.byte
+++**21 ocamlc.byte
++ module = "Plugin_1_2_3.ml"
++-*22 ocamlc.byte
+++**22 ocamlc.byte
++ module = "Plugin_1_2_3_0.ml"
++-*23 ocamlc.byte
+++**23 ocamlc.byte
++ module = "main.ml"
++-*24 ocamlc.byte
+++**24 ocamlc.byte
++ program = "./main.byte.exe"
++ libraries= "dynlink"
++ all_modules = "store.cmo main.cmo"
++ module = ""
++-*25 run
++-*26 check-program-output
+++**25 run
+++**26 check-program-output
++ 
++-*02 native-dynlink
++-*03 setup-ocamlopt.byte-build-env
++-*04 ocamlopt.byte
+++**02 native-dynlink
+++**03 setup-ocamlopt.byte-build-env
+++**04 ocamlopt.byte
++ flags = ""
++ module = "store.ml"
++-*05 ocamlopt.byte
+++**05 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_0.cmxs"
++ module = ""
++ all_modules = "Plugin_0.ml"
++-*06 ocamlopt.byte
+++**06 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_0_0.cmxs"
++ module = ""
++ all_modules = "Plugin_0_0.ml"
++-*07 ocamlopt.byte
+++**07 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_0_0_0.cmxs"
++ module = ""
++ all_modules = "Plugin_0_0_0.ml"
++-*08 ocamlopt.byte
+++**08 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_0_0_0_0.cmxs"
++ module = ""
++ all_modules = "Plugin_0_0_0_0.ml"
++-*09 ocamlopt.byte
+++**09 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_0_0_0_1.cmxs"
++ module = ""
++ all_modules = "Plugin_0_0_0_1.ml"
++-*10 ocamlopt.byte
+++**10 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_0_0_0_2.cmxs"
++ module = ""
++ all_modules = "Plugin_0_0_0_2.ml"
++-*11 ocamlopt.byte
+++**11 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1.cmxs"
++ module = ""
++ all_modules = "Plugin_1.ml"
++-*12 ocamlopt.byte
+++**12 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_0.cmxs"
++ module = ""
++ all_modules = "Plugin_1_0.ml"
++-*13 ocamlopt.byte
+++**13 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_0_0.cmxs"
++ module = ""
++ all_modules = "Plugin_1_0_0.ml"
++-*14 ocamlopt.byte
+++**14 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_0_0_0.cmxs"
++ module = ""
++ all_modules = "Plugin_1_0_0_0.ml"
++-*15 ocamlopt.byte
+++**15 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_1.cmxs"
++ module = ""
++ all_modules = "Plugin_1_1.ml"
++-*16 ocamlopt.byte
+++**16 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_2.cmxs"
++ module = ""
++ all_modules = "Plugin_1_2.ml"
++-*17 ocamlopt.byte
+++**17 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_2_0.cmxs"
++ module = ""
++ all_modules = "Plugin_1_2_0.ml"
++-*18 ocamlopt.byte
+++**18 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_2_0_0.cmxs"
++ module = ""
++ all_modules = "Plugin_1_2_0_0.ml"
++-*19 ocamlopt.byte
+++**19 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_2_1.cmxs"
++ module = ""
++ all_modules = "Plugin_1_2_1.ml"
++-*20 ocamlopt.byte
+++**20 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_2_2.cmxs"
++ module = ""
++ all_modules = "Plugin_1_2_2.ml"
++-*21 ocamlopt.byte
+++**21 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_2_2_0.cmxs"
++ module = ""
++ all_modules = "Plugin_1_2_2_0.ml"
++-*22 ocamlopt.byte
+++**22 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_2_3.cmxs"
++ module = ""
++ all_modules = "Plugin_1_2_3.ml"
++-*23 ocamlopt.byte
+++**23 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_2_3_0.cmxs"
++ module = ""
++ all_modules = "Plugin_1_2_3_0.ml"
++-*24 ocamlopt.byte
+++**24 ocamlopt.byte
++ flags = ""
++ module = "main.ml"
++-*25 ocamlopt.byte
+++**25 ocamlopt.byte
++ program = "./main.exe"
++ libraries="dynlink"
++ all_modules = "store.cmx main.cmx"
++ module = ""
++-*26 run
++-*27 check-program-output
+++**26 run
+++**27 check-program-output
++ *)
++ 
++ (*  This module and all plugin modules are generated by a call to test_generator.ml with parameters:
++diff --git a/testsuite/tests/lib-dynlink-initializers/test10_main.byte.reference b/testsuite/tests/lib-dynlink-initializers/test10_main.byte.reference
++index 7b948d4878..2850bc02d2 100755
++--- a/testsuite/tests/lib-dynlink-initializers/test10_main.byte.reference
+++++ b/testsuite/tests/lib-dynlink-initializers/test10_main.byte.reference
++@@ -3,10 +3,10 @@ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++ Called from Test10_plugin.g in file "test10_plugin.ml", line 3, characters 2-21
++ Called from Test10_plugin.f in file "test10_plugin.ml", line 6, characters 2-6
++ Called from Test10_plugin in file "test10_plugin.ml", line 10, characters 2-6
++-Called from Dynlink.Bytecode.run in file "otherlibs/dynlink/dynlink.ml", line 149, characters 16-25
++-Re-raised at Dynlink.Bytecode.run in file "otherlibs/dynlink/dynlink.ml", line 151, characters 6-137
++-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 363, characters 13-56
+++Called from Dynlink.Bytecode.run in file "otherlibs/dynlink/dynlink.ml", line 152, characters 16-25
+++Re-raised at Dynlink.Bytecode.run in file "otherlibs/dynlink/dynlink.ml", line 154, characters 6-137
+++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
++ Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
++-Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 8-17
+++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
+++Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 381, characters 8-17
++ Called from Test10_main in file "test10_main.ml", line 51, characters 13-69
++diff --git a/testsuite/tests/lib-dynlink-initializers/test10_main.native.reference b/testsuite/tests/lib-dynlink-initializers/test10_main.native.reference
++index 26ef5fb57e..0ae204cce9 100755
++--- a/testsuite/tests/lib-dynlink-initializers/test10_main.native.reference
+++++ b/testsuite/tests/lib-dynlink-initializers/test10_main.native.reference
++@@ -1,10 +1,14 @@
++ Error: Failure("Plugin error")
++-Raised by primitive operation at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
+++Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+++Called from Test10_plugin.g in file "test10_plugin.ml", line 2, characters 15-38
+++Called from Test10_plugin in file "test10_plugin.ml", line 10, characters 2-6
+++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
+++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 85, characters 12-29
++ Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 87, characters 10-149
++ Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 363, characters 13-56
+++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
++ Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
++-Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 8-17
++-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
+++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
+++Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 381, characters 8-17
+++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
++ Called from Test10_main in file "test10_main.ml", line 49, characters 30-87
++diff --git a/testsuite/tests/lib-format/mc_pr586_par.ml b/testsuite/tests/lib-format/mc_pr586_par.ml
++index 456a306ce7..da5c148416 100644
++--- a/testsuite/tests/lib-format/mc_pr586_par.ml
+++++ b/testsuite/tests/lib-format/mc_pr586_par.ml
++@@ -1,4 +1,7 @@
++-(* TEST *)
+++(* TEST
+++   * skip
+++   reason = "OCaml 5 only"
+++*)
++ 
++ let () =
++   let domains = Array.init 7 (fun i ->
++diff --git a/testsuite/tests/lib-format/mc_pr586_par2.ml b/testsuite/tests/lib-format/mc_pr586_par2.ml
++index 0ead3627b5..8a96be1456 100644
++--- a/testsuite/tests/lib-format/mc_pr586_par2.ml
+++++ b/testsuite/tests/lib-format/mc_pr586_par2.ml
++@@ -1,4 +1,7 @@
++-(* TEST *)
+++(* TEST
+++   * skip
+++   reason = "OCaml 5 only"
+++*)
++ 
++ let () =
++   let fmt_key = Format.synchronized_formatter_of_out_channel stdout in
++diff --git a/testsuite/tests/lib-marshal/intext_par.ml b/testsuite/tests/lib-marshal/intext_par.ml
++index 2efb846665..68ad0e1edb 100644
++--- a/testsuite/tests/lib-marshal/intext_par.ml
+++++ b/testsuite/tests/lib-marshal/intext_par.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    modules = "intextaux_par.c"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ (* Test for output_value / input_value *)
++diff --git a/testsuite/tests/lib-obj/reachable_words_np.ml b/testsuite/tests/lib-obj/reachable_words_np.ml
++new file mode 100644
++index 0000000000..8a50268d20
++--- /dev/null
+++++ b/testsuite/tests/lib-obj/reachable_words_np.ml
++@@ -0,0 +1,21 @@
+++(* TEST
+++ * naked_pointers
+++ ** bytecode
+++ ** native
+++*)
+++
+++let native =
+++  match Sys.backend_type with
+++  | Sys.Native -> true
+++  | Sys.Bytecode -> false
+++  | Sys.Other s -> print_endline s; assert false
+++
+++let size x = Obj.reachable_words (Obj.repr x)
+++
+++let expect_size s x =
+++  let i = size x in
+++  if i <> s then
+++    Printf.printf "size = %i; expected = %i\n%!" i s
+++
+++let () =
+++  expect_size (if native then 0 else 3) (1, 2)
++diff --git a/testsuite/tests/lib-random/parallel.ml b/testsuite/tests/lib-random/parallel.ml
++index 68f567abec..90a78e2250 100644
++--- a/testsuite/tests/lib-random/parallel.ml
+++++ b/testsuite/tests/lib-random/parallel.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++    include unix
++-   * libunix
++-   ** bytecode
++-   ** native
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** libunix
+++   *** bytecode
+++   *** native
++  *)
++ 
++ let () = Random.init 42
++diff --git a/testsuite/tests/lib-str/parallel.ml b/testsuite/tests/lib-str/parallel.ml
++index 23f2a5f7de..08055698e7 100644
++--- a/testsuite/tests/lib-str/parallel.ml
+++++ b/testsuite/tests/lib-str/parallel.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasstr
+++* skip
+++reason = "OCaml 5 only"
+++** hasstr
++ include str
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ let total = Atomic.make 0
++diff --git a/testsuite/tests/lib-sync/prodcons.ml b/testsuite/tests/lib-sync/prodcons.ml
++index 2e2c09756c..093d8740be 100644
++--- a/testsuite/tests/lib-sync/prodcons.ml
+++++ b/testsuite/tests/lib-sync/prodcons.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ (* Classic producer-consumer *)
++diff --git a/testsuite/tests/lib-sync/trylock.ml b/testsuite/tests/lib-sync/trylock.ml
++index 314f1142ca..b4719fff04 100644
++--- a/testsuite/tests/lib-sync/trylock.ml
+++++ b/testsuite/tests/lib-sync/trylock.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ (* Test Mutex.try_lock *)
++diff --git a/testsuite/tests/lib-sync/trylock2.ml b/testsuite/tests/lib-sync/trylock2.ml
++index b31ace08b5..e29ee93f9e 100644
++--- a/testsuite/tests/lib-sync/trylock2.ml
+++++ b/testsuite/tests/lib-sync/trylock2.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ (* Test Mutex.try_lock *)
++diff --git a/testsuite/tests/lib-systhreads/multicore_lifecycle.ml b/testsuite/tests/lib-systhreads/multicore_lifecycle.ml
++index f481464906..0138046146 100644
++--- a/testsuite/tests/lib-systhreads/multicore_lifecycle.ml
+++++ b/testsuite/tests/lib-systhreads/multicore_lifecycle.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hassysthreads
+++* skip
+++reason = "OCaml 5 only"
+++** hassysthreads
++ include systhreads
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ let _ =
++diff --git a/testsuite/tests/lib-systhreads/test_c_thread_register.ml b/testsuite/tests/lib-systhreads/test_c_thread_register.ml
++index a8ec98aa9a..784fe6945f 100644
++--- a/testsuite/tests/lib-systhreads/test_c_thread_register.ml
+++++ b/testsuite/tests/lib-systhreads/test_c_thread_register.ml
++@@ -2,9 +2,10 @@
++    modules = "test_c_thread_register_cstubs.c"
++    * hassysthreads
++    include systhreads
++-   ** not-bsd
++-   *** bytecode
++-   *** native
+++   ** not-windows
+++   *** not-bsd
+++   **** bytecode
+++   **** native
++ *)
++ 
++ (* spins a external thread from C and register it to the OCaml runtime *)
++diff --git a/testsuite/tests/lib-threads/uncaught_exception_handler.reference b/testsuite/tests/lib-threads/uncaught_exception_handler.reference
++index 31b97ca50a..cd68534b54 100644
++--- a/testsuite/tests/lib-threads/uncaught_exception_handler.reference
+++++ b/testsuite/tests/lib-threads/uncaught_exception_handler.reference
++@@ -1,15 +1,15 @@
++ Thread 1 killed on uncaught exception Uncaught_exception_handler.CallbackExn
++ Raised at Uncaught_exception_handler.fn in file "uncaught_exception_handler.ml", line 28, characters 12-113
++-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++ [thread 2] caught Uncaught_exception_handler.CallbackExn
++ Raised at Uncaught_exception_handler.fn in file "uncaught_exception_handler.ml", line 28, characters 12-113
++-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++ Thread 2 killed on uncaught exception Uncaught_exception_handler.CallbackExn
++ Raised at Uncaught_exception_handler.fn in file "uncaught_exception_handler.ml", line 28, characters 12-113
++-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++ Thread 2 uncaught exception handler raised Uncaught_exception_handler.UncaughtHandlerExn
++ Raised at Uncaught_exception_handler.handler in file "uncaught_exception_handler.ml", line 26, characters 2-17
++-Called from Thread.create.(fun) in file "thread.ml", line 59, characters 10-41
+++Called from Thread.create.(fun) in file "thread.ml", line 64, characters 10-41
++ [thread 3] caught Uncaught_exception_handler.CallbackExn
++ Raised at Uncaught_exception_handler.fn in file "uncaught_exception_handler.ml", line 28, characters 12-113
++-Called from Thread.create.(fun) in file "thread.ml", line 50, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++diff --git a/testsuite/tests/lib-unix/common/multicore_fork_domain_alone.ml b/testsuite/tests/lib-unix/common/multicore_fork_domain_alone.ml
++index 077a3dba66..78112d293e 100644
++--- a/testsuite/tests/lib-unix/common/multicore_fork_domain_alone.ml
+++++ b/testsuite/tests/lib-unix/common/multicore_fork_domain_alone.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++ include unix
++-* hasunix
++-** not-windows
++-*** bytecode
++-*** native
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
+++*** not-windows
+++**** bytecode
+++**** native
++ *)
++ 
++ (* on Multicore, fork is not allowed is another domain is, and was running. *)
++diff --git a/testsuite/tests/lib-unix/common/multicore_fork_domain_alone2.ml b/testsuite/tests/lib-unix/common/multicore_fork_domain_alone2.ml
++index 929ed5ecf7..61f75dce4a 100644
++--- a/testsuite/tests/lib-unix/common/multicore_fork_domain_alone2.ml
+++++ b/testsuite/tests/lib-unix/common/multicore_fork_domain_alone2.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++ include unix
++-* hasunix
++-** not-windows
++-*** bytecode
++-*** native
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
+++*** not-windows
+++**** bytecode
+++**** native
++ *)
++ 
++ (* on Multicore, fork is not allowed is another domain is, and was running. *)
++diff --git a/testsuite/tests/memory-model/forbidden.ml b/testsuite/tests/memory-model/forbidden.ml
++index afaa814ca5..d696a26e82 100644
++--- a/testsuite/tests/memory-model/forbidden.ml
+++++ b/testsuite/tests/memory-model/forbidden.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++   modules="opt.ml barrier.ml hist.ml shared.ml run.ml outcome.ml"
+++  * skip
+++  reason = "OCaml 5 only"
++ *)
++ 
++ (* Memory model test:
++diff --git a/testsuite/tests/memory-model/publish.ml b/testsuite/tests/memory-model/publish.ml
++index 38fe83e57e..1c2737d8b6 100644
++--- a/testsuite/tests/memory-model/publish.ml
+++++ b/testsuite/tests/memory-model/publish.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++   modules="opt.ml barrier.ml hist.ml shared.ml run.ml outcome.ml"
+++  * skip
+++  reason = "OCaml 5 only"
++ *)
++ 
++ (* Memory model: test the _publish idiom *)
++diff --git a/testsuite/tests/parallel/atomics.ml b/testsuite/tests/parallel/atomics.ml
++index 9c1d0a3cf2..b1f5813b4a 100644
++--- a/testsuite/tests/parallel/atomics.ml
+++++ b/testsuite/tests/parallel/atomics.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ type u = U of unit
++diff --git a/testsuite/tests/parallel/backup_thread.ml b/testsuite/tests/parallel/backup_thread.ml
++index 05b06cc47c..c69f164ce7 100644
++--- a/testsuite/tests/parallel/backup_thread.ml
+++++ b/testsuite/tests/parallel/backup_thread.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ 
++diff --git a/testsuite/tests/parallel/backup_thread_pipe.ml b/testsuite/tests/parallel/backup_thread_pipe.ml
++index 41fd101c1f..d0c5bb6e35 100644
++--- a/testsuite/tests/parallel/backup_thread_pipe.ml
+++++ b/testsuite/tests/parallel/backup_thread_pipe.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ 
++diff --git a/testsuite/tests/parallel/constpromote.ml b/testsuite/tests/parallel/constpromote.ml
++index fc9fd65ff6..466c846ed1 100644
++--- a/testsuite/tests/parallel/constpromote.ml
+++++ b/testsuite/tests/parallel/constpromote.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ (* when run with the bytecode debug runtime, this test
++diff --git a/testsuite/tests/parallel/deadcont.ml b/testsuite/tests/parallel/deadcont.ml
++index 6006323f45..bf6d7658a1 100644
++--- a/testsuite/tests/parallel/deadcont.ml
+++++ b/testsuite/tests/parallel/deadcont.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ (*
++diff --git a/testsuite/tests/parallel/domain_dls.ml b/testsuite/tests/parallel/domain_dls.ml
++index db4ebe0c56..82d8f55e5a 100644
++--- a/testsuite/tests/parallel/domain_dls.ml
+++++ b/testsuite/tests/parallel/domain_dls.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ let check_dls () =
++diff --git a/testsuite/tests/parallel/domain_dls2.ml b/testsuite/tests/parallel/domain_dls2.ml
++index 6c79145ba7..279f178774 100644
++--- a/testsuite/tests/parallel/domain_dls2.ml
+++++ b/testsuite/tests/parallel/domain_dls2.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ let _ =
++diff --git a/testsuite/tests/parallel/domain_id.ml b/testsuite/tests/parallel/domain_id.ml
++index cc583ff508..f3baa3dde0 100644
++--- a/testsuite/tests/parallel/domain_id.ml
+++++ b/testsuite/tests/parallel/domain_id.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ open Domain
++diff --git a/testsuite/tests/parallel/domain_parallel_spawn_burn.ml b/testsuite/tests/parallel/domain_parallel_spawn_burn.ml
++index 8a8a115141..20fd12d705 100644
++--- a/testsuite/tests/parallel/domain_parallel_spawn_burn.ml
+++++ b/testsuite/tests/parallel/domain_parallel_spawn_burn.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ open Domain
++diff --git a/testsuite/tests/parallel/domain_serial_spawn_burn.ml b/testsuite/tests/parallel/domain_serial_spawn_burn.ml
++index e853c25865..30fa17d116 100644
++--- a/testsuite/tests/parallel/domain_serial_spawn_burn.ml
+++++ b/testsuite/tests/parallel/domain_serial_spawn_burn.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ open Domain
++diff --git a/testsuite/tests/parallel/fib_threads.ml b/testsuite/tests/parallel/fib_threads.ml
++index f6005729b7..3ab3dde90d 100644
++--- a/testsuite/tests/parallel/fib_threads.ml
+++++ b/testsuite/tests/parallel/fib_threads.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hassysthreads
+++* skip
+++reason = "OCaml 5 only"
+++** hassysthreads
++ include systhreads
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ 
++diff --git a/testsuite/tests/parallel/join.ml b/testsuite/tests/parallel/join.ml
++index d270cca9bc..5a5c5b2464 100644
++--- a/testsuite/tests/parallel/join.ml
+++++ b/testsuite/tests/parallel/join.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ let test_size =
++diff --git a/testsuite/tests/parallel/major_gc_wait_backup.ml b/testsuite/tests/parallel/major_gc_wait_backup.ml
++index e418500774..f11190aee3 100644
++--- a/testsuite/tests/parallel/major_gc_wait_backup.ml
+++++ b/testsuite/tests/parallel/major_gc_wait_backup.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** native
++-** bytecode
+++*** native
+++*** bytecode
++ *)
++ 
++ type 'a tree = Empty | Node of 'a tree * 'a tree
++diff --git a/testsuite/tests/parallel/mctest.ml b/testsuite/tests/parallel/mctest.ml
++index c5d82d2dbd..bbebf9d4b8 100644
++--- a/testsuite/tests/parallel/mctest.ml
+++++ b/testsuite/tests/parallel/mctest.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ (*
++diff --git a/testsuite/tests/parallel/multicore_systhreads.ml b/testsuite/tests/parallel/multicore_systhreads.ml
++index 2f0fcf20b0..5ce5ea86ea 100644
++--- a/testsuite/tests/parallel/multicore_systhreads.ml
+++++ b/testsuite/tests/parallel/multicore_systhreads.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hassysthreads
+++* skip
+++reason = "OCaml 5 only"
+++** hassysthreads
++ include systhreads
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ 
++diff --git a/testsuite/tests/parallel/pingpong.ml b/testsuite/tests/parallel/pingpong.ml
++index 30fb9eee71..6113340ccf 100644
++--- a/testsuite/tests/parallel/pingpong.ml
+++++ b/testsuite/tests/parallel/pingpong.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ let r = ref (Some 0)
++diff --git a/testsuite/tests/parallel/poll.ml b/testsuite/tests/parallel/poll.ml
++index f07c0e0804..dd7a94f3cf 100644
++--- a/testsuite/tests/parallel/poll.ml
+++++ b/testsuite/tests/parallel/poll.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ let continue = Atomic.make true
++diff --git a/testsuite/tests/parallel/prodcons_domains.ml b/testsuite/tests/parallel/prodcons_domains.ml
++index 67499d342a..e8e9d736f3 100644
++--- a/testsuite/tests/parallel/prodcons_domains.ml
+++++ b/testsuite/tests/parallel/prodcons_domains.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++ 
++-* hassysthreads
+++* skip
+++reason = "OCaml 5 only"
+++** hassysthreads
++ include systhreads
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ 
++ *)
++ 
++diff --git a/testsuite/tests/parallel/tak.ml b/testsuite/tests/parallel/tak.ml
++index a9b6874c4f..bdc4173266 100644
++--- a/testsuite/tests/parallel/tak.ml
+++++ b/testsuite/tests/parallel/tak.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ (* filling minor heaps in parallel to trigger
++diff --git a/testsuite/tests/parallel/test_c_thread_register.ml b/testsuite/tests/parallel/test_c_thread_register.ml
++index 352424a377..9e2073c4ef 100644
++--- a/testsuite/tests/parallel/test_c_thread_register.ml
+++++ b/testsuite/tests/parallel/test_c_thread_register.ml
++@@ -1,9 +1,11 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++    modules = "test_c_thread_register_cstubs.c"
++-   * hassysthreads
+++   ** hassysthreads
++    include systhreads
++-   ** bytecode
++-   ** native
+++   *** bytecode
+++   *** native
++ *)
++ 
++ (* spins a external thread from C and register it to the OCaml runtime *)
++diff --git a/testsuite/tests/parallel/test_issue_11094.ml b/testsuite/tests/parallel/test_issue_11094.ml
++index ffc6d4bedd..8b9fb98c50 100644
++--- a/testsuite/tests/parallel/test_issue_11094.ml
+++++ b/testsuite/tests/parallel/test_issue_11094.ml
++@@ -1,6 +1,8 @@
++ (* TEST
++-* bytecode
++-* native
+++* skip
+++reason = "OCaml 5 only"
+++** bytecode
+++** native
++ *)
++ 
++ open Effect
++diff --git a/testsuite/tests/regression/pr9326/gc_set.ml b/testsuite/tests/regression/pr9326/gc_set.ml
++index 2570aec28e..e9d7dbcd4c 100644
++--- a/testsuite/tests/regression/pr9326/gc_set.ml
+++++ b/testsuite/tests/regression/pr9326/gc_set.ml
++@@ -4,35 +4,32 @@
++ open Gc
++ 
++ let min_heap_sz = 524288 (* 512k *)
++-let space_overhead = 70
++-let stack_limit = 4194304 (* 4M *)
++-let custom_major_ratio = 40
++-let custom_minor_ratio = 99
++-let custom_minor_max_size = 4096
+++let maj_heap_inc = 4194304 (* 4M *)
++ 
++ let _ =
++   let g1 = Gc.get() in
++   (* Do not use { g1 with ... }, so that the code will break if more fields
++      are added to the Gc.control record type *)
++   Gc.set { minor_heap_size = min_heap_sz;
++-           major_heap_increment = g1.major_heap_increment;
++-           space_overhead = space_overhead;
+++           major_heap_increment = maj_heap_inc;
+++           space_overhead = g1.space_overhead;
++            verbose = g1.verbose;
++            max_overhead = g1.max_overhead;
++-           stack_limit = stack_limit;
+++           stack_limit = g1.stack_limit;
++            allocation_policy = g1.allocation_policy;
++            window_size = g1.window_size;
++-           custom_major_ratio = custom_major_ratio;
++-           custom_minor_ratio = custom_minor_ratio;
++-           custom_minor_max_size = custom_minor_max_size };
+++           custom_major_ratio = g1.custom_major_ratio;
+++           custom_minor_ratio = g1.custom_minor_ratio;
+++           custom_minor_max_size = g1.custom_minor_max_size };
++   let g2 = Gc.get() in
++   assert (g2.minor_heap_size = min_heap_sz);
++-  assert (g2.space_overhead = space_overhead);
+++  assert (g2.major_heap_increment = maj_heap_inc);
+++  assert (g2.space_overhead = g1.space_overhead);
++   assert (g2.verbose = g1.verbose);
++   assert (g2.max_overhead = g1.max_overhead);
++-  assert (g2.stack_limit = stack_limit);
+++  assert (g2.stack_limit = g1.stack_limit);
++   assert (g2.allocation_policy = g1.allocation_policy);
++   assert (g2.window_size = g1.window_size);
++-  assert (g2.custom_major_ratio = custom_major_ratio);
++-  assert (g2.custom_minor_ratio = custom_minor_ratio);
++-  assert (g2.custom_minor_max_size = custom_minor_max_size)
+++  assert (g2.custom_major_ratio = g1.custom_major_ratio);
+++  assert (g2.custom_minor_ratio = g1.custom_minor_ratio);
+++  assert (g2.custom_minor_max_size = g1.custom_minor_max_size)
++diff --git a/testsuite/tests/runtime-naked-pointers/cstubs.c b/testsuite/tests/runtime-naked-pointers/cstubs.c
++new file mode 100644
++index 0000000000..e9315f3aea
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/cstubs.c
++@@ -0,0 +1,20 @@
+++#include <string.h>
+++#include "caml/mlvalues.h"
+++#include "caml/gc.h"
+++#include "caml/memory.h"
+++
+++static int colors[4] = { Caml_white, Caml_gray, Caml_blue, Caml_black };
+++
+++value make_block(value header_size, value color, value size)
+++{
+++  intnat sz = Nativeint_val(size);
+++  value * p = caml_stat_alloc((1 + sz) * sizeof(value));
+++  p[0] = Make_header(Nativeint_val(header_size), 0, colors[Int_val(color)]);
+++  memset(p + 1, 0x80, sz * sizeof(value));
+++  return (value) (p + 1);
+++}
+++
+++value make_raw_pointer (value v)
+++{
+++  return (value) Nativeint_val(v);
+++}
++diff --git a/testsuite/tests/runtime-naked-pointers/np.ml b/testsuite/tests/runtime-naked-pointers/np.ml
++new file mode 100644
++index 0000000000..1738934ff0
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/np.ml
++@@ -0,0 +1,11 @@
+++type color = White | Gray | Blue | Black
+++
+++external make_block: nativeint -> color -> nativeint -> Obj.t
+++         = "make_block"
+++
+++external make_raw_pointer: nativeint -> Obj.t
+++         = "make_raw_pointer"
+++
+++let do_gc root =
+++  Gc.compact();   (* full major + compaction *)
+++  root
++diff --git a/testsuite/tests/runtime-naked-pointers/np1.ml b/testsuite/tests/runtime-naked-pointers/np1.ml
++new file mode 100644
++index 0000000000..be4c677a23
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/np1.ml
++@@ -0,0 +1,12 @@
+++(* TEST
+++   modules = "cstubs.c np.ml"
+++   * bytecode
+++   * native
+++*)
+++
+++open Np
+++
+++(* Out-of-heap object with black header is accepted even in no-naked-pointers
+++   mode.  GC doesn't scan black objects. *)
+++
+++let x = do_gc [ make_block 100n Black 100n ]
++diff --git a/testsuite/tests/runtime-naked-pointers/np2.ml b/testsuite/tests/runtime-naked-pointers/np2.ml
++new file mode 100644
++index 0000000000..f24c813c2b
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/np2.ml
++@@ -0,0 +1,13 @@
+++(* TEST
+++   modules = "cstubs.c np.ml"
+++   * bytecode
+++   * native
+++*)
+++
+++open Np
+++
+++(* Out-of-heap object with black header is accepted even in no-naked-pointers
+++   mode.  GC doesn't scan black objects.  However, if the size in the
+++   head is crazily big, the naked pointer detector will warn. *)
+++
+++let x = do_gc [ make_block (-1n) Black 100n ]
++diff --git a/testsuite/tests/runtime-naked-pointers/np2.run b/testsuite/tests/runtime-naked-pointers/np2.run
++new file mode 100755
++index 0000000000..c03f6f688d
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/np2.run
++@@ -0,0 +1,3 @@
+++#!/bin/sh
+++
+++exec ${test_source_directory}/runtest.sh
++diff --git a/testsuite/tests/runtime-naked-pointers/np3.ml b/testsuite/tests/runtime-naked-pointers/np3.ml
++new file mode 100644
++index 0000000000..d207279df1
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/np3.ml
++@@ -0,0 +1,15 @@
+++(* TEST
+++   modules = "cstubs.c np.ml"
+++   * naked_pointers
+++   ** bytecode
+++   ** native
+++*)
+++
+++open Np
+++
+++(* Out-of-heap object with non-black header is OK in naked pointers mode only *)
+++(* Note that the header size can be wrong as it should not be used by the GC *)
+++
+++let x = do_gc [ make_block 10000n White 10n;
+++                make_block 1n Blue 0n;
+++                make_block (-1n) Gray 5n ]
++diff --git a/testsuite/tests/runtime-naked-pointers/np3.run b/testsuite/tests/runtime-naked-pointers/np3.run
++new file mode 100755
++index 0000000000..c03f6f688d
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/np3.run
++@@ -0,0 +1,3 @@
+++#!/bin/sh
+++
+++exec ${test_source_directory}/runtest.sh
++diff --git a/testsuite/tests/runtime-naked-pointers/np4.ml b/testsuite/tests/runtime-naked-pointers/np4.ml
++new file mode 100644
++index 0000000000..98966ddffc
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/np4.ml
++@@ -0,0 +1,13 @@
+++(* TEST
+++   modules = "cstubs.c np.ml"
+++   * naked_pointers
+++   ** bytecode
+++   ** native
+++*)
+++
+++open Np
+++
+++(* Null pointers and bad pointers outside the heap are OK
+++   in naked pointers mode only *)
+++
+++let x = do_gc [ make_raw_pointer 0n; make_raw_pointer 42n ]
++diff --git a/testsuite/tests/runtime-naked-pointers/np4.run b/testsuite/tests/runtime-naked-pointers/np4.run
++new file mode 100755
++index 0000000000..c03f6f688d
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/np4.run
++@@ -0,0 +1,3 @@
+++#!/bin/sh
+++
+++exec ${test_source_directory}/runtest.sh
++diff --git a/testsuite/tests/runtime-naked-pointers/runtest.sh b/testsuite/tests/runtime-naked-pointers/runtest.sh
++new file mode 100755
++index 0000000000..f5d4df561c
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/runtest.sh
++@@ -0,0 +1,10 @@
+++#!/bin/sh
+++
+++if grep -q "#define NAKED_POINTERS_CHECKER" ${ocamlsrcdir}/runtime/caml/m.h \
+++&& (echo ${program} | grep -q '\.opt')
+++then
+++  (${program} > ${output}) 2>&1 | grep -q '^Out-of-heap '
+++  exit $?
+++else
+++  exec ${program} > ${output}
+++fi
++diff --git a/testsuite/tests/shapes/comp_units.ml b/testsuite/tests/shapes/comp_units.ml
++index 1de07d7fcd..648f840099 100644
++--- a/testsuite/tests/shapes/comp_units.ml
+++++ b/testsuite/tests/shapes/comp_units.ml
++@@ -25,7 +25,7 @@ module Mproj = Unit
++ module F (X : sig type t end) = X
++ [%%expect{|
++ {
++- "F"[module] -> Abs<.4>(X/277, X/277<.3>);
+++ "F"[module] -> Abs<.4>(X/272, X/272<.3>);
++  }
++ module F : functor (X : sig type t end) -> sig type t = X.t end
++ |}]
++diff --git a/testsuite/tests/shapes/functors.ml b/testsuite/tests/shapes/functors.ml
++index a909d53ebb..09709b6bfe 100644
++--- a/testsuite/tests/shapes/functors.ml
+++++ b/testsuite/tests/shapes/functors.ml
++@@ -17,7 +17,7 @@ module type S = sig type t val x : t end
++ module Falias (X : S) = X
++ [%%expect{|
++ {
++- "Falias"[module] -> Abs<.4>(X/279, X/279<.3>);
+++ "Falias"[module] -> Abs<.4>(X/274, X/274<.3>);
++  }
++ module Falias : functor (X : S) -> sig type t = X.t val x : t end
++ |}]
++@@ -29,10 +29,10 @@ end
++ {
++  "Finclude"[module] ->
++      Abs<.6>
++-        (X/283,
+++        (X/278,
++          {
++-          "t"[type] -> X/283<.5> . "t"[type];
++-          "x"[value] -> X/283<.5> . "x"[value];
+++          "t"[type] -> X/278<.5> . "t"[type];
+++          "x"[value] -> X/278<.5> . "x"[value];
++           });
++  }
++ module Finclude : functor (X : S) -> sig type t = X.t val x : t end
++@@ -45,7 +45,7 @@ end
++ [%%expect{|
++ {
++  "Fredef"[module] ->
++-     Abs<.10>(X/290, {
+++     Abs<.10>(X/285, {
++                       "t"[type] -> <.8>;
++                       "x"[value] -> <.9>;
++                       });
++@@ -223,8 +223,8 @@ module Big_to_small1 : B2S = functor (X : Big) -> X
++ [%%expect{|
++ {
++  "Big_to_small1"[module] ->
++-     Abs<.40>(X/385, {<.39>
++-                      "t"[type] -> X/385<.39> . "t"[type];
+++     Abs<.40>(X/380, {<.39>
+++                      "t"[type] -> X/380<.39> . "t"[type];
++                       });
++  }
++ module Big_to_small1 : B2S
++@@ -234,8 +234,8 @@ module Big_to_small2 : B2S = functor (X : Big) -> struct include X end
++ [%%expect{|
++ {
++  "Big_to_small2"[module] ->
++-     Abs<.42>(X/388, {
++-                      "t"[type] -> X/388<.41> . "t"[type];
+++     Abs<.42>(X/383, {
+++                      "t"[type] -> X/383<.41> . "t"[type];
++                       });
++  }
++ module Big_to_small2 : B2S
++diff --git a/testsuite/tests/shapes/open_arg.ml b/testsuite/tests/shapes/open_arg.ml
++index e0c5025234..ffd3256e07 100644
++--- a/testsuite/tests/shapes/open_arg.ml
+++++ b/testsuite/tests/shapes/open_arg.ml
++@@ -22,7 +22,7 @@ end = struct end
++ 
++ [%%expect{|
++ {
++- "Make"[module] -> Abs<.3>(I/279, {
+++ "Make"[module] -> Abs<.3>(I/274, {
++                                    });
++  }
++ module Make : functor (I : sig end) -> sig end
++diff --git a/testsuite/tests/shapes/recmodules.ml b/testsuite/tests/shapes/recmodules.ml
++index 1911efd4fc..a889dba47b 100644
++--- a/testsuite/tests/shapes/recmodules.ml
+++++ b/testsuite/tests/shapes/recmodules.ml
++@@ -43,8 +43,8 @@ and B : sig
++ end = B
++ [%%expect{|
++ {
++- "A"[module] -> A/302<.11>;
++- "B"[module] -> B/303<.12>;
+++ "A"[module] -> A/297<.11>;
+++ "B"[module] -> B/298<.12>;
++  }
++ module rec A : sig type t = Leaf of B.t end
++ and B : sig type t = int end
++@@ -82,13 +82,13 @@ end = Set.Make(A)
++  "ASet"[module] ->
++      {
++       "compare"[value] ->
++-          CU Stdlib . "Set"[module] . "Make"[module](A/324<.19>) .
+++          CU Stdlib . "Set"[module] . "Make"[module](A/319<.19>) .
++           "compare"[value];
++       "elt"[type] ->
++-          CU Stdlib . "Set"[module] . "Make"[module](A/324<.19>) .
+++          CU Stdlib . "Set"[module] . "Make"[module](A/319<.19>) .
++           "elt"[type];
++       "t"[type] ->
++-          CU Stdlib . "Set"[module] . "Make"[module](A/324<.19>) . "t"[type];
+++          CU Stdlib . "Set"[module] . "Make"[module](A/319<.19>) . "t"[type];
++       };
++  }
++ module rec A :
++diff --git a/testsuite/tests/shapes/rotor_example.ml b/testsuite/tests/shapes/rotor_example.ml
++index e8f96a6c39..f02190e34a 100644
++--- a/testsuite/tests/shapes/rotor_example.ml
+++++ b/testsuite/tests/shapes/rotor_example.ml
++@@ -26,7 +26,7 @@ end
++ {
++  "Pair"[module] ->
++      Abs<.9>
++-        (X/279, Abs(Y/280, {
+++        (X/274, Abs(Y/275, {
++                             "t"[type] -> <.5>;
++                             "to_string"[value] -> <.6>;
++                             }));
++diff --git a/testsuite/tests/statmemprof/alloc_counts.ml b/testsuite/tests/statmemprof/alloc_counts.ml
++index de0d1e9e49..f8cbb5658d 100644
++--- a/testsuite/tests/statmemprof/alloc_counts.ml
+++++ b/testsuite/tests/statmemprof/alloc_counts.ml
++@@ -1,7 +1,4 @@
++-(* TEST
++-* skip
++-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++-*)
+++(* TEST *)
++ module MP = Gc.Memprof
++ 
++ let allocs_by_memprof f =
++diff --git a/testsuite/tests/statmemprof/arrays_in_major.ml b/testsuite/tests/statmemprof/arrays_in_major.ml
++index eb627324ba..78907a18e3 100644
++--- a/testsuite/tests/statmemprof/arrays_in_major.ml
+++++ b/testsuite/tests/statmemprof/arrays_in_major.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    flags = "-g"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ *)
++ 
++ open Gc.Memprof
++diff --git a/testsuite/tests/statmemprof/arrays_in_major.reference b/testsuite/tests/statmemprof/arrays_in_major.reference
++new file mode 100644
++index 0000000000..1f34ad8ec8
++--- /dev/null
+++++ b/testsuite/tests/statmemprof/arrays_in_major.reference
++@@ -0,0 +1,11 @@
+++check_nosample
+++check_counts_full_major
+++check_counts_full_major
+++check_no_nested
+++check_distrib 300 3000 3 0.000010
+++check_distrib 300 3000 1 0.000100
+++check_distrib 300 3000 1 0.010000
+++check_distrib 300 3000 1 0.900000
+++check_distrib 300 300 100000 0.100000
+++check_distrib 300000 300000 30 0.100000
+++OK !
++diff --git a/testsuite/tests/statmemprof/arrays_in_minor.ml b/testsuite/tests/statmemprof/arrays_in_minor.ml
++index 4359642d0e..432f8b1d09 100644
++--- a/testsuite/tests/statmemprof/arrays_in_minor.ml
+++++ b/testsuite/tests/statmemprof/arrays_in_minor.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    flags = "-g"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ *)
++ 
++ open Gc.Memprof
++diff --git a/testsuite/tests/statmemprof/arrays_in_minor.reference b/testsuite/tests/statmemprof/arrays_in_minor.reference
++new file mode 100644
++index 0000000000..1dad91939c
++--- /dev/null
+++++ b/testsuite/tests/statmemprof/arrays_in_minor.reference
++@@ -0,0 +1,11 @@
+++check_nosample
+++check_counts_full_major
+++check_counts_full_major
+++check_no_nested
+++check_distrib 1 250 1000 0.000010
+++check_distrib 1 250 1000 0.000100
+++check_distrib 1 250 1000 0.010000
+++check_distrib 1 250 1000 0.900000
+++check_distrib 1 1 10000000 0.010000
+++check_distrib 250 250 100000 0.100000
+++OK !
++diff --git a/testsuite/tests/statmemprof/blocking_in_callback.ml b/testsuite/tests/statmemprof/blocking_in_callback.ml
++index e1e40f1fb6..00f49cfc74 100644
++--- a/testsuite/tests/statmemprof/blocking_in_callback.ml
+++++ b/testsuite/tests/statmemprof/blocking_in_callback.ml
++@@ -1,8 +1,6 @@
++ (* TEST
++ * hassysthreads
++ include systhreads
++-* skip
++-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ ** bytecode
++ ** native
++ *)
++diff --git a/testsuite/tests/statmemprof/callstacks.ml b/testsuite/tests/statmemprof/callstacks.ml
++index e864a50019..ec5a4199f0 100644
++--- a/testsuite/tests/statmemprof/callstacks.ml
+++++ b/testsuite/tests/statmemprof/callstacks.ml
++@@ -3,15 +3,11 @@
++ 
++    * flat-float-array
++      reference = "${test_source_directory}/callstacks.flat-float-array.reference"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++    ** native
++    ** bytecode
++ 
++    * no-flat-float-array
++      reference = "${test_source_directory}/callstacks.no-flat-float-array.reference"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++    ** native
++    ** bytecode
++ *)
++diff --git a/testsuite/tests/statmemprof/comballoc.ml b/testsuite/tests/statmemprof/comballoc.ml
++index 60ca4a0123..22b2547101 100644
++--- a/testsuite/tests/statmemprof/comballoc.ml
+++++ b/testsuite/tests/statmemprof/comballoc.ml
++@@ -1,10 +1,8 @@
++ (* TEST
++    flags = "-g"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++-   ** bytecode
+++   * bytecode
++      reference = "${test_source_directory}/comballoc.byte.reference"
++-   ** native
+++   * native
++      reference = "${test_source_directory}/comballoc.opt.reference"
++ *)
++ 
++diff --git a/testsuite/tests/statmemprof/custom.ml b/testsuite/tests/statmemprof/custom.ml
++index 41cf902ec8..f0ddfa7eed 100644
++--- a/testsuite/tests/statmemprof/custom.ml
+++++ b/testsuite/tests/statmemprof/custom.ml
++@@ -1,7 +1,4 @@
++-(* TEST
++-* skip
++-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++-*)
+++(* TEST *)
++ 
++ open Gc.Memprof
++ 
++diff --git a/testsuite/tests/statmemprof/exception_callback.ml b/testsuite/tests/statmemprof/exception_callback.ml
++index f9f02f690f..e1589372ab 100644
++--- a/testsuite/tests/statmemprof/exception_callback.ml
+++++ b/testsuite/tests/statmemprof/exception_callback.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    exit_status = "2"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ *)
++ 
++ open Gc.Memprof
++diff --git a/testsuite/tests/statmemprof/exception_callback_minor.ml b/testsuite/tests/statmemprof/exception_callback_minor.ml
++index 0bb37782be..f514123276 100644
++--- a/testsuite/tests/statmemprof/exception_callback_minor.ml
+++++ b/testsuite/tests/statmemprof/exception_callback_minor.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    exit_status = "2"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ *)
++ 
++ open Gc.Memprof
++diff --git a/testsuite/tests/statmemprof/intern.ml b/testsuite/tests/statmemprof/intern.ml
++index bebcc3c8ff..bce6f89c5c 100644
++--- a/testsuite/tests/statmemprof/intern.ml
+++++ b/testsuite/tests/statmemprof/intern.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    flags = "-g"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ *)
++ 
++ open Gc.Memprof
++diff --git a/testsuite/tests/statmemprof/intern.reference b/testsuite/tests/statmemprof/intern.reference
++new file mode 100644
++index 0000000000..d83e8d6d50
++--- /dev/null
+++++ b/testsuite/tests/statmemprof/intern.reference
++@@ -0,0 +1,10 @@
+++check_nosample
+++check_counts_full_major
+++check_counts_full_major
+++check_no_nested
+++check_distrib 2 3000 3 0.000010
+++check_distrib 2 3000 1 0.000100
+++check_distrib 2 2000 1 0.010000
+++check_distrib 2 2000 1 0.900000
+++check_distrib 300000 300000 20 0.100000
+++OK !
++diff --git a/testsuite/tests/statmemprof/lists_in_minor.ml b/testsuite/tests/statmemprof/lists_in_minor.ml
++index d08716c71b..ebd434857e 100644
++--- a/testsuite/tests/statmemprof/lists_in_minor.ml
+++++ b/testsuite/tests/statmemprof/lists_in_minor.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    flags = "-g"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ *)
++ 
++ open Gc.Memprof
++diff --git a/testsuite/tests/statmemprof/lists_in_minor.reference b/testsuite/tests/statmemprof/lists_in_minor.reference
++new file mode 100644
++index 0000000000..11cfe0ca12
++--- /dev/null
+++++ b/testsuite/tests/statmemprof/lists_in_minor.reference
++@@ -0,0 +1,8 @@
+++check_distrib 10 1000000 0.010000
+++check_distrib 1000000 10 0.000010
+++check_distrib 1000000 10 0.000100
+++check_distrib 1000000 10 0.001000
+++check_distrib 1000000 10 0.010000
+++check_distrib 100000 10 0.100000
+++check_distrib 100000 10 0.900000
+++OK !
++diff --git a/testsuite/tests/statmemprof/minor_no_postpone.ml b/testsuite/tests/statmemprof/minor_no_postpone.ml
++index 21c8bfb244..fcb94cf81d 100644
++--- a/testsuite/tests/statmemprof/minor_no_postpone.ml
+++++ b/testsuite/tests/statmemprof/minor_no_postpone.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    modules = "minor_no_postpone_stub.c"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ *)
++ 
++ open Gc.Memprof
++diff --git a/testsuite/tests/statmemprof/moved_while_blocking.ml b/testsuite/tests/statmemprof/moved_while_blocking.ml
++index bb8dfc9848..8efc172aea 100644
++--- a/testsuite/tests/statmemprof/moved_while_blocking.ml
+++++ b/testsuite/tests/statmemprof/moved_while_blocking.ml
++@@ -1,8 +1,6 @@
++ (* TEST
++ * hassysthreads
++ include systhreads
++-* skip
++-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ ** bytecode
++ ** native
++ *)
++diff --git a/testsuite/tests/statmemprof/thread_exit_in_callback.ml b/testsuite/tests/statmemprof/thread_exit_in_callback.ml
++index 28e2aabb8b..563be966a8 100644
++--- a/testsuite/tests/statmemprof/thread_exit_in_callback.ml
+++++ b/testsuite/tests/statmemprof/thread_exit_in_callback.ml
++@@ -1,8 +1,6 @@
++ (* TEST
++ * hassysthreads
++ include systhreads
++-* skip
++-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ ** bytecode
++ ** native
++ *)
++@@ -12,7 +10,7 @@ let _ =
++   Gc.Memprof.(start ~callstack_size:10 ~sampling_rate:1.
++                 { null_tracker with alloc_minor = fun _ ->
++                       if Thread.id (Thread.self ()) <> main_thread then
++-                        Thread.exit ();
+++                        raise Thread.Exit;
++                       None });
++   let t = Thread.create (fun () ->
++       ignore (Sys.opaque_identity (ref 1));
++@@ -21,6 +19,8 @@ let _ =
++   Thread.join t;
++   Gc.Memprof.stop ()
++ 
+++[@@@ocaml.alert "-deprecated"]
+++
++ let _ =
++   Gc.Memprof.(start ~callstack_size:10 ~sampling_rate:1.
++     { null_tracker with alloc_minor = fun _ -> Thread.exit (); None });
++diff --git a/testsuite/tests/tool-debugger/basic/debuggee.ml b/testsuite/tests/tool-debugger/basic/debuggee.ml
++index 8604edf239..91ad3c21dc 100644
++--- a/testsuite/tests/tool-debugger/basic/debuggee.ml
+++++ b/testsuite/tests/tool-debugger/basic/debuggee.ml
++@@ -2,15 +2,13 @@
++ set foo = "bar"
++ flags += " -g "
++ ocamldebug_script = "${test_source_directory}/input_script"
++-* skip
++-reason = "ocamldebug is broken (#34)"
++-** debugger
++-*** shared-libraries
++-**** setup-ocamlc.byte-build-env
++-***** ocamlc.byte
++-****** check-ocamlc.byte-output
++-******* ocamldebug
++-******** check-program-output
+++* debugger
+++** shared-libraries
+++*** setup-ocamlc.byte-build-env
+++**** ocamlc.byte
+++***** check-ocamlc.byte-output
+++****** ocamldebug
+++******* check-program-output
++ *)
++ 
++ print_endline Sys.argv.(1);;
++diff --git a/testsuite/tests/tool-debugger/dynlink/host.ml b/testsuite/tests/tool-debugger/dynlink/host.ml
++index c445c8acd3..f46ef8a022 100644
++--- a/testsuite/tests/tool-debugger/dynlink/host.ml
+++++ b/testsuite/tests/tool-debugger/dynlink/host.ml
++@@ -7,29 +7,27 @@ libraries = ""
++ flags += " -g "
++ ocamldebug_script = "${test_source_directory}/input_script"
++ 
++-* skip
++-reason = "ocamldebug is broken (#34)"
++-** debugger
++-*** shared-libraries
++-**** setup-ocamlc.byte-build-env
++-***** ocamlc.byte
+++* debugger
+++** shared-libraries
+++*** setup-ocamlc.byte-build-env
+++**** ocamlc.byte
++ module = "host.ml"
++-****** ocamlc.byte
+++***** ocamlc.byte
++ module = "plugin.ml"
++-******* ocamlc.byte
+++****** ocamlc.byte
++ module = ""
++ all_modules = "host.cmo"
++ program = "${test_build_directory}/host.byte"
++ libraries = "dynlink"
++ 
++-******** run
+++******* run
++ output = "host.output"
++-********* check-program-output
+++******** check-program-output
++ reference = "${test_source_directory}/host.reference"
++ 
++-********* ocamldebug
+++******** ocamldebug
++ output = "host.debug.output"
++-********** check-program-output
+++********* check-program-output
++ reference = "${test_source_directory}/host.debug.reference"
++ 
++ *)
++diff --git a/testsuite/tests/tool-debugger/find-artifacts/debuggee.ml b/testsuite/tests/tool-debugger/find-artifacts/debuggee.ml
++index 7c6f00c70f..70aee3ff04 100644
++--- a/testsuite/tests/tool-debugger/find-artifacts/debuggee.ml
+++++ b/testsuite/tests/tool-debugger/find-artifacts/debuggee.ml
++@@ -1,27 +1,25 @@
++ (* TEST
++ ocamldebug_script = "${test_source_directory}/input_script"
++-* skip
++-reason = "ocamldebug is broken (#34)"
++-** debugger
++-*** shared-libraries
++-**** setup-ocamlc.byte-build-env
++-***** script
+++* debugger
+++** shared-libraries
+++*** setup-ocamlc.byte-build-env
+++**** script
++ script = "mkdir out"
++-****** ocamlc.byte
+++***** ocamlc.byte
++ flags = "-g -c"
++ all_modules = "${test_source_directory}/in/blah.ml"
++ program = "out/blah.cmo"
++-******* ocamlc.byte
+++****** ocamlc.byte
++ program = "out/foo.cmo"
++ flags = "-I out -g -c"
++ all_modules = "${test_source_directory}/in/foo.ml"
++-******** ocamlc.byte
+++******* ocamlc.byte
++ all_modules = "out/blah.cmo out/foo.cmo"
++ flags = " -g "
++ program = "debuggee.exe"
++-********* check-ocamlc.byte-output
++-********** ocamldebug
++-*********** check-program-output
+++******** check-ocamlc.byte-output
+++********* ocamldebug
+++********** check-program-output
++ *)
++ 
++ (* This file only contains the specification of how to run the test *)
++diff --git a/testsuite/tests/tool-debugger/module_named_main/main.ml b/testsuite/tests/tool-debugger/module_named_main/main.ml
++index e31c16391e..25eebe7c02 100644
++--- a/testsuite/tests/tool-debugger/module_named_main/main.ml
+++++ b/testsuite/tests/tool-debugger/module_named_main/main.ml
++@@ -1,15 +1,13 @@
++ (* TEST
++ flags += " -g "
++ ocamldebug_script = "${test_source_directory}/input_script"
++-* skip
++-reason = "ocamldebug is broken (#34)"
++-** debugger
++-*** shared-libraries
++-**** setup-ocamlc.byte-build-env
++-***** ocamlc.byte
++-****** check-ocamlc.byte-output
++-******* ocamldebug
++-******** check-program-output
+++* debugger
+++** shared-libraries
+++*** setup-ocamlc.byte-build-env
+++**** ocamlc.byte
+++***** check-ocamlc.byte-output
+++****** ocamldebug
+++******* check-program-output
++ *)
++ 
++ module Submodule = struct
++diff --git a/testsuite/tests/tool-debugger/no_debug_event/noev.ml b/testsuite/tests/tool-debugger/no_debug_event/noev.ml
++index f06c14a117..4eb334ea84 100644
++--- a/testsuite/tests/tool-debugger/no_debug_event/noev.ml
+++++ b/testsuite/tests/tool-debugger/no_debug_event/noev.ml
++@@ -1,30 +1,28 @@
++ (* TEST
++ readonly_files = "a.ml b.ml"
++ ocamldebug_script = "${test_source_directory}/input_script"
++-* skip
++-reason = "ocamldebug is broken (#34)"
++-** debugger
++-*** shared-libraries
++-**** setup-ocamlc.byte-build-env
++-***** ocamlc.byte
+++* debugger
+++** shared-libraries
+++*** setup-ocamlc.byte-build-env
+++**** ocamlc.byte
++ module = "a.ml"
++ flags = "-g -for-pack foo"
++-****** ocamlc.byte
+++***** ocamlc.byte
++ module = ""
++ all_modules = "a.cmo"
++ program = "foo.cmo"
++ flags = "-g -pack"
++-******* ocamlc.byte
+++****** ocamlc.byte
++ module = "b.ml"
++ flags = " -g "
++-******** ocamlc.byte
+++******* ocamlc.byte
++ module = ""
++ flags = " -g "
++ all_modules = "foo.cmo b.cmo"
++ program = "${test_build_directory}/noev.exe"
++-********* check-ocamlc.byte-output
++-********** ocamldebug
++-*********** check-program-output
+++******** check-ocamlc.byte-output
+++********* ocamldebug
+++********** check-program-output
++ *)
++ 
++ (* This file only contains the specification of how to run the test *)
++diff --git a/testsuite/tests/tool-debugger/printer/debuggee.ml b/testsuite/tests/tool-debugger/printer/debuggee.ml
++index b2d6e6e7c5..f22a4bd50f 100644
++--- a/testsuite/tests/tool-debugger/printer/debuggee.ml
+++++ b/testsuite/tests/tool-debugger/printer/debuggee.ml
++@@ -3,17 +3,15 @@ flags += " -g "
++ ocamldebug_script = "${test_source_directory}/input_script"
++ readonly_files = "printer.ml"
++ include debugger
++-* skip
++-reason = "ocamldebug is broken (#34)"
++-** debugger
++-*** shared-libraries
++-**** setup-ocamlc.byte-build-env
++-***** ocamlc.byte
+++* debugger
+++** shared-libraries
+++*** setup-ocamlc.byte-build-env
+++**** ocamlc.byte
++ module = "printer.ml"
++-***** ocamlc.byte
++-****** check-ocamlc.byte-output
++-******* ocamldebug
++-******** check-program-output
+++**** ocamlc.byte
+++***** check-ocamlc.byte-output
+++****** ocamldebug
+++******* check-program-output
++ *)
++ 
++ let f x =
++diff --git a/testsuite/tests/typing-sigsubst/sigsubst.ml b/testsuite/tests/typing-sigsubst/sigsubst.ml
++index 5636e9abe2..53e430713c 100644
++--- a/testsuite/tests/typing-sigsubst/sigsubst.ml
+++++ b/testsuite/tests/typing-sigsubst/sigsubst.ml
++@@ -24,11 +24,11 @@ end
++ Line 3, characters 2-36:
++ 3 |   include Comparable with type t = t
++       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
++-Error: Illegal shadowing of included type t/284 by t/289
+++Error: Illegal shadowing of included type t/279 by t/284
++        Line 2, characters 2-19:
++-         Type t/284 came from this include
+++         Type t/279 came from this include
++        Line 3, characters 2-23:
++-         The value print has no valid type if t/284 is shadowed
+++         The value print has no valid type if t/279 is shadowed
++ |}]
++ 
++ module type Sunderscore = sig
++diff --git a/testsuite/tests/unwind/unwind_test.reference b/testsuite/tests/unwind/unwind_test.reference
++index fbcd16e8e1..56a5f30733 100644
++--- a/testsuite/tests/unwind/unwind_test.reference
+++++ b/testsuite/tests/unwind/unwind_test.reference
++@@ -1,5 +1,4 @@
++ ml_perform_stack_walk
++-caml_c_call
++ Mylib.baz
++ Driver.entry
++ caml_program
++diff --git a/testsuite/tests/weak-ephe-final/ephetest_par.ml b/testsuite/tests/weak-ephe-final/ephetest_par.ml
++index 744c4e844d..621d7292ff 100644
++--- a/testsuite/tests/weak-ephe-final/ephetest_par.ml
+++++ b/testsuite/tests/weak-ephe-final/ephetest_par.ml
++@@ -1,4 +1,7 @@
++-(* TEST *)
+++(* TEST
+++   * skip
+++   reason = "OCaml 5 only"
+++ *)
++ 
++ (* Due to GCs running at non-deterministic places, the output from these tests
++  * are unreliable except the bad value checks and as a check for catastrophic
++diff --git a/testsuite/tests/weak-ephe-final/finaliser2.ml b/testsuite/tests/weak-ephe-final/finaliser2.ml
++index e8ab88e807..5cf871e7ac 100644
++--- a/testsuite/tests/weak-ephe-final/finaliser2.ml
+++++ b/testsuite/tests/weak-ephe-final/finaliser2.ml
++@@ -1,4 +1,7 @@
++-(* TEST *)
+++(* TEST
+++   * skip
+++   reason = "OCaml 5 only"
+++*)
++ 
++ let[@inline never][@local never] test1 () =
++   let r' = ref 0 in
++diff --git a/testsuite/tests/weak-ephe-final/finaliser_handover.ml b/testsuite/tests/weak-ephe-final/finaliser_handover.ml
++index fa2d2efc43..752a7eeabf 100644
++--- a/testsuite/tests/weak-ephe-final/finaliser_handover.ml
+++++ b/testsuite/tests/weak-ephe-final/finaliser_handover.ml
++@@ -1,4 +1,7 @@
++-(* TEST *)
+++(* TEST
+++   * skip
+++   reason = "OCaml 5 only"
+++*)
++ 
++ (* ocaml-multicore issues 528 and 468 *)
++ 
++diff --git a/testsuite/tests/weak-ephe-final/weaklifetime_par.ml b/testsuite/tests/weak-ephe-final/weaklifetime_par.ml
++index 7f80b8ab26..0791f4e53f 100644
++--- a/testsuite/tests/weak-ephe-final/weaklifetime_par.ml
+++++ b/testsuite/tests/weak-ephe-final/weaklifetime_par.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ let size = 1000;;
++diff --git a
\ No newline at end of file
diff --git a/lambda/matching.ml b/lambda/matching.ml
index 6a44270f76..b61f3a3d76 100644
--- a/lambda/matching.ml
+++ b/lambda/matching.ml
@@ -1877,7 +1877,11 @@ let get_mod_field modname field =
 
 let code_force_lazy_block = get_mod_field "CamlinternalLazy" "force_lazy_block"
 
+(* BACKPORT_BEGIN
 let code_force_lazy = get_mod_field "CamlinternalLazy" "force_gen"
+*)
+let code_force_lazy = get_mod_field "CamlinternalLazy" "force"
+(* BACKPORT END *)
 
 (* inline_lazy_force inlines the beginning of the code of Lazy.force. When
    the value argument is tagged as:
@@ -1900,7 +1904,11 @@ let call_force_lazy_block varg loc =
     { ap_tailcall = Default_tailcall;
       ap_loc = loc;
       ap_func = force_fun;
+(* BACKPORT BEGIN
       ap_args = [ Lprim (Popaque, [ varg ], loc) ];
+*)
+      ap_args = [ varg ];
+(* BACKPORT END *)
       ap_inlined = Default_inline;
       ap_specialised = Default_specialise
     }
@@ -1909,9 +1917,14 @@ let inline_lazy_force_cond arg loc =
   let idarg = Ident.create_local "lzarg" in
   let varg = Lvar idarg in
   let tag = Ident.create_local "tag" in
+(* BACKPORT BEGIN *)
+  let tag_var = Lvar tag in
+(* BACKPORT END *)
+(* BACKPORT
   let test_tag t =
     Lprim(Pintcomp Ceq, [Lvar tag; Lconst(Const_base(Const_int t))], loc)
   in
+*)
 
   Llet
     ( Strict,
@@ -1924,16 +1937,32 @@ let inline_lazy_force_cond arg loc =
           tag,
           Lprim (Pccall prim_obj_tag, [ varg ], loc),
           Lifthenelse
+(* BACKPORT BEGIN
             ( (* if (tag == Obj.forward_tag) then varg.(0) else ... *)
               test_tag Obj.forward_tag,
               Lprim (Pfield (0, Pointer, Mutable), [ varg ], loc),
+*)
+            ( Lprim
+                ( Pintcomp Ceq,
+                  [ tag_var; Lconst (Const_base (Const_int Obj.forward_tag)) ],
+                  loc ),
+              Lprim (Pfield (0, Pointer, Mutable), [ varg ], loc),
+(* BACKPORT END *)
               Lifthenelse
+(* BACKPORT BEGIN *)
+                ( Lprim
+                    ( Pintcomp Ceq,
+                      [ tag_var; Lconst (Const_base (Const_int Obj.lazy_tag)) ],
+                      loc ),
+(* BACKPORT END *)
+(* BACKPORT
                 (
                   (* ... if tag == Obj.lazy_tag || tag == Obj.forcing_tag then
                          Lazy.force varg
                        else ... *)
                   Lprim (Psequor,
                        [test_tag Obj.lazy_tag; test_tag Obj.forcing_tag], loc),
+*)
                   call_force_lazy_block varg loc,
                   (* ... arg *)
                   varg ) ) ) )
@@ -1950,16 +1979,31 @@ let inline_lazy_force_switch arg loc =
         ( Lprim (Pisint, [ varg ], loc),
           varg,
           Lswitch
+(* BACKPORT BEGIN
             ( Lprim (Pccall prim_obj_tag, [ varg ], loc),
               { sw_numblocks = 0;
                 sw_blocks = [];
                 sw_numconsts = 256;
+*)
+            ( varg,
+              { sw_numconsts = 0;
+                sw_consts = [];
+                sw_numblocks = 256;
+(* BACKPORT END *)
                 (* PR#6033 - tag ranges from 0 to 255 *)
+(* BACKPORT BEGIN *)
+                sw_blocks =
+                  [ (Obj.forward_tag,
+                     Lprim (Pfield (0, Pointer, Mutable), [ varg ], loc));
+                    (Obj.lazy_tag, call_force_lazy_block varg loc)
+(* BACKPORT END *)
+(* BACKPORT
                 sw_consts =
                   [ (Obj.forward_tag, Lprim (Pfield(0, Pointer, Mutable),
                                              [ varg ], loc));
                     (Obj.lazy_tag, call_force_lazy_block varg loc);
                     (Obj.forcing_tag, call_force_lazy_block varg loc)
+*)
                   ];
                 sw_failaction = Some varg
               },
@@ -1975,7 +2019,11 @@ let inline_lazy_force arg loc =
       { ap_tailcall = Default_tailcall;
         ap_loc = loc;
         ap_func = Lazy.force code_force_lazy;
+(* BACKPORT BEGIN
         ap_args = [ Lconst (Const_base (Const_int 0)); arg ];
+*)
+        ap_args = [ arg ];
+(* BACKPORT END *)
         ap_inlined = Default_inline;
         ap_specialised = Default_specialise
       }
diff --git a/manual/src/library/stdlib-blurb.etex b/manual/src/library/stdlib-blurb.etex
index 4535ec7edf..047464d984 100644
--- a/manual/src/library/stdlib-blurb.etex
+++ b/manual/src/library/stdlib-blurb.etex
@@ -128,10 +128,10 @@ be called from C \\
 \stddocitem{Callback}{registering OCaml values with the C runtime}
 \stddocitem{Char}{character operations}
 \stddocitem{Complex}{complex numbers}
-\stddocitem{Condition}{condition variables to synchronize between threads}
-\stddocitem{Domain}{Domain spawn/join and domain local variables}
+%\stddocitem{Condition}{condition variables to synchronize between threads}
+%\stddocitem{Domain}{Domain spawn/join and domain local variables}
 \stddocitem{Digest}{MD5 message digest}
-\stddocitem{Effect}{deep and shallow effect handlers}
+%\stddocitem{Effect}{deep and shallow effect handlers}
 \stddocitem{Either}{either values}
 \stddocitem{Ephemeron}{Ephemerons and weak hash table}
 \stddocitem{Filename}{operations on file names}
@@ -151,7 +151,7 @@ be called from C \\
 \stddocitem{Map}{association tables over ordered types}
 \stddocitem{Marshal}{marshaling of data structures}
 \stddocitem{MoreLabels}{include modules \texttt{Hashtbl}, \texttt{Map} and \texttt{Set} with labels}
-\stddocitem{Mutex}{locks for mutual exclusion}
+%\stddocitem{Mutex}{locks for mutual exclusion}
 \stddocitem{Nativeint}{processor-native integers}
 \stddocitem{Oo}{object-oriented extension}
 \stddocitem{Option}{option values}
@@ -165,7 +165,7 @@ be called from C \\
 \stddocitem{Scanf}{formatted input functions}
 \stddocitem{Seq}{functional iterators}
 \stddocitem{Set}{sets over ordered types}
-\stddocitem{Semaphore}{semaphores, another thread synchronization mechanism}
+%\stddocitem{Semaphore}{semaphores, another thread synchronization mechanism}
 \stddocitem{Stack}{last-in first-out stacks}
 \stddocitem{StdLabels}{include modules \texttt{Array}, \texttt{List} and \texttt{String} with labels}
 \stddocitem{String}{string operations}
diff --git a/otherlibs/dynlink/byte/dynlink.ml b/otherlibs/dynlink/byte/dynlink.ml
index 70ead03193..e0f77d8579 100644
--- a/otherlibs/dynlink/byte/dynlink.ml
+++ b/otherlibs/dynlink/byte/dynlink.ml
@@ -22,6 +22,9 @@ open! Dynlink_compilerlibs
 
 module DC = Dynlink_common
 module DT = Dynlink_types
+(* BACKPORT BEGIN *)
+module Mutex = DC.Mutex
+(* BACKPORT END *)
 
 module Bytecode = struct
   type filename = string
diff --git a/otherlibs/dynlink/dynlink_common.ml b/otherlibs/dynlink/dynlink_common.ml
index 6f4d8c0b4b..1fd2f98e86 100644
--- a/otherlibs/dynlink/dynlink_common.ml
+++ b/otherlibs/dynlink/dynlink_common.ml
@@ -31,6 +31,15 @@ module String = struct
   end
 end
 
+(* BACKPORT BEGIN *)
+module Mutex = struct
+  type t = unit
+  let create () = ()
+  let lock () = ()
+  let unlock () = ()
+end
+(* BACKPORT END *)
+
 module Make (P : Dynlink_platform_intf.S) = struct
   module DT = Dynlink_types
   module UH = P.Unit_header
diff --git a/otherlibs/dynlink/dynlink_common.mli b/otherlibs/dynlink/dynlink_common.mli
index c6f92d05cd..beb712d3e7 100644
--- a/otherlibs/dynlink/dynlink_common.mli
+++ b/otherlibs/dynlink/dynlink_common.mli
@@ -33,3 +33,12 @@ module Make (_ : Dynlink_platform_intf.S) : sig
   val all_units : unit -> string list
   val allow_unsafe_modules : bool -> unit
 end
+
+(* BACKPORT BEGIN *)
+module Mutex : sig
+  type t = unit
+  val create : unit -> t
+  val lock : t -> unit
+  val unlock : t -> unit
+end
+(* BACKPORT END *)
diff --git a/otherlibs/dynlink/dynlink_platform_intf.ml b/otherlibs/dynlink/dynlink_platform_intf.ml
index b2075070d2..3a175c5424 100644
--- a/otherlibs/dynlink/dynlink_platform_intf.ml
+++ b/otherlibs/dynlink/dynlink_platform_intf.ml
@@ -61,7 +61,11 @@ module type S = sig
     -> handle * (Unit_header.t list)
 
   val run_shared_startup : handle -> unit
+(* BACKPORT BEGIN
   val run : Mutex.t -> handle -> unit_header:Unit_header.t -> priv:bool -> unit
+*)
+  val run : unit -> handle -> unit_header:Unit_header.t -> priv:bool -> unit
+(* BACKPORT END *)
 
   val unsafe_get_global_value : bytecode_or_asm_symbol:string -> Obj.t option
 
diff --git a/otherlibs/str/str.ml b/otherlibs/str/str.ml
index 2fb5de9ea6..1122960547 100644
--- a/otherlibs/str/str.ml
+++ b/otherlibs/str/str.ml
@@ -607,7 +607,18 @@ external re_search_forward: regexp -> string -> int -> int array
 external re_search_backward: regexp -> string -> int -> int array
      = "re_search_backward"
 
+(* BACKPORT BEGIN
 let last_search_result_key = Domain.DLS.new_key (fun () -> [||])
+*)
+let last_search_result_key = ref [||]
+
+module Domain = struct
+  module DLS = struct
+    let get = (!)
+    let set = (:=)
+  end
+end
+(* BACKPORT END *)
 
 let string_match re s pos =
   let res = re_string_match re s pos in
diff --git a/otherlibs/systhreads/.depend b/otherlibs/systhreads/.depend
index 11b76f90bb..661d3575de 100644
--- a/otherlibs/systhreads/.depend
+++ b/otherlibs/systhreads/.depend
@@ -1,8 +1,34 @@
+condition.cmo : \
+    mutex.cmi \
+    condition.cmi
+condition.cmx : \
+    mutex.cmx \
+    condition.cmi
+condition.cmi : \
+    mutex.cmi
 event.cmo : \
+    mutex.cmi \
+    condition.cmi \
     event.cmi
 event.cmx : \
+    mutex.cmx \
+    condition.cmx \
     event.cmi
 event.cmi :
+mutex.cmo : \
+    mutex.cmi
+mutex.cmx : \
+    mutex.cmi
+mutex.cmi :
+semaphore.cmo : \
+    mutex.cmi \
+    condition.cmi \
+    semaphore.cmi
+semaphore.cmx : \
+    mutex.cmx \
+    condition.cmx \
+    semaphore.cmi
+semaphore.cmi :
 thread.cmo : \
     thread.cmi
 thread.cmx : \
diff --git a/otherlibs/systhreads/Makefile b/otherlibs/systhreads/Makefile
index b96b8db82f..579afdba64 100644
--- a/otherlibs/systhreads/Makefile
+++ b/otherlibs/systhreads/Makefile
@@ -50,12 +50,12 @@ LIBNAME=threads
 BYTECODE_C_OBJS=st_stubs.b.$(O)
 NATIVECODE_C_OBJS=st_stubs.n.$(O)
 
-THREADS_SOURCES = thread.ml event.ml
+THREADS_SOURCES = thread.ml mutex.ml condition.ml event.ml semaphore.ml
 
 THREADS_BCOBJS = $(THREADS_SOURCES:.ml=.cmo)
 THREADS_NCOBJS = $(THREADS_SOURCES:.ml=.cmx)
 
-MLIFILES=thread.mli event.mli
+MLIFILES=thread.mli mutex.mli condition.mli event.mli semaphore.mli
 
 CMIFILES=$(MLIFILES:.mli=.cmi)
 
diff --git a/otherlibs/systhreads/condition.ml b/otherlibs/systhreads/condition.ml
new file mode 100644
index 0000000000..9a014528ab
--- /dev/null
+++ b/otherlibs/systhreads/condition.ml
@@ -0,0 +1,20 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*   Xavier Leroy and Pascal Cuoq, projet Cristal, INRIA Rocquencourt     *)
+(*                                                                        *)
+(*   Copyright 1995 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+type t
+external create: unit -> t = "caml_condition_new"
+external wait: t -> Mutex.t -> unit = "caml_condition_wait"
+external signal: t -> unit = "caml_condition_signal"
+external broadcast: t -> unit = "caml_condition_broadcast"
diff --git a/otherlibs/systhreads/condition.mli b/otherlibs/systhreads/condition.mli
new file mode 100644
index 0000000000..36c71fc818
--- /dev/null
+++ b/otherlibs/systhreads/condition.mli
@@ -0,0 +1,53 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*          Xavier Leroy and Damien Doligez, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(** Condition variables to synchronize between threads.
+
+   Condition variables are used when one thread wants to wait until another
+   thread has finished doing something: the former thread 'waits' on the
+   condition variable, the latter thread 'signals' the condition when it
+   is done. Condition variables should always be protected by a mutex.
+   The typical use is (if [D] is a shared data structure, [m] its mutex,
+   and [c] is a condition variable):
+   {[
+     Mutex.lock m;
+     while (* some predicate P over D is not satisfied *) do
+       Condition.wait c m
+     done;
+     (* Modify D *)
+     if (* the predicate P over D is now satisfied *) then Condition.signal c;
+     Mutex.unlock m
+   ]}
+*)
+
+type t
+(** The type of condition variables. *)
+
+val create : unit -> t
+(** Return a new condition variable. *)
+
+val wait : t -> Mutex.t -> unit
+(** [wait c m] atomically unlocks the mutex [m] and suspends the
+   calling process on the condition variable [c]. The process will
+   restart after the condition variable [c] has been signalled.
+   The mutex [m] is locked again before [wait] returns. *)
+
+val signal : t -> unit
+(** [signal c] restarts one of the processes waiting on the
+   condition variable [c]. *)
+
+val broadcast : t -> unit
+(** [broadcast c] restarts all processes waiting on the
+   condition variable [c]. *)
diff --git a/otherlibs/systhreads/mutex.ml b/otherlibs/systhreads/mutex.ml
new file mode 100644
index 0000000000..836109e761
--- /dev/null
+++ b/otherlibs/systhreads/mutex.ml
@@ -0,0 +1,20 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*           Xavier Leroy and Pascal Cuoq, INRIA Rocquencourt             *)
+(*                                                                        *)
+(*   Copyright 1995 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+type t
+external create: unit -> t = "caml_mutex_new"
+external lock: t -> unit = "caml_mutex_lock"
+external try_lock: t -> bool = "caml_mutex_try_lock"
+external unlock: t -> unit = "caml_mutex_unlock"
diff --git a/otherlibs/systhreads/mutex.mli b/otherlibs/systhreads/mutex.mli
new file mode 100644
index 0000000000..70a67ce408
--- /dev/null
+++ b/otherlibs/systhreads/mutex.mli
@@ -0,0 +1,60 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*          Xavier Leroy and Damien Doligez, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(** Locks for mutual exclusion.
+
+   Mutexes (mutual-exclusion locks) are used to implement critical sections
+   and protect shared mutable data structures against concurrent accesses.
+   The typical use is (if [m] is the mutex associated with the data structure
+   [D]):
+   {[
+     Mutex.lock m;
+     (* Critical section that operates over D *);
+     Mutex.unlock m
+   ]}
+*)
+
+type t
+(** The type of mutexes. *)
+
+val create : unit -> t
+(** Return a new mutex. *)
+
+val lock : t -> unit
+(** Lock the given mutex. Only one thread can have the mutex locked
+   at any time. A thread that attempts to lock a mutex already locked
+   by another thread will suspend until the other thread unlocks
+   the mutex.
+
+   @raise Sys_error if the mutex is already locked by the thread calling
+   {!Mutex.lock}.
+
+   @before 4.12 {!Sys_error} was not raised for recursive locking
+   (platform-dependent behaviour) *)
+
+val try_lock : t -> bool
+(** Same as {!Mutex.lock}, but does not suspend the calling thread if
+   the mutex is already locked: just return [false] immediately
+   in that case. If the mutex is unlocked, lock it and
+   return [true]. *)
+
+val unlock : t -> unit
+(** Unlock the given mutex. Other threads suspended trying to lock
+   the mutex will restart.  The mutex must have been previously locked
+   by the thread that calls {!Mutex.unlock}.
+   @raise Sys_error if the mutex is unlocked or was locked by another thread.
+
+   @before 4.12 {!Sys_error} was not raised when unlocking an unlocked mutex
+   or when unlocking a mutex from a different thread. *)
diff --git a/otherlibs/systhreads/semaphore.ml b/otherlibs/systhreads/semaphore.ml
new file mode 100644
index 0000000000..e4fa4181a0
--- /dev/null
+++ b/otherlibs/systhreads/semaphore.ml
@@ -0,0 +1,86 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*          Xavier Leroy, Collège de France and INRIA Paris               *)
+(*                                                                        *)
+(*   Copyright 2020 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(** Semaphores *)
+
+type sem = {
+  mut: Mutex.t;                         (* protects [v] *)
+  mutable v: int;                       (* the current value *)
+  nonzero: Condition.t                  (* signaled when [v > 0] *)
+}
+
+module Counting = struct
+
+type t = sem
+
+let make v =
+  if v < 0 then invalid_arg "Semaphore.Counting.init: wrong initial value";
+  { mut = Mutex.create(); v; nonzero = Condition.create() }
+
+let release s =
+  Mutex.lock s.mut;
+  if s.v < max_int then begin
+    s.v <- s.v + 1;
+    Condition.signal s.nonzero;
+    Mutex.unlock s.mut
+  end else begin
+    Mutex.unlock s.mut;
+    raise (Sys_error "Semaphore.Counting.release: overflow")
+  end
+
+let acquire s =
+  Mutex.lock s.mut;
+  while s.v = 0 do Condition.wait s.nonzero s.mut done;
+  s.v <- s.v - 1;
+  Mutex.unlock s.mut
+
+let try_acquire s =
+  Mutex.lock s.mut;
+  let ret = if s.v = 0 then false else (s.v <- s.v - 1; true) in
+  Mutex.unlock s.mut;
+  ret
+
+let get_value s = s.v
+
+end
+
+module Binary = struct
+
+type t = sem
+
+let make b =
+  { mut = Mutex.create();
+    v = if b then 1 else 0;
+    nonzero = Condition.create() }
+
+let release s =
+  Mutex.lock s.mut;
+  s.v <- 1;
+  Condition.signal s.nonzero;
+  Mutex.unlock s.mut
+
+let acquire s =
+  Mutex.lock s.mut;
+  while s.v = 0 do Condition.wait s.nonzero s.mut done;
+  s.v <- 0;
+  Mutex.unlock s.mut
+
+let try_acquire s =
+  Mutex.lock s.mut;
+  let ret = if s.v = 0 then false else (s.v <- 0; true) in
+  Mutex.unlock s.mut;
+  ret
+
+end
diff --git a/otherlibs/systhreads/semaphore.mli b/otherlibs/systhreads/semaphore.mli
new file mode 100644
index 0000000000..3a62747829
--- /dev/null
+++ b/otherlibs/systhreads/semaphore.mli
@@ -0,0 +1,140 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*          Xavier Leroy, Collège de France and INRIA Paris               *)
+(*                                                                        *)
+(*   Copyright 2020 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(** Semaphores
+
+  A semaphore is a thread synchronization device that can be used to
+  control access to a shared resource.
+
+  Two flavors of semaphores are provided: counting semaphores and
+  binary semaphores.
+
+  @since 4.12 *)
+
+(** {2 Counting semaphores} *)
+
+(**
+  A counting semaphore is a counter that can be accessed concurrently
+  by several threads.  The typical use is to synchronize producers and
+  consumers of a resource by counting how many units of the resource
+  are available.
+
+  The two basic operations on semaphores are:
+- "release" (also called "V", "post", "up", and "signal"), which
+  increments the value of the counter.  This corresponds to producing
+  one more unit of the shared resource and making it available to others.
+- "acquire" (also called "P", "wait", "down", and "pend"), which
+  waits until the counter is greater than zero and decrements it.
+  This corresponds to consuming one unit of the shared resource.
+
+  @since 4.12 *)
+
+module Counting : sig
+
+type t
+(** The type of counting semaphores. *)
+
+val make : int -> t
+(** [make n] returns a new counting semaphore, with initial value [n].
+    The initial value [n] must be nonnegative.
+
+    @raise Invalid_argument if [n < 0]
+*)
+
+val release : t -> unit
+(** [release s] increments the value of semaphore [s].
+    If other threads are waiting on [s], one of them is restarted.
+    If the current value of [s] is equal to [max_int], the value of
+    the semaphore is unchanged and a [Sys_error] exception is raised
+    to signal overflow.
+
+    @raise Sys_error if the value of the semaphore would overflow [max_int]
+*)
+
+val acquire : t -> unit
+(** [acquire s] blocks the calling thread until the value of semaphore [s]
+    is not zero, then atomically decrements the value of [s] and returns.
+*)
+
+val try_acquire : t -> bool
+(** [try_acquire s] immediately returns [false] if the value of semaphore [s]
+    is zero.  Otherwise, the value of [s] is atomically decremented
+    and [try_acquire s] returns [true].
+*)
+
+val get_value : t -> int
+(** [get_value s] returns the current value of semaphore [s].
+    The current value can be modified at any time by concurrent
+    {!release} and {!acquire} operations.  Hence, the [get_value]
+    operation is racy, and its result should only be used for debugging
+    or informational messages.
+*)
+
+end
+
+(** {2 Binary semaphores} *)
+
+(** Binary semaphores are a variant of counting semaphores
+    where semaphores can only take two values, 0 and 1.
+
+    A binary semaphore can be used to control access to a single
+    shared resource, with value 1 meaning "resource is available" and
+    value 0 meaning "resource is unavailable".
+
+    The "release" operation of a binary semaphore sets its value to 1,
+    and "acquire" waits until the value is 1 and sets it to 0.
+
+    A binary semaphore can be used instead of a mutex (see module
+    {!Mutex}) when the mutex discipline (of unlocking the mutex from the
+    thread that locked it) is too restrictive.  The "acquire" operation
+    corresponds to locking the mutex, and the "release" operation to
+    unlocking it, but "release" can be performed in a thread different
+    than the one that performed the "acquire".  Likewise, it is safe
+    to release a binary semaphore that is already available.
+
+    @since 4.12
+*)
+
+module Binary : sig
+
+type t
+(** The type of binary semaphores. *)
+
+val make : bool -> t
+(** [make b] returns a new binary semaphore.
+    If [b] is [true], the initial value of the semaphore is 1, meaning
+    "available".  If [b] is [false], the initial value of the
+    semaphore is 0, meaning "unavailable".
+*)
+
+val release : t -> unit
+(** [release s] sets the value of semaphore [s] to 1, putting it in the
+    "available" state.  If other threads are waiting on [s], one of them is
+    restarted.
+*)
+
+val acquire : t -> unit
+(** [acquire s] blocks the calling thread until the semaphore [s]
+    has value 1 (is available), then atomically sets it to 0
+    and returns.
+*)
+
+val try_acquire : t -> bool
+(** [try_acquire s] immediately returns [false] if the semaphore [s]
+    has value 0.  If [s] has value 1, its value is atomically set to 0
+    and [try_acquire s] returns [true].
+*)
+
+end
diff --git a/otherlibs/systhreads/thread.ml b/otherlibs/systhreads/thread.ml
index d3391e6884..d6fcaa8d91 100644
--- a/otherlibs/systhreads/thread.ml
+++ b/otherlibs/systhreads/thread.ml
@@ -18,8 +18,10 @@
 type t
 
 external thread_initialize : unit -> unit = "caml_thread_initialize"
+(* BACKPORT
 external thread_initialize_domain : unit -> unit =
             "caml_thread_initialize_domain"
+*)
 external thread_cleanup : unit -> unit = "caml_thread_cleanup"
 external thread_new : (unit -> unit) -> t = "caml_thread_new"
 external thread_uncaught_exception : exn -> unit =
@@ -29,6 +31,9 @@ external yield : unit -> unit = "caml_thread_yield"
 external self : unit -> t = "caml_thread_self" [@@noalloc]
 external id : t -> int = "caml_thread_id" [@@noalloc]
 external join : t -> unit = "caml_thread_join"
+(* BACKPORT BEGIN *)
+external exit_stub : unit -> unit = "caml_thread_exit"
+(* BACKPORT END *)
 
 (* For new, make sure the function passed to thread_new never
    raises an exception. *)
@@ -71,7 +76,17 @@ let create fn arg =
           flush stderr)
 
 let exit () =
+(* BACKPORT BEGIN
   raise Exit
+*)
+  ignore (Sys.opaque_identity (check_memprof_cb ()));
+  exit_stub ()
+
+(* Thread.kill is currently not implemented due to problems with
+   cleanup handlers on several platforms *)
+
+let kill th = invalid_arg "Thread.kill: not implemented"
+(* BACKPORT END *)
 
 (* Preemption *)
 
@@ -85,9 +100,12 @@ let preempt_signal =
   | _       -> Sys.sigvtalrm
 
 let () =
+  Sys.set_signal preempt_signal (Sys.Signal_handle preempt);
   thread_initialize ();
+(* BACKPORT
   Domain.at_startup thread_initialize_domain;
   Sys.set_signal preempt_signal (Sys.Signal_handle preempt);
+*)
   Callback.register "Thread.at_shutdown" (fun () ->
     thread_cleanup();
     (* In case of DLL-embedded OCaml the preempt_signal handler
@@ -101,6 +119,11 @@ let () =
 
 let delay = Unix.sleepf
 
+(* BACKPORT BEGIN *)
+let wait_read fd = ()
+let wait_write fd = ()
+(* BACKPORT END *)
+
 let wait_timed_read fd d =
   match Unix.select [fd] [] [] d with ([], _, _) -> false | (_, _, _) -> true
 let wait_timed_write fd d =
diff --git a/otherlibs/unix/fork.c b/otherlibs/unix/fork.c
index 6367f61aa8..7f2beca3af 100644
--- a/otherlibs/unix/fork.c
+++ b/otherlibs/unix/fork.c
@@ -25,15 +25,19 @@
 CAMLprim value unix_fork(value unit)
 {
   int ret;
+#if 0 /* BACKPORT */
   if (caml_domain_is_multicore()) {
     caml_failwith
       ("Unix.fork may not be called while other domains were created");
   }
+#endif
 
   CAML_EV_FLUSH();
 
   ret = fork();
+#if 0 /* BACKPORT */
   if (ret == 0) caml_atfork_hook();
+#endif
   if (ret == -1) uerror("fork", Nothing);
 
   CAML_EVENTLOG_DO({
diff --git a/otherlibs/unix/signals.c b/otherlibs/unix/signals.c
index 3d03d5cff3..24e7218699 100644
--- a/otherlibs/unix/signals.c
+++ b/otherlibs/unix/signals.c
@@ -25,6 +25,12 @@
 #include <caml/signals.h>
 #include "unixsupport.h"
 
+/* BACKPORT BEGIN */
+#ifndef NSIG
+#define NSIG 64
+#endif
+/* BACKPORT END */
+
 #ifdef POSIX_SIGNALS
 
 static void decode_sigset(value vset, sigset_t * set)
@@ -44,9 +50,15 @@ static value encode_sigset(sigset_t * set)
 
   for (i = 1; i < NSIG; i++)
     if (sigismember(set, i) > 0) {
+/* BACKPORT BEGIN */
+      value newcons = caml_alloc_small(2, 0);
+      Field(newcons, 0) = Val_int(caml_rev_convert_signal_number(i));
+      Field(newcons, 1) = res;
+#if 0 /* BACKPORT */
       value newcons = caml_alloc_2(Tag_cons,
         Val_int(caml_rev_convert_signal_number(i)),
         res);
+#endif
       res = newcons;
     }
   CAMLreturn(res);
@@ -63,7 +75,11 @@ CAMLprim value unix_sigprocmask(value vaction, value vset)
   how = sigprocmask_cmd[Int_val(vaction)];
   decode_sigset(vset, &set);
   caml_enter_blocking_section();
+#if 0 /* BACKPORT BEGIN */
   retcode = sigprocmask(how, &set, &oldset);
+#endif
+  retcode = caml_sigmask_hook(how, &set, &oldset);
+/* BACKPORT END */
   caml_leave_blocking_section();
   /* Run any handlers for just-unmasked pending signals */
   caml_process_pending_actions();
@@ -74,9 +90,15 @@ CAMLprim value unix_sigprocmask(value vaction, value vset)
 CAMLprim value unix_sigpending(value unit)
 {
   sigset_t pending;
+/* BACKPORT BEGIN */
+  int i;
+/* BACKPORT END */
+#if 0 /* BACKPORT */
   int i, j;
   uintnat curr;
+#endif
   if (sigpending(&pending) == -1) uerror("sigpending", Nothing);
+#if 0 /* BACKPORT */
   for (i = 0; i < NSIG_WORDS; i++) {
     curr = atomic_load(&caml_pending_signals[i]);
     if (curr == 0) continue;
@@ -85,6 +107,12 @@ CAMLprim value unix_sigpending(value unit)
       sigaddset(&pending, i * BITS_PER_WORD + j + 1);
     }
   }
+#endif
+/* BACKPORT BEGIN */
+  for (i = 1; i < NSIG; i++)
+    if(caml_pending_signals[i])
+      sigaddset(&pending, i);
+/* BACKPORT END */
   return encode_sigset(&pending);
 }
 
diff --git a/otherlibs/unix/unixsupport.h b/otherlibs/unix/unixsupport.h
index fe345466de..e9a1d2a31b 100644
--- a/otherlibs/unix/unixsupport.h
+++ b/otherlibs/unix/unixsupport.h
@@ -57,4 +57,8 @@ extern void unix_clear_cloexec(int fd, char * cmdname, value arg);
 
 #define EXECV_CAST
 
+/* BACKPORT BEGIN */
+#define caml_process_pending_signals caml_process_pending_actions
+/* BACKPORT END */
+
 #endif /* CAML_UNIXSUPPORT_H */
diff --git a/stdlib/.depend b/stdlib/.depend
index da23211543..ca0851f1ac 100644
--- a/stdlib/.depend
+++ b/stdlib/.depend
@@ -188,14 +188,6 @@ stdlib__Complex.cmx : complex.ml \
     stdlib__Float.cmx \
     stdlib__Complex.cmi
 stdlib__Complex.cmi : complex.mli
-stdlib__Condition.cmo : condition.ml \
-    stdlib__Mutex.cmi \
-    stdlib__Condition.cmi
-stdlib__Condition.cmx : condition.ml \
-    stdlib__Mutex.cmx \
-    stdlib__Condition.cmi
-stdlib__Condition.cmi : condition.mli \
-    stdlib__Mutex.cmi
 stdlib__Digest.cmo : digest.ml \
     stdlib__String.cmi \
     stdlib__Char.cmi \
@@ -207,33 +199,6 @@ stdlib__Digest.cmx : digest.ml \
     stdlib__Bytes.cmx \
     stdlib__Digest.cmi
 stdlib__Digest.cmi : digest.mli
-stdlib__Domain.cmo : domain.ml \
-    stdlib__Sys.cmi \
-    stdlib.cmi \
-    stdlib__Obj.cmi \
-    stdlib__Mutex.cmi \
-    stdlib__List.cmi \
-    stdlib__Atomic.cmi \
-    stdlib__Array.cmi \
-    stdlib__Domain.cmi
-stdlib__Domain.cmx : domain.ml \
-    stdlib__Sys.cmx \
-    stdlib.cmx \
-    stdlib__Obj.cmx \
-    stdlib__Mutex.cmx \
-    stdlib__List.cmx \
-    stdlib__Atomic.cmx \
-    stdlib__Array.cmx \
-    stdlib__Domain.cmi
-stdlib__Domain.cmi : domain.mli
-stdlib__Effect.cmo : effect.ml \
-    stdlib__Printexc.cmi \
-    stdlib__Effect.cmi
-stdlib__Effect.cmx : effect.ml \
-    stdlib__Printexc.cmx \
-    stdlib__Effect.cmi
-stdlib__Effect.cmi : effect.mli \
-    stdlib__Printexc.cmi
 stdlib__Either.cmo : either.ml \
     stdlib__Either.cmi
 stdlib__Either.cmx : either.ml \
@@ -270,7 +235,7 @@ stdlib__Filename.cmo : filename.ml \
     stdlib__Random.cmi \
     stdlib__Printf.cmi \
     stdlib__List.cmi \
-    stdlib__Domain.cmi \
+    stdlib__Lazy.cmi \
     stdlib__Buffer.cmi \
     stdlib__Filename.cmi
 stdlib__Filename.cmx : filename.ml \
@@ -279,7 +244,7 @@ stdlib__Filename.cmx : filename.ml \
     stdlib__Random.cmx \
     stdlib__Printf.cmx \
     stdlib__List.cmx \
-    stdlib__Domain.cmx \
+    stdlib__Lazy.cmx \
     stdlib__Buffer.cmx \
     stdlib__Filename.cmi
 stdlib__Filename.cmi : filename.mli
@@ -306,8 +271,8 @@ stdlib__Format.cmo : format.ml \
     stdlib__Queue.cmi \
     stdlib__List.cmi \
     stdlib__Int.cmi \
+    stdlib__Fun.cmi \
     stdlib__Either.cmi \
-    stdlib__Domain.cmi \
     camlinternalFormatBasics.cmi \
     camlinternalFormat.cmi \
     stdlib__Bytes.cmi \
@@ -321,8 +286,8 @@ stdlib__Format.cmx : format.ml \
     stdlib__Queue.cmx \
     stdlib__List.cmx \
     stdlib__Int.cmx \
+    stdlib__Fun.cmx \
     stdlib__Either.cmx \
-    stdlib__Domain.cmx \
     camlinternalFormatBasics.cmx \
     camlinternalFormat.cmx \
     stdlib__Bytes.cmx \
@@ -332,7 +297,6 @@ stdlib__Format.cmi : format.mli \
     stdlib.cmi \
     stdlib__Seq.cmi \
     stdlib__Either.cmi \
-    stdlib__Domain.cmi \
     stdlib__Buffer.cmi
 stdlib__Fun.cmo : fun.ml \
     stdlib__Printexc.cmi \
@@ -361,8 +325,8 @@ stdlib__Hashtbl.cmo : hashtbl.ml \
     stdlib__Seq.cmi \
     stdlib__Random.cmi \
     stdlib__Obj.cmi \
+    stdlib__Lazy.cmi \
     stdlib__Int.cmi \
-    stdlib__Domain.cmi \
     stdlib__Array.cmi \
     stdlib__Hashtbl.cmi
 stdlib__Hashtbl.cmx : hashtbl.ml \
@@ -371,8 +335,8 @@ stdlib__Hashtbl.cmx : hashtbl.ml \
     stdlib__Seq.cmx \
     stdlib__Random.cmx \
     stdlib__Obj.cmx \
+    stdlib__Lazy.cmx \
     stdlib__Int.cmx \
-    stdlib__Domain.cmx \
     stdlib__Array.cmx \
     stdlib__Hashtbl.cmi
 stdlib__Hashtbl.cmi : hashtbl.mli \
@@ -491,11 +455,6 @@ stdlib__MoreLabels.cmi : moreLabels.mli \
     stdlib__Seq.cmi \
     stdlib__Map.cmi \
     stdlib__Hashtbl.cmi
-stdlib__Mutex.cmo : mutex.ml \
-    stdlib__Mutex.cmi
-stdlib__Mutex.cmx : mutex.ml \
-    stdlib__Mutex.cmi
-stdlib__Mutex.cmi : mutex.mli
 stdlib__Nativeint.cmo : nativeint.ml \
     stdlib__Sys.cmi \
     stdlib.cmi \
@@ -598,7 +557,6 @@ stdlib__Random.cmo : random.ml \
     stdlib__Nativeint.cmi \
     stdlib__Int64.cmi \
     stdlib__Int32.cmi \
-    stdlib__Domain.cmi \
     stdlib__Digest.cmi \
     stdlib__Bytes.cmi \
     stdlib__Bigarray.cmi \
@@ -609,7 +567,6 @@ stdlib__Random.cmx : random.ml \
     stdlib__Nativeint.cmx \
     stdlib__Int64.cmx \
     stdlib__Int32.cmx \
-    stdlib__Domain.cmx \
     stdlib__Digest.cmx \
     stdlib__Bytes.cmx \
     stdlib__Bigarray.cmx \
@@ -649,15 +606,6 @@ stdlib__Scanf.cmx : scanf.ml \
     stdlib__Scanf.cmi
 stdlib__Scanf.cmi : scanf.mli \
     stdlib.cmi
-stdlib__Semaphore.cmo : semaphore.ml \
-    stdlib__Mutex.cmi \
-    stdlib__Condition.cmi \
-    stdlib__Semaphore.cmi
-stdlib__Semaphore.cmx : semaphore.ml \
-    stdlib__Mutex.cmx \
-    stdlib__Condition.cmx \
-    stdlib__Semaphore.cmi
-stdlib__Semaphore.cmi : semaphore.mli
 stdlib__Seq.cmo : seq.ml \
     stdlib__Lazy.cmi \
     stdlib__Either.cmi \
diff --git a/stdlib/Makefile b/stdlib/Makefile
index 9f78d23ecd..b6480b298d 100644
--- a/stdlib/Makefile
+++ b/stdlib/Makefile
@@ -264,7 +264,8 @@ GNUISH_SED = \
 
 .PHONY: depend
 depend:
-	$(CAMLDEP) $(DEPFLAGS) $(filter-out stdlib.%,$(wildcard *.mli *.ml)) \
+	$(CAMLDEP) $(DEPFLAGS) $(filter-out stdlib.%,std_exit.ml \
+    $(STDLIB_MODULE_BASENAMES:=.mli) $(STDLIB_MODULE_BASENAMES:=.ml)) \
 	  > .depend.tmp
 	$(CAMLDEP) $(DEPFLAGS) -pp "$(AWK) -f ./remove_module_aliases.awk" \
 	  stdlib.ml stdlib.mli >> .depend.tmp
diff --git a/stdlib/StdlibModules b/stdlib/StdlibModules
index fc299a5ea8..0780508c00 100644
--- a/stdlib/StdlibModules
+++ b/stdlib/StdlibModules
@@ -39,12 +39,11 @@ STDLIB_MODULE_BASENAMES = \
   seq option result bool char uchar \
   list int bytes string unit marshal array float int32 int64 nativeint \
   lexing parsing set map stack queue buffer \
-  mutex condition semaphore domain \
   camlinternalFormat printf arg \
   printexc fun gc digest bigarray random hashtbl weak \
   format scanf callback camlinternalOO oo camlinternalMod ephemeron \
   filename complex arrayLabels listLabels bytesLabels stringLabels moreLabels \
-  stdLabels in_channel out_channel effect
+  stdLabels in_channel out_channel
 
 STDLIB_PREFIXED_MODULES = \
   $(filter-out stdlib camlinternal%, $(STDLIB_MODULE_BASENAMES))
diff --git a/stdlib/atomic.ml b/stdlib/atomic.ml
index d5d6e99e1d..aa057e3985 100644
--- a/stdlib/atomic.ml
+++ b/stdlib/atomic.ml
@@ -12,6 +12,7 @@
 (*                                                                        *)
 (**************************************************************************)
 
+(* BACKPORT BEGIN
 type !'a t
 
 external make : 'a -> 'a t = "%makemutable"
@@ -19,8 +20,53 @@ external get : 'a t -> 'a = "%atomic_load"
 external exchange : 'a t -> 'a -> 'a = "%atomic_exchange"
 external compare_and_set : 'a t -> 'a -> 'a -> bool = "%atomic_cas"
 external fetch_and_add : int t -> int -> int = "%atomic_fetch_add"
+*)
+external ( == ) : 'a -> 'a -> bool = "%eq"
+external ( + ) : int -> int -> int = "%addint"
+(* BACKPORT END *)
 external ignore : 'a -> unit = "%ignore"
 
+(* BACKPORT BEGIN *)
+(* We are not reusing ('a ref) directly to make it easier to reason
+   about atomicity if we wish to: even in a sequential implementation,
+   signals and other asynchronous callbacks might break atomicity. *)
+type 'a t = {mutable v: 'a}
+
+let make v = {v}
+let get r = r.v
+let set r v = r.v <- v
+
+(* The following functions are set to never be inlined: Flambda is
+   allowed to move surrounding code inside the critical section,
+   including allocations. *)
+
+let[@inline never] exchange r v =
+  (* BEGIN ATOMIC *)
+  let cur = r.v in
+  r.v <- v;
+  (* END ATOMIC *)
+  cur
+
+let[@inline never] compare_and_set r seen v =
+  (* BEGIN ATOMIC *)
+  let cur = r.v in
+  if cur == seen then (
+    r.v <- v;
+    (* END ATOMIC *)
+    true
+  ) else
+    false
+
+let[@inline never] fetch_and_add r n =
+  (* BEGIN ATOMIC *)
+  let cur = r.v in
+  r.v <- (cur + n);
+  (* END ATOMIC *)
+  cur
+
+(* BACKPORT END *)
+(* BACKPORT
 let set r x = ignore (exchange r x)
+*)
 let incr r = ignore (fetch_and_add r 1)
 let decr r = ignore (fetch_and_add r (-1))
diff --git a/stdlib/camlinternalLazy.ml b/stdlib/camlinternalLazy.ml
index 07cf954054..1748dc4a87 100644
--- a/stdlib/camlinternalLazy.ml
+++ b/stdlib/camlinternalLazy.ml
@@ -13,12 +13,15 @@
 (*                                                                        *)
 (**************************************************************************)
 
+(* BACKPORT - REVERTED to 4.14 STATE *)
+
 (* Internals of forcing lazy values. *)
 
 type 'a t = 'a lazy_t
 
 exception Undefined
 
+(*
 (* [update_to_forcing blk] tries to update a [blk] with [lazy_tag] to
    [forcing_tag] using compare-and-swap (CAS), taking care to handle concurrent
    marking of the header word by a concurrent GC thread. Returns [0] if the
@@ -103,3 +106,56 @@ let force_gen ~only_val (lzv : 'arg lazy_t) =
   else if t = Obj.forcing_tag then raise Undefined
   else if t <> Obj.lazy_tag then (Obj.obj x : 'arg)
   else force_gen_lazy_block ~only_val lzv
+*)
+let raise_undefined = Obj.repr (fun () -> raise Undefined)
+
+external make_forward : Obj.t -> Obj.t -> unit = "caml_obj_make_forward"
+
+(* Assume [blk] is a block with tag lazy *)
+let force_lazy_block (blk : 'arg lazy_t) =
+  let closure = (Obj.obj (Obj.field (Obj.repr blk) 0) : unit -> 'arg) in
+  Obj.set_field (Obj.repr blk) 0 raise_undefined;
+  try
+    let result = closure () in
+    make_forward (Obj.repr blk) (Obj.repr result);
+    result
+  with e ->
+    Obj.set_field (Obj.repr blk) 0 (Obj.repr (fun () -> raise e));
+    raise e
+
+
+(* Assume [blk] is a block with tag lazy *)
+let force_val_lazy_block (blk : 'arg lazy_t) =
+  let closure = (Obj.obj (Obj.field (Obj.repr blk) 0) : unit -> 'arg) in
+  Obj.set_field (Obj.repr blk) 0 raise_undefined;
+  let result = closure () in
+  make_forward (Obj.repr blk) (Obj.repr result);
+  result
+
+
+(* [force] is not used, since [Lazy.force] is declared as a primitive
+   whose code inlines the tag tests of its argument, except when afl
+   instrumentation is turned on. *)
+
+let force (lzv : 'arg lazy_t) =
+  (* Using [Sys.opaque_identity] prevents two potential problems:
+     - If the value is known to have Forward_tag, then its tag could have
+       changed during GC, so that information must be forgotten (see GPR#713
+       and issue #7301)
+     - If the value is known to be immutable, then if the compiler
+       cannot prove that the last branch is not taken it will issue a
+       warning 59 (modification of an immutable value) *)
+  let lzv = Sys.opaque_identity lzv in
+  let x = Obj.repr lzv in
+  let t = Obj.tag x in
+  if t = Obj.forward_tag then (Obj.obj (Obj.field x 0) : 'arg) else
+  if t <> Obj.lazy_tag then (Obj.obj x : 'arg)
+  else force_lazy_block lzv
+
+
+let force_val (lzv : 'arg lazy_t) =
+  let x = Obj.repr lzv in
+  let t = Obj.tag x in
+  if t = Obj.forward_tag then (Obj.obj (Obj.field x 0) : 'arg) else
+  if t <> Obj.lazy_tag then (Obj.obj x : 'arg)
+  else force_val_lazy_block lzv
diff --git a/stdlib/camlinternalLazy.mli b/stdlib/camlinternalLazy.mli
index ac8b7a8bee..2fd6aa2bf4 100644
--- a/stdlib/camlinternalLazy.mli
+++ b/stdlib/camlinternalLazy.mli
@@ -23,4 +23,13 @@ exception Undefined
 
 val force_lazy_block : 'a lazy_t -> 'a
 
+(* BACKPORT BEGIN *)
+val force_val_lazy_block : 'a lazy_t -> 'a
+
+val force : 'a lazy_t -> 'a
+val force_val : 'a lazy_t -> 'a
+(* BACKPORT END *)
+
+(* BACKPORT
 val force_gen : only_val:bool -> 'a lazy_t -> 'a
+*)
diff --git a/stdlib/filename.ml b/stdlib/filename.ml
index f7ce1e46d8..c13b0d5371 100644
--- a/stdlib/filename.ml
+++ b/stdlib/filename.ml
@@ -326,11 +326,19 @@ let remove_extension name =
 external open_desc: string -> open_flag list -> int -> int = "caml_sys_open"
 external close_desc: int -> unit = "caml_sys_close"
 
+(* BACKPORT BEGIN
 let prng_key =
   Domain.DLS.new_key Random.State.make_self_init
+*)
+let prng_key = lazy(Random.State.make_self_init ())
+(* BACKPORT END *)
 
 let temp_file_name temp_dir prefix suffix =
+(* BACKPORT BEGIN
   let random_state = Domain.DLS.get prng_key in
+*)
+  let random_state = Lazy.force prng_key in
+(* BACKPORT END *)
   let rnd = (Random.State.bits random_state) land 0xFFFFFF in
   concat temp_dir (Printf.sprintf "%s%06x%s" prefix rnd suffix)
 
diff --git a/stdlib/format.ml b/stdlib/format.ml
index 6ca2f8f03d..11580e7524 100644
--- a/stdlib/format.ml
+++ b/stdlib/format.ml
@@ -1020,6 +1020,7 @@ and err_formatter = formatter_of_out_channel Stdlib.stderr
 and str_formatter = formatter_of_buffer stdbuf
 
 (* Initialise domain local state *)
+(* BACKPORT BEGIN
 module DLS = Domain.DLS
 
 let stdbuf_key = DLS.new_key pp_make_buffer
@@ -1064,6 +1065,17 @@ let err_formatter_key = DLS.new_key (fun () ->
   ppf.pp_out_indent <- display_indent ppf;
   ppf)
 let _ = DLS.set err_formatter_key err_formatter
+*)
+
+let std_formatter_key = std_formatter
+let err_formatter_key = err_formatter
+let str_formatter_key = str_formatter
+let stdbuf_key = stdbuf
+
+module DLS = struct
+  let get = Fun.id
+end
+(* BACKPORT END *)
 
 let get_std_formatter () = DLS.get std_formatter_key
 let get_err_formatter () = DLS.get err_formatter_key
@@ -1086,6 +1098,7 @@ let flush_str_formatter () =
   let str_formatter = DLS.get str_formatter_key in
   flush_buffer_formatter stdbuf str_formatter
 
+(* BACKPORT
 let make_synchronized_formatter output flush =
   DLS.new_key (fun () ->
     let buf = Buffer.create pp_buffer_size in
@@ -1099,6 +1112,7 @@ let make_synchronized_formatter output flush =
 
 let synchronized_formatter_of_out_channel oc =
   make_synchronized_formatter (output_substring oc) (fun () -> flush oc)
+*)
 
 (*
   Symbolic pretty-printing
@@ -1474,6 +1488,7 @@ let flush_standard_formatters () =
 
 let () = at_exit flush_standard_formatters
 
+(* BACKPORT
 let () = Domain.at_first_spawn (fun () ->
   flush_standard_formatters ();
 
@@ -1488,3 +1503,4 @@ let () = Domain.at_first_spawn (fun () ->
              out_flush = buffered_out_flush Stdlib.stderr err_buf_key};
 
   Domain.at_exit flush_standard_formatters)
+*)
diff --git a/stdlib/format.mli b/stdlib/format.mli
index 37c6f3136a..020c9466d3 100644
--- a/stdlib/format.mli
+++ b/stdlib/format.mli
@@ -959,6 +959,7 @@ val formatter_of_out_channel : out_channel -> formatter
     to the corresponding output channel [oc].
 *)
 
+(* BACKPORT
 val synchronized_formatter_of_out_channel :
   out_channel -> formatter Domain.DLS.key
 (** [synchronized_formatter_of_out_channel oc] returns the key to the
@@ -969,7 +970,7 @@ val synchronized_formatter_of_out_channel :
     domains will be interleaved with each other at points where the formatter
     is flushed, such as with {!print_flush}.
 *)
-
+*)
 
 val std_formatter : formatter
 (** The initial domain's standard formatter to write to standard output.
@@ -1037,6 +1038,7 @@ val make_formatter :
   returns a formatter to the {!Stdlib.out_channel} [oc].
 *)
 
+(* BACKPORT
 val make_synchronized_formatter :
   (string -> int -> int -> unit) -> (unit -> unit) -> formatter Domain.DLS.key
 (** [make_synchronized_formatter out flush] returns the key to the domain-local
@@ -1047,6 +1049,7 @@ val make_synchronized_formatter :
     domains will be interleaved with each other at points where the formatter
     is flushed, such as with {!print_flush}.
 *)
+*)
 
 val formatter_of_out_functions :
   formatter_out_functions -> formatter
diff --git a/stdlib/hashtbl.ml b/stdlib/hashtbl.ml
index ff4cff4d3e..ae7c06e49c 100644
--- a/stdlib/hashtbl.ml
+++ b/stdlib/hashtbl.ml
@@ -57,7 +57,11 @@ let randomized = ref randomized_default
 let randomize () = randomized := true
 let is_randomized () = !randomized
 
+(* BACKPORT BEGIN
 let prng_key = Domain.DLS.new_key Random.State.make_self_init
+*)
+let prng = lazy (Random.State.make_self_init())
+(* BACKPORT END *)
 
 (* Functions which appear before the functorial interface must either be
    independent of the hash function or take it as a parameter (see #2202 and
@@ -73,7 +77,11 @@ let rec power_2_above x n =
 let create ?(random = !randomized) initial_size =
   let s = power_2_above 16 initial_size in
   let seed =
+(* BACKPORT BEGIN
     if random then Random.State.bits (Domain.DLS.get prng_key) else 0
+*)
+    if random then Random.State.bits (Lazy.force prng) else 0
+(* BACKPORT END *)
   in
   { initial_size = s; size = 0; seed = seed; data = Array.make s Empty }
 
@@ -619,7 +627,11 @@ let of_seq i =
 let rebuild ?(random = !randomized) h =
   let s = power_2_above 16 (Array.length h.data) in
   let seed =
+(* BACKPORT BEGIN
     if random then Random.State.bits (Domain.DLS.get prng_key)
+*)
+    if random then Random.State.bits (Lazy.force prng)
+(* BACKPORT END *)
     else if Obj.size (Obj.repr h) >= 4 then h.seed
     else 0 in
   let h' = {
diff --git a/stdlib/lazy.ml b/stdlib/lazy.ml
index ab29d404c9..8534cb3222 100644
--- a/stdlib/lazy.ml
+++ b/stdlib/lazy.ml
@@ -53,7 +53,11 @@ exception Undefined = CamlinternalLazy.Undefined
 external make_forward : 'a -> 'a lazy_t = "caml_lazy_make_forward"
 external force : 'a t -> 'a = "%lazy_force"
 
+(* BACKPORT BEGIN
 let force_val l = CamlinternalLazy.force_gen ~only_val:true l
+*)
+let force_val = CamlinternalLazy.force_val
+(* BACKPORT END *)
 
 let from_fun (f : unit -> 'arg) =
   let x = Obj.new_block Obj.lazy_tag 1 in
diff --git a/stdlib/obj.ml b/stdlib/obj.ml
index 7f86887346..6fb0581747 100644
--- a/stdlib/obj.ml
+++ b/stdlib/obj.ml
@@ -29,9 +29,11 @@ external size : t -> int = "%obj_size"
 external reachable_words : t -> int = "caml_obj_reachable_words"
 external field : t -> int -> t = "%obj_field"
 external set_field : t -> int -> t -> unit = "%obj_set_field"
+(* BACKPORT
 external compare_and_swap_field : t -> int -> t -> t -> bool
   = "caml_obj_compare_and_swap"
 external is_shared : t -> bool = "caml_obj_is_shared"
+*)
 external floatarray_get : floatarray -> int -> float = "caml_floatarray_get"
 external floatarray_set :
     floatarray -> int -> float -> unit = "caml_floatarray_set"
diff --git a/stdlib/obj.mli b/stdlib/obj.mli
index df5fed1b8b..304596eda8 100644
--- a/stdlib/obj.mli
+++ b/stdlib/obj.mli
@@ -53,9 +53,11 @@ external field : t -> int -> t = "%obj_field"
     be propagated.
 *)
 external set_field : t -> int -> t -> unit = "%obj_set_field"
+(* BACKPORT
 external compare_and_swap_field : t -> int -> t -> t -> bool
   = "caml_obj_compare_and_swap"
 external is_shared : t -> bool = "caml_obj_is_shared"
+*)
 
 val [@inline always] double_field : t -> int -> float  (* @since 3.11.2 *)
 val [@inline always] set_double_field : t -> int -> float -> unit
diff --git a/stdlib/random.ml b/stdlib/random.ml
index 02112d6bbd..c91195d2ff 100644
--- a/stdlib/random.ml
+++ b/stdlib/random.ml
@@ -175,6 +175,7 @@ let mk_default () =
            (-8591268803865043407L)
            6388613595849772044L
 
+(* BACKPORT BEGIN
 let random_key =
   Domain.DLS.new_key ~split_from_parent:State.split mk_default
 
@@ -191,14 +192,39 @@ let bits64 () = State.bits64 (Domain.DLS.get random_key)
 let nativebits () = State.nativebits (Domain.DLS.get random_key)
 
 let full_init seed = State.reinit (Domain.DLS.get random_key) seed
+*)
+let default = mk_default ()
+let bits () = State.bits default
+let int bound = State.int default bound
+let full_int bound = State.full_int default bound
+let int32 bound = State.int32 default bound
+let nativeint bound = State.nativeint default bound
+let int64 bound = State.int64 default bound
+let float scale = State.float default scale
+let bool () = State.bool default
+let bits32 () = State.bits32 default
+let bits64 () = State.bits64 default
+let nativebits () = State.nativebits default
+
+let full_init seed = State.reinit default seed
 let init seed = full_init [| seed |]
+(* BACKPORT END *)
 let self_init () = full_init (random_seed())
 
 (* Splitting *)
 
+(* BACKPORT BEGIN
 let split () = State.split (Domain.DLS.get random_key)
+*)
+let split () = State.split default
+(* BACKPORT END *)
 
 (* Manipulating the current state. *)
 
+(* BACKPORT BEGIN
 let get_state () = State.copy (Domain.DLS.get random_key)
 let set_state s = State.assign (Domain.DLS.get random_key) s
+*)
+let get_state () = State.copy default
+let set_state s = State.assign default s
+(* BACKPORT END *)
diff --git a/stdlib/stdlib.ml b/stdlib/stdlib.ml
index a6e682303d..a1aa7b07a3 100644
--- a/stdlib/stdlib.ml
+++ b/stdlib/stdlib.ml
@@ -548,11 +548,27 @@ let ( ^^ ) (Format (fmt1, str1)) (Format (fmt2, str2)) =
 external sys_exit : int -> 'a = "caml_sys_exit"
 
 (* for at_exit *)
+(* BACKPORT BEGIN
 type 'a atomic_t
 external atomic_make : 'a -> 'a atomic_t = "%makemutable"
 external atomic_get : 'a atomic_t -> 'a = "%atomic_load"
 external atomic_compare_and_set : 'a atomic_t -> 'a -> 'a -> bool
   = "%atomic_cas"
+*)
+type 'a t = {mutable v: 'a}
+
+let atomic_make v = {v}
+let atomic_get r = r.v
+let[@inline never] atomic_compare_and_set r seen v =
+  (* BEGIN ATOMIC *)
+  let cur = r.v in
+  if cur == seen then (
+    r.v <- v;
+    (* END ATOMIC *)
+    true
+  ) else
+    false
+(* BACKPORT END *)
 
 let exit_function = atomic_make flush_all
 
@@ -575,6 +591,13 @@ let exit retcode =
 
 let _ = register_named_value "Pervasives.do_at_exit" do_at_exit
 
+(* BACKPORT BEGIN *)
+external major : unit -> unit = "caml_gc_major"
+external naked_pointers_checked : unit -> bool
+  = "caml_sys_const_naked_pointers_checked"
+let () = if naked_pointers_checked () then at_exit major
+(* BACKPORT END *)
+
 (*MODULE_ALIASES*)
 module Arg            = Arg
 module Array          = Array
@@ -588,10 +611,14 @@ module BytesLabels    = BytesLabels
 module Callback       = Callback
 module Char           = Char
 module Complex        = Complex
+(* BACKPORT
 module Condition      = Condition
+*)
 module Digest         = Digest
+(* BACKPORT
 module Domain         = Domain
 module Effect         = Effect
+*)
 module Either         = Either
 module Ephemeron      = Ephemeron
 module Filename       = Filename
@@ -611,7 +638,9 @@ module ListLabels     = ListLabels
 module Map            = Map
 module Marshal        = Marshal
 module MoreLabels     = MoreLabels
+(* BACKPORT
 module Mutex          = Mutex
+*)
 module Nativeint      = Nativeint
 module Obj            = Obj
 module Oo             = Oo
@@ -624,7 +653,9 @@ module Queue          = Queue
 module Random         = Random
 module Result         = Result
 module Scanf          = Scanf
+(* BACKPORT
 module Semaphore      = Semaphore
+*)
 module Seq            = Seq
 module Set            = Set
 module Stack          = Stack
diff --git a/stdlib/stdlib.mli b/stdlib/stdlib.mli
index 8775eadb88..0c2b22634f 100644
--- a/stdlib/stdlib.mli
+++ b/stdlib/stdlib.mli
@@ -1382,10 +1382,14 @@ module BytesLabels    = BytesLabels
 module Callback       = Callback
 module Char           = Char
 module Complex        = Complex
+(* BACKPORT
 module Condition      = Condition
+*)
 module Digest         = Digest
+(* BACKPORT
 module Domain         = Domain
 module Effect         = Effect
+*)
 module Either         = Either
 module Ephemeron      = Ephemeron
 module Filename       = Filename
@@ -1405,7 +1409,9 @@ module ListLabels     = ListLabels
 module Map            = Map
 module Marshal        = Marshal
 module MoreLabels     = MoreLabels
+(* BACKPORT
 module Mutex          = Mutex
+*)
 module Nativeint      = Nativeint
 module Obj            = Obj
 module Oo             = Oo
@@ -1418,7 +1424,9 @@ module Queue          = Queue
 module Random         = Random
 module Result         = Result
 module Scanf          = Scanf
+(* BACKPORT
 module Semaphore      = Semaphore
+*)
 module Seq            = Seq
 module Set            = Set
 module Stack          = Stack
diff --git a/tools/dumpobj.ml b/tools/dumpobj.ml
index 01722ed9ca..508dd3b226 100644
--- a/tools/dumpobj.ml
+++ b/tools/dumpobj.ml
@@ -394,10 +394,12 @@ let op_shapes = [
   opUGEINT, Nothing;
   opBULTINT, Uint_Disp;
   opBUGEINT, Uint_Disp;
+(* BACKPORT
   opPERFORM, Nothing;
   opRESUME, Nothing;
   opRESUMETERM, Uint;
   opREPERFORMTERM, Uint;
+*)
   opSTOP, Nothing;
   opEVENT, Nothing;
   opBREAK, Nothing;
diff --git a/utils/config.mlp b/utils/config.mlp
index fc92ba77ec..75087e4b2f 100644
--- a/utils/config.mlp
+++ b/utils/config.mlp
@@ -122,8 +122,13 @@ let max_tag = 243
 let lazy_tag = 246
 
 let max_young_wosize = 256
+(* BACKPORT BEGIN
 let stack_threshold = 32 (* see runtime/caml/config.h *)
 let stack_safety_margin = 6
+*)
+let stack_threshold = 256 (* see runtime/caml/config.h *)
+let stack_safety_margin = 60
+(* BACKPORT END *)
 
 let architecture = "%%ARCH%%"
 let model = "%%MODEL%%"
diff --git a/utils/domainstate.ml.c b/utils/domainstate.ml.c
index 6dbae1d07a..1eee2142ad 100644
--- a/utils/domainstate.ml.c
+++ b/utils/domainstate.ml.c
@@ -16,7 +16,9 @@
 
 #define CAML_CONFIG_H_NO_TYPEDEFS
 #include "config.h"
+/* BACKPORT
 let stack_ctx_words = Stack_ctx_words
+*/
 
 type t =
 #define DOMAIN_STATE(type, name) | Domain_##name
diff --git a/utils/domainstate.mli.c b/utils/domainstate.mli.c
index 66a4750d4c..c4a77ff976 100644
--- a/utils/domainstate.mli.c
+++ b/utils/domainstate.mli.c
@@ -14,7 +14,9 @@
 /*                                                                        */
 /**************************************************************************/
 
+/* BACKPORT
 val stack_ctx_words : int
+*/
 
 type t =
 #define DOMAIN_STATE(type, name) | Domain_##name
