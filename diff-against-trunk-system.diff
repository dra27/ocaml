diff --git a/.Diff-of-diff.diff b/.Diff-of-diff.diff
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/.gitattributes b/.gitattributes
index c972b3bc0b..18b5a6ee4f 100644
--- a/.gitattributes
+++ b/.gitattributes
@@ -142,6 +142,7 @@ testsuite/tests/lib-dynlink-domains/main.ml  typo.very-long-line
 testsuite/tests/tool-ocamltest/norm*.reference binary
 
 tools/magic                       typo.missing-header
+tools/eventlog_metadata.in        typo.missing-header
 
 # TODO we should fix the long-line errors in yacc/*.c
 /yacc/*.[ch]         typo.very-long-line=may
diff --git a/Changes b/Changes
index 8f3bc0d100..1f916a8992 100644
--- a/Changes
+++ b/Changes
@@ -548,6 +548,10 @@ Working version
   types.
   (Chris Casinghino, review by Gabriel Scherer)
 
+- #12264, #12289: Fix compact_allocate to avoid a pathological case
+  that causes very slow compaction.
+  (Damien Doligez, report by Arseniy Alekseyev, review by Sadiq Jaffer)
+
 OCaml 5.0.0 (15 December 2022)
 ------------------------------
 
@@ -1084,11 +1088,6 @@ OCaml 5.0.0 (15 December 2022)
   (Damien Doligez, report by Thierry Martinez and Vincent Laviron, review by
    Xavier Leroy)
 
-- #11508, #11509: make Bytes.escaped domain-safe
-  (Christiano Haesbaert and Gabriel Scherer,
-   review by Xavier Leroy,
-   report by Jan Midtgaard and Tom Kelly)
-
 - #11516, #11524: Fix the `deprecated_mutable` attribute.
   (Chris Casinghino, review by Nicolás Ojeda Bär and Florian Angeletti)
 
@@ -1117,6 +1116,30 @@ OCaml 5.0.0 (15 December 2022)
   (Gabriel Scherer, review by Jacques Garrigue and Florian Angeletti,
    report by Yaron Minsky)
 
+OCaml 4.14 maintenance branch
+-----------------------------
+
+- #11508, #11509: make Bytes.escaped domain-safe
+  (Christiano Haesbaert and Gabriel Scherer,
+   review by Xavier Leroy,
+   report by Jan Midtgaard and Tom Kelly)
+
+### Manual and documentation:
+
+- #11045, #11409: document that the array argument to `caml_callbackN`
+  must not have been declared by `CAMLlocalN`.
+  (Xavier Leroy, report by Stephen Dolan, review by Gabriel Scherer.)
+
+### Bug fixes:
+
+- #11489, #11496: More prudent deallocation of alternate signal stack
+  (Xavier Leroy, report by @rajdakin, review by Florian Angeletti)
+
+- #11768, #11788: Fix crash at start-up of bytecode programs in
+  no-naked-pointers mode caused by wrong initialization of caml_global_data
+  (Xavier Leroy, report by Etienne Millon, review by Gabriel Scherer)
+
+
 OCaml 4.14.0 (28 March 2022)
 ----------------------------
 
@@ -1152,13 +1175,13 @@ OCaml 4.14.0 (28 March 2022)
 - #10549: Stack overflow detection and naked pointers checking for ARM64
   (Xavier Leroy, review by Stephen Dolan)
 
-* #10675: Emit deprecation warnings when old C runtime function names
+* #10675, #10937: Emit deprecation warnings when old C runtime function names
   are used.  This will break C stub code that uses these old names and
   treats warnings as errors.  The workaround is to use the new names.
   (Xavier Leroy and David Allsopp, review by Sébastien Hinderer and
    Damien Doligez)
 
-- #10698, #10726: Free the alternate signal stack when the main OCaml
+- #10698, #10726, #10891: Free the alternate signal stack when the main OCaml
    code or an OCaml thread stops
   (Xavier Leroy, review by David Allsopp and Damien Doligez)
 
@@ -1265,6 +1288,9 @@ OCaml 4.14.0 (28 March 2022)
 - #10464: Add List.is_empty.
   (Craig Ferguson, review by David Allsopp)
 
+* #10922: Add deprecation warnings on {Int32,Int64,Nativeint}.format.
+  (Nicolás Ojeda Bär, review by Xavier Leroy and Florian Angeletti)
+
 ### Other libraries:
 
 - #10192: Add support for Unix domain sockets on Windows and use them
@@ -1528,6 +1554,9 @@ OCaml 4.14.0 (28 March 2022)
 
 ### Build system:
 
+- #10828 Build native-code compilers on OpenBSD/aarch64
+  (Christopher Zimmermann)
+
 - #10835 Disable DT_TEXTREL warnings on x86 32 bit architecture by passing
   -Wl,-z,notext in mksharedlib and mkmaindll. Fixes relocation issues, reported
   in #9800, making local patches in Debian, Alpine, and FreeBSD superfluous.
diff --git a/Makefile b/Makefile
index d7ac2bcb22..5f0fa3a427 100644
--- a/Makefile
+++ b/Makefile
@@ -605,7 +605,6 @@ partialclean::
 ## Lists of source files
 
 runtime_COMMON_C_SOURCES = \
-  addrmap \
   afl \
   alloc \
   array \
@@ -613,24 +612,24 @@ runtime_COMMON_C_SOURCES = \
   bigarray \
   callback \
   codefrag \
+  compact \
   compare \
   custom \
   debugger \
   domain \
   dynlink \
+  eventlog \
   extern \
-  fiber \
   finalise \
   floats \
+  freelist \
   gc_ctrl \
-  gc_stats \
   globroots \
   hash \
   intern \
   ints \
   io \
   lexing \
-  lf_skiplist \
   main \
   major_gc \
   md5 \
@@ -641,17 +640,12 @@ runtime_COMMON_C_SOURCES = \
   misc \
   obj \
   parsing \
-  platform \
   printexc \
   prng \
-  roots \
-  runtime_events \
-  shared_heap \
   signals \
   skiplist \
   startup_aux \
   str \
-  sync \
   sys \
   $(UNIX_OR_WIN32) \
   weak
@@ -661,6 +655,9 @@ runtime_BYTECODE_ONLY_C_SOURCES = \
   fail_byt \
   fix_code \
   interp \
+  roots_byt \
+  signals_byt \
+  stacks \
   startup_byt
 runtime_BYTECODE_C_SOURCES = \
   $(runtime_COMMON_C_SOURCES:%=runtime/%.c) \
@@ -671,7 +668,7 @@ runtime_NATIVE_ONLY_C_SOURCES = \
   clambda_checks \
   dynlink_nat \
   fail_nat \
-  frame_descriptors \
+  roots_nat \
   startup_nat \
   signals_nat
 runtime_NATIVE_C_SOURCES = \
@@ -1066,12 +1063,14 @@ clean::
 
 # Dependencies
 
-subdirs = stdlib $(addprefix otherlibs/, $(ALL_OTHERLIBS)) \
+subdirs = \
+  stdlib $(addprefix otherlibs/, \
+    $(filter-out runtime_events, $(ALL_OTHERLIBS))) \
   debugger ocamldoc ocamltest
 
 .PHONY: alldepend
 alldepend: depend
-	for dir in $(subdirs); do \
+	for dir in $(filter-out %/runtime_events, $(subdirs)); do \
 	  $(MAKE) -C $$dir depend || exit; \
 	done
 
@@ -1144,6 +1143,7 @@ $(ocamlyacc_PROGRAM)$(EXE): $(ocamlyacc_OBJECTS)
 	$(V_MKEXE)$(MKEXE) -o $@ $^
 
 clean::
+	rm -f yacc/wstr.o yacc/wstr.obj
 	rm -f $(ocamlyacc_MODULES:=.o) $(ocamlyacc_MODULES:=.obj)
 
 $(ocamlyacc_OTHER_MODULES:=.$(O)): yacc/defs.h
@@ -1643,6 +1643,9 @@ endif
 	else \
 	  $(INSTALL_PROG) tools/ocamlcmt$(EXE) "$(INSTALL_BINDIR)"; \
 	fi
+	$(INSTALL_DATA) \
+	  tools/eventlog_metadata \
+	  "$(INSTALL_LIBDIR)"
 	$(INSTALL_DATA) \
 	   utils/*.cmi \
 	   parsing/*.cmi \
diff --git a/Makefile.config.in b/Makefile.config.in
index c8d6966c40..6a1cbd16a0 100644
--- a/Makefile.config.in
+++ b/Makefile.config.in
@@ -243,7 +243,7 @@ FLAT_FLOAT_ARRAY=@flat_float_array@
 FUNCTION_SECTIONS=@function_sections@
 AWK=@AWK@
 STDLIB_MANPAGES=@stdlib_manpages@
-NAKED_POINTERS=false
+NAKED_POINTERS=@naked_pointers@
 
 # Deprecated variables
 
diff --git a/VERSION b/VERSION
index 1443e92a84..4ef434f979 100644
--- a/VERSION
+++ b/VERSION
@@ -1,4 +1,4 @@
-5.1.0+dev1-2022-06-09
+5.0.0+jst-backport
 
 # Starting with OCaml 4.14, although the version string that appears above is
 # still correct and this file can thus still be used to figure it out,
diff --git a/api_docgen/Makefile.docfiles b/api_docgen/Makefile.docfiles
index ce0406e3d8..20f7595c89 100644
--- a/api_docgen/Makefile.docfiles
+++ b/api_docgen/Makefile.docfiles
@@ -31,7 +31,8 @@ str_MLIS := str.mli
 unix_MLIS := unix.mli unixLabels.mli
 dynlink_MLIS := dynlink.mli
 thread_MLIS := \
-  thread.mli event.mli
+  thread.mli condition.mli mutex.mli event.mli \
+  semaphore.mli
 
 STDLIB=$(STDLIB_MODULES)
 
diff --git a/asmcomp/amd64/emit.mlp b/asmcomp/amd64/emit.mlp
index e2da778605..061e684bdc 100644
--- a/asmcomp/amd64/emit.mlp
+++ b/asmcomp/amd64/emit.mlp
@@ -62,6 +62,7 @@ let cfi_endproc () =
 let cfi_adjust_cfa_offset n =
   if Config.asm_cfi_supported then D.cfi_adjust_cfa_offset n
 
+(* BACKPORT
 let cfi_remember_state () =
   if Config.asm_cfi_supported then D.cfi_remember_state ()
 
@@ -70,13 +71,16 @@ let cfi_restore_state () =
 
 let cfi_def_cfa_register reg =
   if Config.asm_cfi_supported then D.cfi_def_cfa_register reg
+*)
 
 let emit_debug_info dbg =
   emit_debug_info_gen dbg D.file D.loc
 
 let fp = Config.with_frame_pointers
 
+(* BACKPORT
 let stack_threshold_size = Config.stack_threshold * 8 (* bytes *)
+*)
 
 let frame_size env =                     (* includes return address *)
   if env.f.fun_frame_required then begin
@@ -535,8 +539,9 @@ let emit_instr env fallthrough i =
           end
         end
       end
-  | Lop(Iextcall { func; alloc; stack_ofs }) ->
+  | Lop(Iextcall { func; alloc; stack_ofs = _ }) ->
       add_used_symbol func;
+(* BACKPORT
       let base_stack_size =
         if Arch.win64 then
           32 (* Windows x64 rcx+rdx+r8+r9 shadow stack *)
@@ -548,11 +553,26 @@ let emit_instr env fallthrough i =
         load_symbol_addr func rax;
         emit_call "caml_c_call_stack_args";
         record_frame env i.live (Dbg_other i.dbg);
-      end else if alloc then begin
+      end else*) if alloc then begin
         load_symbol_addr func rax;
         emit_call "caml_c_call";
         record_frame env i.live (Dbg_other i.dbg);
+(* BACKPORT BEGIN *)
+        if system <> S_win64 then begin
+
+          (* In amd64.S, "caml_c_call" tail-calls the C function (in order to
+             produce nicer backtraces), so we need to restore r15 manually after
+             it returns (note that this increases code size).
+
+             In amd64nt.asm (used for Win64), "caml_c_call" invokes the C
+             function via a regular call, and restores r15 itself, thus avoiding
+             the code size increase. *)
+
+          I.mov (domain_field Domainstate.Domain_young_ptr) r15
+        end
+(* BACKPORT END *)
       end else begin
+(* BACKPORT
         I.mov rsp rbx;
         cfi_remember_state ();
         cfi_def_cfa_register "rbx";
@@ -560,10 +580,12 @@ let emit_instr env fallthrough i =
            will not unwind through this unless we were to tag this
            calling frame with cfi_signal_frame in it's definition. *)
         I.mov (domain_field Domainstate.Domain_c_stack) rsp;
-
+*)
         emit_call func;
+(* BACKPORT
         I.mov rbx rsp;
         cfi_restore_state ();
+*)
       end
   | Lop(Istackoffset n) ->
       if n < 0
@@ -746,7 +768,10 @@ let emit_instr env fallthrough i =
   | Lop(Ispecific(Izextend32)) ->
       I.mov (arg32 i 0) (res32 i 0)
   | Lop (Idls_get) ->
+      assert false
+(* BACKPORT
       I.mov (domain_field Domainstate.Domain_dls_root) (res i 0)
+*)
   | Lreloadretaddr ->
       ()
   | Lreturn ->
@@ -850,12 +875,24 @@ let emit_instr env fallthrough i =
       load_label_addr lbl_handler r11;
       I.push r11;
       cfi_adjust_cfa_offset 8;
+(* BACKPORT BEGIN
       I.push (domain_field Domainstate.Domain_exn_handler);
+*)
+      I.push (domain_field Domainstate.Domain_exception_pointer);
+(* BACKPORT END *)
       cfi_adjust_cfa_offset 8;
+(* BACKPORT BEGIN
       I.mov rsp (domain_field Domainstate.Domain_exn_handler);
+*)
+      I.mov rsp (domain_field Domainstate.Domain_exception_pointer);
+(* BACKPORT END *)
       env.stack_offset <- env.stack_offset + 16;
   | Lpoptrap ->
+(* BACKPORT BEGIN
       I.pop (domain_field Domainstate.Domain_exn_handler);
+*)
+      I.pop (domain_field Domainstate.Domain_exception_pointer);
+(* BACKPORT END *)
       cfi_adjust_cfa_offset (-8);
       I.add (int 8) rsp;
       cfi_adjust_cfa_offset (-8);
@@ -863,14 +900,26 @@ let emit_instr env fallthrough i =
   | Lraise k ->
       begin match k with
       | Lambda.Raise_regular ->
+(* BACKPORT BEGIN *)
+          I.mov (int 0) (domain_field Domainstate.Domain_backtrace_pos);
+(* BACKPORT END *)
           emit_call "caml_raise_exn";
           record_frame env Reg.Set.empty (Dbg_raise i.dbg)
       | Lambda.Raise_reraise ->
+(* BACKPORT BEGIN
           emit_call "caml_reraise_exn";
+*)
+          emit_call "caml_raise_exn";
+(* BACKPORT END *)
           record_frame env Reg.Set.empty (Dbg_raise i.dbg)
       | Lambda.Raise_notrace ->
+(* BACKPORT BEGIN
           I.mov (domain_field Domainstate.Domain_exn_handler) rsp;
           I.pop (domain_field Domainstate.Domain_exn_handler);
+*)
+          I.mov (domain_field Domainstate.Domain_exception_pointer) rsp;
+          I.pop (domain_field Domainstate.Domain_exception_pointer);
+(* BACKPORT END *)
           I.pop r11;
           I.jmp r11
       end
@@ -903,6 +952,7 @@ let fundecl fundecl =
   D.label (emit_symbol fundecl.fun_name);
   emit_debug_info fundecl.fun_dbg;
   cfi_startproc ();
+(* BACKPORT
   if !Clflags.runtime_variant = "d" then
     emit_call "caml_assert_stack_invariants";
   let { max_frame_size; contains_nontail_calls} =
@@ -920,9 +970,11 @@ let fundecl fundecl =
       Some (overflow, ret)
     end else None
   in
+*)
   emit_all env true fundecl.fun_body;
   List.iter emit_call_gc env.call_gc_sites;
   emit_call_bound_errors env;
+(* BACKPORT
   begin match handle_overflow with
   | None -> ()
   | Some (overflow,ret) -> begin
@@ -939,6 +991,7 @@ let fundecl fundecl =
       I.jmp (label ret)
     end
   end;
+*)
   if fundecl.fun_frame_required then begin
     let n = (frame_size env) - 8 - (if fp then 8 else 0) in
     if n <> 0
diff --git a/asmcomp/amd64/proc.ml b/asmcomp/amd64/proc.ml
index 56377b322c..f3453793cc 100644
--- a/asmcomp/amd64/proc.ml
+++ b/asmcomp/amd64/proc.ml
@@ -293,12 +293,20 @@ let destroyed_at_c_call =
   if win64 then
     (* Win64: rbx, rsi, rdi, r12-r15, xmm6-xmm15 preserved *)
     Array.of_list(List.map phys_reg
+(* BACKPORT BEGIN
       [0;4;5;6;7;10;11;12;
+*)
+      [0;4;5;6;7;10;11;
+(* BACKPORT END *)
        100;101;102;103;104;105])
   else
     (* Unix: rbx, r12-r15 preserved *)
     Array.of_list(List.map phys_reg
+(* BACKPORT BEGIN
       [0;1;2;3;4;5;6;7;10;11;
+*)
+      [0;2;3;4;5;6;7;10;11;
+(* BACKPORT END *)
        100;101;102;103;104;105;106;107;
        108;109;110;111;112;113;114;115])
 
diff --git a/asmcomp/arm64/emit.mlp b/asmcomp/arm64/emit.mlp
index a0c9f62442..f335149b20 100644
--- a/asmcomp/arm64/emit.mlp
+++ b/asmcomp/arm64/emit.mlp
@@ -34,8 +34,10 @@ let reg_trap_ptr = phys_reg 23 (* x26 *)
 let reg_alloc_ptr = phys_reg 24 (* x27 *)
 let reg_tmp1 = phys_reg 26 (* x16 *)
 let reg_x8 = phys_reg 8 (* x8 *)
+(* BACKPORT
 let reg_stack_arg_begin = phys_reg 17  (* x20 *)
 let reg_stack_arg_end  = phys_reg 18 (* x21 *)
+*)
 
 (* Output a label *)
 
@@ -461,24 +463,38 @@ module BR = Branch_relaxation.Make (struct
     | Lop (Itailcall_ind) -> epilogue_size f
     | Lop (Itailcall_imm { func; _ }) ->
       if func = f.fun_name then 1 else epilogue_size f
-    | Lop (Iextcall {alloc; stack_ofs} ) ->
+    | Lop (Iextcall {alloc; stack_ofs = _} ) ->
+(* BACKPORT
       if stack_ofs > 0 then 5
-      else if alloc then 3
+      else*) if alloc then 3
+(* BACKPORT BEGIN
       else 5
+*)
+      else 1
+(* BACKPORT END *)
     | Lop (Istackoffset _) -> 2
+(* BACKPORT BEGIN
     | Lop (Iload  { memory_chunk; addressing_mode; is_atomic }) ->
       let based = match addressing_mode with Iindexed _ -> 0 | Ibased _ -> 1
       and barrier = if is_atomic then 1 else 0
       and single = match memory_chunk with Single -> 2 | _ -> 1 in
       based + barrier + single
     | Lop (Istore (memory_chunk, addressing_mode, assignment)) ->
+*)
+    | Lop (Iload  { memory_chunk; addressing_mode })
+    | Lop (Istore (memory_chunk, addressing_mode, _)) ->
+(* BACKPORT END *)
       let based = match addressing_mode with Iindexed _ -> 0 | Ibased _ -> 1
+      in
+      based + begin match memory_chunk with Single -> 2 | _ -> 1 end
+(* BACKPORT
       and barrier =
         match memory_chunk, assignment with
         | (Word_int | Word_val), true -> 1
         | _ -> 0
       and single = match memory_chunk with Single -> 2 | _ -> 1 in
       based + barrier + single
+*)
     | Lop (Ialloc _) when f.fun_fast -> 5
     | Lop (Ispecific (Ifar_alloc _)) when f.fun_fast -> 6
     | Lop (Ipoll _) -> 3
@@ -538,7 +554,11 @@ module BR = Branch_relaxation.Make (struct
     | Lpoptrap -> 1
     | Lraise k ->
       begin match k with
+(* BACKPORT BEGIN
       | Lambda.Raise_regular -> 1
+*)
+      | Lambda.Raise_regular -> 2
+(* BACKPORT END *)
       | Lambda.Raise_reraise -> 1
       | Lambda.Raise_notrace -> 4
       end
@@ -739,7 +759,8 @@ let emit_instr env i =
           `	b	{emit_label env.f.fun_tailrec_entry_point_label}\n`
         else
           output_epilogue env (fun () -> `	b	{emit_symbol func}\n`)
-    | Lop(Iextcall {func; alloc; stack_ofs}) ->
+    | Lop(Iextcall {func; alloc; stack_ofs = _}) ->
+(* BACKPORT BEGIN
         if stack_ofs > 0 then begin
           `	mov	{emit_reg reg_stack_arg_begin}, sp\n`;
           `	add	{emit_reg reg_stack_arg_end}, sp, #{emit_int (Misc.align stack_ofs 16)}\n`;
@@ -747,9 +768,18 @@ let emit_instr env i =
           `	bl	{emit_symbol "caml_c_call_stack_args"}\n`;
           `{record_frame env i.live (Dbg_other i.dbg)}\n`
         end else if alloc then begin
+*)
+        if not alloc then
+        `	bl	{emit_symbol func}\n`
+        else begin
+(* BACKPORT END *)
           emit_load_symbol_addr reg_x8 func;
           `	bl	{emit_symbol "caml_c_call"}\n`;
           `{record_frame env i.live (Dbg_other i.dbg)}\n`
+(* BACKPORT BEGIN *)
+        end
+(* BACKPORT END *)
+(* BACKPORT
         end else begin
           (* store ocaml stack in the frame pointer register
              NB: no need to store previous x29 because OCaml frames don't
@@ -764,6 +794,7 @@ let emit_instr env i =
           `	mov	sp, x29\n`;
           cfi_restore_state ()
         end
+*)
     | Lop(Istackoffset n) ->
         assert (n mod 16 = 0);
         emit_stack_adjustment (-n);
@@ -804,7 +835,11 @@ let emit_instr env i =
         | Double ->
             `	ldr	{emit_reg dst}, {emit_addressing addressing_mode base}\n`
         end
+(* BACKPORT BEGIN
     | Lop(Istore(size, addr, assignment)) ->
+*)
+    | Lop(Istore(size, addr, _)) ->
+(* BACKPORT END *)
         (* NB: assignments other than Word_int and Word_val do not follow the
         Multicore OCaml memory model and so do not emit a barrier *)
         let src = i.arg.(0) in
@@ -827,7 +862,10 @@ let emit_instr env i =
             `	str	s7, {emit_addressing addr base}\n`;
         | Word_int | Word_val ->
             (* memory model barrier for non-initializing store *)
+(* BACKPORT
+            if assignment then ` dmb ishld\n`;
             if assignment then `	dmb	ishld\n`;
+*)
             `	str	{emit_reg src}, {emit_addressing addr base}\n`
         | Double ->
             `	str	{emit_reg src}, {emit_addressing addr base}\n`
@@ -956,8 +994,13 @@ let emit_instr env i =
     | Lop(Ispecific(Isignext size)) ->
         `	sbfm	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, #0, #{emit_int (size - 1)}\n`
     | Lop(Idls_get) ->
+(* BACKPORT BEGIN *)
+        assert false
+(* BACKPORT END *)
+(* BACKPORT
         let offset = Domainstate.(idx_of_field Domain_dls_root) * 8 in
         `	ldr	{emit_reg i.res.(0)}, [{emit_reg reg_domain_state_ptr}, {emit_int offset}]\n`
+*)
     | Lreloadretaddr ->
         ()
     | Lreturn ->
@@ -1044,10 +1087,18 @@ let emit_instr env i =
     | Lraise k ->
         begin match k with
         | Lambda.Raise_regular ->
+(* BACKPORT BEGIN *)
+          let offset = Domainstate.(idx_of_field Domain_backtrace_pos) * 8 in
+          `	str	xzr, [{emit_reg reg_domain_state_ptr}, {emit_int offset}]\n`;
+(* BACKPORT END *)
           `	bl	{emit_symbol "caml_raise_exn"}\n`;
           `{record_frame env Reg.Set.empty (Dbg_raise i.dbg)}\n`
         | Lambda.Raise_reraise ->
+(* BACKPORT BEGIN
           `	bl	{emit_symbol "caml_reraise_exn"}\n`;
+*)
+          `	bl	{emit_symbol "caml_raise_exn"}\n`;
+(* BACKPORT END *)
           `{record_frame env Reg.Set.empty (Dbg_raise i.dbg)}\n`
         | Lambda.Raise_notrace ->
           `	mov	sp, {emit_reg reg_trap_ptr}\n`;
@@ -1076,6 +1127,7 @@ let fundecl fundecl =
     num_call_gc_and_check_bound_points env
   in
 
+(* BACKPORT
   (* Dynamic stack checking *)
   let stack_threshold_size = Config.stack_threshold * 8 in (* bytes *)
   let { max_frame_size; contains_nontail_calls} =
@@ -1096,9 +1148,12 @@ let fundecl fundecl =
       Some (overflow, ret), 5
     end else None, 0
   in
+*)
 
   let max_out_of_line_code_offset =
+(* BACKPORT
     stack_check_size +
+*)
     max_out_of_line_code_offset ~num_call_gc
       ~num_check_bound
   in
@@ -1111,6 +1166,7 @@ let fundecl fundecl =
   assert (List.length env.call_gc_sites = num_call_gc);
   assert (List.length env.bound_error_sites = num_check_bound);
 
+(* BACKPORT
   begin match handle_overflow with
   | None -> ()
   | Some (overflow,ret) -> begin
@@ -1125,6 +1181,7 @@ let fundecl fundecl =
       `	b	{emit_label ret}\n`
     end
   end;
+*)
 
   cfi_endproc();
   emit_symbol_type emit_symbol fundecl.fun_name "function";
diff --git a/asmcomp/asmlink.ml b/asmcomp/asmlink.ml
index 7021f8c3d1..a10abb9502 100644
--- a/asmcomp/asmlink.ml
+++ b/asmcomp/asmlink.ml
@@ -236,7 +236,11 @@ let make_startup_file ~ppf_dump units_list ~crc_interfaces =
   compile_phrase (Cmm_helpers.entry_point name_list);
   let units = List.map (fun (info,_,_) -> info) units_list in
   List.iter compile_phrase
+(* BACKPORT BEGIN
     (Cmm_helpers.emit_preallocated_blocks [] (* add gc_roots (for dynlink) *)
+*)
+    (
+(* BACKPORT END *)
       (Cmm_helpers.generic_functions false units));
   Array.iteri
     (fun i name -> compile_phrase (Cmm_helpers.predef_exception i name))
@@ -262,7 +266,11 @@ let make_shared_startup_file ~ppf_dump units =
   Compilenv.reset "_shared_startup";
   Emit.begin_assembly ();
   List.iter compile_phrase
+(* BACKPORT BEGIN
     (Cmm_helpers.emit_preallocated_blocks [] (* add gc_roots (for dynlink) *)
+*)
+    (
+(* BACKPORT END *)
       (Cmm_helpers.generic_functions true (List.map fst units)));
   compile_phrase (Cmm_helpers.plugin_header units);
   compile_phrase
diff --git a/asmcomp/cmm_helpers.ml b/asmcomp/cmm_helpers.ml
index ca57632f4a..567dba44cc 100644
--- a/asmcomp/cmm_helpers.ml
+++ b/asmcomp/cmm_helpers.ml
@@ -813,7 +813,11 @@ let make_alloc_generic set_fn dbg tag wordsize args =
     | e1::el -> Csequence(set_fn (Cvar id) (Cconst_int (idx, dbg)) e1 dbg,
                           fill_fields (idx + 2) el) in
     Clet(VP.create id,
+(* BACKPORT BEGIN
          Cop(Cextcall("caml_alloc_shr_check_gc", typ_val, [], true),
+*)
+         Cop(Cextcall("caml_alloc", typ_val, [], true),
+(* BACKPORT END *)
                  [Cconst_int (wordsize, dbg); Cconst_int (tag, dbg)], dbg),
          fill_fields 1 args)
   end
@@ -2113,8 +2117,13 @@ let assignment_kind
     (init: Lambda.initialization_or_assignment) =
   match init, ptr with
   | Assignment, Pointer -> Caml_modify
+(* BACKPORT BEGIN
   | Heap_initialization, Pointer
   | Root_initialization, Pointer -> Caml_initialize
+*)
+  | Heap_initialization, Pointer -> Caml_initialize
+  | Root_initialization, Pointer -> Simple
+(* BACKPORT END *)
   | Assignment, Immediate
   | Heap_initialization, Immediate
   | Root_initialization, Immediate -> Simple
diff --git a/asmcomp/riscv/emit.mlp b/asmcomp/riscv/emit.mlp
index bcc9d12947..5252fa4473 100644
--- a/asmcomp/riscv/emit.mlp
+++ b/asmcomp/riscv/emit.mlp
@@ -343,8 +343,10 @@ let emit_instr env i =
         `	mv	s0, sp\n`;
         cfi_remember_state ();
         cfi_def_cfa_register ~reg:21;
+(* BACKPORT
         let ofs = Domainstate.(idx_of_field Domain_c_stack) * 8 in
         `	ld	sp, {emit_int ofs}({emit_reg reg_domain_state_ptr})\n`;
+*)
         `	{emit_call func}\n`;
         `	mv	sp, s0\n`;
         cfi_restore_state ()
@@ -500,8 +502,12 @@ let emit_instr env i =
       let instr = name_for_specific sop in
       `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(2)}\n`
   | Lop (Idls_get) ->
+(* BACKPORT BEGIN
       let ofs = Domainstate.(idx_of_field Domain_dls_root) * 8 in
       `	ld	{emit_reg i.res.(0)}, {emit_int ofs}({emit_reg reg_domain_state_ptr})\n`
+*)
+      assert false
+(* BACKPORT END *)
   | Lreloadretaddr ->
       let n = frame_size env in
       reload_ra n
@@ -623,6 +629,7 @@ let fundecl fundecl =
   emit_debug_info fundecl.fun_dbg;
   cfi_startproc();
 
+(* BACKPORT
   (* Dynamic stack checking *)
   let stack_threshold_size = Config.stack_threshold * 8 in (* bytes *)
   let { max_frame_size; contains_nontail_calls } =
@@ -642,11 +649,13 @@ let fundecl fundecl =
       Some (overflow, ret)
     end else None
   in
+*)
 
   emit_all env fundecl.fun_body;
   List.iter emit_call_gc env.call_gc_sites;
   List.iter emit_call_bound_error env.bound_error_sites;
 
+(* BACKPORT
   begin match handle_overflow with
   | None -> ()
   | Some (overflow, ret) ->
@@ -663,6 +672,7 @@ let fundecl fundecl =
       `	addi	sp, sp, 16\n`;
       `	j	{emit_label ret}\n`
   end;
+*)
 
   cfi_endproc();
   `	.size	{emit_symbol fundecl.fun_name}, .-{emit_symbol fundecl.fun_name}\n`;
diff --git a/boot/ocamlc b/boot/ocamlc
index 941a1d3bb4..a6a755d449 100755
Binary files a/boot/ocamlc and b/boot/ocamlc differ
diff --git a/boot/ocamllex b/boot/ocamllex
index d247b24d65..5262c62a0a 100755
Binary files a/boot/ocamllex and b/boot/ocamllex differ
diff --git a/build-aux/config.guess b/build-aux/config.guess
index e94095c5fb..b187213930 100755
--- a/build-aux/config.guess
+++ b/build-aux/config.guess
@@ -1,12 +1,14 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright 1992-2020 Free Software Foundation, Inc.
+#   Copyright 1992-2023 Free Software Foundation, Inc.
 
-timestamp='2020-07-12'
+# shellcheck disable=SC2006,SC2268 # see below for rationale
+
+timestamp='2023-07-20'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3 of the License, or
+# the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
@@ -27,17 +29,25 @@ timestamp='2020-07-12'
 # Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
 #
 # You can get the latest version of this script from:
-# https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
+# https://git.savannah.gnu.org/cgit/config.git/plain/config.guess
 #
 # Please send patches to <config-patches@gnu.org>.
 
 
+# The "shellcheck disable" line above the timestamp inhibits complaints
+# about features and limitations of the classic Bourne shell that were
+# superseded or lifted in POSIX.  However, this script identifies a wide
+# variety of pre-POSIX systems that do not have POSIX shells at all, and
+# even some reasonably current systems (Solaris 10 as case-in-point) still
+# have a pre-POSIX /bin/sh.
+
+
 me=`echo "$0" | sed -e 's,.*/,,'`
 
 usage="\
 Usage: $0 [OPTION]
 
-Output the configuration name of the system \`$me' is run on.
+Output the configuration name of the system '$me' is run on.
 
 Options:
   -h, --help         print this help, then exit
@@ -50,13 +60,13 @@ version="\
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright 1992-2020 Free Software Foundation, Inc.
+Copyright 1992-2023 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
-Try \`$me --help' for more information."
+Try '$me --help' for more information."
 
 # Parse command line
 while test $# -gt 0 ; do
@@ -84,13 +94,16 @@ if test $# != 0; then
   exit 1
 fi
 
+# Just in case it came from the environment.
+GUESS=
+
 # CC_FOR_BUILD -- compiler used by this script. Note that the use of a
 # compiler to aid in system detection is discouraged as it requires
 # temporary files to be created and, as you can see below, it is a
 # headache to deal with in a portable fashion.
 
-# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
-# use `HOST_CC' if defined, but it is deprecated.
+# Historically, 'CC_FOR_BUILD' used to be named 'HOST_CC'. We still
+# use 'HOST_CC' if defined, but it is deprecated.
 
 # Portable tmp directory creation inspired by the Autoconf team.
 
@@ -102,7 +115,7 @@ set_cc_for_build() {
     # prevent multiple calls if $tmp is already set
     test "$tmp" && return 0
     : "${TMPDIR=/tmp}"
-    # shellcheck disable=SC2039
+    # shellcheck disable=SC2039,SC3028
     { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
 	{ test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir "$tmp" 2>/dev/null) ; } ||
 	{ tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir "$tmp" 2>/dev/null) && echo "Warning: creating insecure temp directory" >&2 ; } ||
@@ -112,7 +125,7 @@ set_cc_for_build() {
 	,,)    echo "int x;" > "$dummy.c"
 	       for driver in cc gcc c89 c99 ; do
 		   if ($driver -c -o "$dummy.o" "$dummy.c") >/dev/null 2>&1 ; then
-		       CC_FOR_BUILD="$driver"
+		       CC_FOR_BUILD=$driver
 		       break
 		   fi
 	       done
@@ -133,14 +146,12 @@ fi
 
 UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
 UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
-UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
-case "$UNAME_SYSTEM" in
+case $UNAME_SYSTEM in
 Linux|GNU|GNU/*)
-	# If the system lacks a compiler, then just pick glibc.
-	# We could probably try harder.
-	LIBC=gnu
+	LIBC=unknown
 
 	set_cc_for_build
 	cat <<-EOF > "$dummy.c"
@@ -149,24 +160,37 @@ Linux|GNU|GNU/*)
 	LIBC=uclibc
 	#elif defined(__dietlibc__)
 	LIBC=dietlibc
-	#else
+	#elif defined(__GLIBC__)
 	LIBC=gnu
+	#else
+	#include <stdarg.h>
+	/* First heuristic to detect musl libc.  */
+	#ifdef __DEFINED_va_list
+	LIBC=musl
+	#endif
 	#endif
 	EOF
-	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`"
+	cc_set_libc=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
+	eval "$cc_set_libc"
 
-	# If ldd exists, use it to detect musl libc.
-	if command -v ldd >/dev/null && \
-		ldd --version 2>&1 | grep -q ^musl
-	then
-	    LIBC=musl
+	# Second heuristic to detect musl libc.
+	if [ "$LIBC" = unknown ] &&
+	   command -v ldd >/dev/null &&
+	   ldd --version 2>&1 | grep -q ^musl; then
+		LIBC=musl
+	fi
+
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	if [ "$LIBC" = unknown ]; then
+		LIBC=gnu
 	fi
 	;;
 esac
 
 # Note: order is significant - the case branches are not exclusive.
 
-case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
+case $UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION in
     *:NetBSD:*:*)
 	# NetBSD (nbsd) targets should (where applicable) match one or
 	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
@@ -178,12 +202,12 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	#
 	# Note: NetBSD doesn't particularly care about the vendor
 	# portion of the name.  We always set it to "unknown".
-	sysctl="sysctl -n hw.machine_arch"
 	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
-	    "/sbin/$sysctl" 2>/dev/null || \
-	    "/usr/sbin/$sysctl" 2>/dev/null || \
+	    /sbin/sysctl -n hw.machine_arch 2>/dev/null || \
+	    /usr/sbin/sysctl -n hw.machine_arch 2>/dev/null || \
 	    echo unknown)`
-	case "$UNAME_MACHINE_ARCH" in
+	case $UNAME_MACHINE_ARCH in
+	    aarch64eb) machine=aarch64_be-unknown ;;
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
@@ -192,13 +216,13 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	    earmv*)
 		arch=`echo "$UNAME_MACHINE_ARCH" | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
 		endian=`echo "$UNAME_MACHINE_ARCH" | sed -ne 's,^.*\(eb\)$,\1,p'`
-		machine="${arch}${endian}"-unknown
+		machine=${arch}${endian}-unknown
 		;;
-	    *) machine="$UNAME_MACHINE_ARCH"-unknown ;;
+	    *) machine=$UNAME_MACHINE_ARCH-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
 	# to ELF recently (or will in the future) and ABI.
-	case "$UNAME_MACHINE_ARCH" in
+	case $UNAME_MACHINE_ARCH in
 	    earm*)
 		os=netbsdelf
 		;;
@@ -219,7 +243,7 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 		;;
 	esac
 	# Determine ABI tags.
-	case "$UNAME_MACHINE_ARCH" in
+	case $UNAME_MACHINE_ARCH in
 	    earm*)
 		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
 		abi=`echo "$UNAME_MACHINE_ARCH" | sed -e "$expr"`
@@ -230,7 +254,7 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	# thus, need a distinct triplet. However, they do not need
 	# kernel version information, so it can be replaced with a
 	# suitable tag, in the style of linux-gnu.
-	case "$UNAME_VERSION" in
+	case $UNAME_VERSION in
 	    Debian*)
 		release='-gnu'
 		;;
@@ -241,51 +265,57 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "$machine-${os}${release}${abi-}"
-	exit ;;
+	GUESS=$machine-${os}${release}${abi-}
+	;;
     *:Bitrig:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
-	echo "$UNAME_MACHINE_ARCH"-unknown-bitrig"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE_ARCH-unknown-bitrig$UNAME_RELEASE
+	;;
     *:OpenBSD:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
-	echo "$UNAME_MACHINE_ARCH"-unknown-openbsd"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE_ARCH-unknown-openbsd$UNAME_RELEASE
+	;;
+    *:SecBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/SecBSD.//'`
+	GUESS=$UNAME_MACHINE_ARCH-unknown-secbsd$UNAME_RELEASE
+	;;
     *:LibertyBSD:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
-	echo "$UNAME_MACHINE_ARCH"-unknown-libertybsd"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE_ARCH-unknown-libertybsd$UNAME_RELEASE
+	;;
     *:MidnightBSD:*:*)
-	echo "$UNAME_MACHINE"-unknown-midnightbsd"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-midnightbsd$UNAME_RELEASE
+	;;
     *:ekkoBSD:*:*)
-	echo "$UNAME_MACHINE"-unknown-ekkobsd"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-ekkobsd$UNAME_RELEASE
+	;;
     *:SolidBSD:*:*)
-	echo "$UNAME_MACHINE"-unknown-solidbsd"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-solidbsd$UNAME_RELEASE
+	;;
     *:OS108:*:*)
-	echo "$UNAME_MACHINE"-unknown-os108_"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-os108_$UNAME_RELEASE
+	;;
     macppc:MirBSD:*:*)
-	echo powerpc-unknown-mirbsd"$UNAME_RELEASE"
-	exit ;;
+	GUESS=powerpc-unknown-mirbsd$UNAME_RELEASE
+	;;
     *:MirBSD:*:*)
-	echo "$UNAME_MACHINE"-unknown-mirbsd"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-mirbsd$UNAME_RELEASE
+	;;
     *:Sortix:*:*)
-	echo "$UNAME_MACHINE"-unknown-sortix
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-sortix
+	;;
     *:Twizzler:*:*)
-	echo "$UNAME_MACHINE"-unknown-twizzler
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-twizzler
+	;;
     *:Redox:*:*)
-	echo "$UNAME_MACHINE"-unknown-redox
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-redox
+	;;
     mips:OSF1:*.*)
-	echo mips-dec-osf1
-	exit ;;
+	GUESS=mips-dec-osf1
+	;;
     alpha:OSF1:*:*)
+	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
+	trap '' 0
 	case $UNAME_RELEASE in
 	*4.0)
 		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
@@ -299,7 +329,7 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	# covers most systems running today.  This code pipes the CPU
 	# types through head -n 1, so we only detect the type of CPU 0.
 	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
-	case "$ALPHA_CPU_TYPE" in
+	case $ALPHA_CPU_TYPE in
 	    "EV4 (21064)")
 		UNAME_MACHINE=alpha ;;
 	    "EV4.5 (21064)")
@@ -336,117 +366,121 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo "$UNAME_MACHINE"-dec-osf"`echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`"
-	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
-	exitcode=$?
-	trap '' 0
-	exit $exitcode ;;
+	OSF_REL=`echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	GUESS=$UNAME_MACHINE-dec-osf$OSF_REL
+	;;
     Amiga*:UNIX_System_V:4.0:*)
-	echo m68k-unknown-sysv4
-	exit ;;
+	GUESS=m68k-unknown-sysv4
+	;;
     *:[Aa]miga[Oo][Ss]:*:*)
-	echo "$UNAME_MACHINE"-unknown-amigaos
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-amigaos
+	;;
     *:[Mm]orph[Oo][Ss]:*:*)
-	echo "$UNAME_MACHINE"-unknown-morphos
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-morphos
+	;;
     *:OS/390:*:*)
-	echo i370-ibm-openedition
-	exit ;;
+	GUESS=i370-ibm-openedition
+	;;
     *:z/VM:*:*)
-	echo s390-ibm-zvmoe
-	exit ;;
+	GUESS=s390-ibm-zvmoe
+	;;
     *:OS400:*:*)
-	echo powerpc-ibm-os400
-	exit ;;
+	GUESS=powerpc-ibm-os400
+	;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
-	echo arm-acorn-riscix"$UNAME_RELEASE"
-	exit ;;
+	GUESS=arm-acorn-riscix$UNAME_RELEASE
+	;;
     arm*:riscos:*:*|arm*:RISCOS:*:*)
-	echo arm-unknown-riscos
-	exit ;;
+	GUESS=arm-unknown-riscos
+	;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
-	echo hppa1.1-hitachi-hiuxmpp
-	exit ;;
+	GUESS=hppa1.1-hitachi-hiuxmpp
+	;;
     Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
 	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
-	if test "`(/bin/universe) 2>/dev/null`" = att ; then
-		echo pyramid-pyramid-sysv3
-	else
-		echo pyramid-pyramid-bsd
-	fi
-	exit ;;
+	case `(/bin/universe) 2>/dev/null` in
+	    att) GUESS=pyramid-pyramid-sysv3 ;;
+	    *)   GUESS=pyramid-pyramid-bsd   ;;
+	esac
+	;;
     NILE*:*:*:dcosx)
-	echo pyramid-pyramid-svr4
-	exit ;;
+	GUESS=pyramid-pyramid-svr4
+	;;
     DRS?6000:unix:4.0:6*)
-	echo sparc-icl-nx6
-	exit ;;
+	GUESS=sparc-icl-nx6
+	;;
     DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
 	case `/usr/bin/uname -p` in
-	    sparc) echo sparc-icl-nx7; exit ;;
-	esac ;;
+	    sparc) GUESS=sparc-icl-nx7 ;;
+	esac
+	;;
     s390x:SunOS:*:*)
-	echo "$UNAME_MACHINE"-ibm-solaris2"`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`"
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=$UNAME_MACHINE-ibm-solaris2$SUN_REL
+	;;
     sun4H:SunOS:5.*:*)
-	echo sparc-hal-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=sparc-hal-solaris2$SUN_REL
+	;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
-	echo sparc-sun-solaris2"`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`"
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=sparc-sun-solaris2$SUN_REL
+	;;
     i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
-	echo i386-pc-auroraux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=i386-pc-auroraux$UNAME_RELEASE
+	;;
     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
 	set_cc_for_build
 	SUN_ARCH=i386
 	# If there is a compiler, see if it is configured for 64-bit objects.
 	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
 	# This test works for both compilers.
-	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
 	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
-		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		(CCOPTS="" $CC_FOR_BUILD -m64 -E - 2>/dev/null) | \
 		grep IS_64BIT_ARCH >/dev/null
 	    then
 		SUN_ARCH=x86_64
 	    fi
 	fi
-	echo "$SUN_ARCH"-pc-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=$SUN_ARCH-pc-solaris2$SUN_REL
+	;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
 	# it's likely to be more like Solaris than SunOS4.
-	echo sparc-sun-solaris3"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=sparc-sun-solaris3$SUN_REL
+	;;
     sun4*:SunOS:*:*)
-	case "`/usr/bin/arch -k`" in
+	case `/usr/bin/arch -k` in
 	    Series*|S4*)
 		UNAME_RELEASE=`uname -v`
 		;;
 	esac
-	# Japanese Language versions have a version number like `4.1.3-JL'.
-	echo sparc-sun-sunos"`echo "$UNAME_RELEASE"|sed -e 's/-/_/'`"
-	exit ;;
+	# Japanese Language versions have a version number like '4.1.3-JL'.
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/-/_/'`
+	GUESS=sparc-sun-sunos$SUN_REL
+	;;
     sun3*:SunOS:*:*)
-	echo m68k-sun-sunos"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-sun-sunos$UNAME_RELEASE
+	;;
     sun*:*:4.2BSD:*)
 	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
 	test "x$UNAME_RELEASE" = x && UNAME_RELEASE=3
-	case "`/bin/arch`" in
+	case `/bin/arch` in
 	    sun3)
-		echo m68k-sun-sunos"$UNAME_RELEASE"
+		GUESS=m68k-sun-sunos$UNAME_RELEASE
 		;;
 	    sun4)
-		echo sparc-sun-sunos"$UNAME_RELEASE"
+		GUESS=sparc-sun-sunos$UNAME_RELEASE
 		;;
 	esac
-	exit ;;
+	;;
     aushp:SunOS:*:*)
-	echo sparc-auspex-sunos"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sparc-auspex-sunos$UNAME_RELEASE
+	;;
     # The situation for MiNT is a little confusing.  The machine name
     # can be virtually everything (everything which is not
     # "atarist" or "atariste" at least should have a processor
@@ -456,41 +490,41 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-atari-mint$UNAME_RELEASE
+	;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-atari-mint$UNAME_RELEASE
+	;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-	echo m68k-atari-mint"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-atari-mint$UNAME_RELEASE
+	;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-	echo m68k-milan-mint"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-milan-mint$UNAME_RELEASE
+	;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-	echo m68k-hades-mint"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-hades-mint$UNAME_RELEASE
+	;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-	echo m68k-unknown-mint"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-unknown-mint$UNAME_RELEASE
+	;;
     m68k:machten:*:*)
-	echo m68k-apple-machten"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-apple-machten$UNAME_RELEASE
+	;;
     powerpc:machten:*:*)
-	echo powerpc-apple-machten"$UNAME_RELEASE"
-	exit ;;
+	GUESS=powerpc-apple-machten$UNAME_RELEASE
+	;;
     RISC*:Mach:*:*)
-	echo mips-dec-mach_bsd4.3
-	exit ;;
+	GUESS=mips-dec-mach_bsd4.3
+	;;
     RISC*:ULTRIX:*:*)
-	echo mips-dec-ultrix"$UNAME_RELEASE"
-	exit ;;
+	GUESS=mips-dec-ultrix$UNAME_RELEASE
+	;;
     VAX*:ULTRIX*:*:*)
-	echo vax-dec-ultrix"$UNAME_RELEASE"
-	exit ;;
+	GUESS=vax-dec-ultrix$UNAME_RELEASE
+	;;
     2020:CLIX:*:* | 2430:CLIX:*:*)
-	echo clipper-intergraph-clix"$UNAME_RELEASE"
-	exit ;;
+	GUESS=clipper-intergraph-clix$UNAME_RELEASE
+	;;
     mips:*:*:UMIPS | mips:*:*:RISCos)
 	set_cc_for_build
 	sed 's/^	//' << EOF > "$dummy.c"
@@ -518,75 +552,76 @@ EOF
 	  dummyarg=`echo "$UNAME_RELEASE" | sed -n 's/\([0-9]*\).*/\1/p'` &&
 	  SYSTEM_NAME=`"$dummy" "$dummyarg"` &&
 	    { echo "$SYSTEM_NAME"; exit; }
-	echo mips-mips-riscos"$UNAME_RELEASE"
-	exit ;;
+	GUESS=mips-mips-riscos$UNAME_RELEASE
+	;;
     Motorola:PowerMAX_OS:*:*)
-	echo powerpc-motorola-powermax
-	exit ;;
+	GUESS=powerpc-motorola-powermax
+	;;
     Motorola:*:4.3:PL8-*)
-	echo powerpc-harris-powermax
-	exit ;;
+	GUESS=powerpc-harris-powermax
+	;;
     Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
-	echo powerpc-harris-powermax
-	exit ;;
+	GUESS=powerpc-harris-powermax
+	;;
     Night_Hawk:Power_UNIX:*:*)
-	echo powerpc-harris-powerunix
-	exit ;;
+	GUESS=powerpc-harris-powerunix
+	;;
     m88k:CX/UX:7*:*)
-	echo m88k-harris-cxux7
-	exit ;;
+	GUESS=m88k-harris-cxux7
+	;;
     m88k:*:4*:R4*)
-	echo m88k-motorola-sysv4
-	exit ;;
+	GUESS=m88k-motorola-sysv4
+	;;
     m88k:*:3*:R3*)
-	echo m88k-motorola-sysv3
-	exit ;;
+	GUESS=m88k-motorola-sysv3
+	;;
     AViiON:dgux:*:*)
 	# DG/UX returns AViiON for all architectures
 	UNAME_PROCESSOR=`/usr/bin/uname -p`
-	if [ "$UNAME_PROCESSOR" = mc88100 ] || [ "$UNAME_PROCESSOR" = mc88110 ]
+	if test "$UNAME_PROCESSOR" = mc88100 || test "$UNAME_PROCESSOR" = mc88110
 	then
-	    if [ "$TARGET_BINARY_INTERFACE"x = m88kdguxelfx ] || \
-	       [ "$TARGET_BINARY_INTERFACE"x = x ]
+	    if test "$TARGET_BINARY_INTERFACE"x = m88kdguxelfx || \
+	       test "$TARGET_BINARY_INTERFACE"x = x
 	    then
-		echo m88k-dg-dgux"$UNAME_RELEASE"
+		GUESS=m88k-dg-dgux$UNAME_RELEASE
 	    else
-		echo m88k-dg-dguxbcs"$UNAME_RELEASE"
+		GUESS=m88k-dg-dguxbcs$UNAME_RELEASE
 	    fi
 	else
-	    echo i586-dg-dgux"$UNAME_RELEASE"
+	    GUESS=i586-dg-dgux$UNAME_RELEASE
 	fi
-	exit ;;
+	;;
     M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
-	echo m88k-dolphin-sysv3
-	exit ;;
+	GUESS=m88k-dolphin-sysv3
+	;;
     M88*:*:R3*:*)
 	# Delta 88k system running SVR3
-	echo m88k-motorola-sysv3
-	exit ;;
+	GUESS=m88k-motorola-sysv3
+	;;
     XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
-	echo m88k-tektronix-sysv3
-	exit ;;
+	GUESS=m88k-tektronix-sysv3
+	;;
     Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
-	echo m68k-tektronix-bsd
-	exit ;;
+	GUESS=m68k-tektronix-bsd
+	;;
     *:IRIX*:*:*)
-	echo mips-sgi-irix"`echo "$UNAME_RELEASE"|sed -e 's/-/_/g'`"
-	exit ;;
+	IRIX_REL=`echo "$UNAME_RELEASE" | sed -e 's/-/_/g'`
+	GUESS=mips-sgi-irix$IRIX_REL
+	;;
     ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
-	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
-	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
+	GUESS=romp-ibm-aix    # uname -m gives an 8 hex-code CPU id
+	;;                    # Note that: echo "'`uname -s`'" gives 'AIX '
     i*86:AIX:*:*)
-	echo i386-ibm-aix
-	exit ;;
+	GUESS=i386-ibm-aix
+	;;
     ia64:AIX:*:*)
-	if [ -x /usr/bin/oslevel ] ; then
+	if test -x /usr/bin/oslevel ; then
 		IBM_REV=`/usr/bin/oslevel`
 	else
-		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
+		IBM_REV=$UNAME_VERSION.$UNAME_RELEASE
 	fi
-	echo "$UNAME_MACHINE"-ibm-aix"$IBM_REV"
-	exit ;;
+	GUESS=$UNAME_MACHINE-ibm-aix$IBM_REV
+	;;
     *:AIX:2:3)
 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
 		set_cc_for_build
@@ -603,16 +638,16 @@ EOF
 EOF
 		if $CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"`
 		then
-			echo "$SYSTEM_NAME"
+			GUESS=$SYSTEM_NAME
 		else
-			echo rs6000-ibm-aix3.2.5
+			GUESS=rs6000-ibm-aix3.2.5
 		fi
 	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
-		echo rs6000-ibm-aix3.2.4
+		GUESS=rs6000-ibm-aix3.2.4
 	else
-		echo rs6000-ibm-aix3.2
+		GUESS=rs6000-ibm-aix3.2
 	fi
-	exit ;;
+	;;
     *:AIX:*:[4567])
 	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
 	if /usr/sbin/lsattr -El "$IBM_CPU_ID" | grep ' POWER' >/dev/null 2>&1; then
@@ -620,56 +655,56 @@ EOF
 	else
 		IBM_ARCH=powerpc
 	fi
-	if [ -x /usr/bin/lslpp ] ; then
-		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
+	if test -x /usr/bin/lslpp ; then
+		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc | \
 			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
 	else
-		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
+		IBM_REV=$UNAME_VERSION.$UNAME_RELEASE
 	fi
-	echo "$IBM_ARCH"-ibm-aix"$IBM_REV"
-	exit ;;
+	GUESS=$IBM_ARCH-ibm-aix$IBM_REV
+	;;
     *:AIX:*:*)
-	echo rs6000-ibm-aix
-	exit ;;
+	GUESS=rs6000-ibm-aix
+	;;
     ibmrt:4.4BSD:*|romp-ibm:4.4BSD:*)
-	echo romp-ibm-bsd4.4
-	exit ;;
+	GUESS=romp-ibm-bsd4.4
+	;;
     ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
-	echo romp-ibm-bsd"$UNAME_RELEASE"   # 4.3 with uname added to
-	exit ;;                             # report: romp-ibm BSD 4.3
+	GUESS=romp-ibm-bsd$UNAME_RELEASE    # 4.3 with uname added to
+	;;                                  # report: romp-ibm BSD 4.3
     *:BOSX:*:*)
-	echo rs6000-bull-bosx
-	exit ;;
+	GUESS=rs6000-bull-bosx
+	;;
     DPX/2?00:B.O.S.:*:*)
-	echo m68k-bull-sysv3
-	exit ;;
+	GUESS=m68k-bull-sysv3
+	;;
     9000/[34]??:4.3bsd:1.*:*)
-	echo m68k-hp-bsd
-	exit ;;
+	GUESS=m68k-hp-bsd
+	;;
     hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
-	echo m68k-hp-bsd4.4
-	exit ;;
+	GUESS=m68k-hp-bsd4.4
+	;;
     9000/[34678]??:HP-UX:*:*)
-	HPUX_REV=`echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//'`
-	case "$UNAME_MACHINE" in
+	HPUX_REV=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*.[0B]*//'`
+	case $UNAME_MACHINE in
 	    9000/31?)            HP_ARCH=m68000 ;;
 	    9000/[34]??)         HP_ARCH=m68k ;;
 	    9000/[678][0-9][0-9])
-		if [ -x /usr/bin/getconf ]; then
+		if test -x /usr/bin/getconf; then
 		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
 		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
-		    case "$sc_cpu_version" in
+		    case $sc_cpu_version in
 		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
 		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
 		      532)                      # CPU_PA_RISC2_0
-			case "$sc_kernel_bits" in
+			case $sc_kernel_bits in
 			  32) HP_ARCH=hppa2.0n ;;
 			  64) HP_ARCH=hppa2.0w ;;
 			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
 			esac ;;
 		    esac
 		fi
-		if [ "$HP_ARCH" = "" ]; then
+		if test "$HP_ARCH" = ""; then
 		    set_cc_for_build
 		    sed 's/^		//' << EOF > "$dummy.c"
 
@@ -708,7 +743,7 @@ EOF
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
-	if [ "$HP_ARCH" = hppa2.0w ]
+	if test "$HP_ARCH" = hppa2.0w
 	then
 	    set_cc_for_build
 
@@ -729,12 +764,12 @@ EOF
 		HP_ARCH=hppa64
 	    fi
 	fi
-	echo "$HP_ARCH"-hp-hpux"$HPUX_REV"
-	exit ;;
+	GUESS=$HP_ARCH-hp-hpux$HPUX_REV
+	;;
     ia64:HP-UX:*:*)
-	HPUX_REV=`echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//'`
-	echo ia64-hp-hpux"$HPUX_REV"
-	exit ;;
+	HPUX_REV=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*.[0B]*//'`
+	GUESS=ia64-hp-hpux$HPUX_REV
+	;;
     3050*:HI-UX:*:*)
 	set_cc_for_build
 	sed 's/^	//' << EOF > "$dummy.c"
@@ -764,36 +799,36 @@ EOF
 EOF
 	$CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"` &&
 		{ echo "$SYSTEM_NAME"; exit; }
-	echo unknown-hitachi-hiuxwe2
-	exit ;;
+	GUESS=unknown-hitachi-hiuxwe2
+	;;
     9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:*)
-	echo hppa1.1-hp-bsd
-	exit ;;
+	GUESS=hppa1.1-hp-bsd
+	;;
     9000/8??:4.3bsd:*:*)
-	echo hppa1.0-hp-bsd
-	exit ;;
+	GUESS=hppa1.0-hp-bsd
+	;;
     *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
-	echo hppa1.0-hp-mpeix
-	exit ;;
+	GUESS=hppa1.0-hp-mpeix
+	;;
     hp7??:OSF1:*:* | hp8?[79]:OSF1:*:*)
-	echo hppa1.1-hp-osf
-	exit ;;
+	GUESS=hppa1.1-hp-osf
+	;;
     hp8??:OSF1:*:*)
-	echo hppa1.0-hp-osf
-	exit ;;
+	GUESS=hppa1.0-hp-osf
+	;;
     i*86:OSF1:*:*)
-	if [ -x /usr/sbin/sysversion ] ; then
-	    echo "$UNAME_MACHINE"-unknown-osf1mk
+	if test -x /usr/sbin/sysversion ; then
+	    GUESS=$UNAME_MACHINE-unknown-osf1mk
 	else
-	    echo "$UNAME_MACHINE"-unknown-osf1
+	    GUESS=$UNAME_MACHINE-unknown-osf1
 	fi
-	exit ;;
+	;;
     parisc*:Lites*:*:*)
-	echo hppa1.1-hp-lites
-	exit ;;
+	GUESS=hppa1.1-hp-lites
+	;;
     C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
-	echo c1-convex-bsd
-	exit ;;
+	GUESS=c1-convex-bsd
+	;;
     C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
@@ -801,17 +836,18 @@ EOF
 	fi
 	exit ;;
     C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
-	echo c34-convex-bsd
-	exit ;;
+	GUESS=c34-convex-bsd
+	;;
     C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
-	echo c38-convex-bsd
-	exit ;;
+	GUESS=c38-convex-bsd
+	;;
     C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
-	echo c4-convex-bsd
-	exit ;;
+	GUESS=c4-convex-bsd
+	;;
     CRAY*Y-MP:*:*:*)
-	echo ymp-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=ymp-cray-unicos$CRAY_REL
+	;;
     CRAY*[A-Z]90:*:*:*)
 	echo "$UNAME_MACHINE"-cray-unicos"$UNAME_RELEASE" \
 	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
@@ -819,112 +855,153 @@ EOF
 	      -e 's/\.[^.]*$/.X/'
 	exit ;;
     CRAY*TS:*:*:*)
-	echo t90-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=t90-cray-unicos$CRAY_REL
+	;;
     CRAY*T3E:*:*:*)
-	echo alphaev5-cray-unicosmk"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=alphaev5-cray-unicosmk$CRAY_REL
+	;;
     CRAY*SV1:*:*:*)
-	echo sv1-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=sv1-cray-unicos$CRAY_REL
+	;;
     *:UNICOS/mp:*:*)
-	echo craynv-cray-unicosmp"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
-	exit ;;
+	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
+	GUESS=craynv-cray-unicosmp$CRAY_REL
+	;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
 	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
 	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
 	FUJITSU_REL=`echo "$UNAME_RELEASE" | sed -e 's/ /_/'`
-	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-	exit ;;
+	GUESS=${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}
+	;;
     5000:UNIX_System_V:4.*:*)
 	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
 	FUJITSU_REL=`echo "$UNAME_RELEASE" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
-	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-	exit ;;
+	GUESS=sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}
+	;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
-	echo "$UNAME_MACHINE"-pc-bsdi"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-bsdi$UNAME_RELEASE
+	;;
     sparc*:BSD/OS:*:*)
-	echo sparc-unknown-bsdi"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sparc-unknown-bsdi$UNAME_RELEASE
+	;;
     *:BSD/OS:*:*)
-	echo "$UNAME_MACHINE"-unknown-bsdi"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-bsdi$UNAME_RELEASE
+	;;
     arm:FreeBSD:*:*)
 	UNAME_PROCESSOR=`uname -p`
 	set_cc_for_build
 	if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_PCS_VFP
 	then
-	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`"-gnueabi
+	    FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabi
 	else
-	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`"-gnueabihf
+	    FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabihf
 	fi
-	exit ;;
+	;;
     *:FreeBSD:*:*)
 	UNAME_PROCESSOR=`/usr/bin/uname -p`
-	case "$UNAME_PROCESSOR" in
+	case $UNAME_PROCESSOR in
 	    amd64)
 		UNAME_PROCESSOR=x86_64 ;;
 	    i386)
 		UNAME_PROCESSOR=i586 ;;
 	esac
-	echo "$UNAME_PROCESSOR"-unknown-freebsd"`echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`"
-	exit ;;
+	FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL
+	;;
     i*:CYGWIN*:*)
-	echo "$UNAME_MACHINE"-pc-cygwin
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-cygwin
+	;;
     *:MINGW64*:*)
-	echo "$UNAME_MACHINE"-pc-mingw64
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-mingw64
+	;;
     *:MINGW*:*)
-	echo "$UNAME_MACHINE"-pc-mingw32
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-mingw32
+	;;
     *:MSYS*:*)
-	echo "$UNAME_MACHINE"-pc-msys
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-msys
+	;;
     i*:PW*:*)
-	echo "$UNAME_MACHINE"-pc-pw32
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-pw32
+	;;
+    *:SerenityOS:*:*)
+        GUESS=$UNAME_MACHINE-pc-serenity
+        ;;
     *:Interix*:*)
-	case "$UNAME_MACHINE" in
+	case $UNAME_MACHINE in
 	    x86)
-		echo i586-pc-interix"$UNAME_RELEASE"
-		exit ;;
+		GUESS=i586-pc-interix$UNAME_RELEASE
+		;;
 	    authenticamd | genuineintel | EM64T)
-		echo x86_64-unknown-interix"$UNAME_RELEASE"
-		exit ;;
+		GUESS=x86_64-unknown-interix$UNAME_RELEASE
+		;;
 	    IA64)
-		echo ia64-unknown-interix"$UNAME_RELEASE"
-		exit ;;
+		GUESS=ia64-unknown-interix$UNAME_RELEASE
+		;;
 	esac ;;
     i*:UWIN*:*)
-	echo "$UNAME_MACHINE"-pc-uwin
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-uwin
+	;;
     amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
-	echo x86_64-pc-cygwin
-	exit ;;
+	GUESS=x86_64-pc-cygwin
+	;;
     prep*:SunOS:5.*:*)
-	echo powerpcle-unknown-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
-	exit ;;
+	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
+	GUESS=powerpcle-unknown-solaris2$SUN_REL
+	;;
     *:GNU:*:*)
 	# the GNU system
-	echo "`echo "$UNAME_MACHINE"|sed -e 's,[-/].*$,,'`-unknown-$LIBC`echo "$UNAME_RELEASE"|sed -e 's,/.*$,,'`"
-	exit ;;
+	GNU_ARCH=`echo "$UNAME_MACHINE" | sed -e 's,[-/].*$,,'`
+	GNU_REL=`echo "$UNAME_RELEASE" | sed -e 's,/.*$,,'`
+	GUESS=$GNU_ARCH-unknown-$LIBC$GNU_REL
+	;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo "$UNAME_MACHINE-unknown-`echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"``echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`-$LIBC"
-	exit ;;
+	GNU_SYS=`echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"`
+	GNU_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	GUESS=$UNAME_MACHINE-unknown-$GNU_SYS$GNU_REL-$LIBC
+	;;
+    x86_64:[Mm]anagarm:*:*|i?86:[Mm]anagarm:*:*)
+	GUESS="$UNAME_MACHINE-pc-managarm-mlibc"
+	;;
+    *:[Mm]anagarm:*:*)
+	GUESS="$UNAME_MACHINE-unknown-managarm-mlibc"
+	;;
     *:Minix:*:*)
-	echo "$UNAME_MACHINE"-unknown-minix
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-minix
+	;;
     aarch64:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	set_cc_for_build
+	CPU=$UNAME_MACHINE
+	LIBCABI=$LIBC
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
+	    ABI=64
+	    sed 's/^	    //' << EOF > "$dummy.c"
+	    #ifdef __ARM_EABI__
+	    #ifdef __ARM_PCS_VFP
+	    ABI=eabihf
+	    #else
+	    ABI=eabi
+	    #endif
+	    #endif
+EOF
+	    cc_set_abi=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^ABI' | sed 's, ,,g'`
+	    eval "$cc_set_abi"
+	    case $ABI in
+		eabi | eabihf) CPU=armv8l; LIBCABI=$LIBC$ABI ;;
+	    esac
+	fi
+	GUESS=$CPU-unknown-linux-$LIBCABI
+	;;
     aarch64_be:Linux:*:*)
 	UNAME_MACHINE=aarch64_be
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     alpha:Linux:*:*)
 	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' /proc/cpuinfo 2>/dev/null` in
 	  EV5)   UNAME_MACHINE=alphaev5 ;;
@@ -937,60 +1014,72 @@ EOF
 	esac
 	objdump --private-headers /bin/sh | grep -q ld.so.1
 	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
-    arc:Linux:*:* | arceb:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    arc:Linux:*:* | arceb:Linux:*:* | arc32:Linux:*:* | arc64:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     arm*:Linux:*:*)
 	set_cc_for_build
 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_EABI__
 	then
-	    echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	    GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
 	else
 	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
 		| grep -q __ARM_PCS_VFP
 	    then
-		echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"eabi
+		GUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabi
 	    else
-		echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"eabihf
+		GUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabihf
 	    fi
 	fi
-	exit ;;
+	;;
     avr32*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     cris:Linux:*:*)
-	echo "$UNAME_MACHINE"-axis-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-axis-linux-$LIBC
+	;;
     crisv32:Linux:*:*)
-	echo "$UNAME_MACHINE"-axis-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-axis-linux-$LIBC
+	;;
     e2k:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     frv:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     hexagon:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     i*86:Linux:*:*)
-	echo "$UNAME_MACHINE"-pc-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-linux-$LIBC
+	;;
     ia64:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     k1om:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    kvx:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
+    kvx:cos:*:*)
+	GUESS=$UNAME_MACHINE-unknown-cos
+	;;
+    kvx:mbr:*:*)
+	GUESS=$UNAME_MACHINE-unknown-mbr
+	;;
+    loongarch32:Linux:*:* | loongarch64:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     m32r*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     m68*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     mips:Linux:*:* | mips64:Linux:*:*)
 	set_cc_for_build
 	IS_GLIBC=0
@@ -1035,123 +1124,135 @@ EOF
 	#endif
 	#endif
 EOF
-	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU\|^MIPS_ENDIAN\|^LIBCABI'`"
+	cc_set_vars=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU\|^MIPS_ENDIAN\|^LIBCABI'`
+	eval "$cc_set_vars"
 	test "x$CPU" != x && { echo "$CPU${MIPS_ENDIAN}-unknown-linux-$LIBCABI"; exit; }
 	;;
     mips64el:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     openrisc*:Linux:*:*)
-	echo or1k-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=or1k-unknown-linux-$LIBC
+	;;
     or32:Linux:*:* | or1k*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     padre:Linux:*:*)
-	echo sparc-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=sparc-unknown-linux-$LIBC
+	;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=hppa64-unknown-linux-$LIBC
+	;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-"$LIBC" ;;
-	  PA8*) echo hppa2.0-unknown-linux-"$LIBC" ;;
-	  *)    echo hppa-unknown-linux-"$LIBC" ;;
+	  PA7*) GUESS=hppa1.1-unknown-linux-$LIBC ;;
+	  PA8*) GUESS=hppa2.0-unknown-linux-$LIBC ;;
+	  *)    GUESS=hppa-unknown-linux-$LIBC ;;
 	esac
-	exit ;;
+	;;
     ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=powerpc64-unknown-linux-$LIBC
+	;;
     ppc:Linux:*:*)
-	echo powerpc-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=powerpc-unknown-linux-$LIBC
+	;;
     ppc64le:Linux:*:*)
-	echo powerpc64le-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=powerpc64le-unknown-linux-$LIBC
+	;;
     ppcle:Linux:*:*)
-	echo powerpcle-unknown-linux-"$LIBC"
-	exit ;;
-    riscv32:Linux:*:* | riscv64:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=powerpcle-unknown-linux-$LIBC
+	;;
+    riscv32:Linux:*:* | riscv32be:Linux:*:* | riscv64:Linux:*:* | riscv64be:Linux:*:*)
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     s390:Linux:*:* | s390x:Linux:*:*)
-	echo "$UNAME_MACHINE"-ibm-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-ibm-linux-$LIBC
+	;;
     sh64*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     sh*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     tile*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     vax:Linux:*:*)
-	echo "$UNAME_MACHINE"-dec-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-dec-linux-$LIBC
+	;;
     x86_64:Linux:*:*)
 	set_cc_for_build
+	CPU=$UNAME_MACHINE
 	LIBCABI=$LIBC
-	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
-	    if (echo '#ifdef __ILP32__'; echo IS_X32; echo '#endif') | \
-		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
-		grep IS_X32 >/dev/null
-	    then
-		LIBCABI="$LIBC"x32
-	    fi
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
+	    ABI=64
+	    sed 's/^	    //' << EOF > "$dummy.c"
+	    #ifdef __i386__
+	    ABI=x86
+	    #else
+	    #ifdef __ILP32__
+	    ABI=x32
+	    #endif
+	    #endif
+EOF
+	    cc_set_abi=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^ABI' | sed 's, ,,g'`
+	    eval "$cc_set_abi"
+	    case $ABI in
+		x86) CPU=i686 ;;
+		x32) LIBCABI=${LIBC}x32 ;;
+	    esac
 	fi
-	echo "$UNAME_MACHINE"-pc-linux-"$LIBCABI"
-	exit ;;
+	GUESS=$CPU-pc-linux-$LIBCABI
+	;;
     xtensa*:Linux:*:*)
-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+	;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
 	# earlier versions are messed up and put the nodename in both
 	# sysname and nodename.
-	echo i386-sequent-sysv4
-	exit ;;
+	GUESS=i386-sequent-sysv4
+	;;
     i*86:UNIX_SV:4.2MP:2.*)
 	# Unixware is an offshoot of SVR4, but it has its own version
 	# number series starting with 2...
 	# I am not positive that other SVR4 systems won't match this,
 	# I just have to hope.  -- rms.
 	# Use sysv4.2uw... so that sysv4* matches it.
-	echo "$UNAME_MACHINE"-pc-sysv4.2uw"$UNAME_VERSION"
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-sysv4.2uw$UNAME_VERSION
+	;;
     i*86:OS/2:*:*)
-	# If we were able to find `uname', then EMX Unix compatibility
+	# If we were able to find 'uname', then EMX Unix compatibility
 	# is probably installed.
-	echo "$UNAME_MACHINE"-pc-os2-emx
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-os2-emx
+	;;
     i*86:XTS-300:*:STOP)
-	echo "$UNAME_MACHINE"-unknown-stop
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-stop
+	;;
     i*86:atheos:*:*)
-	echo "$UNAME_MACHINE"-unknown-atheos
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-atheos
+	;;
     i*86:syllable:*:*)
-	echo "$UNAME_MACHINE"-pc-syllable
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-syllable
+	;;
     i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
-	echo i386-unknown-lynxos"$UNAME_RELEASE"
-	exit ;;
+	GUESS=i386-unknown-lynxos$UNAME_RELEASE
+	;;
     i*86:*DOS:*:*)
-	echo "$UNAME_MACHINE"-pc-msdosdjgpp
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-msdosdjgpp
+	;;
     i*86:*:4.*:*)
 	UNAME_REL=`echo "$UNAME_RELEASE" | sed 's/\/MP$//'`
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
-		echo "$UNAME_MACHINE"-univel-sysv"$UNAME_REL"
+		GUESS=$UNAME_MACHINE-univel-sysv$UNAME_REL
 	else
-		echo "$UNAME_MACHINE"-pc-sysv"$UNAME_REL"
+		GUESS=$UNAME_MACHINE-pc-sysv$UNAME_REL
 	fi
-	exit ;;
+	;;
     i*86:*:5:[678]*)
 	# UnixWare 7.x, OpenUNIX and OpenServer 6.
 	case `/bin/uname -X | grep "^Machine"` in
@@ -1159,12 +1260,12 @@ EOF
 	    *Pentium)	     UNAME_MACHINE=i586 ;;
 	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
 	esac
-	echo "$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
+	;;
     i*86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
 		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
-		echo "$UNAME_MACHINE"-pc-isc"$UNAME_REL"
+		GUESS=$UNAME_MACHINE-pc-isc$UNAME_REL
 	elif /bin/uname -X 2>/dev/null >/dev/null ; then
 		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
 		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
@@ -1174,11 +1275,11 @@ EOF
 			&& UNAME_MACHINE=i686
 		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
 			&& UNAME_MACHINE=i686
-		echo "$UNAME_MACHINE"-pc-sco"$UNAME_REL"
+		GUESS=$UNAME_MACHINE-pc-sco$UNAME_REL
 	else
-		echo "$UNAME_MACHINE"-pc-sysv32
+		GUESS=$UNAME_MACHINE-pc-sysv32
 	fi
-	exit ;;
+	;;
     pc:*:*:*)
 	# Left here for compatibility:
 	# uname -m prints for DJGPP always 'pc', but it prints nothing about
@@ -1186,31 +1287,31 @@ EOF
 	# Note: whatever this is, it MUST be the same as what config.sub
 	# prints for the "djgpp" host, or else GDB configure will decide that
 	# this is a cross-build.
-	echo i586-pc-msdosdjgpp
-	exit ;;
+	GUESS=i586-pc-msdosdjgpp
+	;;
     Intel:Mach:3*:*)
-	echo i386-pc-mach3
-	exit ;;
+	GUESS=i386-pc-mach3
+	;;
     paragon:*:*:*)
-	echo i860-intel-osf1
-	exit ;;
+	GUESS=i860-intel-osf1
+	;;
     i860:*:4.*:*) # i860-SVR4
 	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
-	  echo i860-stardent-sysv"$UNAME_RELEASE" # Stardent Vistra i860-SVR4
+	  GUESS=i860-stardent-sysv$UNAME_RELEASE    # Stardent Vistra i860-SVR4
 	else # Add other i860-SVR4 vendors below as they are discovered.
-	  echo i860-unknown-sysv"$UNAME_RELEASE"  # Unknown i860-SVR4
+	  GUESS=i860-unknown-sysv$UNAME_RELEASE     # Unknown i860-SVR4
 	fi
-	exit ;;
+	;;
     mini*:CTIX:SYS*5:*)
 	# "miniframe"
-	echo m68010-convergent-sysv
-	exit ;;
+	GUESS=m68010-convergent-sysv
+	;;
     mc68k:UNIX:SYSTEM5:3.51m)
-	echo m68k-convergent-sysv
-	exit ;;
+	GUESS=m68k-convergent-sysv
+	;;
     M680?0:D-NIX:5.3:*)
-	echo m68k-diab-dnix
-	exit ;;
+	GUESS=m68k-diab-dnix
+	;;
     M68*:*:R3V[5678]*:*)
 	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
     3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
@@ -1235,116 +1336,119 @@ EOF
 	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
 	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
-	echo m68k-unknown-lynxos"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-unknown-lynxos$UNAME_RELEASE
+	;;
     mc68030:UNIX_System_V:4.*:*)
-	echo m68k-atari-sysv4
-	exit ;;
+	GUESS=m68k-atari-sysv4
+	;;
     TSUNAMI:LynxOS:2.*:*)
-	echo sparc-unknown-lynxos"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sparc-unknown-lynxos$UNAME_RELEASE
+	;;
     rs6000:LynxOS:2.*:*)
-	echo rs6000-unknown-lynxos"$UNAME_RELEASE"
-	exit ;;
+	GUESS=rs6000-unknown-lynxos$UNAME_RELEASE
+	;;
     PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
-	echo powerpc-unknown-lynxos"$UNAME_RELEASE"
-	exit ;;
+	GUESS=powerpc-unknown-lynxos$UNAME_RELEASE
+	;;
     SM[BE]S:UNIX_SV:*:*)
-	echo mips-dde-sysv"$UNAME_RELEASE"
-	exit ;;
+	GUESS=mips-dde-sysv$UNAME_RELEASE
+	;;
     RM*:ReliantUNIX-*:*:*)
-	echo mips-sni-sysv4
-	exit ;;
+	GUESS=mips-sni-sysv4
+	;;
     RM*:SINIX-*:*:*)
-	echo mips-sni-sysv4
-	exit ;;
+	GUESS=mips-sni-sysv4
+	;;
     *:SINIX-*:*:*)
 	if uname -p 2>/dev/null >/dev/null ; then
 		UNAME_MACHINE=`(uname -p) 2>/dev/null`
-		echo "$UNAME_MACHINE"-sni-sysv4
+		GUESS=$UNAME_MACHINE-sni-sysv4
 	else
-		echo ns32k-sni-sysv
+		GUESS=ns32k-sni-sysv
 	fi
-	exit ;;
-    PENTIUM:*:4.0*:*)	# Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+	;;
+    PENTIUM:*:4.0*:*)	# Unisys 'ClearPath HMP IX 4000' SVR4/MP effort
 			# says <Richard.M.Bartel@ccMail.Census.GOV>
-	echo i586-unisys-sysv4
-	exit ;;
+	GUESS=i586-unisys-sysv4
+	;;
     *:UNIX_System_V:4*:FTX*)
 	# From Gerald Hewes <hewes@openmarket.com>.
 	# How about differentiating between stratus architectures? -djm
-	echo hppa1.1-stratus-sysv4
-	exit ;;
+	GUESS=hppa1.1-stratus-sysv4
+	;;
     *:*:*:FTX*)
 	# From seanf@swdc.stratus.com.
-	echo i860-stratus-sysv4
-	exit ;;
+	GUESS=i860-stratus-sysv4
+	;;
     i*86:VOS:*:*)
 	# From Paul.Green@stratus.com.
-	echo "$UNAME_MACHINE"-stratus-vos
-	exit ;;
+	GUESS=$UNAME_MACHINE-stratus-vos
+	;;
     *:VOS:*:*)
 	# From Paul.Green@stratus.com.
-	echo hppa1.1-stratus-vos
-	exit ;;
+	GUESS=hppa1.1-stratus-vos
+	;;
     mc68*:A/UX:*:*)
-	echo m68k-apple-aux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=m68k-apple-aux$UNAME_RELEASE
+	;;
     news*:NEWS-OS:6*:*)
-	echo mips-sony-newsos6
-	exit ;;
+	GUESS=mips-sony-newsos6
+	;;
     R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
-	if [ -d /usr/nec ]; then
-		echo mips-nec-sysv"$UNAME_RELEASE"
+	if test -d /usr/nec; then
+		GUESS=mips-nec-sysv$UNAME_RELEASE
 	else
-		echo mips-unknown-sysv"$UNAME_RELEASE"
+		GUESS=mips-unknown-sysv$UNAME_RELEASE
 	fi
-	exit ;;
+	;;
     BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
-	echo powerpc-be-beos
-	exit ;;
+	GUESS=powerpc-be-beos
+	;;
     BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
-	echo powerpc-apple-beos
-	exit ;;
+	GUESS=powerpc-apple-beos
+	;;
     BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
-	echo i586-pc-beos
-	exit ;;
+	GUESS=i586-pc-beos
+	;;
     BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
-	echo i586-pc-haiku
-	exit ;;
-    x86_64:Haiku:*:*)
-	echo x86_64-unknown-haiku
-	exit ;;
+	GUESS=i586-pc-haiku
+	;;
+    ppc:Haiku:*:*)	# Haiku running on Apple PowerPC
+	GUESS=powerpc-apple-haiku
+	;;
+    *:Haiku:*:*)	# Haiku modern gcc (not bound by BeOS compat)
+	GUESS=$UNAME_MACHINE-unknown-haiku
+	;;
     SX-4:SUPER-UX:*:*)
-	echo sx4-nec-superux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sx4-nec-superux$UNAME_RELEASE
+	;;
     SX-5:SUPER-UX:*:*)
-	echo sx5-nec-superux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sx5-nec-superux$UNAME_RELEASE
+	;;
     SX-6:SUPER-UX:*:*)
-	echo sx6-nec-superux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sx6-nec-superux$UNAME_RELEASE
+	;;
     SX-7:SUPER-UX:*:*)
-	echo sx7-nec-superux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sx7-nec-superux$UNAME_RELEASE
+	;;
     SX-8:SUPER-UX:*:*)
-	echo sx8-nec-superux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sx8-nec-superux$UNAME_RELEASE
+	;;
     SX-8R:SUPER-UX:*:*)
-	echo sx8r-nec-superux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sx8r-nec-superux$UNAME_RELEASE
+	;;
     SX-ACE:SUPER-UX:*:*)
-	echo sxace-nec-superux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=sxace-nec-superux$UNAME_RELEASE
+	;;
     Power*:Rhapsody:*:*)
-	echo powerpc-apple-rhapsody"$UNAME_RELEASE"
-	exit ;;
+	GUESS=powerpc-apple-rhapsody$UNAME_RELEASE
+	;;
     *:Rhapsody:*:*)
-	echo "$UNAME_MACHINE"-apple-rhapsody"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-apple-rhapsody$UNAME_RELEASE
+	;;
     arm64:Darwin:*:*)
-	echo aarch64-apple-darwin"$UNAME_RELEASE"
-	exit ;;
+	GUESS=aarch64-apple-darwin$UNAME_RELEASE
+	;;
     *:Darwin:*:*)
 	UNAME_PROCESSOR=`uname -p`
 	case $UNAME_PROCESSOR in
@@ -1359,7 +1463,7 @@ EOF
 	else
 	    set_cc_for_build
 	fi
-	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
 	    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
 		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
 		   grep IS_64BIT_ARCH >/dev/null
@@ -1380,109 +1484,119 @@ EOF
 	    # uname -m returns i386 or x86_64
 	    UNAME_PROCESSOR=$UNAME_MACHINE
 	fi
-	echo "$UNAME_PROCESSOR"-apple-darwin"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_PROCESSOR-apple-darwin$UNAME_RELEASE
+	;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
 	if test "$UNAME_PROCESSOR" = x86; then
 		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
 	fi
-	echo "$UNAME_PROCESSOR"-"$UNAME_MACHINE"-nto-qnx"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_PROCESSOR-$UNAME_MACHINE-nto-qnx$UNAME_RELEASE
+	;;
     *:QNX:*:4*)
-	echo i386-pc-qnx
-	exit ;;
+	GUESS=i386-pc-qnx
+	;;
     NEO-*:NONSTOP_KERNEL:*:*)
-	echo neo-tandem-nsk"$UNAME_RELEASE"
-	exit ;;
+	GUESS=neo-tandem-nsk$UNAME_RELEASE
+	;;
     NSE-*:NONSTOP_KERNEL:*:*)
-	echo nse-tandem-nsk"$UNAME_RELEASE"
-	exit ;;
+	GUESS=nse-tandem-nsk$UNAME_RELEASE
+	;;
     NSR-*:NONSTOP_KERNEL:*:*)
-	echo nsr-tandem-nsk"$UNAME_RELEASE"
-	exit ;;
+	GUESS=nsr-tandem-nsk$UNAME_RELEASE
+	;;
     NSV-*:NONSTOP_KERNEL:*:*)
-	echo nsv-tandem-nsk"$UNAME_RELEASE"
-	exit ;;
+	GUESS=nsv-tandem-nsk$UNAME_RELEASE
+	;;
     NSX-*:NONSTOP_KERNEL:*:*)
-	echo nsx-tandem-nsk"$UNAME_RELEASE"
-	exit ;;
+	GUESS=nsx-tandem-nsk$UNAME_RELEASE
+	;;
     *:NonStop-UX:*:*)
-	echo mips-compaq-nonstopux
-	exit ;;
+	GUESS=mips-compaq-nonstopux
+	;;
     BS2000:POSIX*:*:*)
-	echo bs2000-siemens-sysv
-	exit ;;
+	GUESS=bs2000-siemens-sysv
+	;;
     DS/*:UNIX_System_V:*:*)
-	echo "$UNAME_MACHINE"-"$UNAME_SYSTEM"-"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-$UNAME_SYSTEM-$UNAME_RELEASE
+	;;
     *:Plan9:*:*)
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
 	# operating systems.
-	# shellcheck disable=SC2154
-	if test "$cputype" = 386; then
+	if test "${cputype-}" = 386; then
 	    UNAME_MACHINE=i386
-	else
-	    UNAME_MACHINE="$cputype"
+	elif test "x${cputype-}" != x; then
+	    UNAME_MACHINE=$cputype
 	fi
-	echo "$UNAME_MACHINE"-unknown-plan9
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-plan9
+	;;
     *:TOPS-10:*:*)
-	echo pdp10-unknown-tops10
-	exit ;;
+	GUESS=pdp10-unknown-tops10
+	;;
     *:TENEX:*:*)
-	echo pdp10-unknown-tenex
-	exit ;;
+	GUESS=pdp10-unknown-tenex
+	;;
     KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
-	echo pdp10-dec-tops20
-	exit ;;
+	GUESS=pdp10-dec-tops20
+	;;
     XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
-	echo pdp10-xkl-tops20
-	exit ;;
+	GUESS=pdp10-xkl-tops20
+	;;
     *:TOPS-20:*:*)
-	echo pdp10-unknown-tops20
-	exit ;;
+	GUESS=pdp10-unknown-tops20
+	;;
     *:ITS:*:*)
-	echo pdp10-unknown-its
-	exit ;;
+	GUESS=pdp10-unknown-its
+	;;
     SEI:*:*:SEIUX)
-	echo mips-sei-seiux"$UNAME_RELEASE"
-	exit ;;
+	GUESS=mips-sei-seiux$UNAME_RELEASE
+	;;
     *:DragonFly:*:*)
-	echo "$UNAME_MACHINE"-unknown-dragonfly"`echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`"
-	exit ;;
+	DRAGONFLY_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
+	GUESS=$UNAME_MACHINE-unknown-dragonfly$DRAGONFLY_REL
+	;;
     *:*VMS:*:*)
 	UNAME_MACHINE=`(uname -p) 2>/dev/null`
-	case "$UNAME_MACHINE" in
-	    A*) echo alpha-dec-vms ; exit ;;
-	    I*) echo ia64-dec-vms ; exit ;;
-	    V*) echo vax-dec-vms ; exit ;;
+	case $UNAME_MACHINE in
+	    A*) GUESS=alpha-dec-vms ;;
+	    I*) GUESS=ia64-dec-vms ;;
+	    V*) GUESS=vax-dec-vms ;;
 	esac ;;
     *:XENIX:*:SysV)
-	echo i386-pc-xenix
-	exit ;;
+	GUESS=i386-pc-xenix
+	;;
     i*86:skyos:*:*)
-	echo "$UNAME_MACHINE"-pc-skyos"`echo "$UNAME_RELEASE" | sed -e 's/ .*$//'`"
-	exit ;;
+	SKYOS_REL=`echo "$UNAME_RELEASE" | sed -e 's/ .*$//'`
+	GUESS=$UNAME_MACHINE-pc-skyos$SKYOS_REL
+	;;
     i*86:rdos:*:*)
-	echo "$UNAME_MACHINE"-pc-rdos
-	exit ;;
-    i*86:AROS:*:*)
-	echo "$UNAME_MACHINE"-pc-aros
-	exit ;;
+	GUESS=$UNAME_MACHINE-pc-rdos
+	;;
+    i*86:Fiwix:*:*)
+	GUESS=$UNAME_MACHINE-pc-fiwix
+	;;
+    *:AROS:*:*)
+	GUESS=$UNAME_MACHINE-unknown-aros
+	;;
     x86_64:VMkernel:*:*)
-	echo "$UNAME_MACHINE"-unknown-esx
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-esx
+	;;
     amd64:Isilon\ OneFS:*:*)
-	echo x86_64-unknown-onefs
-	exit ;;
+	GUESS=x86_64-unknown-onefs
+	;;
     *:Unleashed:*:*)
-	echo "$UNAME_MACHINE"-unknown-unleashed"$UNAME_RELEASE"
-	exit ;;
+	GUESS=$UNAME_MACHINE-unknown-unleashed$UNAME_RELEASE
+	;;
 esac
 
+# Do we have a guess based on uname results?
+if test "x$GUESS" != x; then
+    echo "$GUESS"
+    exit
+fi
+
 # No uname command or uname output not recognized.
 set_cc_for_build
 cat > "$dummy.c" <<EOF
@@ -1614,7 +1728,7 @@ main ()
 }
 EOF
 
-$CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null && SYSTEM_NAME=`$dummy` &&
+$CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null && SYSTEM_NAME=`"$dummy"` &&
 	{ echo "$SYSTEM_NAME"; exit; }
 
 # Apollos put the system type in the environment.
@@ -1622,7 +1736,7 @@ test -d /usr/apollo && { echo "$ISP-apollo-$SYSTYPE"; exit; }
 
 echo "$0: unable to guess system type" >&2
 
-case "$UNAME_MACHINE:$UNAME_SYSTEM" in
+case $UNAME_MACHINE:$UNAME_SYSTEM in
     mips:Linux | mips64:Linux)
 	# If we got here on MIPS GNU/Linux, output extra information.
 	cat >&2 <<EOF
@@ -1639,14 +1753,16 @@ This script (version $timestamp), has failed to recognize the
 operating system you are using. If your script is old, overwrite *all*
 copies of config.guess and config.sub with the latest versions from:
 
-  https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
+  https://git.savannah.gnu.org/cgit/config.git/plain/config.guess
 and
-  https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
+  https://git.savannah.gnu.org/cgit/config.git/plain/config.sub
 EOF
 
-year=`echo $timestamp | sed 's,-.*,,'`
+our_year=`echo $timestamp | sed 's,-.*,,'`
+thisyear=`date +%Y`
 # shellcheck disable=SC2003
-if test "`expr "\`date +%Y\`" - "$year"`" -lt 3 ; then
+script_age=`expr "$thisyear" - "$our_year"`
+if test "$script_age" -lt 3 ; then
    cat >&2 <<EOF
 
 If $0 has already been updated, send the following data and any
diff --git a/build-aux/config.sub b/build-aux/config.sub
index 3d9a8dc3d5..6ae2502753 100755
--- a/build-aux/config.sub
+++ b/build-aux/config.sub
@@ -1,12 +1,14 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright 1992-2020 Free Software Foundation, Inc.
+#   Copyright 1992-2023 Free Software Foundation, Inc.
 
-timestamp='2020-07-10'
+# shellcheck disable=SC2006,SC2268 # see below for rationale
+
+timestamp='2023-07-31'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3 of the License, or
+# the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
@@ -33,7 +35,7 @@ timestamp='2020-07-10'
 # Otherwise, we print the canonical config type on stdout and succeed.
 
 # You can get the latest version of this script from:
-# https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
+# https://git.savannah.gnu.org/cgit/config.git/plain/config.sub
 
 # This file is supposed to be the same for all GNU packages
 # and recognize all the CPU types, system types and aliases
@@ -50,6 +52,13 @@ timestamp='2020-07-10'
 #	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
 # It is wrong to echo any other type of specification.
 
+# The "shellcheck disable" line above the timestamp inhibits complaints
+# about features and limitations of the classic Bourne shell that were
+# superseded or lifted in POSIX.  However, this script identifies a wide
+# variety of pre-POSIX systems that do not have POSIX shells at all, and
+# even some reasonably current systems (Solaris 10 as case-in-point) still
+# have a pre-POSIX /bin/sh.
+
 me=`echo "$0" | sed -e 's,.*/,,'`
 
 usage="\
@@ -67,13 +76,13 @@ Report bugs and patches to <config-patches@gnu.org>."
 version="\
 GNU config.sub ($timestamp)
 
-Copyright 1992-2020 Free Software Foundation, Inc.
+Copyright 1992-2023 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
-Try \`$me --help' for more information."
+Try '$me --help' for more information."
 
 # Parse command line
 while test $# -gt 0 ; do
@@ -112,14 +121,16 @@ esac
 
 # Split fields of configuration type
 # shellcheck disable=SC2162
+saved_IFS=$IFS
 IFS="-" read field1 field2 field3 field4 <<EOF
 $1
 EOF
+IFS=$saved_IFS
 
 # Separate into logical components for further validation
 case $1 in
 	*-*-*-*-*)
-		echo Invalid configuration \`"$1"\': more than four components >&2
+		echo "Invalid configuration '$1': more than four components" >&2
 		exit 1
 		;;
 	*-*-*-*)
@@ -134,7 +145,8 @@ case $1 in
 			nto-qnx* | linux-* | uclinux-uclibc* \
 			| uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* \
 			| netbsd*-eabi* | kopensolaris*-gnu* | cloudabi*-eabi* \
-			| storm-chaos* | os2-emx* | rtmk-nova*)
+			| storm-chaos* | os2-emx* | rtmk-nova* | managarm-* \
+			| windows-* )
 				basic_machine=$field1
 				basic_os=$maybe_os
 				;;
@@ -163,6 +175,10 @@ case $1 in
 						basic_machine=$field1
 						basic_os=$field2
 						;;
+					zephyr*)
+						basic_machine=$field1-unknown
+						basic_os=$field2
+						;;
 					# Manufacturers
 					dec* | mips* | sequent* | encore* | pc533* | sgi* | sony* \
 					| att* | 7300* | 3300* | delta* | motorola* | sun[234]* \
@@ -922,11 +938,13 @@ case $basic_machine in
 
 	*-*)
 		# shellcheck disable=SC2162
+		saved_IFS=$IFS
 		IFS="-" read cpu vendor <<EOF
 $basic_machine
 EOF
+		IFS=$saved_IFS
 		;;
-	# We use `pc' rather than `unknown'
+	# We use 'pc' rather than 'unknown'
 	# because (1) that's what they normally are, and
 	# (2) the word "unknown" tends to confuse beginning users.
 	i*86 | x86_64)
@@ -1003,6 +1021,11 @@ case $cpu-$vendor in
 		;;
 
 	# Here we normalize CPU types with a missing or matching vendor
+	armh-unknown | armh-alt)
+		cpu=armv7l
+		vendor=alt
+		basic_os=${basic_os:-linux-gnueabihf}
+		;;
 	dpx20-unknown | dpx20-bull)
 		cpu=rs6000
 		vendor=bull
@@ -1053,7 +1076,7 @@ case $cpu-$vendor in
 	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
 		cpu=i586
 		;;
-	pentiumpro-* | p6-* | 6x86-* | athlon-* | athalon_*-*)
+	pentiumpro-* | p6-* | 6x86-* | athlon-* | athlon_*-*)
 		cpu=i686
 		;;
 	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
@@ -1104,7 +1127,7 @@ case $cpu-$vendor in
 	xscale-* | xscalee[bl]-*)
 		cpu=`echo "$cpu" | sed 's/^xscale/arm/'`
 		;;
-	arm64-*)
+	arm64-* | aarch64le-*)
 		cpu=aarch64
 		;;
 
@@ -1165,7 +1188,7 @@ case $cpu-$vendor in
 			| alphapca5[67] | alpha64pca5[67] \
 			| am33_2.0 \
 			| amdgcn \
-			| arc | arceb \
+			| arc | arceb | arc32 | arc64 \
 			| arm | arm[lb]e | arme[lb] | armv* \
 			| avr | avr32 \
 			| asmjs \
@@ -1183,34 +1206,16 @@ case $cpu-$vendor in
 			| i370 | i*86 | i860 | i960 | ia16 | ia64 \
 			| ip2k | iq2000 \
 			| k1om \
+			| kvx \
 			| le32 | le64 \
 			| lm32 \
+			| loongarch32 | loongarch64 \
 			| m32c | m32r | m32rle \
 			| m5200 | m68000 | m680[012346]0 | m68360 | m683?2 | m68k \
 			| m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x \
 			| m88110 | m88k | maxq | mb | mcore | mep | metag \
 			| microblaze | microblazeel \
-			| mips | mipsbe | mipseb | mipsel | mipsle \
-			| mips16 \
-			| mips64 | mips64eb | mips64el \
-			| mips64octeon | mips64octeonel \
-			| mips64orion | mips64orionel \
-			| mips64r5900 | mips64r5900el \
-			| mips64vr | mips64vrel \
-			| mips64vr4100 | mips64vr4100el \
-			| mips64vr4300 | mips64vr4300el \
-			| mips64vr5000 | mips64vr5000el \
-			| mips64vr5900 | mips64vr5900el \
-			| mipsisa32 | mipsisa32el \
-			| mipsisa32r2 | mipsisa32r2el \
-			| mipsisa32r6 | mipsisa32r6el \
-			| mipsisa64 | mipsisa64el \
-			| mipsisa64r2 | mipsisa64r2el \
-			| mipsisa64r6 | mipsisa64r6el \
-			| mipsisa64sb1 | mipsisa64sb1el \
-			| mipsisa64sr71k | mipsisa64sr71kel \
-			| mipsr5900 | mipsr5900el \
-			| mipstx39 | mipstx39el \
+			| mips* \
 			| mmix \
 			| mn10200 | mn10300 \
 			| moxie \
@@ -1229,7 +1234,7 @@ case $cpu-$vendor in
 			| powerpc | powerpc64 | powerpc64le | powerpcle | powerpcspe \
 			| pru \
 			| pyramid \
-			| riscv | riscv32 | riscv64 \
+			| riscv | riscv32 | riscv32be | riscv64 | riscv64be \
 			| rl78 | romp | rs6000 | rx \
 			| s390 | s390x \
 			| score \
@@ -1241,6 +1246,7 @@ case $cpu-$vendor in
 			| sparcv8 | sparcv9 | sparcv9b | sparcv9v | sv1 | sx* \
 			| spu \
 			| tahoe \
+			| thumbv7* \
 			| tic30 | tic4x | tic54x | tic55x | tic6x | tic80 \
 			| tron \
 			| ubicom32 \
@@ -1257,7 +1263,7 @@ case $cpu-$vendor in
 				;;
 
 			*)
-				echo Invalid configuration \`"$1"\': machine \`"$cpu-$vendor"\' not recognized 1>&2
+				echo "Invalid configuration '$1': machine '$cpu-$vendor' not recognized" 1>&2
 				exit 1
 				;;
 		esac
@@ -1278,34 +1284,44 @@ esac
 
 # Decode manufacturer-specific aliases for certain operating systems.
 
-if [ x$basic_os != x ]
+if test x$basic_os != x
 then
 
-# First recognize some ad-hoc caes, or perhaps split kernel-os, or else just
+# First recognize some ad-hoc cases, or perhaps split kernel-os, or else just
 # set os.
 case $basic_os in
 	gnu/linux*)
 		kernel=linux
-		os=`echo $basic_os | sed -e 's|gnu/linux|gnu|'`
+		os=`echo "$basic_os" | sed -e 's|gnu/linux|gnu|'`
+		;;
+	os2-emx)
+		kernel=os2
+		os=`echo "$basic_os" | sed -e 's|os2-emx|emx|'`
 		;;
 	nto-qnx*)
 		kernel=nto
-		os=`echo $basic_os | sed -e 's|nto-qnx|qnx|'`
+		os=`echo "$basic_os" | sed -e 's|nto-qnx|qnx|'`
 		;;
 	*-*)
 		# shellcheck disable=SC2162
+		saved_IFS=$IFS
 		IFS="-" read kernel os <<EOF
 $basic_os
 EOF
+		IFS=$saved_IFS
 		;;
 	# Default OS when just kernel was specified
 	nto*)
 		kernel=nto
-		os=`echo $basic_os | sed -e 's|nto|qnx|'`
+		os=`echo "$basic_os" | sed -e 's|nto|qnx|'`
 		;;
 	linux*)
 		kernel=linux
-		os=`echo $basic_os | sed -e 's|linux|gnu|'`
+		os=`echo "$basic_os" | sed -e 's|linux|gnu|'`
+		;;
+	managarm*)
+		kernel=managarm
+		os=`echo "$basic_os" | sed -e 's|managarm|mlibc|'`
 		;;
 	*)
 		kernel=
@@ -1326,7 +1342,7 @@ case $os in
 		os=cnk
 		;;
 	solaris1 | solaris1.*)
-		os=`echo $os | sed -e 's|solaris1|sunos4|'`
+		os=`echo "$os" | sed -e 's|solaris1|sunos4|'`
 		;;
 	solaris)
 		os=solaris2
@@ -1355,7 +1371,7 @@ case $os in
 		os=sco3.2v4
 		;;
 	sco3.2.[4-9]*)
-		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
+		os=`echo "$os" | sed -e 's/sco3.2./sco3.2v/'`
 		;;
 	sco*v* | scout)
 		# Don't match below
@@ -1367,13 +1383,7 @@ case $os in
 		os=psos
 		;;
 	qnx*)
-		case $cpu in
-		    x86 | i*86)
-			;;
-		    *)
-			os=nto-$os
-			;;
-		esac
+		os=qnx
 		;;
 	hiux*)
 		os=hiuxwe2
@@ -1437,7 +1447,7 @@ case $os in
 		;;
 	# Preserve the version number of sinix5.
 	sinix5.*)
-		os=`echo $os | sed -e 's|sinix|sysv|'`
+		os=`echo "$os" | sed -e 's|sinix|sysv|'`
 		;;
 	sinix*)
 		os=sysv4
@@ -1683,11 +1693,14 @@ fi
 
 # Now, validate our (potentially fixed-up) OS.
 case $os in
-	# Sometimes we do "kernel-abi", so those need to count as OSes.
-	musl* | newlib* | uclibc*)
+	# Sometimes we do "kernel-libc", so those need to count as OSes.
+	musl* | newlib* | relibc* | uclibc*)
+		;;
+	# Likewise for "kernel-abi"
+	eabi* | gnueabi*)
 		;;
-	# Likewise for "kernel-libc"
-	eabi | eabihf | gnueabi | gnueabihf)
+	# VxWorks passes extra cpu info in the 4th filed.
+	simlinux | simwindows | spe)
 		;;
 	# Now accept the basic system types.
 	# The portable systems comes first.
@@ -1697,19 +1710,19 @@ case $os in
 	     | hpux* | unos* | osf* | luna* | dgux* | auroraux* | solaris* \
 	     | sym* |  plan9* | psp* | sim* | xray* | os68k* | v88r* \
 	     | hiux* | abug | nacl* | netware* | windows* \
-	     | os9* | macos* | osx* | ios* \
+	     | os9* | macos* | osx* | ios* | tvos* | watchos* \
 	     | mpw* | magic* | mmixware* | mon960* | lnews* \
 	     | amigaos* | amigados* | msdos* | newsos* | unicos* | aof* \
 	     | aos* | aros* | cloudabi* | sortix* | twizzler* \
 	     | nindy* | vxsim* | vxworks* | ebmon* | hms* | mvs* \
 	     | clix* | riscos* | uniplus* | iris* | isc* | rtu* | xenix* \
 	     | mirbsd* | netbsd* | dicos* | openedition* | ose* \
-	     | bitrig* | openbsd* | solidbsd* | libertybsd* | os108* \
+	     | bitrig* | openbsd* | secbsd* | solidbsd* | libertybsd* | os108* \
 	     | ekkobsd* | freebsd* | riscix* | lynxos* | os400* \
 	     | bosx* | nextstep* | cxux* | aout* | elf* | oabi* \
 	     | ptx* | coff* | ecoff* | winnt* | domain* | vsta* \
 	     | udi* | lites* | ieee* | go32* | aux* | hcos* \
-	     | chorusrdb* | cegcc* | glidix* \
+	     | chorusrdb* | cegcc* | glidix* | serenity* \
 	     | cygwin* | msys* | pe* | moss* | proelf* | rtems* \
 	     | midipix* | mingw32* | mingw64* | mint* \
 	     | uxpv* | beos* | mpeix* | udk* | moxiebox* \
@@ -1722,7 +1735,8 @@ case $os in
 	     | skyos* | haiku* | rdos* | toppers* | drops* | es* \
 	     | onefs* | tirtos* | phoenix* | fuchsia* | redox* | bme* \
 	     | midnightbsd* | amdhsa* | unleashed* | emscripten* | wasi* \
-	     | nsk* | powerunix* | genode* | zvmoe* )
+	     | nsk* | powerunix* | genode* | zvmoe* | qnx* | emx* | zephyr* \
+	     | fiwix* | mlibc* | cos* | mbr* )
 		;;
 	# This one is extra strict with allowed versions
 	sco3.2v2 | sco3.2v[4-9]* | sco5v6*)
@@ -1730,8 +1744,11 @@ case $os in
 		;;
 	none)
 		;;
+	kernel* | msvc* )
+		# Restricted further below
+		;;
 	*)
-		echo Invalid configuration \`"$1"\': OS \`"$os"\' not recognized 1>&2
+		echo "Invalid configuration '$1': OS '$os' not recognized" 1>&2
 		exit 1
 		;;
 esac
@@ -1739,25 +1756,52 @@ esac
 # As a final step for OS-related things, validate the OS-kernel combination
 # (given a valid OS), if there is a kernel.
 case $kernel-$os in
-	linux-gnu* | linux-dietlibc* | linux-android* | linux-newlib* | linux-musl* | linux-uclibc* )
+	linux-gnu* | linux-dietlibc* | linux-android* | linux-newlib* \
+		   | linux-musl* | linux-relibc* | linux-uclibc* | linux-mlibc* )
+		;;
+	uclinux-uclibc* )
+		;;
+	managarm-mlibc* | managarm-kernel* )
+		;;
+	windows*-gnu* | windows*-msvc*)
 		;;
-	-dietlibc* | -newlib* | -musl* | -uclibc* )
+	-dietlibc* | -newlib* | -musl* | -relibc* | -uclibc* | -mlibc* )
 		# These are just libc implementations, not actual OSes, and thus
 		# require a kernel.
-		echo "Invalid configuration \`$1': libc \`$os' needs explicit kernel." 1>&2
+		echo "Invalid configuration '$1': libc '$os' needs explicit kernel." 1>&2
+		exit 1
+		;;
+	-kernel* )
+		echo "Invalid configuration '$1': '$os' needs explicit kernel." 1>&2
+		exit 1
+		;;
+	*-kernel* )
+		echo "Invalid configuration '$1': '$kernel' does not support '$os'." 1>&2
+		exit 1
+		;;
+	*-msvc* )
+		echo "Invalid configuration '$1': '$os' needs 'windows'." 1>&2
 		exit 1
 		;;
 	kfreebsd*-gnu* | kopensolaris*-gnu*)
 		;;
+	vxworks-simlinux | vxworks-simwindows | vxworks-spe)
+		;;
 	nto-qnx*)
 		;;
+	os2-emx)
+		;;
 	*-eabi* | *-gnueabi*)
 		;;
+	none-coff* | none-elf*)
+		# None (no kernel, i.e. freestanding / bare metal),
+		# can be paired with an output format "OS"
+		;;
 	-*)
 		# Blank kernel with real OS is always fine.
 		;;
 	*-*)
-		echo "Invalid configuration \`$1': Kernel \`$kernel' not known to work with OS \`$os'." 1>&2
+		echo "Invalid configuration '$1': Kernel '$kernel' not known to work with OS '$os'." 1>&2
 		exit 1
 		;;
 esac
diff --git a/build-aux/ocaml_version.m4 b/build-aux/ocaml_version.m4
index 41776d2578..0a59107ea8 100644
--- a/build-aux/ocaml_version.m4
+++ b/build-aux/ocaml_version.m4
@@ -32,11 +32,11 @@ m4_define([OCAML__DEVELOPMENT_VERSION], [true])
 # including the patchlevel, are mandatory.
 
 m4_define([OCAML__VERSION_MAJOR], [5])
-m4_define([OCAML__VERSION_MINOR], [1])
+m4_define([OCAML__VERSION_MINOR], [0])
 m4_define([OCAML__VERSION_PATCHLEVEL], [0])
 # Note that the OCAML__VERSION_EXTRA string defined below is always empty
 # for officially-released versions of OCaml.
-m4_define([OCAML__VERSION_EXTRA], [dev1-2022-06-09])
+m4_define([OCAML__VERSION_EXTRA], [jst-backport])
 
 # The OCAML__VERSION_EXTRA_PREFIX macro defined below should be a
 # single character:
diff --git a/bytecomp/dll.ml b/bytecomp/dll.ml
index 1675a6ca21..75809c8285 100644
--- a/bytecomp/dll.ml
+++ b/bytecomp/dll.ml
@@ -19,7 +19,11 @@ type dll_handle
 type dll_address
 type dll_mode = For_checking | For_execution
 
+(* BACKPORT BEGIN
 external dll_open: string -> dll_handle = "caml_dynlink_open_lib"
+*)
+external dll_open: dll_mode -> string -> dll_handle = "caml_dynlink_open_lib"
+(* BACKPORT END *)
 external dll_close: dll_handle -> unit = "caml_dynlink_close_lib"
 external dll_sym: dll_handle -> string -> dll_address
                 = "caml_dynlink_lookup_symbol"
@@ -81,7 +85,11 @@ let open_dll mode name =
           failwith (fullname ^ ": " ^ Binutils.error_to_string err)
       end
   | (None | Some (Checking _) as current), For_execution ->
+(* BACKPORT BEGIN
       begin match dll_open fullname with
+*)
+      begin match dll_open For_execution fullname with
+(* BACKPORT END *)
       | dll ->
           let opened = match current with
             | None -> List.remove_assoc fullname !opened_dlls
diff --git a/bytecomp/emitcode.ml b/bytecomp/emitcode.ml
index 8e600d7fa0..a71d53aecc 100644
--- a/bytecomp/emitcode.ml
+++ b/bytecomp/emitcode.ml
@@ -309,10 +309,14 @@ let emit_instr = function
   | Kgetpubmet tag -> out opGETPUBMET; out_int tag; out_int 0
   | Kgetdynmet -> out opGETDYNMET
   | Kevent ev -> record_event ev
+(* BACKPORT BEGIN
   | Kperform -> out opPERFORM
   | Kresume -> out opRESUME
   | Kresumeterm n -> out opRESUMETERM; out_int n
   | Kreperformterm n -> out opREPERFORMTERM; out_int n
+*)
+  | Kperform | Kresume | Kresumeterm _ | Kreperformterm _ -> assert false
+(* BACKPORT END *)
   | Kstop -> out opSTOP
 
 (* Emission of a list of instructions. Include some peephole optimization. *)
diff --git a/configure b/configure
index b0c4c4ccfe..6a1e8a809c 100755
Binary files a/configure and b/configure differ
diff --git a/configure.ac b/configure.ac
index ba0ecc38b6..66a2ecd848 100644
--- a/configure.ac
+++ b/configure.ac
@@ -210,6 +210,8 @@ AC_SUBST([mkexe_ldflags_exp])
 AC_SUBST([PACKLD])
 AC_SUBST([stdlib_manpages])
 AC_SUBST([compute_deps])
+AC_SUBST([naked_pointers])
+AC_SUBST([naked_pointers_checker])
 AC_SUBST([ocaml_bindir])
 AC_SUBST([ocaml_libdir])
 AC_SUBST([QS])
@@ -221,6 +223,7 @@ AC_CONFIG_FILES([Makefile.config])
 AC_CONFIG_FILES([stdlib/sys.ml])
 AC_CONFIG_FILES([manual/src/version.tex])
 AC_CONFIG_FILES([manual/src/html_processing/src/common.ml])
+AC_CONFIG_FILES([tools/eventlog_metadata])
 AC_CONFIG_FILES([ocamltest/ocamltest_config.ml])
 AC_CONFIG_FILES([utils/config.generated.ml])
 AC_CONFIG_HEADERS([runtime/caml/m.h])
@@ -369,15 +372,23 @@ AC_ARG_ENABLE([frame-pointers],
   [AS_HELP_STRING([--enable-frame-pointers],
     [use frame pointers in runtime and generated code])])
 
-AC_ARG_ENABLE([naked-pointers], [],
-  [AS_IF([test "x$enableval" != 'xno'],
-    [AC_MSG_ERROR([Naked pointers were prohibited in OCaml 5.0.])])],
-  [])
+dnl AC_ARG_ENABLE([naked-pointers], [],
+dnl   [AS_IF([test "x$enableval" != 'xno'],
+dnl     [AC_MSG_ERROR([Naked pointers were prohibited in OCaml 5.0.])])],
+dnl   [])
 
-AC_ARG_ENABLE([naked-pointers-checker], [],
-  [AS_IF([test "x$enableval" != 'xno'],
-    [AC_MSG_ERROR([The naked pointers checker was removed in OCaml 5.0.])])],
-  [])
+dnl AC_ARG_ENABLE([naked-pointers-checker], [],
+dnl   [AS_IF([test "x$enableval" != 'xno'],
+dnl     [AC_MSG_ERROR(m4_normalize([The naked pointers checker was removed in
+dnl       OCaml 5.0.]))])],
+dnl   [])
+AC_ARG_ENABLE([naked-pointers],
+  [AS_HELP_STRING([--disable-naked-pointers],
+    [do not allow naked pointers])])
+
+AC_ARG_ENABLE([naked-pointers-checker],
+  [AS_HELP_STRING([--enable-naked-pointers-checker],
+    [enable the naked pointers checker])])
 
 AC_ARG_ENABLE([spacetime], [],
   [AS_IF([test "x$enableval" != 'xno'],
@@ -608,7 +619,8 @@ AS_CASE([$host],
     [exeext=".exe"],
   [exeext=''])
 
-otherlibraries="dynlink runtime_events"
+dnl otherlibraries="dynlink runtime_events"
+otherlibraries="dynlink"
 lib_dynlink=true
 lib_runtime_events=true
 AS_IF([test x"$enable_unix_lib" != "xno"],
@@ -682,8 +694,9 @@ AS_CASE([$ocaml_cv_cc_vendor],
     cc_warnings=''],
   [outputobj='-o '
   warn_error_flag='-Werror'
-  cc_warnings="-Wall -Wint-conversion -Wstrict-prototypes \
--Wold-style-definition"])
+  cc_warnings="-Wall"])
+dnl  cc_warnings="-Wall -Wint-conversion -Wstrict-prototypes \
+dnl -Wold-style-definition"])
 
 AS_CASE([$enable_warn_error,OCAML__DEVELOPMENT_VERSION],
   [yes,*|,true],
@@ -1023,9 +1036,9 @@ AS_IF([! $arch64],
 
 # Atomics library
 
-AS_IF([! $arch64],
-  [AS_CASE([$ocaml_cv_cc_vendor],
-    [gcc-*], [cclibs="$cclibs -latomic"])])
+dnl AS_IF([! $arch64],
+dnl  [AS_CASE([$ocaml_cv_cc_vendor],
+dnl    [gcc-*], [cclibs="$cclibs -latomic"])])
 
 # Support for C11 atomic types
 
@@ -1183,13 +1196,14 @@ AS_CASE([$host],
   [i686-pc-windows],
     [arch=i386; system=win32],
   [x86_64-pc-windows],
-    [arch=amd64; system=win64],
+    [has_native_backend=yes; arch=amd64; system=win64],
   [[powerpc64le*-*-linux*]],
-    [arch=power; model=ppc64le; system=elf],
+    [has_native_backend=yes; arch=power; model=ppc64le; system=elf],
   [[powerpc*-*-linux*]],
-    [arch=power; AS_IF([$arch64],[model=ppc64],[model=ppc]); system=elf],
+    [has_native_backend=yes; arch=power
+    AS_IF([$arch64],[model=ppc64],[model=ppc]); system=elf],
   [[s390x*-*-linux*]],
-    [arch=s390x; model=z10; system=elf],
+    [has_native_backend=yes; arch=s390x; model=z10; system=elf],
   # expected to match "gnueabihf" as well as "musleabihf"
   [armv6*-*-linux-*eabihf],
     [arch=arm; model=armv6; system=linux_eabihf],
@@ -1226,9 +1240,9 @@ AS_CASE([$host],
   [x86_64-*-linux*],
     [has_native_backend=yes; arch=amd64; system=linux],
   [x86_64-*-gnu*],
-    [arch=amd64; system=gnu],
+    [has_native_backend=yes; arch=amd64; system=gnu],
   [x86_64-*-dragonfly*],
-    [arch=amd64; system=dragonfly],
+    [has_native_backend=yes; arch=amd64; system=dragonfly],
   [x86_64-*-solaris*],
     [has_native_backend=yes; arch=amd64; system=solaris],
   [x86_64-*-freebsd*],
@@ -1238,7 +1252,7 @@ AS_CASE([$host],
   [x86_64-*-openbsd*],
     [has_native_backend=yes; arch=amd64; system=openbsd],
   [x86_64-*-haiku*],
-    [arch=amd64; system=beos],
+    [has_native_backend=yes; arch=amd64; system=beos],
   [arm64-*-darwin*],
     [has_native_backend=yes; arch=arm64; system=macosx],
   [aarch64-*-darwin*],
@@ -1258,7 +1272,7 @@ AS_CASE([$host],
   [x86_64-*-cygwin*],
     [has_native_backend=yes; arch=amd64; system=cygwin],
   [riscv64-*-linux*],
-    [has_native_backend=yes; arch=riscv; model=riscv64; system=linux]
+    [arch=riscv; model=riscv64; system=linux]
 )
 
 AS_CASE([$ccomptype],
@@ -1950,11 +1964,23 @@ AS_CASE([$enable_debug_runtime],
   [no], [debug_runtime=false],
   [debug_runtime=true])
 
+## Determine if system stack overflows can be detected
+
+AC_MSG_CHECKING([whether stack overflows can be detected])
+
+AS_CASE([$arch,$system],
+  [i386,linux_elf|amd64,linux|amd64,macosx \
+    |amd64,openbsd|i386,bsd_elf|arm64,linux|arm64,macosx],
+    [AC_DEFINE([HAS_STACK_OVERFLOW_DETECTION])
+    AC_MSG_RESULT([yes])],
+  [AC_MSG_RESULT([no])])
+
 ## Determine how to link with the POSIX threads library
 
 AS_CASE([$host],
   [*-*-mingw32*|*-pc-windows],
-    [PTHREAD_LIBS="-l:libpthread.a"],
+dnl    [PTHREAD_LIBS="-l:libpthread.a"],
+    [PTHREAD_LIBS=''],
   [AX_PTHREAD(
     [common_cflags="$common_cflags $PTHREAD_CFLAGS"
     saved_CFLAGS="$CFLAGS"
@@ -2005,6 +2031,30 @@ AS_IF([test x"$enable_frame_pointers" = "xyes"],
   [AC_MSG_NOTICE([not using frame pointers])
   frame_pointers=false])
 
+## No naked pointers
+
+AS_IF([test x"$enable_naked_pointers" = "xno" ],
+  [naked_pointers=false
+   AC_DEFINE([NO_NAKED_POINTERS])],
+  [naked_pointers=true])
+
+AS_IF([test x"$enable_naked_pointers_checker" = "xyes" ],
+  [AS_IF([test x"$enable_naked_pointers" = "xno" ],
+         [AC_MSG_ERROR(m4_normalize([
+               --enable-naked-pointers-checker and --disable-naked-pointers
+               are incompatible]))])
+   AS_CASE(["$arch","$system"],
+    [amd64,linux|amd64,macosx \
+    |amd64,openbsd|amd64,win64 \
+    |amd64,freebsd|amd64,solaris \
+    |arm64,linux|arm64,macosx],
+      [naked_pointers_checker=true
+      AC_DEFINE([NAKED_POINTERS_CHECKER])],
+    [*],
+      [AC_MSG_ERROR([naked pointers checker not supported on this platform])]
+  )],
+  [naked_pointers_checker=false])
+
 ## Check for mmap support for huge pages and contiguous heap
 OCAML_MMAP_SUPPORTS_HUGE_PAGES
 
@@ -2151,8 +2201,10 @@ AC_CHECK_LIB(execinfo, backtrace, cclibs="$cclibs -lexecinfo",[])
 
 AS_CASE([$host],
   [*-*-mingw32*],
-    [bytecclibs="-lws2_32 -lversion -l:libpthread.a -lgcc_eh"
-    nativecclibs="-lws2_32 -lversion -l:libpthread.a -lgcc_eh"],
+dnl    [bytecclibs="-lws2_32 -lversion -l:libpthread.a -lgcc_eh"
+dnl    nativecclibs="-lws2_32 -lversion -l:libpthread.a -lgcc_eh"],
+    [bytecclibs="-lws2_32 -lversion -lgcc_eh"
+    nativecclibs="-lws2_32 -lversion -lgcc_eh"],
   [*-pc-windows],
     [bytecclibs="advapi32.lib ws2_32.lib version.lib"
     nativecclibs="advapi32.lib ws2_32.lib version.lib"],
diff --git a/debugger/debugcom.ml b/debugger/debugcom.ml
index 5705cd73db..e852b3bb97 100644
--- a/debugger/debugcom.ml
+++ b/debugger/debugcom.ml
@@ -52,6 +52,7 @@ type pc =
 module Sp = struct
 
   (* Position in the debuggee's stack. *)
+(* BACKPORT BEGIN
   type t = {
     block : int;
     offset : int;
@@ -65,6 +66,13 @@ module Sp = struct
     match Stdlib.compare sp1.block sp2.block with
     | 0 -> Stdlib.compare sp1.offset sp2.offset
     | x -> x
+*)
+  type t = int
+
+  let null = 0
+  let base _ _ = assert false
+  let compare = Int.compare
+(* BACKPORT END *)
 
 end
 
@@ -72,7 +80,11 @@ end
    Numbering starts at 1 and the runtime registers 2 fragments before
    the main program: one for uncaught exceptions and one for callbacks.
 *)
+(* BACKPOR BEGIN
 let main_frag = 3
+*)
+let main_frag = 0
+(* BACKPORT END *)
 
 let set_event {frag; pos} =
   output_char !conn.io_out 'e';
@@ -137,13 +149,21 @@ let do_go_smallint n =
          |  c  -> Misc.fatal_error (Printf.sprintf "Debugcom.do_go %c" c)
        in
        let event_counter = input_binary_int !conn.io_in in
+(* BACKPORT BEGIN
        let block = input_binary_int !conn.io_in in
        let offset = input_binary_int !conn.io_in in
+*)
+       let rep_stack_pointer = input_binary_int !conn.io_in in
+(* BACKPORT END *)
        let frag = input_binary_int !conn.io_in in
        let pos = input_binary_int !conn.io_in in
        { rep_type = summary;
          rep_event_count = Int64.of_int event_counter;
+(* BACKPORT BEGIN
          rep_stack_pointer = Sp.{block; offset};
+*)
+         rep_stack_pointer;
+(* BACKPORT END *)
          rep_program_pointer = {frag; pos} })
 
 let rec do_go n =
@@ -192,11 +212,19 @@ let wait_child chan =
 let initial_frame () =
   output_char !conn.io_out '0';
   flush !conn.io_out;
+(* BACKPORT BEGIN
   let block = input_binary_int !conn.io_in in
   let offset = input_binary_int !conn.io_in in
+*)
+  let stack_pos = input_binary_int !conn.io_in in
+(* BACKPORT END *)
   let frag = input_binary_int !conn.io_in in
   let pos = input_binary_int !conn.io_in in
+(* BACKPORT BEGIN
   (Sp.{block; offset}, {frag; pos})
+*)
+  (stack_pos, {frag; pos})
+(* BACKPOR END *)
 
 let set_initial_frame () =
   ignore(initial_frame ())
@@ -209,9 +237,14 @@ let up_frame stacksize =
   output_char !conn.io_out 'U';
   output_binary_int !conn.io_out stacksize;
   flush !conn.io_out;
+(* BACKPORT BEGIN
   let block = input_binary_int !conn.io_in in
   let offset = input_binary_int !conn.io_in in
+*)
+  let stack_pos = input_binary_int !conn.io_in in
+(* BACKPORT END *)
   let frag, pos =
+(* BACKPORT BEGIN
     if block = -1 then
     begin
       assert (offset = -1);
@@ -221,31 +254,56 @@ let up_frame stacksize =
       let pos = input_binary_int !conn.io_in in
       frag, pos
     end
+*)
+    if stack_pos = -1
+    then 0, 0
+    else let frag = input_binary_int !conn.io_in in
+         let pos = input_binary_int !conn.io_in in
+         frag, pos
+(* BACKPORT END *)
   in
+(* BACKPORT BEGIN
   (Sp.{block; offset}, { frag; pos })
+*)
+  (stack_pos, { frag; pos })
+(* BACKPORT END *)
 
 (* Get and set the current frame position *)
 
 let get_frame () =
   output_char !conn.io_out 'f';
   flush !conn.io_out;
+  let stack_pos = input_binary_int !conn.io_in in
+(*
   let block = input_binary_int !conn.io_in in
   let offset = input_binary_int !conn.io_in in
+*)
   let frag = input_binary_int !conn.io_in in
   let pos = input_binary_int !conn.io_in in
+(*
   (Sp.{block; offset}, {frag; pos})
+*)
+  (stack_pos, {frag; pos})
 
 let set_frame stack_pos =
   output_char !conn.io_out 'S';
+(* BACKPORT BEGIN
   output_binary_int !conn.io_out stack_pos.Sp.block;
   output_binary_int !conn.io_out stack_pos.Sp.offset
+*)
+  output_binary_int !conn.io_out stack_pos
+(* BACKPORT END *)
 
 (* Set the trap barrier to given stack position. *)
 
 let set_trap_barrier pos =
   output_char !conn.io_out 'b';
+(* BACKPORT BEGIN
   output_binary_int !conn.io_out pos.Sp.block;
   output_binary_int !conn.io_out pos.Sp.offset
+*)
+  output_binary_int !conn.io_out pos
+(* BACKPORT END *)
 
 (* Handling of remote values *)
 
diff --git a/debugger/debugcom.mli b/debugger/debugcom.mli
index 4e022dbf10..e9d19edae1 100644
--- a/debugger/debugcom.mli
+++ b/debugger/debugcom.mli
@@ -17,7 +17,11 @@
 (* Low-level communication with the debuggee *)
 
 module Sp : sig
+(* BACKPORT BEGIN
   type t
+*)
+  type t = int
+(* BACKPORT END *)
   val null : t
   val base : t -> int -> t
   val compare : t -> t -> int
diff --git a/debugger/frames.ml b/debugger/frames.ml
index d590367d6d..364fa4ca71 100644
--- a/debugger/frames.ml
+++ b/debugger/frames.ml
@@ -53,7 +53,11 @@ let selected_event_is_before () =
 let rec move_up frame_count event =
   if frame_count <= 0 then event else begin
     let (sp, pc) = up_frame event.ev_ev.ev_stacksize in
+(* BACKPORT BEGIN
     if sp = Sp.null then raise Not_found;
+*)
+    if sp < Sp.null then raise Not_found;
+(* BACKPORT END *)
     move_up (frame_count - 1) (any_event_at_pc pc)
   end
 
@@ -113,7 +117,11 @@ let do_backtrace action =
       begin try
         while action (Some !event) do
           let (sp, pc) = up_frame !event.ev_ev.ev_stacksize in
+(* BACKPORT BEGIN
           if sp = Sp.null then raise Exit;
+*)
+          if sp < Sp.null then raise Exit;
+(* BACKPORT END *)
           event := any_event_at_pc pc
         done
       with Exit -> ()
diff --git a/debugger/time_travel.ml b/debugger/time_travel.ml
index b05d05767b..7a2665d305 100644
--- a/debugger/time_travel.ml
+++ b/debugger/time_travel.ml
@@ -555,7 +555,11 @@ let finish () =
   | Some {ev_ev={ev_stacksize}} ->
       set_initial_frame();
       let (frame, pc) = up_frame ev_stacksize in
+(* BACKPORT BEGIN
       if frame = Sp.null then begin
+*)
+      if frame < Sp.null then begin
+(* BACKPORT END *)
         prerr_endline "`finish' not meaningful in outermost frame.";
         raise Toplevel
       end;
@@ -598,9 +602,14 @@ let next_1 () =
         | Some {ev_ev={ev_stacksize=ev_stacksize2}} ->
             let (frame2, _pc2) = initial_frame() in
             (* Call `finish' if we've entered a function. *)
+(* BACKPORT BEGIN
             if frame1 <> Sp.null && frame2 <> Sp.null &&
                Sp.(compare (base frame2 ev_stacksize2)
                      (base frame1 ev_stacksize1)) > 0
+*)
+            if frame1 >= 0 && frame2 >= 0 &&
+               frame2 - ev_stacksize2 > frame1 - ev_stacksize1
+(* BACKPORT END *)
             then finish()
       end
 
@@ -623,7 +632,11 @@ let start () =
   | Some {ev_ev={ev_stacksize}} ->
       let (frame, _) = initial_frame() in
       let (frame', pc) = up_frame ev_stacksize in
+(* BACKPORT BEGIN
       if frame' = Sp.null then begin
+*)
+      if frame' < Sp.null then begin
+(* BACKPORT END *)
         prerr_endline "`start not meaningful in outermost frame.";
         raise Toplevel
       end;
@@ -645,7 +658,11 @@ let start () =
             step _minus1;
             (not !interrupted)
               &&
+(* BACKPORT BEGIN
             Sp.(compare (base frame' nargs) (base frame ev_stacksize)) > 0
+*)
+            (frame' - nargs > frame - ev_stacksize)
+(* BACKPORT END *)
         | _ ->
             false
       do
@@ -667,9 +684,14 @@ let previous_1 () =
         | Some {ev_ev={ev_stacksize=ev_stacksize2}} ->
             let (frame2, _pc2) = initial_frame() in
             (* Call `start' if we've entered a function. *)
+(* BACKPORT BEGIN
             if frame1 <> Sp.null && frame2 <> Sp.null &&
               Sp.(compare (base frame2 ev_stacksize2)
                     (base frame1 ev_stacksize1)) > 0
+*)
+            if frame1 >= 0 && frame2 >= 0 &&
+               frame2 - ev_stacksize2 > frame1 - ev_stacksize1
+(* BACKPORT END *)
             then start()
       end
 
diff --git a/diff-against-4.14-runtime.diff b/diff-against-4.14-runtime.diff
new file mode 100644
index 0000000000..7fe9834336
--- /dev/null
+++ b/diff-against-4.14-runtime.diff
@@ -0,0 +1,2452 @@
+diff --git a/otherlibs/systhreads/st_posix.h b/otherlibs/systhreads/st_posix.h
+index 957f4717b6..09b243f6a5 100644
+--- a/otherlibs/systhreads/st_posix.h
++++ b/otherlibs/systhreads/st_posix.h
+@@ -446,7 +446,7 @@ static value st_encode_sigset(sigset_t * set)
+ 
+ static int sigmask_cmd[3] = { SIG_SETMASK, SIG_BLOCK, SIG_UNBLOCK };
+ 
+-value caml_thread_sigmask(value cmd, value sigs) /* ML */
++value caml_thread_sigmask(value cmd, value sigs)
+ {
+   int how;
+   sigset_t set, oldset;
+@@ -463,7 +463,7 @@ value caml_thread_sigmask(value cmd, value sigs) /* ML */
+   return st_encode_sigset(&oldset);
+ }
+ 
+-value caml_wait_signal(value sigs) /* ML */
++value caml_wait_signal(value sigs)
+ {
+ #ifdef HAS_SIGWAIT
+   sigset_t set;
+diff --git a/otherlibs/systhreads/st_stubs.c b/otherlibs/systhreads/st_stubs.c
+index 043e07031e..9dc38727a5 100644
+--- a/otherlibs/systhreads/st_stubs.c
++++ b/otherlibs/systhreads/st_stubs.c
+@@ -430,7 +430,7 @@ static void caml_thread_reinitialize(void)
+ 
+ /* Initialize the thread machinery */
+ 
+-CAMLprim value caml_thread_initialize(value unit)   /* ML */
++CAMLprim value caml_thread_initialize(value unit)
+ {
+   /* Protect against repeated initialization (PR#3532) */
+   if (curr_thread != NULL) return Val_unit;
+@@ -483,7 +483,7 @@ CAMLprim value caml_thread_initialize(value unit)   /* ML */
+    thread take 25ms on average / 50ms in the worst case, so we don't do it on
+    program exit. */
+ 
+-CAMLprim value caml_thread_cleanup(value unit)   /* ML */
++CAMLprim value caml_thread_cleanup(value unit)
+ {
+   if (caml_tick_thread_running){
+     caml_tick_thread_stop = 1;
+@@ -556,7 +556,7 @@ static ST_THREAD_FUNCTION caml_thread_start(void * arg)
+   return 0;
+ }
+ 
+-CAMLprim value caml_thread_new(value clos)          /* ML */
++CAMLprim value caml_thread_new(value clos)
+ {
+   caml_thread_t th;
+   st_retcode err;
+@@ -663,7 +663,7 @@ CAMLexport int caml_c_thread_unregister(void)
+ 
+ /* Return the current thread */
+ 
+-CAMLprim value caml_thread_self(value unit)         /* ML */
++CAMLprim value caml_thread_self(value unit)
+ {
+   if (curr_thread == NULL)
+     caml_invalid_argument("Thread.self: not initialized");
+@@ -672,14 +672,14 @@ CAMLprim value caml_thread_self(value unit)         /* ML */
+ 
+ /* Return the identifier of a thread */
+ 
+-CAMLprim value caml_thread_id(value th)          /* ML */
++CAMLprim value caml_thread_id(value th)
+ {
+   return Ident(th);
+ }
+ 
+ /* Print uncaught exception and backtrace */
+ 
+-CAMLprim value caml_thread_uncaught_exception(value exn)  /* ML */
++CAMLprim value caml_thread_uncaught_exception(value exn)
+ {
+   char * msg = caml_format_exception(exn);
+   fprintf(stderr, "Thread %d killed on uncaught exception %s\n",
+@@ -692,7 +692,7 @@ CAMLprim value caml_thread_uncaught_exception(value exn)  /* ML */
+ 
+ /* Terminate current thread */
+ 
+-CAMLprim value caml_thread_exit(value unit)   /* ML */
++CAMLprim value caml_thread_exit(value unit)
+ {
+   struct longjmp_buffer * exit_buf = NULL;
+ 
+@@ -723,7 +723,7 @@ CAMLprim value caml_thread_exit(value unit)   /* ML */
+ 
+ /* Allow re-scheduling */
+ 
+-CAMLprim value caml_thread_yield(value unit)        /* ML */
++CAMLprim value caml_thread_yield(value unit)
+ {
+   if (st_masterlock_waiters(&caml_master_lock) == 0) return Val_unit;
+ 
+@@ -744,7 +744,7 @@ CAMLprim value caml_thread_yield(value unit)        /* ML */
+ 
+ /* Suspend the current thread until another thread terminates */
+ 
+-CAMLprim value caml_thread_join(value th)          /* ML */
++CAMLprim value caml_thread_join(value th)
+ {
+   st_retcode rc = caml_threadstatus_wait(Terminated(th));
+   st_check_error(rc, "Thread.join");
+@@ -783,7 +783,7 @@ static struct custom_operations caml_mutex_ops = {
+   custom_fixed_length_default
+ };
+ 
+-CAMLprim value caml_mutex_new(value unit)        /* ML */
++CAMLprim value caml_mutex_new(value unit)
+ {
+   st_mutex mut = NULL;          /* suppress warning */
+   value wrapper;
+@@ -794,7 +794,7 @@ CAMLprim value caml_mutex_new(value unit)        /* ML */
+   return wrapper;
+ }
+ 
+-CAMLprim value caml_mutex_lock(value wrapper)     /* ML */
++CAMLprim value caml_mutex_lock(value wrapper)
+ {
+   st_mutex mut = Mutex_val(wrapper);
+   st_retcode retcode;
+@@ -811,7 +811,7 @@ CAMLprim value caml_mutex_lock(value wrapper)     /* ML */
+   return Val_unit;
+ }
+ 
+-CAMLprim value caml_mutex_unlock(value wrapper)           /* ML */
++CAMLprim value caml_mutex_unlock(value wrapper)
+ {
+   st_mutex mut = Mutex_val(wrapper);
+   st_retcode retcode;
+@@ -821,7 +821,7 @@ CAMLprim value caml_mutex_unlock(value wrapper)           /* ML */
+   return Val_unit;
+ }
+ 
+-CAMLprim value caml_mutex_try_lock(value wrapper)           /* ML */
++CAMLprim value caml_mutex_try_lock(value wrapper)
+ {
+   st_mutex mut = Mutex_val(wrapper);
+   st_retcode retcode;
+@@ -863,7 +863,7 @@ static struct custom_operations caml_condition_ops = {
+   custom_fixed_length_default
+ };
+ 
+-CAMLprim value caml_condition_new(value unit)        /* ML */
++CAMLprim value caml_condition_new(value unit)
+ {
+   st_condvar cond = NULL;       /* suppress warning */
+   value wrapper;
+@@ -874,7 +874,7 @@ CAMLprim value caml_condition_new(value unit)        /* ML */
+   return wrapper;
+ }
+ 
+-CAMLprim value caml_condition_wait(value wcond, value wmut)           /* ML */
++CAMLprim value caml_condition_wait(value wcond, value wmut)
+ {
+   st_condvar cond = Condition_val(wcond);
+   st_mutex mut = Mutex_val(wmut);
+@@ -889,14 +889,14 @@ CAMLprim value caml_condition_wait(value wcond, value wmut)           /* ML */
+   return Val_unit;
+ }
+ 
+-CAMLprim value caml_condition_signal(value wrapper)           /* ML */
++CAMLprim value caml_condition_signal(value wrapper)
+ {
+   st_check_error(st_condvar_signal(Condition_val(wrapper)),
+                  "Condition.signal");
+   return Val_unit;
+ }
+ 
+-CAMLprim value caml_condition_broadcast(value wrapper)           /* ML */
++CAMLprim value caml_condition_broadcast(value wrapper)
+ {
+   st_check_error(st_condvar_broadcast(Condition_val(wrapper)),
+                  "Condition.broadcast");
+diff --git a/otherlibs/systhreads/st_win32.h b/otherlibs/systhreads/st_win32.h
+index 3f598a715d..21eb674fc5 100644
+--- a/otherlibs/systhreads/st_win32.h
++++ b/otherlibs/systhreads/st_win32.h
+@@ -525,13 +525,13 @@ static DWORD st_atfork(void (*fn)(void))
+ 
+ /* Signal handling -- none under Win32 */
+ 
+-value caml_thread_sigmask(value cmd, value sigs) /* ML */
++value caml_thread_sigmask(value cmd, value sigs)
+ {
+   caml_invalid_argument("Thread.sigmask not implemented");
+   return Val_int(0);            /* not reached */
+ }
+ 
+-value caml_wait_signal(value sigs) /* ML */
++value caml_wait_signal(value sigs)
+ {
+   caml_invalid_argument("Thread.wait_signal not implemented");
+   return Val_int(0);            /* not reached */
+diff --git a/runtime/HACKING.adoc b/runtime/HACKING.adoc
+new file mode 100644
+index 0000000000..bf18b5a7d1
+--- /dev/null
++++ b/runtime/HACKING.adoc
+@@ -0,0 +1,156 @@
++= Tips on hacking the OCaml runtime system =
++
++== Linking a test program with the debug runtime ==
++
++Suppose you have a self-contained OCaml program `test.ml` that
++crashes, you are working on a development repository (not an installed
++version of your system). You probably want to run `test.ml` against
++the "debug runtime", which in particular activates the `CAMLassert`
++debug assertions.
++
++If you want to use the bytecode compiler:
++
++----
++# build the runtime
++make runtime -j
++
++# compile as usual
++./ocamlc.opt -nostdlib -I stdlib test.ml -o test
++
++# run with the debug runtime (ocamlrund)
++./runtime/ocamlrund ./test
++----
++
++If you want to use the native compiler:
++
++----
++# build the native runtime
++make runtimeopt -j
++
++# compile with "-runtime-variant d"
++./ocamlopt.opt -nostdlib -I stdlib -runtime-variant d -I runtime test.ml -o test
++
++./test
++----
++
++Note that the debug runtime does extra work, so it may slow down your
++program -- and sometimes make the issue you are trying to debug
++vanish.
++
++== GC messages ==
++
++The GC can send various messages about what it is doing, enabled with
++the "v" option of OCAMLRUNPARAM. Various options are more or less
++documented in
++link:https://ocaml.org/manual/runtime.html#s:ocamlrun-options[].
++You can enable all printing with
++
++----
++OCAMLRUNPARAM="v=0xffffffff" ./test
++----
++
++Note: `caml_gc_log` can be used to show log messages prefixed with the
++thread number, and it corresponds to the more precise setting
++`v=0x800`.
++
++== Heap verification ==
++
++Another useful OCAMLRUNPARAM setting is `V=1`, which enables
++additional sanity checks on the heap during major GC cycles.
++
++----
++OCAMLRUNPARAM="V=1" ./test
++----
++
++== Getting stack traces after assertion failures (Linux) ==
++
++The output of a crashing OCaml program may end up like this:
++
++----
++[03] file domain.c; line 404 ### Assertion failed: domain_state->young_start == NULL
++Aborted (core dumped)
++----
++
++The message "core dumped" indicates that some debugging information was kept on the disk.
++
++On Linux, systemd-enabled systems tend to use a systemd tool (of course!) to store core dumps.
++
++----
++# ask your system how core dumps are handled.
++$ cat /proc/sys/kernel/core_pattern
++|/usr/lib/systemd/systemd-coredump %P %u %g %s %t %c %h
++----
++
++If your system is also using `systemd-coredump`, then the command
++`coredumpctl dump` will show you information about the last "core
++dump".
++
++----
++$ $ coredumpctl dump
++           PID: 678260 (Domain0)
++           UID: 1000 (gasche)
++           GID: 1000 (gasche)
++        Signal: 6 (ABRT)
++     Timestamp: Fri 2022-02-25 09:30:32 CET (4min 30s ago)
++  Command Line: ./test
++    Executable: /home/gasche/Prog/ocaml/github-max_domains/test
++ Control Group: [...]
++                [...]
++     Disk Size: 133.0K
++       Message: Process 678260 (Domain0) of user 1000 dumped core.
++
++                Stack trace of thread 678266:
++                #0  0x00007f60ee4842a2 raise (libc.so.6 + 0x3d2a2)
++                #1  0x00007f60ee46d8a4 abort (libc.so.6 + 0x268a4)
++                #2  0x0000000000475022 n/a (/home/gasche/Prog/ocaml/github-max_domains/test + 0x75022)
++Refusing to dump core to tty (use shell redirection or specify --output).
++----
++
++You can get a full backtrace using `echo bt | coredumpctl debug`:
++
++----
++$ echo bt | coredumpctl debug
++[...]
++Core was generated by `./test'.
++Program terminated with signal SIGABRT, Aborted.
++#0  0x00007f60ee4842a2 in raise () from /lib64/libc.so.6
++[Current thread is 1 (Thread 0x7f60d77fe640 (LWP 678266))]
++Missing separate debuginfos, use: dnf debuginfo-install glibc-2.33-20.fc34.x86_64
++(gdb) #0  0x00007f60ee4842a2 in raise () from /lib64/libc.so.6
++#1  0x00007f60ee46d8a4 in abort () from /lib64/libc.so.6
++#2  0x0000000000475022 in caml_failed_assert (
++    expr=expr@entry=0x488498 "domain_state->young_start == NULL",
++    file_os=file_os@entry=0x488218 "domain.c", line=line@entry=404) at misc.c:56
++#3  0x0000000000461831 in caml_free_minor_heap () at domain.c:404
++#4  0x000000000046237b in caml_reallocate_minor_heap (wsize=wsize@entry=786432) at domain.c:469
++#5  0x0000000000474404 in caml_set_minor_heap_size (wsize=wsize@entry=786432) at minor_gc.c:130
++#6  0x00000000004696b3 in caml_gc_set (v=<optimized out>) at gc_ctrl.c:222
++#7  <signal handler called>
++#8  0x000000000042a3b2 in camlTest__set_gc_280 () at test.ml:17
++#9  0x000000000042a818 in camlTest__fun_529 () at test.ml:39
++#10 0x000000000044947a in camlStdlib__Domain__body_694 () at domain.ml:204
++#11 <signal handler called>
++#12 0x000000000045fe38 in caml_callback_exn (closure=<optimized out>, arg=<optimized out>, arg@entry=1) at callback.c:169
++#13 0x0000000000460369 in caml_callback (closure=<optimized out>, arg=arg@entry=1) at callback.c:253
++#14 0x0000000000461f6a in domain_thread_func (v=0x7ffdd7357bb0) at domain.c:1034
++#15 0x00007f60ee61f299 in start_thread () from /lib64/libpthread.so.0
++#16 0x00007f60ee547353 in clone () from /lib64/libc.so.6
++(gdb) quit
++----
++
++== Using `rr` for deterministic replay debugging ==
++
++There is a lot of information on how to use `rr` to debug the OCaml
++runtime on the OCaml Multicore wiki:
++link:https://github.com/ocaml-multicore/ocaml-multicore/wiki/Debugging-the-OCaml-Multicore-runtime#rr[].
++
++TODO: it would be nice to migrate some information here.
++
++== Compiling with sanitizers ==
++
++TODO: I would be curious to know!
++
++(For the brave there are some scripts in
++link:../tools/ci/inria/sanitizers/script[], but you probably don't
++want to run them directly, in particular they will `git clean -xfd`,
++destroying changed/uncommitted files in your development repository!)
+diff --git a/runtime/Makefile b/runtime/Makefile
+deleted file mode 100644
+index f5c08d8798..0000000000
+--- a/runtime/Makefile
++++ /dev/null
+@@ -1,421 +0,0 @@
+-#**************************************************************************
+-#*                                                                        *
+-#*                                 OCaml                                  *
+-#*                                                                        *
+-#*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *
+-#*                                                                        *
+-#*   Copyright 1999 Institut National de Recherche en Informatique et     *
+-#*     en Automatique.                                                    *
+-#*                                                                        *
+-#*   All rights reserved.  This file is distributed under the terms of    *
+-#*   the GNU Lesser General Public License version 2.1, with the          *
+-#*   special exception on linking described in the file LICENSE.          *
+-#*                                                                        *
+-#**************************************************************************
+-
+-ROOTDIR = ..
+-
+-include $(ROOTDIR)/Makefile.common
+-
+-# Lists of source files
+-
+-BYTECODE_C_SOURCES := $(addsuffix .c, \
+-  interp misc stacks fix_code startup_aux startup_byt freelist major_gc \
+-  minor_gc memory alloc roots_byt globroots fail_byt signals \
+-  signals_byt printexc backtrace_byt backtrace compare ints eventlog \
+-  floats str array io extern intern hash sys meta parsing gc_ctrl md5 obj \
+-  lexing callback debugger weak compact finalise custom dynlink \
+-  afl $(UNIX_OR_WIN32) bigarray main memprof domain \
+-  skiplist codefrag)
+-
+-NATIVE_C_SOURCES := $(addsuffix .c, \
+-  startup_aux startup_nat main fail_nat roots_nat signals \
+-  signals_nat misc freelist major_gc minor_gc memory alloc compare ints \
+-  floats str array io extern intern hash sys parsing gc_ctrl eventlog md5 obj \
+-  lexing $(UNIX_OR_WIN32) printexc callback weak compact finalise custom \
+-  globroots backtrace_nat backtrace dynlink_nat debugger meta \
+-  dynlink clambda_checks afl bigarray \
+-  memprof domain skiplist codefrag)
+-
+-# Header files generated by configure
+-CONFIGURED_HEADERS := caml/m.h caml/s.h caml/version.h
+-
+-# Header files generated by make
+-BUILT_HEADERS := caml/opnames.h caml/jumptbl.h build_config.h
+-
+-ifeq "$(TOOLCHAIN)" "msvc"
+-ASM_EXT := asm
+-ASM_SOURCES := $(ARCH)nt.$(ASM_EXT)
+-else
+-ASM_EXT := S
+-ASM_SOURCES := $(ARCH).$(ASM_EXT)
+-endif
+-
+-# Targets to build and install
+-
+-PROGRAMS := ocamlrun$(EXE)
+-BYTECODE_STATIC_LIBRARIES := ld.conf libcamlrun.$(A)
+-BYTECODE_SHARED_LIBRARIES :=
+-NATIVE_STATIC_LIBRARIES := libasmrun.$(A)
+-NATIVE_SHARED_LIBRARIES :=
+-
+-ifeq "$(RUNTIMED)" "true"
+-PROGRAMS += ocamlrund$(EXE)
+-BYTECODE_STATIC_LIBRARIES += libcamlrund.$(A)
+-NATIVE_STATIC_LIBRARIES += libasmrund.$(A)
+-endif
+-
+-ifeq "$(INSTRUMENTED_RUNTIME)" "true"
+-PROGRAMS += ocamlruni$(EXE)
+-BYTECODE_STATIC_LIBRARIES += libcamlruni.$(A)
+-NATIVE_STATIC_LIBRARIES += libasmruni.$(A)
+-endif
+-
+-ifeq "$(UNIX_OR_WIN32)" "unix"
+-ifeq "$(SUPPORTS_SHARED_LIBRARIES)" "true"
+-BYTECODE_STATIC_LIBRARIES += libcamlrun_pic.$(A)
+-BYTECODE_SHARED_LIBRARIES += libcamlrun_shared.$(SO)
+-NATIVE_STATIC_LIBRARIES += libasmrun_pic.$(A)
+-NATIVE_SHARED_LIBRARIES += libasmrun_shared.$(SO)
+-endif
+-endif
+-
+-# List of object files for each target
+-
+-ASM_OBJECTS := $(ASM_SOURCES:.$(ASM_EXT)=.$(O))
+-
+-libcamlrun_OBJECTS := $(BYTECODE_C_SOURCES:.c=.b.$(O))
+-
+-libcamlrun_non_shared_OBJECTS := \
+-  $(subst $(UNIX_OR_WIN32).b.$(O),$(UNIX_OR_WIN32)_non_shared.b.$(O), \
+-          $(libcamlrun_OBJECTS))
+-
+-libcamlrund_OBJECTS := $(BYTECODE_C_SOURCES:.c=.bd.$(O)) \
+-  instrtrace.bd.$(O)
+-
+-libcamlruni_OBJECTS := $(BYTECODE_C_SOURCES:.c=.bi.$(O))
+-
+-libcamlrunpic_OBJECTS := $(BYTECODE_C_SOURCES:.c=.bpic.$(O))
+-
+-libasmrun_OBJECTS := $(NATIVE_C_SOURCES:.c=.n.$(O)) $(ASM_OBJECTS)
+-
+-libasmrund_OBJECTS := $(NATIVE_C_SOURCES:.c=.nd.$(O)) $(ASM_OBJECTS)
+-
+-libasmruni_OBJECTS := $(NATIVE_C_SOURCES:.c=.ni.$(O)) $(ASM_OBJECTS)
+-
+-libasmrunpic_OBJECTS := $(NATIVE_C_SOURCES:.c=.npic.$(O)) \
+-  $(ASM_OBJECTS:.$(O)=_libasmrunpic.$(O))
+-
+-# General (non target-specific) assembler and compiler flags
+-
+-ifneq "$(CCOMPTYPE)" "msvc"
+-OC_CFLAGS += -g
+-endif
+-
+-OC_CPPFLAGS += -DCAMLDLLIMPORT=
+-
+-OC_NATIVE_CPPFLAGS = -DNATIVE_CODE -DTARGET_$(ARCH)
+-
+-ifeq "$(UNIX_OR_WIN32)" "unix"
+-OC_NATIVE_CPPFLAGS += -DMODEL_$(MODEL)
+-endif
+-
+-OC_NATIVE_CPPFLAGS += -DSYS_$(SYSTEM)
+-
+-OC_DEBUG_CPPFLAGS=-DDEBUG
+-OC_INSTR_CPPFLAGS=-DCAML_INSTR
+-
+-ifeq "$(TOOLCHAIN)" "msvc"
+-ASMFLAGS=
+-endif
+-
+-ASPPFLAGS = -DSYS_$(SYSTEM) -I$(ROOTDIR)/runtime
+-ifeq "$(UNIX_OR_WIN32)" "unix"
+-ASPPFLAGS += -DMODEL_$(MODEL)
+-endif
+-
+-# Commands used to build native libraries
+-
+-LIBS := $(BYTECCLIBS)
+-
+-ifeq "$(UNIX_OR_WIN32)" "win32"
+-LIBS += $(EXTRALIBS)
+-endif
+-
+-# Build, install and clean targets
+-
+-.PHONY: all
+-all: $(BYTECODE_STATIC_LIBRARIES) $(BYTECODE_SHARED_LIBRARIES) $(PROGRAMS) \
+-     sak$(EXE)
+-
+-.PHONY: allopt
+-ifneq "$(NATIVE_COMPILER)" "false"
+-allopt: $(NATIVE_STATIC_LIBRARIES) $(NATIVE_SHARED_LIBRARIES)
+-else
+-allopt:
+-	$(error The build has been configured with --disable-native-compiler)
+-endif
+-
+-INSTALL_INCDIR=$(INSTALL_LIBDIR)/caml
+-.PHONY: install
+-install:
+-	$(INSTALL_PROG) $(PROGRAMS) "$(INSTALL_BINDIR)"
+-	$(INSTALL_DATA) $(BYTECODE_STATIC_LIBRARIES) "$(INSTALL_LIBDIR)"
+-ifneq "$(BYTECODE_SHARED_LIBRARIES)" ""
+-	$(INSTALL_PROG) $(BYTECODE_SHARED_LIBRARIES) "$(INSTALL_LIBDIR)"
+-endif
+-	mkdir -p "$(INSTALL_INCDIR)"
+-	$(INSTALL_DATA) caml/domain_state.tbl caml/*.h "$(INSTALL_INCDIR)"
+-
+-.PHONY: installopt
+-installopt:
+-	$(INSTALL_DATA) $(NATIVE_STATIC_LIBRARIES) "$(INSTALL_LIBDIR)"
+-ifneq "$(NATIVE_SHARED_LIBRARIES)" ""
+-	$(INSTALL_PROG) $(NATIVE_SHARED_LIBRARIES) "$(INSTALL_LIBDIR)"
+-endif
+-
+-.PHONY: clean
+-clean:
+-	rm -f *.o *.obj *.a *.lib *.so *.dll ld.conf
+-	rm -f ocamlrun ocamlrund ocamlruni ocamlruns sak
+-	rm -f ocamlrun.exe ocamlrund.exe ocamlruni.exe ocamlruns.exe sak.exe
+-	rm -f primitives primitives.new prims.c $(BUILT_HEADERS)
+-	rm -f domain_state*.inc
+-	rm -rf $(DEPDIR)
+-
+-.PHONY: distclean
+-distclean: clean
+-	rm -f $(CONFIGURED_HEADERS)
+-
+-# Generated non-object files
+-
+-ld.conf: $(ROOTDIR)/Makefile.config
+-	echo "$(STUBLIBDIR)" > $@
+-	echo "$(LIBDIR)" >> $@
+-
+-# If primitives contain duplicated lines (e.g. because the code is defined
+-# like
+-# #ifdef X
+-# CAMLprim value caml_foo() ...
+-# #else
+-# CAMLprim value caml_foo() ...
+-# end), horrible things will happen (duplicated entries in Runtimedef ->
+-# double registration in Symtable -> empty entry in the PRIM table ->
+-# the bytecode interpreter is confused).
+-# We sort the primitive file and remove duplicates to avoid this problem.
+-
+-# Warning: we use "sort | uniq" instead of "sort -u" because in the MSVC
+-# port, the "sort" program in the path is Microsoft's and not cygwin's
+-
+-# Warning: POSIX sort is locale dependent, that's why we set LC_ALL explicitly.
+-# Sort is unstable for "is_directory" and "isatty"
+-# see http://pubs.opengroup.org/onlinepubs/9699919799/utilities/sort.html:
+-# "using sort to process pathnames, it is recommended that LC_ALL .. set to C"
+-
+-# To speed up builds, we avoid changing "primitives" when files
+-# containing primitives change but the primitives table does not
+-primitives: $(shell ./gen_primitives.sh > primitives.new; \
+-                    cmp -s primitives primitives.new || echo primitives.new)
+-	cp $^ $@
+-
+-prims.c : primitives
+-	(echo '#define CAML_INTERNALS'; \
+-         echo '#include "caml/mlvalues.h"'; \
+-	 echo '#include "caml/prims.h"'; \
+-	 sed -e 's/.*/extern value &();/' primitives; \
+-	 echo 'c_primitive caml_builtin_cprim[] = {'; \
+-	 sed -e 's/.*/  &,/' primitives; \
+-	 echo '  0 };'; \
+-	 echo 'char * caml_names_of_builtin_cprim[] = {'; \
+-	 sed -e 's/.*/  "&",/' primitives; \
+-	 echo '  0 };') > prims.c
+-
+-caml/opnames.h : caml/instruct.h
+-	tr -d '\r' < $< | \
+-	sed -e '/\/\*/d' \
+-	    -e '/^#/d' \
+-	    -e 's/enum /static char * names_of_/' \
+-	    -e 's/{$$/[] = {/' \
+-	    -e 's/\([[:upper:]][[:upper:]_0-9]*\)/"\1"/g' > $@
+-
+-# caml/jumptbl.h is required only if you have GCC 2.0 or later
+-caml/jumptbl.h : caml/instruct.h
+-	tr -d '\r' < $< | \
+-	sed -n -e '/^  /s/ \([A-Z]\)/ \&\&lbl_\1/gp' \
+-	       -e '/^}/q' > $@
+-# These are provided as a temporary shim to allow cross-compilation systems
+-# to supply a host C compiler and different flags and a linking macro.
+-SAK_CC ?= $(CC)
+-SAK_CFLAGS ?= $(OC_CFLAGS) $(CFLAGS) $(OC_CPPFLAGS) $(CPPFLAGS)
+-SAK_LINK ?= $(MKEXE_USING_COMPILER)
+-
+-sak$(EXE): sak.$(O)
+-	$(call SAK_LINK,$@,$^)
+-
+-sak.$(O): sak.c caml/misc.h caml/config.h
+-	$(SAK_CC) -c $(SAK_CFLAGS) $(OUTPUTOBJ)$@ $<
+-
+-C_LITERAL = $(shell ./sak$(EXE) encode-C-literal '$(1)')
+-
+-build_config.h: $(ROOTDIR)/Makefile.config sak$(EXE)
+-	echo '/* This file is generated from $(ROOTDIR)/Makefile.config */' > $@
+-	echo '#define OCAML_STDLIB_DIR $(call C_LITERAL,$(LIBDIR))' >> $@
+-	echo '#define HOST "$(HOST)"' >> $@
+-
+-# Libraries and programs
+-
+-ocamlrun$(EXE): prims.$(O) libcamlrun.$(A)
+-	$(MKEXE) -o $@ $^ $(LIBS)
+-
+-ocamlruns$(EXE): prims.$(O) libcamlrun_non_shared.$(A)
+-	$(call MKEXE_USING_COMPILER,$@,$^ $(LIBS))
+-
+-libcamlrun.$(A): $(libcamlrun_OBJECTS)
+-	$(call MKLIB,$@, $^)
+-
+-libcamlrun_non_shared.$(A): $(libcamlrun_non_shared_OBJECTS)
+-	$(call MKLIB,$@, $^)
+-
+-ocamlrund$(EXE): prims.$(O) libcamlrund.$(A)
+-	$(MKEXE) $(MKEXEDEBUGFLAG) -o $@ $^ $(LIBS)
+-
+-libcamlrund.$(A): $(libcamlrund_OBJECTS)
+-	$(call MKLIB,$@, $^)
+-
+-ocamlruni$(EXE): prims.$(O) libcamlruni.$(A)
+-	$(MKEXE) -o $@ $^ $(INSTRUMENTED_RUNTIME_LIBS) $(LIBS)
+-
+-libcamlruni.$(A): $(libcamlruni_OBJECTS)
+-	$(call MKLIB,$@, $^)
+-
+-libcamlrun_pic.$(A): $(libcamlrunpic_OBJECTS)
+-	$(call MKLIB,$@, $^)
+-
+-libcamlrun_shared.$(SO): $(libcamlrunpic_OBJECTS)
+-	$(MKDLL) -o $@ $^ $(BYTECCLIBS)
+-
+-libasmrun.$(A): $(libasmrun_OBJECTS)
+-	$(call MKLIB,$@, $^)
+-
+-libasmrund.$(A): $(libasmrund_OBJECTS)
+-	$(call MKLIB,$@, $^)
+-
+-libasmruni.$(A): $(libasmruni_OBJECTS)
+-	$(call MKLIB,$@, $^)
+-
+-libasmrun_pic.$(A): $(libasmrunpic_OBJECTS)
+-	$(call MKLIB,$@, $^)
+-
+-libasmrun_shared.$(SO): $(libasmrunpic_OBJECTS)
+-	$(MKDLL) -o $@ $^ $(NATIVECCLIBS)
+-
+-# Target-specific preprocessor and compiler flags
+-
+-%.bd.$(O): OC_CPPFLAGS += $(OC_DEBUG_CPPFLAGS)
+-%.bd.$(D): OC_CPPFLAGS += $(OC_DEBUG_CPPFLAGS)
+-
+-%.bi.$(O): OC_CPPFLAGS += $(OC_INSTR_CPPFLAGS)
+-%.bi.$(D): OC_CPPFLAGS += $(OC_INSTR_CPPFLAGS)
+-
+-%.bpic.$(O): OC_CFLAGS += $(SHAREDLIB_CFLAGS)
+-
+-%.n.$(O): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS)
+-%.n.$(D): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS)
+-
+-%.nd.$(O): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS) $(OC_DEBUG_CPPFLAGS)
+-%.nd.$(D): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS) $(OC_DEBUG_CPPFLAGS)
+-
+-%.ni.$(O): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS) $(OC_INSTR_CPPFLAGS)
+-%.ni.$(D): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS) $(OC_INSTR_CPPFLAGS)
+-
+-%.npic.$(O): OC_CFLAGS += $(SHAREDLIB_CFLAGS)
+-%.npic.$(O): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS)
+-%.npic.$(D): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS)
+-
+-# Compilation of C files
+-
+-# The COMPILE_C_FILE macro below receives as argument the pattern
+-# that corresponds to the name of the generated object file
+-# (without the extension, which is added by the macro)
+-define COMPILE_C_FILE
+-ifneq "$(COMPUTE_DEPS)" "false"
+-ifneq "$(1)" "%"
+-# -MG would ensure that the dependencies are generated even if the files listed
+-# in $$(BUILT_HEADERS) haven't been assembled yet. However, this goes subtly
+-# wrong if the user has the headers installed, as gcc will pick up a dependency
+-# on those instead and the local ones will not be generated. For this reason, we
+-# don't use -MG and instead include $(BUILT_HEADERS) in the order only
+-# dependencies to ensure that they exist before dependencies are computed.
+-$(DEPDIR)/$(1).$(D): %.c | $(DEPDIR) $(BUILT_HEADERS)
+-	$$(DEP_CC) $$(OC_CPPFLAGS) $$(CPPFLAGS) $$< -MT \
+-	  '$$*$(subst %,,$(1)).$(O)' -MF $$@
+-endif # ifneq "$(1)" "%"
+-$(1).$(O): $(2).c
+-else
+-$(1).$(O): $(2).c $(CONFIGURED_HEADERS) $(BUILT_HEADERS) $(RUNTIME_HEADERS)
+-endif # ifneq "$(COMPUTE_DEPS)" "false"
+-	$$(CC) -c $$(OC_CFLAGS) $$(CFLAGS) $$(OC_CPPFLAGS) $$(CPPFLAGS) \
+-	  $$(OUTPUTOBJ)$$@ $$<
+-endef
+-
+-object_types := % %.b %.bd %.bi %.bpic
+-ifneq "$(NATIVE_COMPILER)" "false"
+-object_types += %.n %.nd %.ni %.np %.npic
+-endif
+-
+-$(foreach object_type, $(object_types), \
+-  $(eval $(call COMPILE_C_FILE,$(object_type),%)))
+-
+-$(UNIX_OR_WIN32)_non_shared.%.$(O): OC_CPPFLAGS += -DBUILDING_LIBCAMLRUNS
+-
+-$(eval $(call COMPILE_C_FILE,$(UNIX_OR_WIN32)_non_shared.%,$(UNIX_OR_WIN32)))
+-
+-$(foreach object_type,$(subst %,,$(object_types)), \
+-  $(eval dynlink$(object_type).$(O): $(ROOTDIR)/Makefile.config))
+-
+-# Compilation of assembly files
+-
+-%.o: %.S
+-	$(ASPP) $(ASPPFLAGS) -o $@ $< || \
+-	{ echo "If your assembler produced syntax errors, it is probably";\
+-          echo "unhappy with the preprocessor. Check your assembler, or";\
+-          echo "try producing $*.o by hand.";\
+-          exit 2; }
+-
+-%_libasmrunpic.o: %.S
+-	$(ASPP) $(ASPPFLAGS) $(SHAREDLIB_CFLAGS) -o $@ $<
+-
+-domain_state64.inc: caml/domain_state.tbl gen_domain_state64_inc.awk
+-	$(AWK) -f ./gen_domain_state64_inc.awk $< > $@
+-
+-domain_state32.inc: caml/domain_state.tbl gen_domain_state32_inc.awk
+-	$(AWK) -f ./gen_domain_state32_inc.awk $< > $@
+-
+-amd64nt.obj: amd64nt.asm domain_state64.inc
+-	$(ASM)$@ $(ASMFLAGS) $<
+-
+-i386nt.obj: i386nt.asm domain_state32.inc
+-	$(ASM)$@ $(ASMFLAGS) $<
+-
+-%_libasmrunpic.obj: %.asm
+-	$(ASM)$@ $(ASMFLAGS) $<
+-
+-# Dependencies
+-
+-DEP_FILES := $(addsuffix .b, $(basename $(BYTECODE_C_SOURCES) instrtrace))
+-ifneq "$(NATIVE_COMPILER)" "false"
+-DEP_FILES += $(addsuffix .n, $(basename $(NATIVE_C_SOURCES)))
+-endif
+-DEP_FILES += $(addsuffix d, $(DEP_FILES)) \
+-             $(addsuffix i, $(DEP_FILES)) \
+-             $(addsuffix pic, $(DEP_FILES))
+-DEP_FILES := $(addsuffix .$(D), $(DEP_FILES))
+-
+-ifeq "$(COMPUTE_DEPS)" "true"
+-include $(addprefix $(DEPDIR)/, $(DEP_FILES))
+-endif
+-
+-# This empty target is here for AppVeyor to allow dependencies to be built
+-# without doing anything else.
+-.PHONY: setup-depend
+-setup-depend:
+diff --git a/runtime/amd64.S b/runtime/amd64.S
+index 756d4a5a0a..8081087c68 100644
+--- a/runtime/amd64.S
++++ b/runtime/amd64.S
+@@ -295,13 +295,13 @@
+         .text
+ 
+ #if defined(FUNCTION_SECTIONS)
+-        TEXT_SECTION(caml_hot__code_begin)
+-        .globl  G(caml_hot__code_begin)
+-G(caml_hot__code_begin):
++        TEXT_SECTION(caml_hot.code_begin)
++        .globl  G(caml_hot.code_begin)
++G(caml_hot.code_begin):
+ 
+-        TEXT_SECTION(caml_hot__code_end)
+-        .globl  G(caml_hot__code_end)
+-G(caml_hot__code_end):
++        TEXT_SECTION(caml_hot.code_end)
++        .globl  G(caml_hot.code_end)
++G(caml_hot.code_end):
+ #endif
+ 
+         TEXT_SECTION(caml_system__code_begin)
+@@ -664,9 +664,9 @@ ENDFUNCTION(G(caml_ml_array_bound_error))
+ G(caml_system__code_end):
+ 
+         .data
+-        .globl  G(caml_system__frametable)
++        .globl  G(caml_system.frametable)
+         .align  EIGHT_ALIGN
+-G(caml_system__frametable):
++G(caml_system.frametable):
+         .quad   1           /* one descriptor */
+         .quad   LBL(107)    /* return address into callback */
+         .value  -1          /* negative frame size => use callback link */
+diff --git a/runtime/arm.S b/runtime/arm.S
+index 612757a104..d2632bfceb 100644
+--- a/runtime/arm.S
++++ b/runtime/arm.S
+@@ -113,13 +113,13 @@ domain_state_ptr  .req    r11
+ name:
+ 
+ #if defined(FUNCTION_SECTIONS)
+-        TEXT_SECTION(caml_hot__code_begin)
+-        .globl  caml_hot__code_begin
+-caml_hot__code_begin:
++        TEXT_SECTION(caml_hot.code_begin)
++        .globl  caml_hot.code_begin
++caml_hot.code_begin:
+ 
+-        TEXT_SECTION(caml_hot__code_end)
+-        .globl  caml_hot__code_end
+-caml_hot__code_end:
++        TEXT_SECTION(caml_hot.code_end)
++        .globl  caml_hot.code_end
++caml_hot.code_end:
+ #endif
+ 
+         .set    domain_curr_field, 0
+@@ -433,15 +433,15 @@ caml_system__code_end:
+ 
+         .data
+         .align  2
+-        .globl  caml_system__frametable
+-caml_system__frametable:
++        .globl  caml_system.frametable
++caml_system.frametable:
+         .word   1               /* one descriptor */
+         .word   .Lcaml_retaddr  /* return address into callback */
+         .short  -1              /* negative frame size => use callback link */
+         .short  0               /* no roots */
+         .align  2
+-        .type   caml_system__frametable, %object
+-        .size   caml_system__frametable, .-caml_system__frametable
++        .type   caml_system.frametable, %object
++        .size   caml_system.frametable, .-caml_system.frametable
+ 
+ /* Mark stack as non-executable */
+         .section .note.GNU-stack,"",%progbits
+diff --git a/runtime/arm64.S b/runtime/arm64.S
+index 02a7ba0832..abb38be6e7 100644
+--- a/runtime/arm64.S
++++ b/runtime/arm64.S
+@@ -100,13 +100,13 @@
+ #endif
+ 
+ #if defined(FUNCTION_SECTIONS)
+-        TEXT_SECTION(caml_hot__code_begin)
+-        .globl  G(caml_hot__code_begin)
+-G(caml_hot__code_begin):
++        TEXT_SECTION(caml_hot.code_begin)
++        .globl  G(caml_hot.code_begin)
++G(caml_hot.code_begin):
+ 
+-        TEXT_SECTION(caml_hot__code_end)
+-        .globl  G(caml_hot__code_end)
+-G(caml_hot__code_end):
++        TEXT_SECTION(caml_hot.code_end)
++        .globl  G(caml_hot.code_end)
++G(caml_hot.code_end):
+ #endif
+ 
+ #if defined(SYS_macosx)
+@@ -533,13 +533,13 @@ G(caml_system__code_end):
+ 
+ /* GC roots for callback */
+ 
+-OBJECT(caml_system__frametable)
++OBJECT(caml_system.frametable)
+         .quad   1               /* one descriptor */
+         .quad   L(caml_retaddr) /* return address into callback */
+         .short  -1              /* negative frame size => use callback link */
+         .short  0               /* no roots */
+         .align  3
+-        END_OBJECT(caml_system__frametable)
++        END_OBJECT(caml_system.frametable)
+ 
+ #if !defined(SYS_macosx)
+ /* Mark stack as non-executable */
+diff --git a/runtime/bigarray.c b/runtime/bigarray.c
+index ed4ff67d21..03151f6946 100644
+--- a/runtime/bigarray.c
++++ b/runtime/bigarray.c
+@@ -89,7 +89,7 @@ CAMLexport value
+ caml_ba_alloc(int flags, int num_dims, void * data, intnat * dim)
+ {
+   uintnat num_elts, asize, size;
+-  int i;
++  int i, is_managed;
+   value res;
+   struct caml_ba_array * b;
+   intnat dimcopy[CAML_BA_MAX_NUM_DIMS];
+@@ -97,23 +97,23 @@ caml_ba_alloc(int flags, int num_dims, void * data, intnat * dim)
+   CAMLassert(num_dims >= 0 && num_dims <= CAML_BA_MAX_NUM_DIMS);
+   CAMLassert((flags & CAML_BA_KIND_MASK) <= CAML_BA_CHAR);
+   for (i = 0; i < num_dims; i++) dimcopy[i] = dim[i];
+-  size = 0;
+-  if (data == NULL) {
+-    num_elts = 1;
+-    for (i = 0; i < num_dims; i++) {
+-      if (caml_umul_overflow(num_elts, dimcopy[i], &num_elts))
+-        caml_raise_out_of_memory();
+-    }
+-    if (caml_umul_overflow(num_elts,
+-                           caml_ba_element_size[flags & CAML_BA_KIND_MASK],
+-                           &size))
++  num_elts = 1;
++  for (i = 0; i < num_dims; i++) {
++    if (caml_umul_overflow(num_elts, dimcopy[i], &num_elts))
+       caml_raise_out_of_memory();
++  }
++  if (caml_umul_overflow(num_elts,
++                         caml_ba_element_size[flags & CAML_BA_KIND_MASK],
++                         &size))
++    caml_raise_out_of_memory();
++  if (data == NULL) {
+     data = malloc(size);
+     if (data == NULL && size != 0) caml_raise_out_of_memory();
+     flags |= CAML_BA_MANAGED;
+   }
+   asize = SIZEOF_BA_ARRAY + num_dims * sizeof(intnat);
+-  res = caml_alloc_custom_mem(&caml_ba_ops, asize, size);
++  is_managed = ((flags & CAML_BA_MANAGED_MASK) == CAML_BA_MANAGED);
++  res = caml_alloc_custom_mem(&caml_ba_ops, asize, is_managed ? size : 0);
+   b = Caml_ba_array_val(res);
+   b->data = data;
+   b->num_dims = num_dims;
+diff --git a/runtime/caml/alloc.h b/runtime/caml/alloc.h
+index 13f0fac2fb..816da799bb 100644
+--- a/runtime/caml/alloc.h
++++ b/runtime/caml/alloc.h
+@@ -17,9 +17,6 @@
+ #define CAML_ALLOC_H
+ 
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "misc.h"
+ #include "mlvalues.h"
+ 
+diff --git a/runtime/caml/bigarray.h b/runtime/caml/bigarray.h
+index fc1fb14570..1664ae3f6e 100644
+--- a/runtime/caml/bigarray.h
++++ b/runtime/caml/bigarray.h
+@@ -16,9 +16,6 @@
+ #ifndef CAML_BIGARRAY_H
+ #define CAML_BIGARRAY_H
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "config.h"
+ #include "mlvalues.h"
+ 
+diff --git a/runtime/caml/callback.h b/runtime/caml/callback.h
+index eef3342ec7..5c45995b8a 100644
+--- a/runtime/caml/callback.h
++++ b/runtime/caml/callback.h
+@@ -18,9 +18,6 @@
+ #ifndef CAML_CALLBACK_H
+ #define CAML_CALLBACK_H
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "mlvalues.h"
+ 
+ #ifdef __cplusplus
+diff --git a/runtime/caml/camlatomic.h b/runtime/caml/camlatomic.h
+new file mode 100644
+index 0000000000..7206f0579a
+--- /dev/null
++++ b/runtime/caml/camlatomic.h
+@@ -0,0 +1,85 @@
++/**************************************************************************/
++/*                                                                        */
++/*                                 OCaml                                  */
++/*                                                                        */
++/*      KC Sivaramakrishnan, Indian Institute of Technology, Madras       */
++/*                Stephen Dolan, University of Cambridge                  */
++/*                                                                        */
++/*   Copyright 2018 Indian Institute of Technology, Madras                */
++/*   Copyright 2018 University of Cambridge                               */
++/*                                                                        */
++/*   All rights reserved.  This file is distributed under the terms of    */
++/*   the GNU Lesser General Public License version 2.1, with the          */
++/*   special exception on linking described in the file LICENSE.          */
++/*                                                                        */
++/**************************************************************************/
++#ifndef CAML_ATOMIC_H
++#define CAML_ATOMIC_H
++
++#include "config.h"
++
++/* On platforms supporting C11 atomics, this file just includes <stdatomic.h>.
++
++   On other platforms, this file includes platform-specific stubs for
++   the subset of C11 atomics needed by the OCaml runtime
++ */
++
++#ifdef __cplusplus
++
++extern "C++" {
++#include <atomic>
++#define ATOMIC_UINTNAT_INIT(x) (x)
++typedef std::atomic<uintnat> atomic_uintnat;
++typedef std::atomic<intnat> atomic_intnat;
++using std::memory_order_relaxed;
++using std::memory_order_acquire;
++using std::memory_order_release;
++using std::memory_order_acq_rel;
++using std::memory_order_seq_cst;
++}
++
++#elif defined(HAS_STDATOMIC_H)
++
++#include <stdatomic.h>
++#define ATOMIC_UINTNAT_INIT(x) (x)
++typedef _Atomic uintnat atomic_uintnat;
++typedef _Atomic intnat atomic_intnat;
++
++#elif defined(__GNUC__)
++
++/* Support for versions of gcc which have built-in atomics but do not
++   expose stdatomic.h (e.g. gcc 4.8) */
++typedef enum memory_order {
++  memory_order_relaxed = __ATOMIC_RELAXED,
++  memory_order_acquire = __ATOMIC_ACQUIRE,
++  memory_order_release = __ATOMIC_RELEASE,
++  memory_order_acq_rel = __ATOMIC_ACQ_REL,
++  memory_order_seq_cst = __ATOMIC_SEQ_CST
++} memory_order;
++
++#define ATOMIC_UINTNAT_INIT(x) { (x) }
++typedef struct { uintnat repr; } atomic_uintnat;
++typedef struct { intnat repr; } atomic_intnat;
++
++#define atomic_load_explicit(x, m) __atomic_load_n(&(x)->repr, (m))
++#define atomic_load(x) atomic_load_explicit((x), memory_order_seq_cst)
++#define atomic_store_explicit(x, v, m) __atomic_store_n(&(x)->repr, (v), (m))
++#define atomic_store(x, v) atomic_store_explicit((x), (v), memory_order_seq_cst)
++#define atomic_compare_exchange_strong(x, oldv, newv) \
++  __atomic_compare_exchange_n( \
++    &(x)->repr, \
++    (oldv), (newv), 0, \
++    memory_order_seq_cst, memory_order_seq_cst)
++#define atomic_exchange(x, newv) \
++  __atomic_exchange_n(&(x)->repr, (newv), memory_order_seq_cst)
++#define atomic_fetch_add(x, n) \
++  __atomic_fetch_add(&(x)->repr, (n), memory_order_seq_cst)
++#define atomic_fetch_or(x, n) \
++  __atomic_fetch_or(&(x)->repr, (n), memory_order_seq_cst)
++#define atomic_thread_fence __atomic_thread_fence
++
++#else
++#error "C11 atomics are unavailable on this platform. See camlatomic.h"
++#endif
++
++#endif /* CAML_ATOMIC_H */
+diff --git a/runtime/caml/compatibility.h b/runtime/caml/compatibility.h
+deleted file mode 100644
+index 1c109aa470..0000000000
+--- a/runtime/caml/compatibility.h
++++ /dev/null
+@@ -1,373 +0,0 @@
+-/**************************************************************************/
+-/*                                                                        */
+-/*                                 OCaml                                  */
+-/*                                                                        */
+-/*           Damien Doligez, projet Moscova, INRIA Rocquencourt           */
+-/*                                                                        */
+-/*   Copyright 2003 Institut National de Recherche en Informatique et     */
+-/*     en Automatique.                                                    */
+-/*                                                                        */
+-/*   All rights reserved.  This file is distributed under the terms of    */
+-/*   the GNU Lesser General Public License version 2.1, with the          */
+-/*   special exception on linking described in the file LICENSE.          */
+-/*                                                                        */
+-/**************************************************************************/
+-
+-/* definitions for compatibility with old identifiers */
+-
+-#ifndef CAML_COMPATIBILITY_H
+-#define CAML_COMPATIBILITY_H
+-
+-/* internal global variables renamed between 4.02.1 and 4.03.0 */
+-#define caml_stat_top_heap_size Bsize_wsize(caml_stat_top_heap_wsz)
+-#define caml_stat_heap_size Bsize_wsize(caml_stat_heap_wsz)
+-
+-#ifndef CAML_NAME_SPACE
+-
+-/*
+-   #define --> CAMLextern  (defined with CAMLexport or CAMLprim)
+-   (rien)  --> CAMLprim
+-   g       --> global C identifier
+-   x       --> special case
+-
+-   SP* signals the special cases:
+-   - when the identifier was not simply prefixed with [caml_]
+-   - when the [caml_] version was already used for something else, and
+-     was renamed out of the way (watch out for [caml_alloc] and
+-     [caml_array_bound_error] in *.s)
+-*/
+-
+-/* a faire:
+-   - ui_*   (reverifier que win32.c n'en depend pas)
+-*/
+-
+-
+-/* **** alloc.c */
+-#define alloc CAML_DEPRECATED("alloc", "caml_alloc") caml_alloc /*SP*/
+-#define alloc_small CAML_DEPRECATED("alloc_small", "caml_alloc_small") caml_alloc_small
+-#define alloc_tuple CAML_DEPRECATED("alloc_tuple", "caml_alloc_tuple") caml_alloc_tuple
+-#define alloc_string CAML_DEPRECATED("alloc_string", "caml_alloc_string") caml_alloc_string
+-#define alloc_final CAML_DEPRECATED("alloc_final", "caml_alloc_final") caml_alloc_final
+-#define copy_string CAML_DEPRECATED("copy_string", "caml_copy_string") caml_copy_string
+-#define alloc_array CAML_DEPRECATED("alloc_array", "caml_alloc_array") caml_alloc_array
+-#define copy_string_array CAML_DEPRECATED("copy_string_array", "caml_copy_string_array") caml_copy_string_array
+-#define convert_flag_list CAML_DEPRECATED("convert_flag_list", "caml_convert_flag_list") caml_convert_flag_list
+-
+-/* **** array.c */
+-
+-/* **** backtrace.c */
+-#define backtrace_active CAML_DEPRECATED("backtrace_active", "caml_backtrace_active") caml_backtrace_active
+-#define backtrace_pos CAML_DEPRECATED("backtrace_pos", "caml_backtrace_pos") caml_backtrace_pos
+-#define backtrace_buffer CAML_DEPRECATED("backtrace_buffer", "caml_backtrace_buffer") caml_backtrace_buffer
+-#define backtrace_last_exn CAML_DEPRECATED("backtrace_last_exn", "caml_backtrace_last_exn") caml_backtrace_last_exn
+-#define print_exception_backtrace CAML_DEPRECATED("print_exception_backtrace", "caml_print_exception_backtrace") caml_print_exception_backtrace
+-
+-/* **** callback.c */
+-#define callback_depth CAML_DEPRECATED("callback_depth", "caml_callback_depth") caml_callback_depth
+-#define callbackN_exn CAML_DEPRECATED("callbackN_exn", "caml_callbackN_exn") caml_callbackN_exn
+-#define callback_exn CAML_DEPRECATED("callback_exn", "caml_callback_exn") caml_callback_exn
+-#define callback2_exn CAML_DEPRECATED("callback2_exn", "caml_callback2_exn") caml_callback2_exn
+-#define callback3_exn CAML_DEPRECATED("callback3_exn", "caml_callback3_exn") caml_callback3_exn
+-#define callback CAML_DEPRECATED("callback", "caml_callback") caml_callback
+-#define callback2 CAML_DEPRECATED("callback2", "caml_callback2") caml_callback2
+-#define callback3 CAML_DEPRECATED("callback3", "caml_callback3") caml_callback3
+-#define callbackN CAML_DEPRECATED("callbackN", "caml_callbackN") caml_callbackN
+-
+-/* **** compact.c */
+-
+-/* **** compare.c */
+-#define compare_unordered CAML_DEPRECATED("compare_unordered", "caml_compare_unordered") caml_compare_unordered
+-
+-/* **** custom.c */
+-#define alloc_custom CAML_DEPRECATED("alloc_custom", "caml_alloc_custom") caml_alloc_custom
+-#define register_custom_operations CAML_DEPRECATED("register_custom_operations", "caml_register_custom_operations") caml_register_custom_operations
+-
+-/* **** debugger.c */
+-
+-/* **** dynlink.c */
+-
+-/* **** extern.c */
+-#define output_val CAML_DEPRECATED("output_val", "caml_output_val") caml_output_val
+-#define output_value_to_malloc CAML_DEPRECATED("output_value_to_malloc", "caml_output_value_to_malloc") caml_output_value_to_malloc
+-#define output_value_to_block CAML_DEPRECATED("output_value_to_block", "caml_output_value_to_block") caml_output_value_to_block
+-#define serialize_int_1 CAML_DEPRECATED("serialize_int_1", "caml_serialize_int_1") caml_serialize_int_1
+-#define serialize_int_2 CAML_DEPRECATED("serialize_int_2", "caml_serialize_int_2") caml_serialize_int_2
+-#define serialize_int_4 CAML_DEPRECATED("serialize_int_4", "caml_serialize_int_4") caml_serialize_int_4
+-#define serialize_int_8 CAML_DEPRECATED("serialize_int_8", "caml_serialize_int_8") caml_serialize_int_8
+-#define serialize_float_4 CAML_DEPRECATED("serialize_float_4", "caml_serialize_float_4") caml_serialize_float_4
+-#define serialize_float_8 CAML_DEPRECATED("serialize_float_8", "caml_serialize_float_8") caml_serialize_float_8
+-#define serialize_block_1 CAML_DEPRECATED("serialize_block_1", "caml_serialize_block_1") caml_serialize_block_1
+-#define serialize_block_2 CAML_DEPRECATED("serialize_block_2", "caml_serialize_block_2") caml_serialize_block_2
+-#define serialize_block_4 CAML_DEPRECATED("serialize_block_4", "caml_serialize_block_4") caml_serialize_block_4
+-#define serialize_block_8 CAML_DEPRECATED("serialize_block_8", "caml_serialize_block_8") caml_serialize_block_8
+-#define serialize_block_float_8 CAML_DEPRECATED("serialize_block_float_8", "caml_serialize_block_float_8") caml_serialize_block_float_8
+-
+-/* **** fail.c */
+-#define external_raise CAML_DEPRECATED("external_raise", "caml_external_raise") caml_external_raise
+-#define mlraise CAML_DEPRECATED("mlraise", "caml_raise") caml_raise /*SP*/
+-#define raise_constant CAML_DEPRECATED("raise_constant", "caml_raise_constant") caml_raise_constant
+-#define raise_with_arg CAML_DEPRECATED("raise_with_arg", "caml_raise_with_arg") caml_raise_with_arg
+-#define raise_with_string CAML_DEPRECATED("raise_with_string", "caml_raise_with_string") caml_raise_with_string
+-#define failwith CAML_DEPRECATED("failwith", "caml_failwith") caml_failwith
+-#define invalid_argument CAML_DEPRECATED("invalid_argument", "caml_invalid_argument") caml_invalid_argument
+-#define array_bound_error CAML_DEPRECATED("array_bound_error", "caml_array_bound_error") caml_array_bound_error /*SP*/
+-#define raise_out_of_memory CAML_DEPRECATED("raise_out_of_memory", "caml_raise_out_of_memory") caml_raise_out_of_memory
+-#define raise_stack_overflow CAML_DEPRECATED("raise_stack_overflow", "caml_raise_stack_overflow") caml_raise_stack_overflow
+-#define raise_sys_error CAML_DEPRECATED("raise_sys_error", "caml_raise_sys_error") caml_raise_sys_error
+-#define raise_end_of_file CAML_DEPRECATED("raise_end_of_file", "caml_raise_end_of_file") caml_raise_end_of_file
+-#define raise_zero_divide CAML_DEPRECATED("raise_zero_divide", "caml_raise_zero_divide") caml_raise_zero_divide
+-#define raise_not_found CAML_DEPRECATED("raise_not_found", "caml_raise_not_found") caml_raise_not_found
+-#define raise_sys_blocked_io CAML_DEPRECATED("raise_sys_blocked_io", "caml_raise_sys_blocked_io") caml_raise_sys_blocked_io
+-/* **** runtime/fail_nat.c */
+-/* **** runtime/<arch>.s */
+-
+-/* **** finalise.c */
+-
+-/* **** fix_code.c */
+-
+-/* **** floats.c */
+-/*#define Double_val caml_Double_val             done in mlvalues.h as needed */
+-/*#define Store_double_val caml_Store_double_val done in mlvalues.h as needed */
+-#define copy_double CAML_DEPRECATED("copy_double", "caml_copy_double") caml_copy_double
+-
+-/* **** freelist.c */
+-
+-/* **** gc_ctrl.c */
+-
+-/* **** globroots.c */
+-#define register_global_root CAML_DEPRECATED("register_global_root", "caml_register_global_root") caml_register_global_root
+-#define remove_global_root CAML_DEPRECATED("remove_global_root", "caml_remove_global_root") caml_remove_global_root
+-
+-/* **** hash.c */
+-#define hash_variant CAML_DEPRECATED("hash_variant", "caml_hash_variant") caml_hash_variant
+-
+-/* **** instrtrace.c */
+-
+-/* **** intern.c */
+-#define input_val CAML_DEPRECATED("input_val", "caml_input_val") caml_input_val
+-#define input_val_from_string CAML_DEPRECATED("input_val_from_string", "caml_input_val_from_string") caml_input_val_from_string
+-#define input_value_from_malloc CAML_DEPRECATED("input_value_from_malloc", "caml_input_value_from_malloc") caml_input_value_from_malloc
+-#define input_value_from_block CAML_DEPRECATED("input_value_from_block", "caml_input_value_from_block") caml_input_value_from_block
+-#define deserialize_uint_1 CAML_DEPRECATED("deserialize_uint_1", "caml_deserialize_uint_1") caml_deserialize_uint_1
+-#define deserialize_sint_1 CAML_DEPRECATED("deserialize_sint_1", "caml_deserialize_sint_1") caml_deserialize_sint_1
+-#define deserialize_uint_2 CAML_DEPRECATED("deserialize_uint_2", "caml_deserialize_uint_2") caml_deserialize_uint_2
+-#define deserialize_sint_2 CAML_DEPRECATED("deserialize_sint_2", "caml_deserialize_sint_2") caml_deserialize_sint_2
+-#define deserialize_uint_4 CAML_DEPRECATED("deserialize_uint_4", "caml_deserialize_uint_4") caml_deserialize_uint_4
+-#define deserialize_sint_4 CAML_DEPRECATED("deserialize_sint_4", "caml_deserialize_sint_4") caml_deserialize_sint_4
+-#define deserialize_uint_8 CAML_DEPRECATED("deserialize_uint_8", "caml_deserialize_uint_8") caml_deserialize_uint_8
+-#define deserialize_sint_8 CAML_DEPRECATED("deserialize_sint_8", "caml_deserialize_sint_8") caml_deserialize_sint_8
+-#define deserialize_float_4 CAML_DEPRECATED("deserialize_float_4", "caml_deserialize_float_4") caml_deserialize_float_4
+-#define deserialize_float_8 CAML_DEPRECATED("deserialize_float_8", "caml_deserialize_float_8") caml_deserialize_float_8
+-#define deserialize_block_1 CAML_DEPRECATED("deserialize_block_1", "caml_deserialize_block_1") caml_deserialize_block_1
+-#define deserialize_block_2 CAML_DEPRECATED("deserialize_block_2", "caml_deserialize_block_2") caml_deserialize_block_2
+-#define deserialize_block_4 CAML_DEPRECATED("deserialize_block_4", "caml_deserialize_block_4") caml_deserialize_block_4
+-#define deserialize_block_8 CAML_DEPRECATED("deserialize_block_8", "caml_deserialize_block_8") caml_deserialize_block_8
+-#define deserialize_block_float_8 CAML_DEPRECATED("deserialize_block_float_8", "caml_deserialize_block_float_8") caml_deserialize_block_float_8
+-#define deserialize_error CAML_DEPRECATED("deserialize_error", "caml_deserialize_error") caml_deserialize_error
+-
+-/* **** interp.c */
+-
+-/* **** ints.c */
+-#define int32_ops CAML_DEPRECATED("int32_ops", "caml_int32_ops") caml_int32_ops
+-#define copy_int32 CAML_DEPRECATED("copy_int32", "caml_copy_int32") caml_copy_int32
+-/*#define Int64_val caml_Int64_val   *** done in mlvalues.h as needed */
+-#define int64_ops CAML_DEPRECATED("int64_ops", "caml_int64_ops") caml_int64_ops
+-#define copy_int64 CAML_DEPRECATED("copy_int64", "caml_copy_int64") caml_copy_int64
+-#define nativeint_ops CAML_DEPRECATED("nativeint_ops", "caml_nativeint_ops") caml_nativeint_ops
+-#define copy_nativeint CAML_DEPRECATED("copy_nativeint", "caml_copy_nativeint") caml_copy_nativeint
+-
+-/* **** io.c */
+-#define channel_mutex_free CAML_DEPRECATED("channel_mutex_free", "caml_channel_mutex_free") caml_channel_mutex_free
+-#define channel_mutex_lock CAML_DEPRECATED("channel_mutex_lock", "caml_channel_mutex_lock") caml_channel_mutex_lock
+-#define channel_mutex_unlock CAML_DEPRECATED("channel_mutex_unlock", "caml_channel_mutex_unlock") caml_channel_mutex_unlock
+-#define channel_mutex_unlock_exn CAML_DEPRECATED("channel_mutex_unlock_exn", "caml_channel_mutex_unlock_exn") caml_channel_mutex_unlock_exn
+-#define all_opened_channels CAML_DEPRECATED("all_opened_channels", "caml_all_opened_channels") caml_all_opened_channels
+-#define open_descriptor_in CAML_DEPRECATED("open_descriptor_in", "caml_open_descriptor_in") caml_open_descriptor_in /*SP*/
+-#define open_descriptor_out CAML_DEPRECATED("open_descriptor_out", "caml_open_descriptor_out") caml_open_descriptor_out /*SP*/
+-#define close_channel CAML_DEPRECATED("close_channel", "caml_close_channel") caml_close_channel /*SP*/
+-#define channel_size CAML_DEPRECATED("channel_size", "caml_channel_size") caml_channel_size /*SP*/
+-#define channel_binary_mode CAML_DEPRECATED("channel_binary_mode", "caml_channel_binary_mode") caml_channel_binary_mode
+-#define flush_partial CAML_DEPRECATED("flush_partial", "caml_flush_partial") caml_flush_partial /*SP*/
+-#define flush CAML_DEPRECATED("flush", "caml_flush") caml_flush /*SP*/
+-#define putword CAML_DEPRECATED("putword", "caml_putword") caml_putword
+-#define putblock CAML_DEPRECATED("putblock", "caml_putblock") caml_putblock
+-#define really_putblock CAML_DEPRECATED("really_putblock", "caml_really_putblock") caml_really_putblock
+-#define seek_out CAML_DEPRECATED("seek_out", "caml_seek_out") caml_seek_out /*SP*/
+-#define pos_out CAML_DEPRECATED("pos_out", "caml_pos_out") caml_pos_out /*SP*/
+-#define do_read CAML_DEPRECATED("do_read", "caml_do_read") caml_do_read
+-#define refill CAML_DEPRECATED("refill", "caml_refill") caml_refill
+-#define getword CAML_DEPRECATED("getword", "caml_getword") caml_getword
+-#define getblock CAML_DEPRECATED("getblock", "caml_getblock") caml_getblock
+-#define really_getblock CAML_DEPRECATED("really_getblock", "caml_really_getblock") caml_really_getblock
+-#define seek_in CAML_DEPRECATED("seek_in", "caml_seek_in") caml_seek_in /*SP*/
+-#define pos_in CAML_DEPRECATED("pos_in", "caml_pos_in") caml_pos_in /*SP*/
+-#define input_scan_line CAML_DEPRECATED("input_scan_line", "caml_input_scan_line") caml_input_scan_line /*SP*/
+-#define finalize_channel CAML_DEPRECATED("finalize_channel", "caml_finalize_channel") caml_finalize_channel
+-#define alloc_channel CAML_DEPRECATED("alloc_channel", "caml_alloc_channel") caml_alloc_channel
+-/*#define Val_file_offset caml_Val_file_offset   *** done in io.h as needed */
+-/*#define File_offset_val caml_File_offset_val   *** done in io.h as needed */
+-
+-/* **** lexing.c */
+-
+-/* **** main.c */
+-/* *** no change */
+-
+-/* **** major_gc.c */
+-#define heap_start CAML_DEPRECATED("heap_start", "caml_heap_start") caml_heap_start
+-#define page_table CAML_DEPRECATED("page_table", "caml_page_table") caml_page_table
+-
+-/* **** md5.c */
+-#define md5_string CAML_DEPRECATED("md5_string", "caml_md5_string") caml_md5_string
+-#define md5_chan CAML_DEPRECATED("md5_chan", "caml_md5_chan") caml_md5_chan
+-#define MD5Init CAML_DEPRECATED("MD5Init", "caml_MD5Init") caml_MD5Init
+-#define MD5Update CAML_DEPRECATED("MD5Update", "caml_MD5Update") caml_MD5Update
+-#define MD5Final CAML_DEPRECATED("MD5Final", "caml_MD5Final") caml_MD5Final
+-#define MD5Transform CAML_DEPRECATED("MD5Transform", "caml_MD5Transform") caml_MD5Transform
+-
+-/* **** memory.c */
+-#define alloc_shr CAML_DEPRECATED("alloc_shr", "caml_alloc_shr") caml_alloc_shr
+-#define initialize CAML_DEPRECATED("initialize", "caml_initialize") caml_initialize
+-#define modify CAML_DEPRECATED("modify", "caml_modify") caml_modify
+-#define stat_alloc CAML_DEPRECATED("stat_alloc", "caml_stat_alloc") caml_stat_alloc
+-#define stat_free CAML_DEPRECATED("stat_free", "caml_stat_free") caml_stat_free
+-#define stat_resize CAML_DEPRECATED("stat_resize", "caml_stat_resize") caml_stat_resize
+-
+-/* **** meta.c */
+-
+-/* **** minor_gc.c */
+-#define young_start CAML_DEPRECATED("young_start", "caml_young_start") caml_young_start
+-#define young_end CAML_DEPRECATED("young_end", "caml_young_end") caml_young_end
+-#define young_ptr CAML_DEPRECATED("young_ptr", "caml_young_ptr") caml_young_ptr
+-#define young_limit CAML_DEPRECATED("young_limit", "caml_young_limit") caml_young_limit
+-#define ref_table CAML_DEPRECATED("ref_table", "caml_ref_table") caml_ref_table
+-#define minor_collection CAML_DEPRECATED("minor_collection", "caml_minor_collection") caml_minor_collection
+-#define check_urgent_gc CAML_DEPRECATED("check_urgent_gc", "caml_check_urgent_gc") caml_check_urgent_gc
+-
+-/* **** misc.c */
+-
+-/* **** obj.c */
+-
+-/* **** parsing.c */
+-
+-/* **** prims.c */
+-
+-/* **** printexc.c */
+-#define format_caml_exception CAML_DEPRECATED("format_caml_exception", "caml_format_exception") caml_format_exception /*SP*/
+-
+-/* **** roots.c */
+-#define local_roots CAML_DEPRECATED("local_roots", "caml_local_roots") caml_local_roots
+-#define scan_roots_hook CAML_DEPRECATED("scan_roots_hook", "caml_scan_roots_hook") caml_scan_roots_hook
+-#define do_local_roots CAML_DEPRECATED("do_local_roots", "caml_do_local_roots") caml_do_local_roots
+-
+-/* **** signals.c */
+-#define pending_signals CAML_DEPRECATED("pending_signals", "caml_pending_signals") caml_pending_signals
+-#define something_to_do CAML_DEPRECATED("something_to_do", "caml_something_to_do") caml_something_to_do
+-#define enter_blocking_section_hook CAML_DEPRECATED("enter_blocking_section_hook", "caml_enter_blocking_section_hook") caml_enter_blocking_section_hook
+-#define leave_blocking_section_hook CAML_DEPRECATED("leave_blocking_section_hook", "caml_leave_blocking_section_hook") caml_leave_blocking_section_hook
+-#define enter_blocking_section CAML_DEPRECATED("enter_blocking_section", "caml_enter_blocking_section") caml_enter_blocking_section
+-#define leave_blocking_section CAML_DEPRECATED("leave_blocking_section", "caml_leave_blocking_section") caml_leave_blocking_section
+-#define convert_signal_number CAML_DEPRECATED("convert_signal_number", "caml_convert_signal_number") caml_convert_signal_number
+-
+-/* **** runtime/signals.c */
+-#define garbage_collection CAML_DEPRECATED("garbage_collection", "caml_garbage_collection") caml_garbage_collection
+-
+-/* **** stacks.c */
+-#define stack_low CAML_DEPRECATED("stack_low", "caml_stack_low") caml_stack_low
+-#define stack_high CAML_DEPRECATED("stack_high", "caml_stack_high") caml_stack_high
+-#define stack_threshold CAML_DEPRECATED("stack_threshold", "caml_stack_threshold") caml_stack_threshold
+-#define extern_sp CAML_DEPRECATED("extern_sp", "caml_extern_sp") caml_extern_sp
+-#define trapsp CAML_DEPRECATED("trapsp", "caml_trapsp") caml_trapsp
+-#define trap_barrier CAML_DEPRECATED("trap_barrier", "caml_trap_barrier") caml_trap_barrier
+-
+-/* **** startup.c */
+-#define atom_table CAML_DEPRECATED("atom_table", "caml_atom_table") caml_atom_table
+-/* **** runtime/startup_nat.c */
+-#define static_data_start CAML_DEPRECATED("static_data_start", "caml_static_data_start") caml_static_data_start
+-#define static_data_end CAML_DEPRECATED("static_data_end", "caml_static_data_end") caml_static_data_end
+-
+-/* **** str.c */
+-#define string_length CAML_DEPRECATED("string_length", "caml_string_length") caml_string_length
+-
+-/* **** sys.c */
+-#define sys_error CAML_DEPRECATED("sys_error", "caml_sys_error") caml_sys_error
+-
+-/* **** terminfo.c */
+-
+-/* **** unix.c  &  win32.c */
+-#define search_exe_in_path CAML_DEPRECATED("search_exe_in_path", "caml_search_exe_in_path") caml_search_exe_in_path
+-
+-/* **** weak.c */
+-
+-/* **** asmcomp/asmlink.ml */
+-
+-/* **** asmcomp/cmmgen.ml */
+-
+-/* **** asmcomp/asmlink.ml, asmcomp/cmmgen.ml, asmcomp/compilenv.ml */
+-
+-/* ************************************************************* */
+-
+-/* **** otherlibs/bigarray */
+-#define int8 caml_ba_int8
+-#define uint8 caml_ba_uint8
+-#define int16 caml_ba_int16
+-#define uint16 caml_ba_uint16
+-#define MAX_NUM_DIMS CAML_DEPRECATED("MAX_NUM_DIMS", "CAML_BA_MAX_NUM_DIMS") CAML_BA_MAX_NUM_DIMS
+-#define caml_bigarray_kind CAML_DEPRECATED("caml_bigarray_kind", "caml_ba_kind") caml_ba_kind
+-#define BIGARRAY_FLOAT32 CAML_DEPRECATED("BIGARRAY_FLOAT32", "CAML_BA_FLOAT32") CAML_BA_FLOAT32
+-#define BIGARRAY_FLOAT64 CAML_DEPRECATED("BIGARRAY_FLOAT64", "CAML_BA_FLOAT64") CAML_BA_FLOAT64
+-#define BIGARRAY_SINT8 CAML_DEPRECATED("BIGARRAY_SINT8", "CAML_BA_SINT8") CAML_BA_SINT8
+-#define BIGARRAY_UINT8 CAML_DEPRECATED("BIGARRAY_UINT8", "CAML_BA_UINT8") CAML_BA_UINT8
+-#define BIGARRAY_SINT16 CAML_DEPRECATED("BIGARRAY_SINT16", "CAML_BA_SINT16") CAML_BA_SINT16
+-#define BIGARRAY_UINT16 CAML_DEPRECATED("BIGARRAY_UINT16", "CAML_BA_UINT16") CAML_BA_UINT16
+-#define BIGARRAY_INT32 CAML_DEPRECATED("BIGARRAY_INT32", "CAML_BA_INT32") CAML_BA_INT32
+-#define BIGARRAY_INT64 CAML_DEPRECATED("BIGARRAY_INT64", "CAML_BA_INT64") CAML_BA_INT64
+-#define BIGARRAY_CAML_INT CAML_DEPRECATED("BIGARRAY_CAML_INT", "CAML_BA_CAML_INT") CAML_BA_CAML_INT
+-#define BIGARRAY_NATIVE_INT CAML_DEPRECATED("BIGARRAY_NATIVE_INT", "CAML_BA_NATIVE_INT") CAML_BA_NATIVE_INT
+-#define BIGARRAY_COMPLEX32 CAML_DEPRECATED("BIGARRAY_COMPLEX32", "CAML_BA_COMPLEX32") CAML_BA_COMPLEX32
+-#define BIGARRAY_COMPLEX64 CAML_DEPRECATED("BIGARRAY_COMPLEX64", "CAML_BA_COMPLEX64") CAML_BA_COMPLEX64
+-#define BIGARRAY_KIND_MASK CAML_DEPRECATED("BIGARRAY_KIND_MASK", "CAML_BA_KIND_MASK") CAML_BA_KIND_MASK
+-#define caml_bigarray_layout CAML_DEPRECATED("caml_bigarray_layout", "caml_ba_layout") caml_ba_layout
+-#define BIGARRAY_C_LAYOUT CAML_DEPRECATED("BIGARRAY_C_LAYOUT", "CAML_BA_C_LAYOUT") CAML_BA_C_LAYOUT
+-#define BIGARRAY_FORTRAN_LAYOUT CAML_DEPRECATED("BIGARRAY_FORTRAN_LAYOUT", "CAML_BA_FORTRAN_LAYOUT") CAML_BA_FORTRAN_LAYOUT
+-#define BIGARRAY_LAYOUT_MASK CAML_DEPRECATED("BIGARRAY_LAYOUT_MASK", "CAML_BA_LAYOUT_MASK") CAML_BA_LAYOUT_MASK
+-#define caml_bigarray_managed CAML_DEPRECATED("caml_bigarray_managed", "caml_ba_managed") caml_ba_managed
+-#define BIGARRAY_EXTERNAL CAML_DEPRECATED("BIGARRAY_EXTERNAL", "CAML_BA_EXTERNAL") CAML_BA_EXTERNAL
+-#define BIGARRAY_MANAGED CAML_DEPRECATED("BIGARRAY_MANAGED", "CAML_BA_MANAGED") CAML_BA_MANAGED
+-#define BIGARRAY_MAPPED_FILE CAML_DEPRECATED("BIGARRAY_MAPPED_FILE", "CAML_BA_MAPPED_FILE") CAML_BA_MAPPED_FILE
+-#define BIGARRAY_MANAGED_MASK CAML_DEPRECATED("BIGARRAY_MANAGED_MASK", "CAML_BA_MANAGED_MASK") CAML_BA_MANAGED_MASK
+-#define caml_bigarray_proxy CAML_DEPRECATED("caml_bigarray_proxy", "caml_ba_proxy") caml_ba_proxy
+-#define caml_bigarray CAML_DEPRECATED("caml_bigarray", "caml_ba_array") caml_ba_array
+-#define Bigarray_val CAML_DEPRECATED("Bigarray_val", "Caml_ba_array_val") Caml_ba_array_val
+-#define Data_bigarray_val CAML_DEPRECATED("Data_bigarray_val", "Caml_ba_data_val") Caml_ba_data_val
+-#define alloc_bigarray CAML_DEPRECATED("alloc_bigarray", "caml_ba_alloc") caml_ba_alloc
+-#define alloc_bigarray_dims CAML_DEPRECATED("alloc_bigarray_dims", "caml_ba_alloc_dims") caml_ba_alloc_dims
+-#define bigarray_map_file CAML_DEPRECATED("bigarray_map_file", "caml_ba_map_file") caml_ba_map_file
+-#define bigarray_unmap_file CAML_DEPRECATED("bigarray_unmap_file", "caml_ba_unmap_file") caml_ba_unmap_file
+-#define bigarray_element_size CAML_DEPRECATED("bigarray_element_size", "caml_ba_element_size") caml_ba_element_size
+-#define bigarray_byte_size CAML_DEPRECATED("bigarray_byte_size", "caml_ba_byte_size") caml_ba_byte_size
+-#define bigarray_deserialize CAML_DEPRECATED("bigarray_deserialize", "caml_ba_deserialize") caml_ba_deserialize
+-#define MAX_BIGARRAY_MEMORY CAML_DEPRECATED("MAX_BIGARRAY_MEMORY", "CAML_BA_MAX_MEMORY") CAML_BA_MAX_MEMORY
+-#define bigarray_create CAML_DEPRECATED("bigarray_create", "caml_ba_create") caml_ba_create
+-#define bigarray_get_N CAML_DEPRECATED("bigarray_get_N", "caml_ba_get_N") caml_ba_get_N
+-#define bigarray_get_1 CAML_DEPRECATED("bigarray_get_1", "caml_ba_get_1") caml_ba_get_1
+-#define bigarray_get_2 CAML_DEPRECATED("bigarray_get_2", "caml_ba_get_2") caml_ba_get_2
+-#define bigarray_get_3 CAML_DEPRECATED("bigarray_get_3", "caml_ba_get_3") caml_ba_get_3
+-#define bigarray_get_generic CAML_DEPRECATED("bigarray_get_generic", "caml_ba_get_generic") caml_ba_get_generic
+-#define bigarray_set_1 CAML_DEPRECATED("bigarray_set_1", "caml_ba_set_1") caml_ba_set_1
+-#define bigarray_set_2 CAML_DEPRECATED("bigarray_set_2", "caml_ba_set_2") caml_ba_set_2
+-#define bigarray_set_3 CAML_DEPRECATED("bigarray_set_3", "caml_ba_set_3") caml_ba_set_3
+-#define bigarray_set_N CAML_DEPRECATED("bigarray_set_N", "caml_ba_set_N") caml_ba_set_N
+-#define bigarray_set_generic CAML_DEPRECATED("bigarray_set_generic", "caml_ba_set_generic") caml_ba_set_generic
+-#define bigarray_num_dims CAML_DEPRECATED("bigarray_num_dims", "caml_ba_num_dims") caml_ba_num_dims
+-#define bigarray_dim CAML_DEPRECATED("bigarray_dim", "caml_ba_dim") caml_ba_dim
+-#define bigarray_kind CAML_DEPRECATED("bigarray_kind", "caml_ba_kind") caml_ba_kind
+-#define bigarray_layout CAML_DEPRECATED("bigarray_layout", "caml_ba_layout") caml_ba_layout
+-#define bigarray_slice CAML_DEPRECATED("bigarray_slice", "caml_ba_slice") caml_ba_slice
+-#define bigarray_sub CAML_DEPRECATED("bigarray_sub", "caml_ba_sub") caml_ba_sub
+-#define bigarray_blit CAML_DEPRECATED("bigarray_blit", "caml_ba_blit") caml_ba_blit
+-#define bigarray_fill CAML_DEPRECATED("bigarray_fill", "caml_ba_fill") caml_ba_fill
+-#define bigarray_reshape CAML_DEPRECATED("bigarray_reshape", "caml_ba_reshape") caml_ba_reshape
+-#define bigarray_init CAML_DEPRECATED("bigarray_init", "caml_ba_init") caml_ba_init
+-
+-#endif /* CAML_NAME_SPACE */
+-#endif /* CAML_COMPATIBILITY_H */
+diff --git a/runtime/caml/config.h b/runtime/caml/config.h
+index 471a6bc6f4..a7e56be8d9 100644
+--- a/runtime/caml/config.h
++++ b/runtime/caml/config.h
+@@ -16,6 +16,15 @@
+ #ifndef CAML_CONFIG_H
+ #define CAML_CONFIG_H
+ 
++/* CAML_NAME_SPACE was introduced in OCaml 3.08 to declare compatibility with
++   the newly caml_-prefixed names of C runtime functions and to disable the
++   definition of compatibility macros for the un-prefixed names. The
++   compatibility layer was removed in OCaml 5.00, so CAML_NAME_SPACE is the
++   default. */
++#ifndef CAML_NAME_SPACE
++#define CAML_NAME_SPACE
++#endif
++
+ #include "m.h"
+ 
+ /* If supported, tell gcc that we can use 32-bit code addresses for
+@@ -41,10 +50,6 @@
+ 
+ #include "s.h"
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+-
+ #ifndef CAML_CONFIG_H_NO_TYPEDEFS
+ 
+ #include <stddef.h>
+diff --git a/runtime/caml/custom.h b/runtime/caml/custom.h
+index 420121f43e..231019aef7 100644
+--- a/runtime/caml/custom.h
++++ b/runtime/caml/custom.h
+@@ -17,9 +17,6 @@
+ #define CAML_CUSTOM_H
+ 
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "mlvalues.h"
+ 
+ struct custom_fixed_length {
+diff --git a/runtime/caml/domain_state.h b/runtime/caml/domain_state.h
+index 84e677d041..2ee932459a 100644
+--- a/runtime/caml/domain_state.h
++++ b/runtime/caml/domain_state.h
+@@ -29,11 +29,7 @@ typedef value extra_params_area[NUM_EXTRA_PARAMS];
+  * via native code, which is why the indices are important */
+ 
+ typedef struct {
+-#ifdef CAML_NAME_SPACE
+ #define DOMAIN_STATE(type, name) CAMLalign(8) type name;
+-#else
+-#define DOMAIN_STATE(type, name) CAMLalign(8) type _##name;
+-#endif
+ #include "domain_state.tbl"
+ #undef DOMAIN_STATE
+ } caml_domain_state;
+@@ -45,11 +41,7 @@ enum {
+ #undef DOMAIN_STATE
+ };
+ 
+-#ifdef CAML_NAME_SPACE
+ #define LAST_DOMAIN_STATE_MEMBER extra_params
+-#else
+-#define LAST_DOMAIN_STATE_MEMBER _extra_params
+-#endif
+ 
+ /* Check that the structure was laid out without padding,
+    since the runtime assumes this in computing offsets */
+@@ -57,11 +49,8 @@ CAML_STATIC_ASSERT(
+     offsetof(caml_domain_state, LAST_DOMAIN_STATE_MEMBER) ==
+     (Domain_state_num_fields - 1) * 8);
+ 
+-CAMLextern caml_domain_state* Caml_state;
+-#ifdef CAML_NAME_SPACE
++CAMLextern caml_domain_state* caml_state;
++#define Caml_state caml_state
+ #define Caml_state_field(field) Caml_state->field
+-#else
+-#define Caml_state_field(field) Caml_state->_##field
+-#endif
+ 
+ #endif /* CAML_STATE_H */
+diff --git a/runtime/caml/fail.h b/runtime/caml/fail.h
+index 822c603260..887ef9c227 100644
+--- a/runtime/caml/fail.h
++++ b/runtime/caml/fail.h
+@@ -20,9 +20,6 @@
+ #include <setjmp.h>
+ #endif /* CAML_INTERNALS */
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "misc.h"
+ #include "mlvalues.h"
+ 
+diff --git a/runtime/caml/fix_code.h b/runtime/caml/fix_code.h
+index 2eafaa814b..83c393a17d 100644
+--- a/runtime/caml/fix_code.h
++++ b/runtime/caml/fix_code.h
+@@ -34,7 +34,8 @@ void caml_set_instruction (code_t pos, opcode_t instr);
+ int caml_is_instruction (opcode_t instr1, opcode_t instr2);
+ 
+ #ifdef THREADED_CODE
+-void caml_init_thread_code(void ** instr_table, void * instr_base);
++extern char ** caml_instr_table;
++extern char * caml_instr_base;
+ void caml_thread_code (code_t code, asize_t len);
+ #endif
+ 
+diff --git a/runtime/caml/intext.h b/runtime/caml/intext.h
+index a2a3fb8248..b68030aad8 100644
+--- a/runtime/caml/intext.h
++++ b/runtime/caml/intext.h
+@@ -18,9 +18,6 @@
+ #ifndef CAML_INTEXT_H
+ #define CAML_INTEXT_H
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "misc.h"
+ #include "mlvalues.h"
+ 
+diff --git a/runtime/caml/m.h.in b/runtime/caml/m.h.in
+index 1c3dee1779..ba0074318d 100644
+--- a/runtime/caml/m.h.in
++++ b/runtime/caml/m.h.in
+@@ -90,7 +90,7 @@
+ 
+ #undef CAML_WITH_FPIC
+ 
+-#undef CAML_SAFE_STRING
++#define CAML_SAFE_STRING 1
+ 
+ #undef FLAT_FLOAT_ARRAY
+ 
+diff --git a/runtime/caml/memory.h b/runtime/caml/memory.h
+index d9e58bc2d0..8837d33d25 100644
+--- a/runtime/caml/memory.h
++++ b/runtime/caml/memory.h
+@@ -18,9 +18,6 @@
+ #ifndef CAML_MEMORY_H
+ #define CAML_MEMORY_H
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "config.h"
+ #ifdef CAML_INTERNALS
+ #include "gc.h"
+@@ -329,7 +326,7 @@ struct caml__roots_block {
+   #define CAMLunused_start __attribute__ ((unused))
+   #define CAMLunused_end
+   #define CAMLunused __attribute__ ((unused))
+-#elif defined(_MSC_VER) && _MSC_VER >= 1500
++#elif _MSC_VER >= 1500
+   #define CAMLunused_start  __pragma( warning (push) )           \
+     __pragma( warning (disable:4189 ) )
+   #define CAMLunused_end __pragma( warning (pop))
+diff --git a/runtime/caml/misc.h b/runtime/caml/misc.h
+index c605f8711e..b97d20c2bd 100644
+--- a/runtime/caml/misc.h
++++ b/runtime/caml/misc.h
+@@ -18,9 +18,6 @@
+ #ifndef CAML_MISC_H
+ #define CAML_MISC_H
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "config.h"
+ 
+ /* Standard definitions */
+@@ -29,13 +26,15 @@
+ #include <stdlib.h>
+ #include <stdarg.h>
+ 
++#include "camlatomic.h"
++
+ /* Deprecation warnings */
+ 
+ #if defined(__GNUC__) || defined(__clang__)
+   /* Supported since at least GCC 3.1 */
+   #define CAMLdeprecated_typedef(name, type) \
+     typedef type name __attribute ((deprecated))
+-#elif defined(_MSC_VER) && _MSC_VER >= 1310
++#elif _MSC_VER >= 1310
+   /* NB deprecated("message") only supported from _MSC_VER >= 1400 */
+   #define CAMLdeprecated_typedef(name, type) \
+     typedef __declspec(deprecated) type name
+@@ -43,8 +42,7 @@
+   #define CAMLdeprecated_typedef(name, type) typedef type name
+ #endif
+ 
+-#if defined(__GNUC__) && __STDC_VERSION__ >= 199901L \
+- || defined(_MSC_VER) && _MSC_VER >= 1925
++#if defined(__GNUC__) && __STDC_VERSION__ >= 199901L || _MSC_VER >= 1925
+ 
+ #define CAML_STRINGIFY(x) #x
+ #ifdef _MSC_VER
+@@ -91,7 +89,7 @@ CAMLdeprecated_typedef(addr, char *);
+   #define CAMLnoreturn_start
+   #define CAMLnoreturn_end __attribute__ ((noreturn))
+   #define Noreturn __attribute__ ((noreturn))
+-#elif defined(_MSC_VER) && _MSC_VER >= 1500
++#elif _MSC_VER >= 1500
+   #define CAMLnoreturn_start __declspec(noreturn)
+   #define CAMLnoreturn_end
+   #define Noreturn
+@@ -139,12 +137,11 @@ CAMLdeprecated_typedef(addr, char *);
+ /* we need to be able to compute the exact offset of each member. */
+ #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
+ #define CAMLalign(n) _Alignas(n)
+-#elif defined(__cplusplus) \
+-   && (__cplusplus >= 201103L || defined(_MSC_VER) && _MSC_VER >= 1900)
++#elif defined(__cplusplus) && (__cplusplus >= 201103L || _MSC_VER >= 1900)
+ #define CAMLalign(n) alignas(n)
+ #elif defined(SUPPORTS_ALIGNED_ATTRIBUTE)
+ #define CAMLalign(n) __attribute__((aligned(n)))
+-#elif defined(_MSC_VER) && _MSC_VER >= 1500
++#elif _MSC_VER >= 1500
+ #define CAMLalign(n) __declspec(align(n))
+ #else
+ #error "How do I align values on this platform?"
+@@ -172,7 +169,7 @@ CAMLdeprecated_typedef(addr, char *);
+   #define CAMLunused_start __attribute__ ((unused))
+   #define CAMLunused_end
+   #define CAMLunused __attribute__ ((unused))
+-#elif defined(_MSC_VER) && _MSC_VER >= 1500
++#elif _MSC_VER >= 1500
+   #define CAMLunused_start  __pragma( warning (push) )           \
+     __pragma( warning (disable:4189 ) )
+   #define CAMLunused_end __pragma( warning (pop))
+diff --git a/runtime/caml/mlvalues.h b/runtime/caml/mlvalues.h
+index 677e44e183..00143e5ea0 100644
+--- a/runtime/caml/mlvalues.h
++++ b/runtime/caml/mlvalues.h
+@@ -16,9 +16,6 @@
+ #ifndef CAML_MLVALUES_H
+ #define CAML_MLVALUES_H
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "config.h"
+ #include "misc.h"
+ 
+@@ -286,11 +283,7 @@ CAMLextern value caml_hash_variant(char const * tag);
+ 
+ /* Strings. */
+ #define String_tag 252
+-#ifdef CAML_SAFE_STRING
+ #define String_val(x) ((const char *) Bp_val(x))
+-#else
+-#define String_val(x) ((char *) Bp_val(x))
+-#endif
+ #define Bytes_val(x) ((unsigned char *) Bp_val(x))
+ CAMLextern mlsize_t caml_string_length (value);   /* size in bytes */
+ CAMLextern int caml_string_is_c_safe (value);
+diff --git a/runtime/caml/s.h.in b/runtime/caml/s.h.in
+index 8e4efdcc72..9a5d9f4a91 100644
+--- a/runtime/caml/s.h.in
++++ b/runtime/caml/s.h.in
+@@ -60,6 +60,8 @@
+ /* Define HAS_WORKING_ROUND is the round function is correctly implemented. This
+    hatch exists primarily for https://sourceforge.net/p/mingw-w64/bugs/573/ */
+ 
++#undef HAS_GETENTROPY
++
+ #undef HAS_GETRUSAGE
+ 
+ #undef HAS_TIMES
+@@ -70,6 +72,8 @@
+ 
+ #undef HAS_ISSETUGID
+ 
++#undef HAS_STDATOMIC_H
++
+ /* 2. For the Unix library. */
+ 
+ #undef HAS_SOCKETS
+diff --git a/runtime/caml/signals.h b/runtime/caml/signals.h
+index 62b0e7fafa..0b8cc50064 100644
+--- a/runtime/caml/signals.h
++++ b/runtime/caml/signals.h
+@@ -20,9 +20,6 @@
+ #include<signal.h>
+ #endif
+ 
+-#ifndef CAML_NAME_SPACE
+-#include "compatibility.h"
+-#endif
+ #include "misc.h"
+ #include "mlvalues.h"
+ 
+diff --git a/runtime/caml/sys.h b/runtime/caml/sys.h
+index 75b97818c1..3b2d537ac4 100644
+--- a/runtime/caml/sys.h
++++ b/runtime/caml/sys.h
+@@ -24,6 +24,8 @@
+ extern "C" {
+ #endif
+ 
++CAMLextern char * caml_strerror(int errnum, char * buf, size_t buflen);
++
+ #define NO_ARG Val_int(0)
+ 
+ CAMLnoreturn_start
+diff --git a/runtime/caml/winsupport.h b/runtime/caml/winsupport.h
+index 6851457e29..2978195337 100644
+--- a/runtime/caml/winsupport.h
++++ b/runtime/caml/winsupport.h
+@@ -60,6 +60,11 @@ typedef struct _REPARSE_DATA_BUFFER
+ } REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
+ #endif
+ 
++typedef union {
++  FILETIME ft;
++  ULONGLONG ul;
++} CAML_ULONGLONG_FILETIME;
++
+ #endif
+ 
+ #endif /* CAML_WINSUPPORT_H */
+diff --git a/runtime/debugger.c b/runtime/debugger.c
+index 97d22832a0..c10c7d0f8f 100644
+--- a/runtime/debugger.c
++++ b/runtime/debugger.c
+@@ -30,6 +30,7 @@
+ #include "caml/misc.h"
+ #include "caml/osdeps.h"
+ #include "caml/skiplist.h"
++#include "caml/sys.h"
+ 
+ int caml_debugger_in_use = 0;
+ uintnat caml_event_count;
+@@ -110,6 +111,7 @@ static struct skiplist event_points_table = SKIPLIST_STATIC_INITIALIZER;
+ 
+ static void open_connection(void)
+ {
++  char buf[1024];
+ #ifdef _WIN32
+   /* Set socket to synchronous mode (= non-overlapped) so that file
+      descriptor-oriented functions (read()/write() etc.) can be
+@@ -133,7 +135,7 @@ static void open_connection(void)
+     caml_fatal_error("cannot connect to debugger at %s\n"
+                      "error: %s",
+                      (dbg_addr ? dbg_addr : "(none)"),
+-                     strerror (errno));
++                     caml_strerror(errno, buf, sizeof(buf)));
+   dbg_in = caml_open_descriptor_in(dbg_socket);
+   dbg_out = caml_open_descriptor_out(dbg_socket);
+   /* The code in this file does not bracket channel I/O operations with
+diff --git a/runtime/domain.c b/runtime/domain.c
+index d4d8de53fc..a6f0a3028e 100644
+--- a/runtime/domain.c
++++ b/runtime/domain.c
+@@ -19,7 +19,7 @@
+ #include "caml/domain_state.h"
+ #include "caml/memory.h"
+ 
+-CAMLexport caml_domain_state* Caml_state;
++CAMLexport caml_domain_state* caml_state;
+ 
+ void caml_init_domain ()
+ {
+diff --git a/runtime/dune b/runtime/dune
+index 78c39300ed..23eb1d1e8a 100644
+--- a/runtime/dune
++++ b/runtime/dune
+@@ -21,7 +21,7 @@
+      interp.c ints.c io.c
+    lexing.c md5.c meta.c memprof.c obj.c parsing.c signals.c str.c sys.c
+      callback.c weak.c
+-   finalise.c stacks.c dynlink.c backtrace_byt.c backtrace.c
++   finalise.c dynlink.c backtrace_byt.c backtrace.c
+      afl.c
+    bigarray.c eventlog.c)
+  (action  (with-stdout-to %{targets} (run %{dep:gen_primitives.sh}))))
+@@ -36,7 +36,7 @@
+    ../Makefile.common Makefile
+    (glob_files caml/*.h)
+    ; matches the line structure of files in Makefile/BYTECODE_C_SOURCES
+-   interp.c misc.c stacks.c fix_code.c startup_aux.c startup_byt.c freelist.c
++   interp.c misc.c fix_code.c startup_aux.c startup_byt.c freelist.c
+      major_gc.c
+    minor_gc.c memory.c alloc.c roots_byt.c globroots.c fail_byt.c signals.c
+    signals_byt.c printexc.c backtrace_byt.c backtrace.c compare.c ints.c
+diff --git a/runtime/dynlink_nat.c b/runtime/dynlink_nat.c
+index dba30c3848..628d837208 100644
+--- a/runtime/dynlink_nat.c
++++ b/runtime/dynlink_nat.c
+@@ -43,7 +43,7 @@ static value Val_handle(void* handle) {
+ }
+ 
+ static void *getsym(void *handle, const char *module, const char *name){
+-  char *fullname = caml_stat_strconcat(3, "caml", module, name);
++  char *fullname = caml_stat_strconcat(4, "caml", module, ".", name);
+   void *sym;
+   sym = caml_dlsym (handle, fullname);
+   /*  printf("%s => %lx\n", fullname, (uintnat) sym); */
+@@ -105,26 +105,27 @@ CAMLprim value caml_natdynlink_run(value handle_v, value symbol) {
+ 
+   unit = String_val(symbol);
+ 
+-  sym = optsym("__frametable");
++  sym = optsym("frametable");
+   if (NULL != sym) caml_register_frametable(sym);
+ 
+-  sym = optsym("__gc_roots");
++  sym = optsym("gc_roots");
+   if (NULL != sym) caml_register_dyn_global(sym);
+ 
+-  sym = optsym("__data_begin");
+-  sym2 = optsym("__data_end");
++  sym = optsym("data_begin");
++  sym2 = optsym("data_end");
+   if (NULL != sym && NULL != sym2)
+     caml_page_table_add(In_static_data, sym, sym2);
+ 
+-  sym = optsym("__code_begin");
+-  sym2 = optsym("__code_end");
+-  if (NULL != sym && NULL != sym2)
++  sym = optsym("code_begin");
++  sym2 = optsym("code_end");
++  /* Do not register empty code fragments */
++  if (NULL != sym && NULL != sym2 && sym != sym2)
+     caml_register_code_fragment((char *) sym, (char *) sym2,
+                                 DIGEST_LATER, NULL);
+ 
+   if( caml_natdynlink_hook != NULL ) caml_natdynlink_hook(handle,unit);
+ 
+-  entrypoint = optsym("__entry");
++  entrypoint = optsym("entry");
+   if (NULL != entrypoint) result = caml_callback((value)(&entrypoint), 0);
+   else result = Val_unit;
+ 
+diff --git a/runtime/fix_code.c b/runtime/fix_code.c
+index 5584019867..aa059be5df 100644
+--- a/runtime/fix_code.c
++++ b/runtime/fix_code.c
+@@ -82,14 +82,8 @@ void caml_fixup_endianness(code_t code, asize_t len)
+ 
+ #ifdef THREADED_CODE
+ 
+-static char ** caml_instr_table;
+-static char * caml_instr_base;
+-
+-void caml_init_thread_code(void ** instr_table, void * instr_base)
+-{
+-  caml_instr_table = (char **) instr_table;
+-  caml_instr_base = (char *) instr_base;
+-}
++char ** caml_instr_table;
++char * caml_instr_base;
+ 
+ static int* opcode_nargs = NULL;
+ int* caml_init_opcode_nargs(void)
+diff --git a/runtime/gen_primitives.sh b/runtime/gen_primitives.sh
+index a727d5c25c..01644a8a17 100755
+--- a/runtime/gen_primitives.sh
++++ b/runtime/gen_primitives.sh
+@@ -25,10 +25,11 @@ export LC_ALL=C
+       alloc array compare extern floats gc_ctrl hash intern interp ints io \
+       lexing md5 meta memprof obj parsing signals str sys callback weak \
+       finalise stacks dynlink backtrace_byt backtrace afl \
+-      bigarray eventlog
++      bigarray eventlog prng
+   do
+-      sed -n -e 's/^CAMLprim value \([a-z0-9_][a-z0-9_]*\).*/\1/p' "$prim.c"
++      sed -n -e 's/^CAMLprim value \([a-z0-9_][a-z0-9_]*\).*/\1/p' \
++        "runtime/$prim.c"
+   done
+   sed -n -e 's/^CAMLprim_int64_[0-9](\([a-z0-9_][a-z0-9_]*\)).*/caml_int64_\1\
+-caml_int64_\1_native/p' ints.c
++caml_int64_\1_native/p' runtime/ints.c
+ ) | sort | uniq
+diff --git a/runtime/hash.c b/runtime/hash.c
+index f33634c227..da111db629 100644
+--- a/runtime/hash.c
++++ b/runtime/hash.c
+@@ -301,6 +301,15 @@ CAMLprim value caml_hash(value count, value limit, value seed, value obj)
+   return Val_int(h & 0x3FFFFFFFU);
+ }
+ 
++CAMLprim value caml_string_hash(value seed, value string)
++{
++  uint32_t h;
++  h = Int_val(seed);
++  h = caml_hash_mix_string (h, string);
++  FINAL_MIX(h);
++  return Val_int(h & 0x3FFFFFFFU);
++}
++
+ /* Hashing variant tags */
+ 
+ CAMLexport value caml_hash_variant(char const * tag)
+diff --git a/runtime/i386.S b/runtime/i386.S
+index 4d273c9f04..585c2e4c5b 100644
+--- a/runtime/i386.S
++++ b/runtime/i386.S
+@@ -98,13 +98,13 @@
+ 
+         .text
+ #if defined(FUNCTION_SECTIONS)
+-        TEXT_SECTION(caml_hot__code_begin)
+-        .globl  G(caml_hot__code_begin)
+-G(caml_hot__code_begin):
++        TEXT_SECTION(caml_hot.code_begin)
++        .globl  G(caml_hot.code_begin)
++G(caml_hot.code_begin):
+ 
+-        TEXT_SECTION(caml_hot__code_end)
+-        .globl  G(caml_hot__code_end)
+-G(caml_hot__code_end):
++        TEXT_SECTION(caml_hot.code_end)
++        .globl  G(caml_hot.code_end)
++G(caml_hot.code_end):
+ #endif
+ 
+ /* Allocation */
+@@ -116,7 +116,7 @@ FUNCTION(caml_call_gc)
+         CFI_STARTPROC
+ LBL(caml_call_gc):
+     /* Record lowest stack address and return address */
+-        movl    G(Caml_state), %ebx
++        movl    G(caml_state), %ebx
+         movl    (%esp), %eax
+         movl    %eax, CAML_STATE(last_return_address, %ebx)
+         leal    4(%esp), %eax
+@@ -128,7 +128,7 @@ LBL(caml_call_gc):
+         movl    %eax, 0(%esp)
+         addl    $(STACK_PROBE_SIZE), %esp; CFI_ADJUST(-STACK_PROBE_SIZE);
+ #endif
+-    /* Build array of registers, save it into Caml_state->gc_regs */
++    /* Build array of registers, save it into caml_state->gc_regs */
+         pushl   %ebp; CFI_ADJUST(4)
+         pushl   %edi; CFI_ADJUST(4)
+         pushl   %esi; CFI_ADJUST(4)
+@@ -156,7 +156,7 @@ LBL(caml_call_gc):
+ 
+ FUNCTION(caml_alloc1)
+         CFI_STARTPROC
+-        movl    G(Caml_state), %ebx
++        movl    G(caml_state), %ebx
+         movl    CAML_STATE(young_ptr, %ebx), %eax
+         subl    $8, %eax
+         movl    %eax, CAML_STATE(young_ptr, %ebx)
+@@ -168,7 +168,7 @@ FUNCTION(caml_alloc1)
+ 
+ FUNCTION(caml_alloc2)
+         CFI_STARTPROC
+-        movl    G(Caml_state), %ebx
++        movl    G(caml_state), %ebx
+         movl    CAML_STATE(young_ptr, %ebx), %eax
+         subl    $12, %eax
+         movl    %eax, CAML_STATE(young_ptr, %ebx)
+@@ -180,7 +180,7 @@ FUNCTION(caml_alloc2)
+ 
+ FUNCTION(caml_alloc3)
+         CFI_STARTPROC
+-        movl    G(Caml_state), %ebx
++        movl    G(caml_state), %ebx
+         movl    CAML_STATE(young_ptr, %ebx), %eax
+         subl    $16, %eax
+         movl    %eax, CAML_STATE(young_ptr, %ebx)
+@@ -192,10 +192,10 @@ FUNCTION(caml_alloc3)
+ 
+ FUNCTION(caml_allocN)
+         CFI_STARTPROC
+-        movl    G(Caml_state), %ebx
+-        /* eax = size - Caml_state->young_ptr */
++        movl    G(caml_state), %ebx
++        /* eax = size - caml_state->young_ptr */
+         subl    CAML_STATE(young_ptr, %ebx), %eax
+-        negl    %eax              /* eax = Caml_state->young_ptr - size */
++        negl    %eax              /* eax = caml_state->young_ptr - size */
+         movl    %eax, CAML_STATE(young_ptr, %ebx)
+         cmpl    CAML_STATE(young_limit, %ebx), %eax
+         jb      LBL(caml_call_gc)
+@@ -209,7 +209,7 @@ FUNCTION(caml_c_call)
+         CFI_STARTPROC
+     /* Record lowest stack address and return address */
+     /* ecx and edx are destroyed at C call. Use them as temp. */
+-        movl    G(Caml_state), %ecx
++        movl    G(caml_state), %ecx
+         movl    (%esp), %edx
+         movl    %edx, CAML_STATE(last_return_address, %ecx)
+         leal    4(%esp), %edx
+@@ -239,7 +239,7 @@ FUNCTION(caml_start_program)
+         movl    $ G(caml_program), %esi
+     /* Common code for caml_start_program and caml_callback* */
+ LBL(106):
+-        movl    G(Caml_state), %edi
++        movl    G(caml_state), %edi
+     /* Build a callback link */
+         pushl   CAML_STATE(gc_regs, %edi); CFI_ADJUST(4)
+         pushl   CAML_STATE(last_return_address, %edi); CFI_ADJUST(4)
+@@ -253,12 +253,12 @@ LBL(106):
+     /* Call the OCaml code */
+         call    *%esi
+ LBL(107):
+-        movl    G(Caml_state), %edi
++        movl    G(caml_state), %edi
+     /* Pop the exception handler */
+         popl    CAML_STATE(exception_pointer, %edi); CFI_ADJUST(-4)
+         addl    $12, %esp       ; CFI_ADJUST(-12)
+ LBL(109):
+-        movl    G(Caml_state), %edi /* Reload for LBL(109) entry */
++        movl    G(caml_state), %edi /* Reload for LBL(109) entry */
+     /* Pop the callback link, restoring the global variables */
+         popl    CAML_STATE(bottom_of_stack, %edi); CFI_ADJUST(-4)
+         popl    CAML_STATE(last_return_address, %edi); CFI_ADJUST(-4)
+@@ -282,7 +282,7 @@ LBL(108):
+ 
+ FUNCTION(caml_raise_exn)
+         CFI_STARTPROC
+-        movl    G(Caml_state), %ebx
++        movl    G(caml_state), %ebx
+         testl   $1, CAML_STATE(backtrace_active, %ebx)
+         jne     LBL(110)
+         movl    CAML_STATE(exception_pointer, %ebx), %esp
+@@ -312,7 +312,7 @@ LBL(110):
+ 
+ FUNCTION(caml_raise_exception)
+         CFI_STARTPROC
+-        movl    G(Caml_state), %ebx
++        movl    G(caml_state), %ebx
+         testl   $1, CAML_STATE(backtrace_active, %ebx)
+         jne     LBL(112)
+         movl    8(%esp), %eax
+@@ -405,7 +405,7 @@ FUNCTION(caml_ml_array_bound_error)
+         ffree   %st(6)
+         ffree   %st(7)
+     /* Record lowest stack address and return address */
+-        movl    G(Caml_state), %ebx
++        movl    G(caml_state), %ebx
+         movl    (%esp), %edx
+         movl    %edx, CAML_STATE(last_return_address, %ebx)
+         leal    4(%esp), %edx
+@@ -422,8 +422,8 @@ FUNCTION(caml_ml_array_bound_error)
+ G(caml_system__code_end):
+ 
+         .data
+-        .globl  G(caml_system__frametable)
+-G(caml_system__frametable):
++        .globl  G(caml_system.frametable)
++G(caml_system.frametable):
+         .long   1               /* one descriptor */
+         .long   LBL(107)        /* return address into callback */
+ #ifndef SYS_solaris
+diff --git a/runtime/interp.c b/runtime/interp.c
+index e6700994bc..a59811c87d 100644
+--- a/runtime/interp.c
++++ b/runtime/interp.c
+@@ -50,9 +50,9 @@ sp is a local copy of the global variable Caml_state->extern_sp. */
+ #ifdef THREADED_CODE
+ #  define Instruct(name) lbl_##name
+ #  if defined(ARCH_SIXTYFOUR) && !defined(ARCH_CODE32)
+-#    define Jumptbl_base &&lbl_ACC0
++#    define Jumptbl_base ((char *) &&lbl_ACC0)
+ #  else
+-#    define Jumptbl_base 0
++#    define Jumptbl_base ((char *) 0)
+ #    define jumptbl_base ((char *) 0)
+ #  endif
+ #  ifdef DEBUG
+@@ -249,7 +249,8 @@ value caml_interprete(code_t prog, asize_t prog_size)
+ 
+   if (prog == NULL) {           /* Interpreter is initializing */
+ #ifdef THREADED_CODE
+-    caml_init_thread_code(jumptable, Jumptbl_base);
++    caml_instr_table = (char **) jumptable;
++    caml_instr_base = Jumptbl_base;
+ #endif
+     return Val_unit;
+   }
+diff --git a/runtime/power.S b/runtime/power.S
+index 4ca1a14538..68486cb7dc 100644
+--- a/runtime/power.S
++++ b/runtime/power.S
+@@ -645,9 +645,9 @@ caml_system__code_end:
+ /* Frame table */
+ 
+         .section ".data"
+-        .globl  caml_system__frametable
+-        .type   caml_system__frametable, @object
+-caml_system__frametable:
++        .globl  caml_system.frametable
++        .type   caml_system.frametable, @object
++caml_system.frametable:
+         datag   1               /* one descriptor */
+         datag   .L105 + 4       /* return address into callback */
+         .short  -1              /* negative size count => use callback link */
+diff --git a/runtime/prng.c b/runtime/prng.c
+new file mode 100644
+index 0000000000..4357afbbfb
+--- /dev/null
++++ b/runtime/prng.c
+@@ -0,0 +1,69 @@
++/**************************************************************************/
++/*                                                                        */
++/*                                 OCaml                                  */
++/*                                                                        */
++/*          Xavier Leroy, projet Cambium, College de France and Inria     */
++/*                                                                        */
++/*   Copyright 2021 Institut National de Recherche en Informatique et     */
++/*     en Automatique.                                                    */
++/*                                                                        */
++/*   All rights reserved.  This file is distributed under the terms of    */
++/*   the GNU Lesser General Public License version 2.1, with the          */
++/*   special exception on linking described in the file LICENSE.          */
++/*                                                                        */
++/**************************************************************************/
++
++#include <string.h>
++#include "caml/alloc.h"
++#include "caml/bigarray.h"
++#include "caml/mlvalues.h"
++
++/* The L64X128 member of the LXM family.  Taken from figure 1 in
++   "LXM: Better Splittable Pseudorandom Number Generators
++    (and Almost as Fast)" by Guy L. Steele Jr. and Sebastiano Vigna,
++    OOPSLA 2021.  */
++
++static const uint64_t M = 0xd1342543de82ef95;
++
++struct LXM_state {
++  uint64_t a;            /* per-instance additive parameter (odd) */
++  uint64_t s;            /* state of the LCG subgenerator */
++  uint64_t x[2];         /* state of the XBG subgenerator (not 0) */
++};
++
++/* In OCaml, states are represented as a 1D big array of 64-bit integers */
++
++#define LXM_val(v) ((struct LXM_state *) Caml_ba_data_val(v))
++
++Caml_inline uint64_t rotl(const uint64_t x, int k) {
++  return (x << k) | (x >> (64 - k));
++}
++
++CAMLprim uint64_t caml_lxm_next_unboxed(value v)
++{
++  uint64_t z, q0, q1;
++  struct LXM_state * st = LXM_val(v);
++
++  /* Combining operation */
++  z = st->s + st->x[0];
++  /* Mixing function */
++  z = (z ^ (z >> 32)) * 0xdaba0b6eb09322e3;
++  z = (z ^ (z >> 32)) * 0xdaba0b6eb09322e3;
++  z = (z ^ (z >> 32));
++  /* LCG update */
++  st->s = st->s * M + st->a;
++  /* XBG update */
++  q0 = st->x[0]; q1 = st->x[1];
++  q1 ^= q0;
++  q0 = rotl(q0, 24);
++  q0 = q0 ^ q1 ^ (q1 << 16);
++  q1 = rotl(q1, 37);
++  st->x[0] = q0; st->x[1] = q1;
++  /* Return result */
++  return z;
++}
++
++CAMLprim value caml_lxm_next(value v)
++{
++  return caml_copy_int64(caml_lxm_next_unboxed(v));
++}
+diff --git a/runtime/riscv.S b/runtime/riscv.S
+index 25b624b56b..112627726f 100644
+--- a/runtime/riscv.S
++++ b/runtime/riscv.S
+@@ -442,12 +442,12 @@ caml_system__code_end:
+ 
+         .section .data
+         .align  3
+-        .globl  caml_system__frametable
+-        .type   caml_system__frametable, @object
+-caml_system__frametable:
++        .globl  caml_system.frametable
++        .type   caml_system.frametable, @object
++caml_system.frametable:
+         .quad   1               /* one descriptor */
+         .quad   .Lcaml_retaddr  /* return address into callback */
+         .short  -1              /* negative frame size => use callback link */
+         .short  0               /* no roots */
+         .align  3
+-        .size   caml_system__frametable, .-caml_system__frametable
++        .size   caml_system.frametable, .-caml_system.frametable
+diff --git a/runtime/s390x.S b/runtime/s390x.S
+index aab63e9b24..a05f721836 100644
+--- a/runtime/s390x.S
++++ b/runtime/s390x.S
+@@ -342,9 +342,9 @@ caml_system__code_end:
+ 
+         .section ".data"
+         .align 8
+-        .globl  caml_system__frametable
+-        .type   caml_system__frametable, @object
+-caml_system__frametable:
++        .globl  caml_system.frametable
++        .type   caml_system.frametable, @object
++caml_system.frametable:
+         .quad   1               /* one descriptor */
+         .quad   .L105           /* return address into callback */
+         .short  -1              /* negative size count => use callback link */
+diff --git a/runtime/sak.c b/runtime/sak.c
+index b7e5c721c2..7499dbf46f 100644
+--- a/runtime/sak.c
++++ b/runtime/sak.c
+@@ -34,7 +34,9 @@
+ #define printf_os wprintf
+ #else
+ #define strncmp_os strncmp
+-#define toupper_os toupper
++/* NOTE: See CAVEATS section in https://man.netbsd.org/ctype.3 */
++/* and NOTE section in https://man7.org/linux/man-pages/man3/toupper.3.html */
++#define toupper_os(x) toupper((unsigned char)x)
+ #define printf_os printf
+ #endif
+ 
+diff --git a/runtime/sys.c b/runtime/sys.c
+index a77fd9d1cf..9508d3f903 100644
+--- a/runtime/sys.c
++++ b/runtime/sys.c
+@@ -45,6 +45,9 @@
+ #ifdef HAS_GETTIMEOFDAY
+ #include <sys/time.h>
+ #endif
++#ifdef __APPLE__
++#include <sys/random.h> /* for getentropy */
++#endif
+ #include "caml/alloc.h"
+ #include "caml/debugger.h"
+ #include "caml/fail.h"
+@@ -61,9 +64,21 @@
+ #include "caml/callback.h"
+ #include "caml/startup_aux.h"
+ 
+-static char * error_message(void)
++CAMLexport char * caml_strerror(int errnum, char * buf, size_t buflen)
+ {
+-  return strerror(errno);
++#ifdef _WIN32
++  /* Windows has a thread-safe strerror */
++  return strerror(errnum);
++#else
++  int res = strerror_r(errnum, buf, buflen);
++  /* glibc<2.13 returns -1/sets errno, >2.13 returns +ve errno.
++     We assume that buffer size is large enough not to get ERANGE,
++     so we assume we got EINVAL. */
++  if (res != 0) {
++    snprintf(buf, buflen, "Unknown error %d", errnum);
++  }
++  return buf;
++#endif
+ }
+ 
+ #ifndef EAGAIN
+@@ -77,9 +92,10 @@ CAMLexport void caml_sys_error(value arg)
+ {
+   CAMLparam1 (arg);
+   char * err;
++  char buf[1024];
+   CAMLlocal1 (str);
+ 
+-  err = error_message();
++  err = caml_strerror(errno, buf, sizeof(buf));
+   if (arg == NO_ARG) {
+     str = caml_copy_string(err);
+   } else {
+@@ -236,7 +252,7 @@ CAMLprim value caml_sys_close(value fd_v)
+   return Val_unit;
+ }
+ 
+-CAMLprim value caml_sys_file_exists(value name)
++static int caml_sys_file_mode(value name)
+ {
+ #ifdef _WIN32
+   struct _stati64 st;
+@@ -246,39 +262,42 @@ CAMLprim value caml_sys_file_exists(value name)
+   char_os * p;
+   int ret;
+ 
+-  if (! caml_string_is_c_safe(name)) return Val_false;
++  if (! caml_string_is_c_safe(name)) { errno = ENOENT; return -1; }
+   p = caml_stat_strdup_to_os(String_val(name));
+   caml_enter_blocking_section();
+   ret = stat_os(p, &st);
+   caml_leave_blocking_section();
+   caml_stat_free(p);
++  if (ret == -1) return -1; else return st.st_mode;
++}
+ 
+-  return Val_bool(ret == 0);
++CAMLprim value caml_sys_file_exists(value name)
++{
++  int mode = caml_sys_file_mode(name);
++  return (Val_bool(mode != -1));
+ }
+ 
+ CAMLprim value caml_sys_is_directory(value name)
+ {
+   CAMLparam1(name);
+-#ifdef _WIN32
+-  struct _stati64 st;
++  int mode = caml_sys_file_mode(name);
++  if (mode == -1) caml_sys_error(name);
++#ifdef S_ISDIR
++  CAMLreturn(Val_bool(S_ISDIR(mode)));
+ #else
+-  struct stat st;
++  CAMLreturn(Val_bool(mode & S_IFDIR));
+ #endif
+-  char_os * p;
+-  int ret;
+-
+-  caml_sys_check_path(name);
+-  p = caml_stat_strdup_to_os(String_val(name));
+-  caml_enter_blocking_section();
+-  ret = stat_os(p, &st);
+-  caml_leave_blocking_section();
+-  caml_stat_free(p);
++}
+ 
+-  if (ret == -1) caml_sys_error(name);
+-#ifdef S_ISDIR
+-  CAMLreturn(Val_bool(S_ISDIR(st.st_mode)));
++CAMLprim value caml_sys_is_regular_file(value name)
++{
++  CAMLparam1(name);
++  int mode = caml_sys_file_mode(name);
++  if (mode == -1) caml_sys_error(name);
++#ifdef S_ISREG
++  CAMLreturn(Val_bool(S_ISREG(mode)));
+ #else
+-  CAMLreturn(Val_bool(st.st_mode & S_IFDIR));
++  CAMLreturn(Val_bool(mode & S_IFREG));
+ #endif
+ }
+ 
+@@ -565,20 +584,27 @@ extern int caml_win32_random_seed (intnat data[16]);
+ #else
+ int caml_unix_random_seed(intnat data[16])
+ {
+-  int fd;
+   int n = 0;
+-
+-  /* Try /dev/urandom first */
+-  fd = open("/dev/urandom", O_RDONLY, 0);
+-  if (fd != -1) {
+-    unsigned char buffer[12];
+-    int nread = read(fd, buffer, 12);
+-    close(fd);
+-    while (nread > 0) data[n++] = buffer[--nread];
++  unsigned char buffer[12];
++  int nread = 0;
++
++  /* Try kernel entropy first */
++#if defined(HAS_GETENTROPY) || defined(__APPLE__)
++  if (getentropy(buffer, 12) != -1) {
++    nread = 12;
++  } else
++#endif
++  { int fd = open("/dev/urandom", O_RDONLY, 0);
++    if (fd != -1) {
++      nread = read(fd, buffer, 12);
++      close(fd);
++    }
+   }
+-  /* If the read from /dev/urandom fully succeeded, we now have 96 bits
++  while (nread > 0) data[n++] = buffer[--nread];
++  /* If the kernel provided enough entropy, we now have 96 bits
+      of good random data and can stop here. */
+   if (n >= 12) return n;
++
+   /* Otherwise, complement whatever we got (probably nothing)
+      with some not-very-random data. */
+   {
diff --git a/diff-against-trunk-support.diff b/diff-against-trunk-support.diff
new file mode 100644
index 0000000000..381be8cdc2
--- /dev/null
+++ b/diff-against-trunk-support.diff
@@ -0,0 +1,3974 @@
+diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
+index 59b5162a2f..13cd6abde1 100644
+--- a/.github/workflows/build.yml
++++ b/.github/workflows/build.yml
+@@ -57,7 +57,7 @@ jobs:
+          '${{ github.event.repository.full_name }}'
+       - name: Configure tree
+         run: |
+-          MAKE_ARG=-j XARCH=x64 CONFIG_ARG='--enable-flambda --enable-cmm-invariants --enable-dependency-generation --enable-native-toplevel' OCAMLRUNPARAM=b,v=0 bash -xe tools/ci/actions/runner.sh configure
++          MAKE_ARG=-j CONFIG_ARG='--enable-flambda --enable-cmm-invariants --enable-dependency-generation --enable-native-toplevel' OCAMLRUNPARAM=b,v=0 bash -xe tools/ci/actions/runner.sh configure
+       - name: Build
+         run: |
+           MAKE_ARG=-j bash -xe tools/ci/actions/runner.sh build
+@@ -125,7 +125,7 @@ jobs:
+         run: brew install parallel
+       - name: configure tree
+         run: |
+-          CONFIG_ARG=${{ matrix.config_arg }} MAKE_ARG=-j XARCH=x64 bash -xe tools/ci/actions/runner.sh configure
++          CONFIG_ARG=${{ matrix.config_arg }} MAKE_ARG=-j bash -xe tools/ci/actions/runner.sh configure
+       - name: Build
+         run: |
+           MAKE_ARG=-j bash -xe tools/ci/actions/runner.sh build
+@@ -146,7 +146,7 @@ jobs:
+   i386:
+     runs-on: ubuntu-latest
+     container:
+-      image: i386/ubuntu:18.04
++      image: debian:10
+       options: --platform linux/i386 --user root
+     steps:
+       - name: OS Dependencies
+@@ -158,7 +158,7 @@ jobs:
+         uses: actions/checkout@v1
+       - name: configure tree
+         run: |
+-          MAKE_ARG=-j XARCH=i386 bash -xe tools/ci/actions/runner.sh configure
++          MAKE_ARG=-j bash -xe tools/ci/actions/runner.sh configure
+       - name: Build
+         run: |
+           MAKE_ARG=-j bash -xe tools/ci/actions/runner.sh build
+diff --git a/appveyor.yml b/appveyor.yml
+index 333bcad1af..94ee1cfe3d 100644
+--- a/appveyor.yml
++++ b/appveyor.yml
+@@ -31,9 +31,10 @@ environment:
+     FORCE_CYGWIN_UPGRADE: 0
+     BUILD_MODE: world.opt
+   matrix:
++    - PORT: mingw32
++      BOOTSTRAP_FLEXDLL: true
+     - PORT: mingw64
+       BOOTSTRAP_FLEXDLL: true
+-# OCaml 5.0 does not yet support MSVC
+ #    - PORT: msvc64
+ #      BOOTSTRAP_FLEXDLL: false
+ #      BUILD_MODE: steps
+@@ -43,8 +44,8 @@ environment:
+ #      SDK: |-
+ #        "C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\SetEnv.cmd" /x86
+ 
+-matrix:
+-  fast_finish: true
++#matrix:
++#  fast_finish: true
+ 
+ cache:
+   - C:\cygwin64\var\cache\setup
+diff --git a/ocamltest/builtin_actions.ml b/ocamltest/builtin_actions.ml
+index 0bc17bc281..faae83cf0e 100644
+--- a/ocamltest/builtin_actions.ml
++++ b/ocamltest/builtin_actions.ml
+@@ -204,6 +204,13 @@ let function_sections = make
+      "Target supports function sections"
+      "Target does not support function sections")
+ 
++let naked_pointers = make
++  ~name:"naked_pointers"
++  ~description:"Pass if target supports naked pointers"
++  (Actions_helpers.pass_or_skip (Ocamltest_config.naked_pointers)
++     "Runtime system supports naked pointers"
++     "Runtime system does not support naked pointers")
++
+ let frame_pointers = make
+   ~name:"frame_pointers"
+   ~description:"Pass if frame pointers are available"
+@@ -343,6 +350,7 @@ let _ =
+     arch_i386;
+     arch_power;
+     function_sections;
++    naked_pointers;
+     frame_pointers;
+     file_exists;
+     copy;
+diff --git a/ocamltest/ocamltest_config.ml.in b/ocamltest/ocamltest_config.ml.in
+index 282090b4c3..dfda7b1f87 100644
+--- a/ocamltest/ocamltest_config.ml.in
++++ b/ocamltest/ocamltest_config.ml.in
+@@ -90,4 +90,6 @@ let function_sections = @function_sections@
+ 
+ let instrumented_runtime = @instrumented_runtime@
+ 
++let naked_pointers = @naked_pointers@
++
+ let frame_pointers = @frame_pointers@
+diff --git a/ocamltest/ocamltest_config.mli b/ocamltest/ocamltest_config.mli
+index cbe1432466..d20ec18ff3 100644
+--- a/ocamltest/ocamltest_config.mli
++++ b/ocamltest/ocamltest_config.mli
+@@ -125,5 +125,8 @@ val function_sections : bool
+ val instrumented_runtime : bool
+ (** Whether the instrumented runtime is available *)
+ 
++val naked_pointers : bool
++(** Whether the runtime system supports naked pointers outside the heap *)
++
+ val frame_pointers : bool
+ (** Whether frame-pointers have been enabled at configure time *)
+diff --git a/ocamltest/run_unix.c b/ocamltest/run_unix.c
+index 80eac2d727..f8f264f471 100644
+--- a/ocamltest/run_unix.c
++++ b/ocamltest/run_unix.c
+@@ -349,7 +349,9 @@ int run_command(const command_settings *settings)
+       myperror("fork");
+       return -1;
+     case 0: /* child process */
++#if 0
+       caml_atfork_hook();
++#endif
+       exit( run_command_child(settings) );
+     default:
+       return run_command_parent(settings, child_pid);
+diff --git a/testsuite/tests/asmcomp/is_in_static_data.c b/testsuite/tests/asmcomp/is_in_static_data.c
+new file mode 100644
+index 0000000000..ccf0582c0a
+--- /dev/null
++++ b/testsuite/tests/asmcomp/is_in_static_data.c
+@@ -0,0 +1,5 @@
++#include "caml/address_class.h"
++
++value caml_is_in_static_data(value v) {
++  return(Val_bool(Is_in_static_data(v)));
++}
+diff --git a/testsuite/tests/asmcomp/is_static.ml b/testsuite/tests/asmcomp/is_static.ml
+new file mode 100644
+index 0000000000..b8a3bef006
+--- /dev/null
++++ b/testsuite/tests/asmcomp/is_static.ml
+@@ -0,0 +1,40 @@
++(* TEST
++   modules = "is_in_static_data.c"
++   * naked_pointers
++   ** native
++*)
++
++(* Data that should be statically allocated by the compiler (all versions) *)
++
++external is_in_static_data : 'a -> bool = "caml_is_in_static_data"
++
++(* Basic constant blocks should be static *)
++let block1 = (1,2)
++let () = assert(is_in_static_data block1)
++
++(* as pattern shouldn't prevent it *)
++let (a, b) as block2 = (1,2)
++let () = assert(is_in_static_data block2)
++
++(* Also in functions *)
++let f () =
++  let block = (1,2) in
++  assert(is_in_static_data block)
++
++let () = (f [@inlined never]) ()
++
++(* Closed functions should be static *)
++let closed_function x = x + 1 (* + is a primitive, it cannot be in the closure*)
++let () = assert(is_in_static_data closed_function)
++
++(* And functions using closed functions *)
++let almost_closed_function x =
++  (closed_function [@inlined never]) x
++let () = assert(is_in_static_data almost_closed_function)
++
++(* Recursive constant functions should be static *)
++let rec f1 a = g1 a
++and g1 a = f1 a
++let () =
++  assert(is_in_static_data f1);
++  assert(is_in_static_data g1)
+diff --git a/testsuite/tests/asmcomp/is_static_flambda.ml b/testsuite/tests/asmcomp/is_static_flambda.ml
+new file mode 100644
+index 0000000000..63e53cfc42
+--- /dev/null
++++ b/testsuite/tests/asmcomp/is_static_flambda.ml
+@@ -0,0 +1,207 @@
++(* TEST
++   modules = "is_in_static_data.c is_static_flambda_dep.ml"
++   * flambda
++   ** naked_pointers
++   *** native
++*)
++
++(* Data that should be statically allocated by the compiler (flambda only) *)
++
++external is_in_static_data : 'a -> bool = "caml_is_in_static_data"
++
++(* Also after inlining *)
++let g x =
++  let block = (1,x) in
++  assert(is_in_static_data block)
++
++let () = (g [@inlined always]) 2
++
++(* Toplevel immutable blocks should be static *)
++let block3 = (Sys.opaque_identity 1, Sys.opaque_identity 2)
++let () = assert(is_in_static_data block3)
++
++(* Not being bound shouldn't prevent it *)
++let () =
++  assert(is_in_static_data (Sys.opaque_identity 1, Sys.opaque_identity 2))
++
++(* Only with rounds >= 2 currently !
++(* Also after inlining *)
++let h x =
++  let block = (Sys.opaque_identity 1,x) in
++  assert(is_in_static_data block)
++
++let () = (h [@inlined always]) (Sys.opaque_identity 2)
++*)
++
++(* Recursive constant values should be static *)
++let rec a = 1 :: b
++and b = 2 :: a
++let () =
++  assert(is_in_static_data a);
++  assert(is_in_static_data b)
++
++(* And a mix *)
++type e = E : 'a -> e
++
++let rec f1 a = E (g1 a, l1)
++and g1 a = E (f1 a, l2)
++and l1 = E (f1, l2)
++and l2 = E (g1, l1)
++
++let () =
++  assert(is_in_static_data f1);
++  assert(is_in_static_data g1);
++  assert(is_in_static_data l1);
++  assert(is_in_static_data l2)
++
++(* Also in functions *)
++let i () =
++  let rec f1 a = E (g1 a, l1)
++  and g1 a = E (f1 a, l2)
++  and l1 = E (f1, l2)
++  and l2 = E (g1, l1) in
++
++  assert(is_in_static_data f1);
++  assert(is_in_static_data g1);
++  assert(is_in_static_data l1);
++  assert(is_in_static_data l2)
++
++let () = (i [@inlined never]) ()
++
++module type P = module type of Stdlib
++(* Top-level modules should be static *)
++let () = assert(is_in_static_data (module Stdlib:P))
++
++(* Not constant let rec to test extraction to initialize_symbol *)
++let r = ref 0
++let rec a = (incr r; !r) :: b
++and b = (incr r; !r) :: a
++
++let next =
++  let r = ref 0 in
++  fun () -> incr r; !r
++
++let () =
++  assert(is_in_static_data next)
++
++(* Exceptions without arguments should be static *)
++exception No_argument
++let () = assert(is_in_static_data No_argument)
++
++(* And also with constant arguments *)
++exception Some_argument of string
++let () = assert(is_in_static_data (Some_argument "some string"))
++
++(* Even when exposed by inlining *)
++let () =
++  let exn =
++    try (failwith [@inlined always]) "some other string" with exn -> exn
++  in
++  assert(is_in_static_data exn)
++
++(* Verify that approximation intersection correctly loads exported
++   approximations.
++
++   Is_static_flambda_dep.pair is a pair with 1 as first element. The
++   intersection of approximations should return a block with
++   approximation: [tag 0: [tag 0: Int 1, Unknown], Unknown] *)
++let f x =
++  let pair =
++    if Sys.opaque_identity x then
++      (1, 2), 3
++    else
++      Is_static_flambda_dep.pair, 4
++  in
++  let n = fst (fst pair) in
++  let res = n, n in
++  assert(is_in_static_data res)
++  [@@inline never]
++
++let () =
++  f true;
++  f false
++
++(* Verify that physical equality/inequality is correctly propagated *)
++
++(* In these tests, tuple can be statically allocated only if it is a
++   known constant since the function is never inlined (hence this
++   code is never at toplevel) *)
++
++let () =
++  let f () =
++    let v = (1, 2) in
++    (* eq is supposed to be considered always true since v is a
++       constant, hence aliased to a symbol.
++       It is not yet optimized away if it is not constant *)
++    let eq = v == v in
++    let n = if eq then 1 else 2 in
++    let tuple = (n,n) in
++    assert(is_in_static_data tuple)
++  in
++  (f [@inlined never]) ()
++
++let () =
++  let f () =
++    let v = (1, 2) in
++    (* same with inequality *)
++    let eq = v != v in
++    let n = if eq then 1 else 2 in
++    let tuple = (n,n) in
++    assert(is_in_static_data tuple)
++  in
++  (f [@inlined never]) ()
++
++let () =
++  let f x =
++    let v1 = Some x in
++    let v2 = None in
++    let eq = v1 == v2 in
++    (* The values are structurally different, so must be physically
++       different *)
++    let n = if eq then 1 else 2 in
++    let tuple = (n,n) in
++    assert(is_in_static_data tuple)
++  in
++  (f [@inlined never]) ()
++
++let () =
++  let f x =
++    let v1 = Some x in
++    let v2 = None in
++    let eq = v1 != v2 in
++    (* same with inequality *)
++    let n = if eq then 1 else 2 in
++    let tuple = (n,n) in
++    assert(is_in_static_data tuple)
++  in
++  (f [@inlined never]) ()
++
++let () =
++  let f x =
++    let v1 = (1, 2) in
++    let v2 = (3, 2) in
++    let eq = v1 == v2 in
++    (* difference is deeper *)
++    let n = if eq then 1 else 2 in
++    let tuple = (n,n) in
++    assert(is_in_static_data tuple)
++  in
++  (f [@inlined never]) ()
++
++module Int = struct
++  type t = int
++  let compare (a:int) b = compare a b
++end
++module IntMap = Map.Make (Int)
++
++let () =
++  let f () =
++    let a = IntMap.empty in
++    let b = (IntMap.add [@inlined]) 1 (Some 1) a in
++    assert(is_in_static_data b);
++    let c = (IntMap.add [@inlined]) 1 (Some 2) b in
++    assert(is_in_static_data c);
++    let d = (IntMap.add [@inlined]) 1 (Some 2) c in
++    assert(is_in_static_data d);
++  in
++  (f [@inlined never]) ()
+diff --git a/testsuite/tests/asmcomp/is_static_flambda_dep.ml b/testsuite/tests/asmcomp/is_static_flambda_dep.ml
+new file mode 100644
+index 0000000000..3a50f7cad4
+--- /dev/null
++++ b/testsuite/tests/asmcomp/is_static_flambda_dep.ml
+@@ -0,0 +1 @@
++let pair = 1, 12
+diff --git a/testsuite/tests/asmcomp/polling.c b/testsuite/tests/asmcomp/polling.c
+index b10b9fa4ea..b4680dcd04 100644
+--- a/testsuite/tests/asmcomp/polling.c
++++ b/testsuite/tests/asmcomp/polling.c
+@@ -14,11 +14,18 @@ CAMLprim value request_minor_gc(value v) {
+     tests are only run in a single domain, so we're probably
+     good.
+   */
++#if 0
+   Caml_state->young_limit = (uintnat)Caml_state->young_end;
++#endif
++  caml_something_to_do = 1;
++  Caml_state->young_limit = Caml_state->young_alloc_end;
+ 
+   return Val_unit;
+ }
+ 
+ CAMLprim value minor_gcs(value v) {
++#if 0
+   return Val_long(atomic_load(&caml_minor_collections_count));
++#endif
++  return Val_long(Caml_state->stat_minor_collections);
+ }
+diff --git a/testsuite/tests/asmcomp/simple_float_const.ml b/testsuite/tests/asmcomp/simple_float_const.ml
+new file mode 100644
+index 0000000000..1aca414f7e
+--- /dev/null
++++ b/testsuite/tests/asmcomp/simple_float_const.ml
+@@ -0,0 +1 @@
++let f = 3.14
+diff --git a/testsuite/tests/asmcomp/simple_float_const_opaque.ml b/testsuite/tests/asmcomp/simple_float_const_opaque.ml
+new file mode 100644
+index 0000000000..1aca414f7e
+--- /dev/null
++++ b/testsuite/tests/asmcomp/simple_float_const_opaque.ml
+@@ -0,0 +1 @@
++let f = 3.14
+diff --git a/testsuite/tests/asmcomp/static_float_array_flambda.ml b/testsuite/tests/asmcomp/static_float_array_flambda.ml
+new file mode 100644
+index 0000000000..824a12ca89
+--- /dev/null
++++ b/testsuite/tests/asmcomp/static_float_array_flambda.ml
+@@ -0,0 +1,26 @@
++(* TEST
++   modules = "is_in_static_data.c simple_float_const.ml"
++   * flambda
++   ** flat-float-array
++   *** naked_pointers
++   **** native
++*)
++
++external is_in_static_data : 'a -> bool = "caml_is_in_static_data"
++
++let a = [|0.; 1.|]
++let f = 1.23
++let b = [|0.; f; f|]
++let g = Sys.opaque_identity 1.23
++let c = [|0.; g|]
++let d = [|0.; Simple_float_const.f|]
++
++let () = assert(is_in_static_data a)
++let () = assert(is_in_static_data f)
++let () = assert(is_in_static_data b)
++
++let () = assert(not (is_in_static_data c))
++(* In fact this one could be static by preallocating the array then
++   patching it when g is available *)
++
++let () = assert(is_in_static_data d)
+diff --git a/testsuite/tests/asmcomp/static_float_array_flambda_opaque.ml b/testsuite/tests/asmcomp/static_float_array_flambda_opaque.ml
+new file mode 100644
+index 0000000000..56ea9e1793
+--- /dev/null
++++ b/testsuite/tests/asmcomp/static_float_array_flambda_opaque.ml
+@@ -0,0 +1,30 @@
++(* TEST
++   modules = "is_in_static_data.c simple_float_const_opaque.ml"
++   flags = "-opaque"
++   * flambda
++   ** flat-float-array
++   *** naked_pointers
++   **** native
++*)
++
++external is_in_static_data : 'a -> bool = "caml_is_in_static_data"
++
++let a = [|0.; 1.|]
++let f = 1.23
++let b = [|0.; f; f|]
++let g = Sys.opaque_identity 1.23
++let c = [|0.; g|]
++let d = [|0.; Simple_float_const_opaque.f|]
++
++let () = assert(is_in_static_data a)
++let () = assert(is_in_static_data f)
++let () = assert(is_in_static_data b)
++
++let () = assert(not (is_in_static_data c))
++(* In fact this one could be static by preallocating the array then
++   patching it when g is available *)
++
++let () = assert(not (is_in_static_data d))
++(* The dependency Simple_float_const_opaque is built with opaque,
++   hence the value of Simple_float_const_opaque.f cannot be known
++   preventing the static allocation of d *)
+diff --git a/testsuite/tests/backtrace/backtrace2.reference b/testsuite/tests/backtrace/backtrace2.reference
+index 62ae0cb77b..816405ff78 100644
+--- a/testsuite/tests/backtrace/backtrace2.reference
++++ b/testsuite/tests/backtrace/backtrace2.reference
+@@ -35,7 +35,7 @@ Uncaught exception Invalid_argument("index out of bounds")
+ Raised by primitive operation at Backtrace2.run in file "backtrace2.ml", line 62, characters 14-22
+ test_Not_found
+ Uncaught exception Not_found
+-Raised at Stdlib__Hashtbl.find in file "hashtbl.ml", line 542, characters 13-28
++Raised at Stdlib__Hashtbl.find in file "hashtbl.ml", line 550, characters 13-28
+ Called from Backtrace2.test_Not_found in file "backtrace2.ml", line 43, characters 9-42
+ Re-raised at Backtrace2.test_Not_found in file "backtrace2.ml", line 43, characters 61-70
+ Called from Backtrace2.run in file "backtrace2.ml", line 62, characters 11-23
+@@ -46,13 +46,13 @@ Called from Backtrace2.test_lazy.aux in file "backtrace2.ml", line 47, character
+ Called from Backtrace2.test_lazy.aux in file "backtrace2.ml", line 47, characters 43-52
+ Called from Backtrace2.test_lazy.aux in file "backtrace2.ml", line 47, characters 43-52
+ Called from Backtrace2.test_lazy.aux in file "backtrace2.ml", line 47, characters 43-52
+-Called from CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 49, characters 17-27
+-Re-raised at CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 56, characters 4-11
++Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 119, characters 17-27
++Re-raised at CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 124, characters 4-11
+ Called from Backtrace2.run in file "backtrace2.ml", line 62, characters 11-23
+ Uncaught exception Not_found
+-Raised at Stdlib__Hashtbl.find in file "hashtbl.ml", line 542, characters 13-28
++Raised at Stdlib__Hashtbl.find in file "hashtbl.ml", line 550, characters 13-28
+ Called from Backtrace2.test_lazy.exception_raised_internally in file "backtrace2.ml", line 50, characters 8-41
+-Re-raised at CamlinternalLazy.do_force_block.(fun) in file "camlinternalLazy.ml", line 54, characters 43-50
+-Called from CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 49, characters 17-27
+-Re-raised at CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 56, characters 4-11
++Re-raised at CamlinternalLazy.force_lazy_block.(fun) in file "camlinternalLazy.ml", line 123, characters 56-63
++Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 119, characters 17-27
++Re-raised at CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 124, characters 4-11
+ Called from Backtrace2.run in file "backtrace2.ml", line 62, characters 11-23
+diff --git a/testsuite/tests/backtrace/backtrace_c_exn.ml b/testsuite/tests/backtrace/backtrace_c_exn.ml
+index 9b0077d509..1680c23f7b 100644
+--- a/testsuite/tests/backtrace/backtrace_c_exn.ml
++++ b/testsuite/tests/backtrace/backtrace_c_exn.ml
+@@ -2,6 +2,8 @@
+    modules = "backtrace_c_exn_.c"
+    flags = "-g"
+    ocamlrunparam += ",b=1"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ (* https://github.com/ocaml-multicore/ocaml-multicore/issues/498 *)
+diff --git a/testsuite/tests/backtrace/backtrace_dynlink.flambda.reference b/testsuite/tests/backtrace/backtrace_dynlink.flambda.reference
+index 3dc0656252..77a0d85598 100644
+--- a/testsuite/tests/backtrace/backtrace_dynlink.flambda.reference
++++ b/testsuite/tests/backtrace/backtrace_dynlink.flambda.reference
+@@ -1,20 +1,24 @@
+ Raised by primitive operation at Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 6, characters 13-38
+-Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 87, characters 12-29
++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 12-29
+ Called from Stdlib__List.iter in file "list.ml" (inlined), line 112, characters 12-15
+-Called from Dynlink.Native.run in file "otherlibs/dynlink/native/dynlink.ml", line 86, characters 4-273
+-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 363, characters 13-56
++Called from Dynlink.Native.run in file "otherlibs/dynlink/native/dynlink.ml", line 88, characters 4-273
++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
+ Called from Stdlib__List.iter in file "list.ml" (inlined), line 112, characters 12-15
+-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
+-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
+ Called from Backtrace_dynlink in file "backtrace_dynlink.ml", line 39, characters 4-52
+ execution of module initializers in the shared library failed: Failure("SUCCESS")
+-Raised by primitive operation at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 87, characters 12-29
+-Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 10-149
++Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++Called from Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 3, characters 4-22
++Re-raised at Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 8, characters 5-12
++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 12-29
++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 12-29
++Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 91, characters 10-149
+ Called from Stdlib__List.iter in file "list.ml" (inlined), line 112, characters 12-15
+-Called from Dynlink.Native.run in file "otherlibs/dynlink/native/dynlink.ml", line 86, characters 4-273
+-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 363, characters 13-56
++Called from Dynlink.Native.run in file "otherlibs/dynlink/native/dynlink.ml", line 88, characters 4-273
++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
+ Called from Stdlib__List.iter in file "list.ml" (inlined), line 112, characters 12-15
+-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
+-Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 8-17
+-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
++Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 381, characters 8-17
++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
+ Called from Backtrace_dynlink in file "backtrace_dynlink.ml", line 39, characters 4-52
+diff --git a/testsuite/tests/backtrace/backtrace_dynlink.reference b/testsuite/tests/backtrace/backtrace_dynlink.reference
+index 3f4fa74593..d469a6fc9d 100644
+--- a/testsuite/tests/backtrace/backtrace_dynlink.reference
++++ b/testsuite/tests/backtrace/backtrace_dynlink.reference
+@@ -1,18 +1,22 @@
+ Raised by primitive operation at Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 6, characters 13-38
+-Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 87, characters 12-29
++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 12-29
+ Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 363, characters 13-56
++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
+ Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
+-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
+ Called from Backtrace_dynlink in file "backtrace_dynlink.ml", line 39, characters 4-52
+ execution of module initializers in the shared library failed: Failure("SUCCESS")
+-Raised by primitive operation at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 87, characters 12-29
+-Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 10-149
++Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++Called from Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 3, characters 4-22
++Re-raised at Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 8, characters 5-12
++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 12-29
++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 12-29
++Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 91, characters 10-149
+ Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 363, characters 13-56
++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
+ Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
+-Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 8-17
+-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
++Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 381, characters 8-17
++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
+ Called from Backtrace_dynlink in file "backtrace_dynlink.ml", line 39, characters 4-52
+diff --git a/testsuite/tests/backtrace/backtrace_effects.ml b/testsuite/tests/backtrace/backtrace_effects.ml
+index 352b32cbd7..bafd2259e8 100644
+--- a/testsuite/tests/backtrace/backtrace_effects.ml
++++ b/testsuite/tests/backtrace/backtrace_effects.ml
+@@ -2,6 +2,8 @@
+    flags = "-g"
+    ocamlrunparam += ",b=1"
+    exit_status = "2"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ open Effect
+diff --git a/testsuite/tests/backtrace/backtrace_effects_nested.ml b/testsuite/tests/backtrace/backtrace_effects_nested.ml
+index 37638a200a..2a2a630160 100644
+--- a/testsuite/tests/backtrace/backtrace_effects_nested.ml
++++ b/testsuite/tests/backtrace/backtrace_effects_nested.ml
+@@ -1,12 +1,14 @@
+ (* TEST
+ 
+ flags = "-g"
+-* bytecode
+-* no-flambda
+-** native
+-* flambda
++* skip
++reason = "OCaml 5 only"
++** bytecode
++** no-flambda
++*** native
++** flambda
+ reference = "${test_source_directory}/backtrace_effects_nested.flambda.reference"
+-** native
++*** native
+ 
+ *)
+ 
+diff --git a/testsuite/tests/backtrace/backtrace_systhreads.reference b/testsuite/tests/backtrace/backtrace_systhreads.reference
+index a7feaa8690..815506e7ea 100644
+--- a/testsuite/tests/backtrace/backtrace_systhreads.reference
++++ b/testsuite/tests/backtrace/backtrace_systhreads.reference
+@@ -2,24 +2,24 @@ Thread 2 killed on uncaught exception Failure("0")
+ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+ Called from Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 14, characters 6-37
+ Re-raised at Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 18, characters 5-14
+-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+ Thread 3 killed on uncaught exception Failure("1")
+ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+ Called from Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 14, characters 6-37
+ Re-raised at Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 18, characters 5-14
+-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+ Thread 4 killed on uncaught exception Failure("2")
+ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+ Called from Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 14, characters 6-37
+ Re-raised at Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 18, characters 5-14
+-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+ Thread 5 killed on uncaught exception Failure("3")
+ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+ Called from Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 14, characters 6-37
+ Re-raised at Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 18, characters 5-14
+-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+ Thread 1 killed on uncaught exception Failure("backtrace")
+ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+ Called from Backtrace_systhreads.thread_backtrace in file "backtrace_systhreads.ml", line 22, characters 6-27
+ Re-raised at Backtrace_systhreads.thread_backtrace in file "backtrace_systhreads.ml", line 26, characters 5-14
+-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+diff --git a/testsuite/tests/backtrace/callstack.reference b/testsuite/tests/backtrace/callstack.reference
+index c762728d14..8287432b20 100644
+--- a/testsuite/tests/backtrace/callstack.reference
++++ b/testsuite/tests/backtrace/callstack.reference
+@@ -12,4 +12,4 @@ Raised by primitive operation at Callstack.f0 in file "callstack.ml", line 11, c
+ Called from Callstack.f1 in file "callstack.ml", line 12, characters 27-32
+ Called from Callstack.f2 in file "callstack.ml", line 13, characters 27-32
+ Called from Callstack.f3 in file "callstack.ml", line 14, characters 27-32
+-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+diff --git a/testsuite/tests/backtrace/lazy.reference b/testsuite/tests/backtrace/lazy.reference
+index 5e8f53482f..af15509686 100644
+--- a/testsuite/tests/backtrace/lazy.reference
++++ b/testsuite/tests/backtrace/lazy.reference
+@@ -1,14 +1,12 @@
+ Uncaught exception Not_found
+ Raised at Lazy.l1 in file "lazy.ml", line 7, characters 28-45
+-Called from CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 49, characters 17-27
+-Re-raised at CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 56, characters 4-11
+-Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml" (inlined), line 78, characters 27-67
++Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 119, characters 17-27
++Re-raised at CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 124, characters 4-11
+ Called from Lazy.test1 in file "lazy.ml", line 10, characters 11-24
+ Called from Lazy.run in file "lazy.ml", line 19, characters 4-11
+ Uncaught exception Not_found
+ Raised at Lazy.l2 in file "lazy.ml", line 12, characters 28-45
+-Called from CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 49, characters 17-27
+-Re-raised at CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 56, characters 4-11
+-Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml" (inlined), line 78, characters 27-67
++Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 119, characters 17-27
++Re-raised at CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 124, characters 4-11
+ Called from Lazy.test2 in file "lazy.ml", line 15, characters 6-15
+ Called from Lazy.run in file "lazy.ml", line 19, characters 4-11
+diff --git a/testsuite/tests/basic/patmatch_for_multiple.ml b/testsuite/tests/basic/patmatch_for_multiple.ml
+index 0f532c5b5f..8e9081ebdb 100644
+--- a/testsuite/tests/basic/patmatch_for_multiple.ml
++++ b/testsuite/tests/basic/patmatch_for_multiple.ml
+@@ -26,15 +26,15 @@ match (3, 2, 1) with
+ | _ -> false
+ ;;
+ [%%expect{|
+-(let (*match*/276 = 3 *match*/277 = 2 *match*/278 = 1)
++(let (*match*/271 = 3 *match*/272 = 2 *match*/273 = 1)
+   (catch
+     (catch
+-      (catch (if (!= *match*/277 3) (exit 3) (exit 1)) with (3)
+-        (if (!= *match*/276 1) (exit 2) (exit 1)))
++      (catch (if (!= *match*/272 3) (exit 3) (exit 1)) with (3)
++        (if (!= *match*/271 1) (exit 2) (exit 1)))
+      with (2) 0)
+    with (1) 1))
+-(let (*match*/276 = 3 *match*/277 = 2 *match*/278 = 1)
+-  (catch (if (!= *match*/277 3) (if (!= *match*/276 1) 0 (exit 1)) (exit 1))
++(let (*match*/271 = 3 *match*/272 = 2 *match*/273 = 1)
++  (catch (if (!= *match*/272 3) (if (!= *match*/271 1) 0 (exit 1)) (exit 1))
+    with (1) 1))
+ - : bool = false
+ |}];;
+@@ -47,26 +47,26 @@ match (3, 2, 1) with
+ | _ -> false
+ ;;
+ [%%expect{|
+-(let (*match*/281 = 3 *match*/282 = 2 *match*/283 = 1)
++(let (*match*/276 = 3 *match*/277 = 2 *match*/278 = 1)
+   (catch
+     (catch
+       (catch
+-        (if (!= *match*/282 3) (exit 6)
+-          (let (x/285 =a (makeblock 0 *match*/281 *match*/282 *match*/283))
+-            (exit 4 x/285)))
++        (if (!= *match*/277 3) (exit 6)
++          (let (x/280 =a (makeblock 0 *match*/276 *match*/277 *match*/278))
++            (exit 4 x/280)))
+        with (6)
+-        (if (!= *match*/281 1) (exit 5)
+-          (let (x/284 =a (makeblock 0 *match*/281 *match*/282 *match*/283))
+-            (exit 4 x/284))))
++        (if (!= *match*/276 1) (exit 5)
++          (let (x/279 =a (makeblock 0 *match*/276 *match*/277 *match*/278))
++            (exit 4 x/279))))
+      with (5) 0)
+-   with (4 x/279) (seq (ignore x/279) 1)))
+-(let (*match*/281 = 3 *match*/282 = 2 *match*/283 = 1)
++   with (4 x/274) (seq (ignore x/274) 1)))
++(let (*match*/276 = 3 *match*/277 = 2 *match*/278 = 1)
+   (catch
+-    (if (!= *match*/282 3)
+-      (if (!= *match*/281 1) 0
+-        (exit 4 (makeblock 0 *match*/281 *match*/282 *match*/283)))
+-      (exit 4 (makeblock 0 *match*/281 *match*/282 *match*/283)))
+-   with (4 x/279) (seq (ignore x/279) 1)))
++    (if (!= *match*/277 3)
++      (if (!= *match*/276 1) 0
++        (exit 4 (makeblock 0 *match*/276 *match*/277 *match*/278)))
++      (exit 4 (makeblock 0 *match*/276 *match*/277 *match*/278)))
++   with (4 x/274) (seq (ignore x/274) 1)))
+ - : bool = false
+ |}];;
+ 
+@@ -76,8 +76,8 @@ let _ = fun a b ->
+   | ((true, _) as _g)
+   | ((false, _) as _g) -> ()
+ [%%expect{|
+-(function a/286[int] b/287 : int 0)
+-(function a/286[int] b/287 : int 0)
++(function a/281[int] b/282 : int 0)
++(function a/281[int] b/282 : int 0)
+ - : bool -> 'a -> unit = <fun>
+ |}];;
+ 
+@@ -96,8 +96,8 @@ let _ = fun a b -> match a, b with
+ | (false, _) as p -> p
+ (* outside, trivial *)
+ [%%expect {|
+-(function a/290[int] b/291 (let (p/292 =a (makeblock 0 a/290 b/291)) p/292))
+-(function a/290[int] b/291 (makeblock 0 a/290 b/291))
++(function a/285[int] b/286 (let (p/287 =a (makeblock 0 a/285 b/286)) p/287))
++(function a/285[int] b/286 (makeblock 0 a/285 b/286))
+ - : bool -> 'a -> bool * 'a = <fun>
+ |}]
+ 
+@@ -106,8 +106,8 @@ let _ = fun a b -> match a, b with
+ | ((false, _) as p) -> p
+ (* inside, trivial *)
+ [%%expect{|
+-(function a/294[int] b/295 (let (p/296 =a (makeblock 0 a/294 b/295)) p/296))
+-(function a/294[int] b/295 (makeblock 0 a/294 b/295))
++(function a/289[int] b/290 (let (p/291 =a (makeblock 0 a/289 b/290)) p/291))
++(function a/289[int] b/290 (makeblock 0 a/289 b/290))
+ - : bool -> 'a -> bool * 'a = <fun>
+ |}];;
+ 
+@@ -116,11 +116,11 @@ let _ = fun a b -> match a, b with
+ | (false as x, _) as p -> x, p
+ (* outside, simple *)
+ [%%expect {|
+-(function a/300[int] b/301
+-  (let (x/302 =a[int] a/300 p/303 =a (makeblock 0 a/300 b/301))
+-    (makeblock 0 (int,*) x/302 p/303)))
+-(function a/300[int] b/301
+-  (makeblock 0 (int,*) a/300 (makeblock 0 a/300 b/301)))
++(function a/295[int] b/296
++  (let (x/297 =a[int] a/295 p/298 =a (makeblock 0 a/295 b/296))
++    (makeblock 0 (int,*) x/297 p/298)))
++(function a/295[int] b/296
++  (makeblock 0 (int,*) a/295 (makeblock 0 a/295 b/296)))
+ - : bool -> 'a -> bool * (bool * 'a) = <fun>
+ |}]
+ 
+@@ -129,11 +129,11 @@ let _ = fun a b -> match a, b with
+ | ((false as x, _) as p) -> x, p
+ (* inside, simple *)
+ [%%expect {|
+-(function a/306[int] b/307
+-  (let (x/308 =a[int] a/306 p/309 =a (makeblock 0 a/306 b/307))
+-    (makeblock 0 (int,*) x/308 p/309)))
+-(function a/306[int] b/307
+-  (makeblock 0 (int,*) a/306 (makeblock 0 a/306 b/307)))
++(function a/301[int] b/302
++  (let (x/303 =a[int] a/301 p/304 =a (makeblock 0 a/301 b/302))
++    (makeblock 0 (int,*) x/303 p/304)))
++(function a/301[int] b/302
++  (makeblock 0 (int,*) a/301 (makeblock 0 a/301 b/302)))
+ - : bool -> 'a -> bool * (bool * 'a) = <fun>
+ |}]
+ 
+@@ -142,15 +142,15 @@ let _ = fun a b -> match a, b with
+ | (false, x) as p -> x, p
+ (* outside, complex *)
+ [%%expect{|
+-(function a/316[int] b/317[int]
+-  (if a/316
+-    (let (x/318 =a[int] a/316 p/319 =a (makeblock 0 a/316 b/317))
+-      (makeblock 0 (int,*) x/318 p/319))
+-    (let (x/320 =a b/317 p/321 =a (makeblock 0 a/316 b/317))
+-      (makeblock 0 (int,*) x/320 p/321))))
+-(function a/316[int] b/317[int]
+-  (if a/316 (makeblock 0 (int,*) a/316 (makeblock 0 a/316 b/317))
+-    (makeblock 0 (int,*) b/317 (makeblock 0 a/316 b/317))))
++(function a/311[int] b/312[int]
++  (if a/311
++    (let (x/313 =a[int] a/311 p/314 =a (makeblock 0 a/311 b/312))
++      (makeblock 0 (int,*) x/313 p/314))
++    (let (x/315 =a b/312 p/316 =a (makeblock 0 a/311 b/312))
++      (makeblock 0 (int,*) x/315 p/316))))
++(function a/311[int] b/312[int]
++  (if a/311 (makeblock 0 (int,*) a/311 (makeblock 0 a/311 b/312))
++    (makeblock 0 (int,*) b/312 (makeblock 0 a/311 b/312))))
+ - : bool -> bool -> bool * (bool * bool) = <fun>
+ |}]
+ 
+@@ -160,19 +160,19 @@ let _ = fun a b -> match a, b with
+   -> x, p
+ (* inside, complex *)
+ [%%expect{|
+-(function a/322[int] b/323[int]
++(function a/317[int] b/318[int]
+   (catch
+-    (if a/322
+-      (let (x/330 =a[int] a/322 p/331 =a (makeblock 0 a/322 b/323))
+-        (exit 10 x/330 p/331))
+-      (let (x/328 =a b/323 p/329 =a (makeblock 0 a/322 b/323))
+-        (exit 10 x/328 p/329)))
+-   with (10 x/324[int] p/325) (makeblock 0 (int,*) x/324 p/325)))
+-(function a/322[int] b/323[int]
++    (if a/317
++      (let (x/325 =a[int] a/317 p/326 =a (makeblock 0 a/317 b/318))
++        (exit 10 x/325 p/326))
++      (let (x/323 =a b/318 p/324 =a (makeblock 0 a/317 b/318))
++        (exit 10 x/323 p/324)))
++   with (10 x/319[int] p/320) (makeblock 0 (int,*) x/319 p/320)))
++(function a/317[int] b/318[int]
+   (catch
+-    (if a/322 (exit 10 a/322 (makeblock 0 a/322 b/323))
+-      (exit 10 b/323 (makeblock 0 a/322 b/323)))
+-   with (10 x/324[int] p/325) (makeblock 0 (int,*) x/324 p/325)))
++    (if a/317 (exit 10 a/317 (makeblock 0 a/317 b/318))
++      (exit 10 b/318 (makeblock 0 a/317 b/318)))
++   with (10 x/319[int] p/320) (makeblock 0 (int,*) x/319 p/320)))
+ - : bool -> bool -> bool * (bool * bool) = <fun>
+ |}]
+ 
+@@ -185,15 +185,15 @@ let _ = fun a b -> match a, b with
+ | (false as x, _) as p -> x, p
+ (* outside, onecase *)
+ [%%expect {|
+-(function a/332[int] b/333[int]
+-  (if a/332
+-    (let (x/334 =a[int] a/332 _p/335 =a (makeblock 0 a/332 b/333))
+-      (makeblock 0 (int,*) x/334 [0: 1 1]))
+-    (let (x/336 =a[int] a/332 p/337 =a (makeblock 0 a/332 b/333))
+-      (makeblock 0 (int,*) x/336 p/337))))
+-(function a/332[int] b/333[int]
+-  (if a/332 (makeblock 0 (int,*) a/332 [0: 1 1])
+-    (makeblock 0 (int,*) a/332 (makeblock 0 a/332 b/333))))
++(function a/327[int] b/328[int]
++  (if a/327
++    (let (x/329 =a[int] a/327 _p/330 =a (makeblock 0 a/327 b/328))
++      (makeblock 0 (int,*) x/329 [0: 1 1]))
++    (let (x/331 =a[int] a/327 p/332 =a (makeblock 0 a/327 b/328))
++      (makeblock 0 (int,*) x/331 p/332))))
++(function a/327[int] b/328[int]
++  (if a/327 (makeblock 0 (int,*) a/327 [0: 1 1])
++    (makeblock 0 (int,*) a/327 (makeblock 0 a/327 b/328))))
+ - : bool -> bool -> bool * (bool * bool) = <fun>
+ |}]
+ 
+@@ -202,11 +202,11 @@ let _ = fun a b -> match a, b with
+ | ((false as x, _) as p) -> x, p
+ (* inside, onecase *)
+ [%%expect{|
+-(function a/338[int] b/339
+-  (let (x/340 =a[int] a/338 p/341 =a (makeblock 0 a/338 b/339))
+-    (makeblock 0 (int,*) x/340 p/341)))
+-(function a/338[int] b/339
+-  (makeblock 0 (int,*) a/338 (makeblock 0 a/338 b/339)))
++(function a/333[int] b/334
++  (let (x/335 =a[int] a/333 p/336 =a (makeblock 0 a/333 b/334))
++    (makeblock 0 (int,*) x/335 p/336)))
++(function a/333[int] b/334
++  (makeblock 0 (int,*) a/333 (makeblock 0 a/333 b/334)))
+ - : bool -> 'a -> bool * (bool * 'a) = <fun>
+ |}]
+ 
+@@ -223,14 +223,14 @@ let _ =fun a b -> match a, b with
+ | (_, _) as p -> p
+ (* outside, tuplist *)
+ [%%expect {|
+-(function a/351[int] b/352
++(function a/346[int] b/347
+   (catch
+-    (if a/351 (if b/352 (let (p/353 =a (field_imm 0 b/352)) p/353) (exit 12))
++    (if a/346 (if b/347 (let (p/348 =a (field_imm 0 b/347)) p/348) (exit 12))
+       (exit 12))
+-   with (12) (let (p/354 =a (makeblock 0 a/351 b/352)) p/354)))
+-(function a/351[int] b/352
+-  (catch (if a/351 (if b/352 (field_imm 0 b/352) (exit 12)) (exit 12))
+-   with (12) (makeblock 0 a/351 b/352)))
++   with (12) (let (p/349 =a (makeblock 0 a/346 b/347)) p/349)))
++(function a/346[int] b/347
++  (catch (if a/346 (if b/347 (field_imm 0 b/347) (exit 12)) (exit 12))
++   with (12) (makeblock 0 a/346 b/347)))
+ - : bool -> bool tuplist -> bool * bool tuplist = <fun>
+ |}]
+ 
+@@ -239,20 +239,20 @@ let _ = fun a b -> match a, b with
+ | ((_, _) as p) -> p
+ (* inside, tuplist *)
+ [%%expect{|
+-(function a/355[int] b/356
++(function a/350[int] b/351
+   (catch
+     (catch
+-      (if a/355
+-        (if b/356 (let (p/360 =a (field_imm 0 b/356)) (exit 13 p/360))
++      (if a/350
++        (if b/351 (let (p/355 =a (field_imm 0 b/351)) (exit 13 p/355))
+           (exit 14))
+         (exit 14))
+-     with (14) (let (p/359 =a (makeblock 0 a/355 b/356)) (exit 13 p/359)))
+-   with (13 p/357) p/357))
+-(function a/355[int] b/356
++     with (14) (let (p/354 =a (makeblock 0 a/350 b/351)) (exit 13 p/354)))
++   with (13 p/352) p/352))
++(function a/350[int] b/351
+   (catch
+     (catch
+-      (if a/355 (if b/356 (exit 13 (field_imm 0 b/356)) (exit 14)) (exit 14))
+-     with (14) (exit 13 (makeblock 0 a/355 b/356)))
+-   with (13 p/357) p/357))
++      (if a/350 (if b/351 (exit 13 (field_imm 0 b/351)) (exit 14)) (exit 14))
++     with (14) (exit 13 (makeblock 0 a/350 b/351)))
++   with (13 p/352) p/352))
+ - : bool -> bool tuplist -> bool * bool tuplist = <fun>
+ |}]
+diff --git a/testsuite/tests/c-api/alloc_async.ml b/testsuite/tests/c-api/alloc_async.ml
+index b8c99a4b07..0ed35acf16 100644
+--- a/testsuite/tests/c-api/alloc_async.ml
++++ b/testsuite/tests/c-api/alloc_async.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    modules = "alloc_async_stubs.c"
+-   * skip
+-   reason = "alloc async changes: https://github.com/ocaml/ocaml/pull/8897"
+ *)
+ 
+ external test : int ref -> unit = "stub"
+diff --git a/testsuite/tests/c-api/test_c_thread_has_lock.ml b/testsuite/tests/c-api/test_c_thread_has_lock.ml
+index e826001559..f3e4a20be8 100644
+--- a/testsuite/tests/c-api/test_c_thread_has_lock.ml
++++ b/testsuite/tests/c-api/test_c_thread_has_lock.ml
+@@ -1,7 +1,9 @@
+ (* TEST
+    modules = "test_c_thread_has_lock_cstubs.c"
+-   * bytecode
+-   * native
++   * skip
++   reason = "OCaml 5 only"
++   ** bytecode
++   ** native
+ *)
+ 
+ external test_with_lock : unit -> bool = "with_lock"
+diff --git a/testsuite/tests/c-api/test_c_thread_has_lock_systhread.ml b/testsuite/tests/c-api/test_c_thread_has_lock_systhread.ml
+index 65327be652..036068739a 100644
+--- a/testsuite/tests/c-api/test_c_thread_has_lock_systhread.ml
++++ b/testsuite/tests/c-api/test_c_thread_has_lock_systhread.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+    modules = "test_c_thread_has_lock_cstubs.c"
+-   * hassysthreads
++   * skip
++   reason = "OCaml 5 only"
++   ** hassysthreads
+    include systhreads
+-   ** bytecode
+-   ** native
++   *** bytecode
++   *** native
+ *)
+ 
+ external test_with_lock : unit -> bool = "with_lock"
+diff --git a/testsuite/tests/callback/nested_fiber.ml b/testsuite/tests/callback/nested_fiber.ml
+index 3786e455ef..77478728df 100644
+--- a/testsuite/tests/callback/nested_fiber.ml
++++ b/testsuite/tests/callback/nested_fiber.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+    include unix
+    modules = "nested_fiber_.c"
+-   * libunix
+-   ** bytecode
+-   ** native
++   * skip
++   reason = "OCaml 5 only"
++   ** libunix
++   *** bytecode
++   *** native
+ *)
+ 
+ external caml_to_c : (unit -> 'a) -> 'a = "caml_to_c"
+diff --git a/testsuite/tests/callback/stack_overflow.ml b/testsuite/tests/callback/stack_overflow.ml
+index 23691dcf6c..6281d76e2a 100644
+--- a/testsuite/tests/callback/stack_overflow.ml
++++ b/testsuite/tests/callback/stack_overflow.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+    include unix
+    modules = "stack_overflow_.c"
+-   * libunix
+-   ** bytecode
+-   ** native
++   * skip
++   reason = "OCaml 5 only"
++   ** libunix
++   *** bytecode
++   *** native
+ *)
+ 
+ external caml_to_c : (unit -> 'a) -> 'a = "caml_to_c"
+diff --git a/testsuite/tests/callback/test7.ml b/testsuite/tests/callback/test7.ml
+index 8883a55f69..800c60e6de 100644
+--- a/testsuite/tests/callback/test7.ml
++++ b/testsuite/tests/callback/test7.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+    include unix
+    modules = "test7_.c"
+-   * libunix
+-   ** bytecode
+-   ** native
++   * skip
++   reason = "OCaml 5 only"
++   ** libunix
++   *** bytecode
++   *** native
+ *)
+ 
+ (* Tests nested calls from C (main C) to OCaml (main OCaml) to C (caml_to_c) to
+diff --git a/testsuite/tests/callback/test_signalhandler.ml b/testsuite/tests/callback/test_signalhandler.ml
+index a2bbacee72..9250395618 100644
+--- a/testsuite/tests/callback/test_signalhandler.ml
++++ b/testsuite/tests/callback/test_signalhandler.ml
+@@ -1,6 +1,6 @@
+ (* TEST
+    include unix
+-   modules = "test_signalhandler_.c"
++   modules = "callbackprim.c"
+    * libunix
+    ** bytecode
+    ** native
+@@ -52,17 +52,19 @@ let sighandler signo =
+   (* Thoroughly wipe the minor heap *)
+   ignore (tak (18, 12, 6))
+ 
+-external mykill : int -> int -> unit = "mykill" [@@noalloc]
++external raise_sigusr1 : unit -> unit = "raise_sigusr1" [@@noalloc]
++(*external mykill : int -> int -> unit = "mykill" [@@noalloc]*)
+ 
+ let callbacksig () =
+-  let pid = Unix.getpid () in
++  let _pid = Unix.getpid() in
+   (* Allocate a block in the minor heap *)
+   let s = String.make 5 'b' in
+   (* Send a signal to self.  We want s to remain in a register and
+      not be spilled on the stack, hence we use [mykill]
+      (which is [@@noalloc] and doesn't trigger signal handling)
+      instead of [Unix.kill]. *)
+-  mykill pid Sys.sigusr1;
++  (*mykill pid Sys.sigusr1;*)
++  raise_sigusr1 ();
+   (* Allocate some more so that the signal will be tested *)
+   let u = (s, s) in
+   fst u
+diff --git a/testsuite/tests/effects/backtrace.ml b/testsuite/tests/effects/backtrace.ml
+index 6257ba75c5..df6e11ac7a 100644
+--- a/testsuite/tests/effects/backtrace.ml
++++ b/testsuite/tests/effects/backtrace.ml
+@@ -1,6 +1,8 @@
+ (* TEST
+    flags = "-g"
+    ocamlrunparam += ",b=1"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/cmphash.ml b/testsuite/tests/effects/cmphash.ml
+index 78481d6404..a36d20cb8c 100644
+--- a/testsuite/tests/effects/cmphash.ml
++++ b/testsuite/tests/effects/cmphash.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/evenodd.ml b/testsuite/tests/effects/evenodd.ml
+index 035308b58f..85f178310b 100644
+--- a/testsuite/tests/effects/evenodd.ml
++++ b/testsuite/tests/effects/evenodd.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/issue479.ml b/testsuite/tests/effects/issue479.ml
+index 228e098d2e..c00b55c6ff 100644
+--- a/testsuite/tests/effects/issue479.ml
++++ b/testsuite/tests/effects/issue479.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+-   * toplevel
++   * skip
++   reason = "OCaml 5 only"
++   ** toplevel
+ *)
+ 
+ (* https://github.com/ocaml-multicore/ocaml-multicore/issues/479 *)
+diff --git a/testsuite/tests/effects/marshal.ml b/testsuite/tests/effects/marshal.ml
+index 89eee89457..02b9d4e4af 100644
+--- a/testsuite/tests/effects/marshal.ml
++++ b/testsuite/tests/effects/marshal.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++* skip
++reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/overflow.ml b/testsuite/tests/effects/overflow.ml
+index a187e9e10d..c12503863e 100644
+--- a/testsuite/tests/effects/overflow.ml
++++ b/testsuite/tests/effects/overflow.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/partial.ml b/testsuite/tests/effects/partial.ml
+index 50e4b53cfc..010741b9fc 100644
+--- a/testsuite/tests/effects/partial.ml
++++ b/testsuite/tests/effects/partial.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/reperform.ml b/testsuite/tests/effects/reperform.ml
+index 8aefdd0587..685b48b5dd 100644
+--- a/testsuite/tests/effects/reperform.ml
++++ b/testsuite/tests/effects/reperform.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/sched.ml b/testsuite/tests/effects/sched.ml
+index 3dc14a2cfc..6065d21c70 100644
+--- a/testsuite/tests/effects/sched.ml
++++ b/testsuite/tests/effects/sched.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/shallow_state.ml b/testsuite/tests/effects/shallow_state.ml
+index 56c61b0c3c..4d52362bc7 100644
+--- a/testsuite/tests/effects/shallow_state.ml
++++ b/testsuite/tests/effects/shallow_state.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/shallow_state_io.ml b/testsuite/tests/effects/shallow_state_io.ml
+index 6b1fa649a7..6ca4fef8b1 100644
+--- a/testsuite/tests/effects/shallow_state_io.ml
++++ b/testsuite/tests/effects/shallow_state_io.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/test1.ml b/testsuite/tests/effects/test1.ml
+index 5d05359f8a..65da5c8b90 100644
+--- a/testsuite/tests/effects/test1.ml
++++ b/testsuite/tests/effects/test1.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/test10.ml b/testsuite/tests/effects/test10.ml
+index 29c5f47f25..9b10559cfd 100644
+--- a/testsuite/tests/effects/test10.ml
++++ b/testsuite/tests/effects/test10.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/test11.ml b/testsuite/tests/effects/test11.ml
+index 6714473e0e..303cdd03c5 100644
+--- a/testsuite/tests/effects/test11.ml
++++ b/testsuite/tests/effects/test11.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ (* Tests RESUMETERM with extra_args != 0 in bytecode,
+diff --git a/testsuite/tests/effects/test2.ml b/testsuite/tests/effects/test2.ml
+index e9b8289bb2..f4e805f1d0 100644
+--- a/testsuite/tests/effects/test2.ml
++++ b/testsuite/tests/effects/test2.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Printf
+diff --git a/testsuite/tests/effects/test3.ml b/testsuite/tests/effects/test3.ml
+index d76130eaaa..2828f933a7 100644
+--- a/testsuite/tests/effects/test3.ml
++++ b/testsuite/tests/effects/test3.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/test4.ml b/testsuite/tests/effects/test4.ml
+index f5cf78cbda..77320a1ab5 100644
+--- a/testsuite/tests/effects/test4.ml
++++ b/testsuite/tests/effects/test4.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/test5.ml b/testsuite/tests/effects/test5.ml
+index 33ed2c23ca..98802a934e 100644
+--- a/testsuite/tests/effects/test5.ml
++++ b/testsuite/tests/effects/test5.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/test6.ml b/testsuite/tests/effects/test6.ml
+index 40574561bf..451e9704bc 100644
+--- a/testsuite/tests/effects/test6.ml
++++ b/testsuite/tests/effects/test6.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/test_lazy.ml b/testsuite/tests/effects/test_lazy.ml
+index 24f457f0af..036c7d5038 100644
+--- a/testsuite/tests/effects/test_lazy.ml
++++ b/testsuite/tests/effects/test_lazy.ml
+@@ -1,4 +1,7 @@
+-(* TEST *)
++(* TEST
++   * skip
++   reason = "OCaml 5 only"
++*)
+ 
+ open Effect
+ open Effect.Deep
+diff --git a/testsuite/tests/effects/unhandled_unlinked.ml b/testsuite/tests/effects/unhandled_unlinked.ml
+index bc2badb8e8..094eaad6e8 100644
+--- a/testsuite/tests/effects/unhandled_unlinked.ml
++++ b/testsuite/tests/effects/unhandled_unlinked.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+      exit_status= "2"
++     * skip
++     reason = "OCaml 5 only"
+ *)
+ 
+ open Effect
+diff --git a/testsuite/tests/effects/used_cont.ml b/testsuite/tests/effects/used_cont.ml
+index 71a33388ec..7972d000b7 100644
+--- a/testsuite/tests/effects/used_cont.ml
++++ b/testsuite/tests/effects/used_cont.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+  *)
+ 
+ open Effect
+diff --git a/testsuite/tests/ephe-c-api/test.ml b/testsuite/tests/ephe-c-api/test.ml
+index ff1646835a..a29cd8516b 100644
+--- a/testsuite/tests/ephe-c-api/test.ml
++++ b/testsuite/tests/ephe-c-api/test.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    modules = "stubs.c"
+-   * skip
+-   reason = "port the new Ephemeron C-api to multicore : https://github.com/ocaml/ocaml/pull/676"
+ *)
+ 
+ (* C version of ephetest.ml *)
+diff --git a/testsuite/tests/frame-pointers/c_call.ml b/testsuite/tests/frame-pointers/c_call.ml
+index c2493b3a99..e156e23d11 100644
+--- a/testsuite/tests/frame-pointers/c_call.ml
++++ b/testsuite/tests/frame-pointers/c_call.ml
+@@ -1,7 +1,9 @@
+ (* TEST
+ 
+-* frame_pointers
+-** native
++* skip
++reason = "OCaml 5 only"
++** frame_pointers
++*** native
+ readonly_files = "fp_backtrace.c c_call_.c"
+ all_modules = "${readonly_files} c_call.ml"
+ 
+diff --git a/testsuite/tests/frame-pointers/effects.ml b/testsuite/tests/frame-pointers/effects.ml
+index e14633a374..03068242a4 100644
+--- a/testsuite/tests/frame-pointers/effects.ml
++++ b/testsuite/tests/frame-pointers/effects.ml
+@@ -1,7 +1,9 @@
+ (* TEST
+ 
+-* frame_pointers
+-** native
++* skip
++reason - "OCaml 5 only"
++** frame_pointers
++*** native
+ readonly_files = "fp_backtrace.c"
+ all_modules = "${readonly_files} effects.ml"
+ 
+diff --git a/testsuite/tests/frame-pointers/exception_handler.ml b/testsuite/tests/frame-pointers/exception_handler.ml
+index 575f7329bf..56676119b7 100644
+--- a/testsuite/tests/frame-pointers/exception_handler.ml
++++ b/testsuite/tests/frame-pointers/exception_handler.ml
+@@ -1,7 +1,9 @@
+ (* TEST
+ 
+-* frame_pointers
+-** native
++* skip
++reason = "OCaml 5 only"
++** frame_pointers
++*** native
+ readonly_files = "fp_backtrace.c"
+ all_modules = "${readonly_files} exception_handler.ml"
+ 
+diff --git a/testsuite/tests/frame-pointers/reperform.ml b/testsuite/tests/frame-pointers/reperform.ml
+index 1af8452e5f..5e7a76f0e3 100644
+--- a/testsuite/tests/frame-pointers/reperform.ml
++++ b/testsuite/tests/frame-pointers/reperform.ml
+@@ -1,7 +1,9 @@
+ (* TEST
+ 
+-* frame_pointers
+-** native
++* skip
++reason - "OCaml 5 only"
++** frame_pointers
++*** native
+ 
+ readonly_files = "fp_backtrace.c"
+ all_modules = "${readonly_files} reperform.ml"
+diff --git a/testsuite/tests/frame-pointers/stack_realloc.ml b/testsuite/tests/frame-pointers/stack_realloc.ml
+index 79e70c2add..b36bcd3a70 100644
+--- a/testsuite/tests/frame-pointers/stack_realloc.ml
++++ b/testsuite/tests/frame-pointers/stack_realloc.ml
+@@ -1,7 +1,9 @@
+ (* TEST
+ 
+-* frame_pointers
+-** native
++* skip
++reason - "OCaml 5 only"
++** frame_pointers
++*** native
+ 
+ readonly_files = "fp_backtrace.c stack_realloc_.c"
+ all_modules = "${readonly_files} stack_realloc.ml"
+diff --git a/testsuite/tests/frame-pointers/stack_realloc2.ml b/testsuite/tests/frame-pointers/stack_realloc2.ml
+index a3d21bf2bf..df4a074443 100644
+--- a/testsuite/tests/frame-pointers/stack_realloc2.ml
++++ b/testsuite/tests/frame-pointers/stack_realloc2.ml
+@@ -1,7 +1,9 @@
+ (* TEST
+ 
+-* frame_pointers
+-** native
++* skip
++reason - "OCaml 5 only"
++** frame_pointers
++*** native
+ 
+ readonly_files = "fp_backtrace.c stack_realloc_.c"
+ all_modules = "${readonly_files} stack_realloc2.ml"
+diff --git a/testsuite/tests/gc-roots/globroots.ml b/testsuite/tests/gc-roots/globroots.ml
+index 56d1586331..6bdb7fdaf3 100644
+--- a/testsuite/tests/gc-roots/globroots.ml
++++ b/testsuite/tests/gc-roots/globroots.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    modules = "globrootsprim.c"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ module type GLOBREF = sig
+diff --git a/testsuite/tests/gc-roots/globroots_parallel.ml b/testsuite/tests/gc-roots/globroots_parallel.ml
+index 9ef88575b2..4858ecc49b 100644
+--- a/testsuite/tests/gc-roots/globroots_parallel.ml
++++ b/testsuite/tests/gc-roots/globroots_parallel.ml
+@@ -1,6 +1,8 @@
+ (* TEST
+    flags += " -w a "
+    modules = "globrootsprim.c globroots.ml"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ open Globroots
+diff --git a/testsuite/tests/gc-roots/globroots_parallel_spawn_burn.ml b/testsuite/tests/gc-roots/globroots_parallel_spawn_burn.ml
+index c8b36098ac..d548d6e540 100644
+--- a/testsuite/tests/gc-roots/globroots_parallel_spawn_burn.ml
++++ b/testsuite/tests/gc-roots/globroots_parallel_spawn_burn.ml
+@@ -1,6 +1,8 @@
+ (* TEST
+    flags += " -w a "
+    modules = "globrootsprim.c globroots.ml"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ open Globroots
+diff --git a/testsuite/tests/gc-roots/globroots_sequential.ml b/testsuite/tests/gc-roots/globroots_sequential.ml
+index 6bf995bf96..dc732ce6a3 100644
+--- a/testsuite/tests/gc-roots/globroots_sequential.ml
++++ b/testsuite/tests/gc-roots/globroots_sequential.ml
+@@ -1,6 +1,8 @@
+ (* TEST
+    flags += " -w a "
+    modules = "globrootsprim.c globroots.ml"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ open Globroots
+ 
+diff --git a/testsuite/tests/generalized-open/gpr1506.ml b/testsuite/tests/generalized-open/gpr1506.ml
+index 0041d91889..cf0eb4eed3 100644
+--- a/testsuite/tests/generalized-open/gpr1506.ml
++++ b/testsuite/tests/generalized-open/gpr1506.ml
+@@ -103,9 +103,9 @@ include struct open struct type t = T end let x = T end
+ Line 1, characters 15-41:
+ 1 | include struct open struct type t = T end let x = T end
+                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
+-Error: The type t/339 introduced by this open appears in the signature
++Error: The type t/334 introduced by this open appears in the signature
+        Line 1, characters 46-47:
+-         The value x has no valid type if t/339 is hidden
++         The value x has no valid type if t/334 is hidden
+ |}];;
+ 
+ module A = struct
+@@ -123,9 +123,9 @@ Lines 3-6, characters 4-7:
+ 4 |       type t = T
+ 5 |       let x = T
+ 6 |     end
+-Error: The type t/344 introduced by this open appears in the signature
++Error: The type t/339 introduced by this open appears in the signature
+        Line 7, characters 8-9:
+-         The value y has no valid type if t/344 is hidden
++         The value y has no valid type if t/339 is hidden
+ |}];;
+ 
+ module A = struct
+@@ -142,9 +142,9 @@ Lines 3-5, characters 4-7:
+ 3 | ....open struct
+ 4 |       type t = T
+ 5 |     end
+-Error: The type t/349 introduced by this open appears in the signature
++Error: The type t/344 introduced by this open appears in the signature
+        Line 6, characters 8-9:
+-         The value y has no valid type if t/349 is hidden
++         The value y has no valid type if t/344 is hidden
+ |}]
+ 
+ (* It was decided to not allow this anymore. *)
+diff --git a/testsuite/tests/lazy/lazy2.ml b/testsuite/tests/lazy/lazy2.ml
+index cccbd96d71..35dd7fd85b 100644
+--- a/testsuite/tests/lazy/lazy2.ml
++++ b/testsuite/tests/lazy/lazy2.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    ocamlopt_flags += " -O3 "
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ open Domain
+diff --git a/testsuite/tests/lazy/lazy3.ml b/testsuite/tests/lazy/lazy3.ml
+index a22a0893b9..737791b7db 100644
+--- a/testsuite/tests/lazy/lazy3.ml
++++ b/testsuite/tests/lazy/lazy3.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    ocamlopt_flags += " -O3 "
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ let f count =
+diff --git a/testsuite/tests/lazy/lazy5.ml b/testsuite/tests/lazy/lazy5.ml
+index 217b84175e..e37b499268 100644
+--- a/testsuite/tests/lazy/lazy5.ml
++++ b/testsuite/tests/lazy/lazy5.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    ocamlopt_flags += " -O3 "
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ let rec safe_force l =
+   try Lazy.force l with
+diff --git a/testsuite/tests/lazy/lazy6.ml b/testsuite/tests/lazy/lazy6.ml
+index 098848769a..29067f1a41 100644
+--- a/testsuite/tests/lazy/lazy6.ml
++++ b/testsuite/tests/lazy/lazy6.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    ocamlopt_flags += " -O3 "
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ let flag1 = Atomic.make false
+diff --git a/testsuite/tests/lazy/lazy7.ml b/testsuite/tests/lazy/lazy7.ml
+index 6c96f32907..d9c9b82127 100644
+--- a/testsuite/tests/lazy/lazy7.ml
++++ b/testsuite/tests/lazy/lazy7.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    ocamlopt_flags += " -O3 "
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ let num_domains = 4
+diff --git a/testsuite/tests/lazy/lazy8.ml b/testsuite/tests/lazy/lazy8.ml
+index c9b5781617..ddadf48a1b 100644
+--- a/testsuite/tests/lazy/lazy8.ml
++++ b/testsuite/tests/lazy/lazy8.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    ocamlopt_flags += " -O3 "
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ exception E
+diff --git a/testsuite/tests/lazy/minor_major_force.ml b/testsuite/tests/lazy/minor_major_force.ml
+index 37f367a9c7..3b2c33af87 100644
+--- a/testsuite/tests/lazy/minor_major_force.ml
++++ b/testsuite/tests/lazy/minor_major_force.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    ocamlopt_flags += " -O3 "
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ (*
+diff --git a/testsuite/tests/lf_skiplist/test.ml b/testsuite/tests/lf_skiplist/test.ml
+index f3b11bf411..4dcffc523d 100644
+--- a/testsuite/tests/lf_skiplist/test.ml
++++ b/testsuite/tests/lf_skiplist/test.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    modules = "stubs.c"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ external test_skiplist_serial : unit -> unit = "test_skiplist_serial"
+diff --git a/testsuite/tests/lf_skiplist/test_parallel.ml b/testsuite/tests/lf_skiplist/test_parallel.ml
+index ac02717889..c882a8dac7 100644
+--- a/testsuite/tests/lf_skiplist/test_parallel.ml
++++ b/testsuite/tests/lf_skiplist/test_parallel.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    modules = "stubs.c"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ external init_skiplist : unit -> unit = "init_skiplist"
+diff --git a/testsuite/tests/lib-bigarray-2/has-gfortran.sh b/testsuite/tests/lib-bigarray-2/has-gfortran.sh
+index 051122113a..7eef1e662e 100644
+--- a/testsuite/tests/lib-bigarray-2/has-gfortran.sh
++++ b/testsuite/tests/lib-bigarray-2/has-gfortran.sh
+@@ -5,7 +5,7 @@ if ! which gfortran > /dev/null 2>&1; then
+ elif ! grep -q '^CC=gcc' ${ocamlsrcdir}/Makefile.config; then
+   echo "OCaml was not compiled with gcc" > ${ocamltest_response}
+   test_result=${TEST_SKIP}
+-elif gcc --version 2>&1 | grep 'Apple clang version'; then
++elif gcc --version 2>&1 | grep -q 'Apple clang version'; then
+   echo "OCaml was not compiled with gcc" > ${ocamltest_response}
+   test_result=${TEST_SKIP}
+ else
+diff --git a/testsuite/tests/lib-channels/close_in.ml b/testsuite/tests/lib-channels/close_in.ml
+index 2986e5b8c9..8c51c7d52c 100644
+--- a/testsuite/tests/lib-channels/close_in.ml
++++ b/testsuite/tests/lib-channels/close_in.ml
+@@ -1,4 +1,7 @@
+-(* TEST *)
++(* TEST
++* skip
++reason = "OCaml 5 only"
++ *)
+ 
+ (* Test that inputting bytes from a closed in_channel triggers an exception *)
+ 
+diff --git a/testsuite/tests/lib-channels/refcounting.ml b/testsuite/tests/lib-channels/refcounting.ml
+index bc0b8dfe66..deaba0a3ee 100644
+--- a/testsuite/tests/lib-channels/refcounting.ml
++++ b/testsuite/tests/lib-channels/refcounting.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+-   * expect
++   * skip
++   reason = "OCaml 5 only"
++   ** expect
+ *)
+ 
+ (* Test the behavior of channel refcounting. *)
+diff --git a/testsuite/tests/lib-dynlink-domains/main.ml b/testsuite/tests/lib-dynlink-domains/main.ml
+index d87ddc24e4..a10828c80e 100644
+--- a/testsuite/tests/lib-dynlink-domains/main.ml
++++ b/testsuite/tests/lib-dynlink-domains/main.ml
+@@ -4,169 +4,171 @@ include dynlink
+ libraries = ""
+ readonly_files = "store.ml main.ml Plugin_0.ml Plugin_0_0.ml Plugin_0_0_0.ml Plugin_0_0_0_0.ml Plugin_0_0_0_1.ml Plugin_0_0_0_2.ml Plugin_1.ml Plugin_1_0.ml Plugin_1_0_0.ml Plugin_1_0_0_0.ml Plugin_1_1.ml Plugin_1_2.ml Plugin_1_2_0.ml Plugin_1_2_0_0.ml Plugin_1_2_1.ml Plugin_1_2_2.ml Plugin_1_2_2_0.ml Plugin_1_2_3.ml Plugin_1_2_3_0.ml"
+ 
+-*01 not-windows
+-*02 shared-libraries
+-*03 setup-ocamlc.byte-build-env
+-*04 ocamlc.byte
++* skip
++reason = "OCaml 5 only"
++**01 not-windows
++**02 shared-libraries
++**03 setup-ocamlc.byte-build-env
++**04 ocamlc.byte
+ module = "store.ml"
+-*05 ocamlc.byte
++**05 ocamlc.byte
+ module = "Plugin_0.ml"
+-*06 ocamlc.byte
++**06 ocamlc.byte
+ module = "Plugin_0_0.ml"
+-*07 ocamlc.byte
++**07 ocamlc.byte
+ module = "Plugin_0_0_0.ml"
+-*08 ocamlc.byte
++**08 ocamlc.byte
+ module = "Plugin_0_0_0_0.ml"
+-*09 ocamlc.byte
++**09 ocamlc.byte
+ module = "Plugin_0_0_0_1.ml"
+-*10 ocamlc.byte
++**10 ocamlc.byte
+ module = "Plugin_0_0_0_2.ml"
+-*11 ocamlc.byte
++**11 ocamlc.byte
+ module = "Plugin_1.ml"
+-*12 ocamlc.byte
++**12 ocamlc.byte
+ module = "Plugin_1_0.ml"
+-*13 ocamlc.byte
++**13 ocamlc.byte
+ module = "Plugin_1_0_0.ml"
+-*14 ocamlc.byte
++**14 ocamlc.byte
+ module = "Plugin_1_0_0_0.ml"
+-*15 ocamlc.byte
++**15 ocamlc.byte
+ module = "Plugin_1_1.ml"
+-*16 ocamlc.byte
++**16 ocamlc.byte
+ module = "Plugin_1_2.ml"
+-*17 ocamlc.byte
++**17 ocamlc.byte
+ module = "Plugin_1_2_0.ml"
+-*18 ocamlc.byte
++**18 ocamlc.byte
+ module = "Plugin_1_2_0_0.ml"
+-*19 ocamlc.byte
++**19 ocamlc.byte
+ module = "Plugin_1_2_1.ml"
+-*20 ocamlc.byte
++**20 ocamlc.byte
+ module = "Plugin_1_2_2.ml"
+-*21 ocamlc.byte
++**21 ocamlc.byte
+ module = "Plugin_1_2_2_0.ml"
+-*22 ocamlc.byte
++**22 ocamlc.byte
+ module = "Plugin_1_2_3.ml"
+-*23 ocamlc.byte
++**23 ocamlc.byte
+ module = "Plugin_1_2_3_0.ml"
+-*24 ocamlc.byte
++**24 ocamlc.byte
+ module = "main.ml"
+-*25 ocamlc.byte
++**25 ocamlc.byte
+ program = "./main.byte.exe"
+ libraries= "dynlink"
+ all_modules = "store.cmo main.cmo"
+ module = ""
+-*26 run
+-*27 check-program-output
++**26 run
++**27 check-program-output
+ 
+-*02 native-dynlink
+-*03 setup-ocamlopt.byte-build-env
+-*04 ocamlopt.byte
++**02 native-dynlink
++**03 setup-ocamlopt.byte-build-env
++**04 ocamlopt.byte
+ flags = ""
+ module = "store.ml"
+-*05 ocamlopt.byte
++**05 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_0.cmxs"
+ module = ""
+ all_modules = "Plugin_0.ml"
+-*06 ocamlopt.byte
++**06 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_0_0.cmxs"
+ module = ""
+ all_modules = "Plugin_0_0.ml"
+-*07 ocamlopt.byte
++**07 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_0_0_0.cmxs"
+ module = ""
+ all_modules = "Plugin_0_0_0.ml"
+-*08 ocamlopt.byte
++**08 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_0_0_0_0.cmxs"
+ module = ""
+ all_modules = "Plugin_0_0_0_0.ml"
+-*09 ocamlopt.byte
++**09 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_0_0_0_1.cmxs"
+ module = ""
+ all_modules = "Plugin_0_0_0_1.ml"
+-*10 ocamlopt.byte
++**10 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_0_0_0_2.cmxs"
+ module = ""
+ all_modules = "Plugin_0_0_0_2.ml"
+-*11 ocamlopt.byte
++**11 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1.cmxs"
+ module = ""
+ all_modules = "Plugin_1.ml"
+-*12 ocamlopt.byte
++**12 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_0.cmxs"
+ module = ""
+ all_modules = "Plugin_1_0.ml"
+-*13 ocamlopt.byte
++**13 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_0_0.cmxs"
+ module = ""
+ all_modules = "Plugin_1_0_0.ml"
+-*14 ocamlopt.byte
++**14 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_0_0_0.cmxs"
+ module = ""
+ all_modules = "Plugin_1_0_0_0.ml"
+-*15 ocamlopt.byte
++**15 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_1.cmxs"
+ module = ""
+ all_modules = "Plugin_1_1.ml"
+-*16 ocamlopt.byte
++**16 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_2.cmxs"
+ module = ""
+ all_modules = "Plugin_1_2.ml"
+-*17 ocamlopt.byte
++**17 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_2_0.cmxs"
+ module = ""
+ all_modules = "Plugin_1_2_0.ml"
+-*18 ocamlopt.byte
++**18 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_2_0_0.cmxs"
+ module = ""
+ all_modules = "Plugin_1_2_0_0.ml"
+-*19 ocamlopt.byte
++**19 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_2_1.cmxs"
+ module = ""
+ all_modules = "Plugin_1_2_1.ml"
+-*20 ocamlopt.byte
++**20 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_2_2.cmxs"
+ module = ""
+ all_modules = "Plugin_1_2_2.ml"
+-*21 ocamlopt.byte
++**21 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_2_2_0.cmxs"
+ module = ""
+ all_modules = "Plugin_1_2_2_0.ml"
+-*22 ocamlopt.byte
++**22 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_2_3.cmxs"
+ module = ""
+ all_modules = "Plugin_1_2_3.ml"
+-*23 ocamlopt.byte
++**23 ocamlopt.byte
+ flags = "-shared"
+ program= "Plugin_1_2_3_0.cmxs"
+ module = ""
+ all_modules = "Plugin_1_2_3_0.ml"
+-*24 ocamlopt.byte
++**24 ocamlopt.byte
+ flags = ""
+ module = "main.ml"
+-*25 ocamlopt.byte
++**25 ocamlopt.byte
+ program = "./main.exe"
+ libraries="dynlink"
+ all_modules = "store.cmx main.cmx"
+ module = ""
+-*26 run
+-*27 check-program-output
++**26 run
++**27 check-program-output
+ *)
+ 
+ (*  This module and all plugin modules are generated by a call to test_generator.ml with parameters:
+diff --git a/testsuite/tests/lib-dynlink-initializers/test10_main.byte.reference b/testsuite/tests/lib-dynlink-initializers/test10_main.byte.reference
+index f9157e7c43..01165c2489 100755
+--- a/testsuite/tests/lib-dynlink-initializers/test10_main.byte.reference
++++ b/testsuite/tests/lib-dynlink-initializers/test10_main.byte.reference
+@@ -3,10 +3,10 @@ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+ Called from Test10_plugin.g in file "test10_plugin.ml", line 3, characters 2-21
+ Called from Test10_plugin.f in file "test10_plugin.ml", line 6, characters 2-6
+ Called from Test10_plugin in file "test10_plugin.ml", line 10, characters 2-6
+-Called from Dynlink.Bytecode.run in file "otherlibs/dynlink/dynlink.ml", line 149, characters 16-25
+-Re-raised at Dynlink.Bytecode.run in file "otherlibs/dynlink/dynlink.ml", line 151, characters 6-137
+-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 363, characters 13-56
++Called from Dynlink.Bytecode.run in file "otherlibs/dynlink/dynlink.ml", line 152, characters 16-25
++Re-raised at Dynlink.Bytecode.run in file "otherlibs/dynlink/dynlink.ml", line 154, characters 6-137
++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
+ Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
+-Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 8-17
++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
++Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 381, characters 8-17
+ Called from Test10_main in file "test10_main.ml", line 51, characters 13-69
+diff --git a/testsuite/tests/lib-dynlink-initializers/test10_main.native.reference b/testsuite/tests/lib-dynlink-initializers/test10_main.native.reference
+index 89f1d20b39..287f9a8dba 100755
+--- a/testsuite/tests/lib-dynlink-initializers/test10_main.native.reference
++++ b/testsuite/tests/lib-dynlink-initializers/test10_main.native.reference
+@@ -1,10 +1,14 @@
+ Error: Failure("Plugin error")
+-Raised by primitive operation at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 87, characters 12-29
+-Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 10-149
++Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++Called from Test10_plugin.g in file "test10_plugin.ml", line 2, characters 15-38
++Called from Test10_plugin in file "test10_plugin.ml", line 10, characters 2-6
++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 12-29
++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 12-29
++Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 91, characters 10-149
+ Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 363, characters 13-56
++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
+ Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
+-Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 8-17
+-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
++Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 381, characters 8-17
++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
+ Called from Test10_main in file "test10_main.ml", line 49, characters 30-87
+diff --git a/testsuite/tests/lib-format/domains.ml b/testsuite/tests/lib-format/domains.ml
+index 941aa681cf..0daaad5171 100644
+--- a/testsuite/tests/lib-format/domains.ml
++++ b/testsuite/tests/lib-format/domains.ml
+@@ -1,4 +1,7 @@
+-(* TEST *)
++(* TEST
++* skip
++reason = "OCaml 5 only"
++*)
+ 
+ (** Test that domains stdout and stderr are flushed at domain exit *)
+ 
+diff --git a/testsuite/tests/lib-format/mc_pr586_par.ml b/testsuite/tests/lib-format/mc_pr586_par.ml
+index 456a306ce7..da5c148416 100644
+--- a/testsuite/tests/lib-format/mc_pr586_par.ml
++++ b/testsuite/tests/lib-format/mc_pr586_par.ml
+@@ -1,4 +1,7 @@
+-(* TEST *)
++(* TEST
++   * skip
++   reason = "OCaml 5 only"
++*)
+ 
+ let () =
+   let domains = Array.init 7 (fun i ->
+diff --git a/testsuite/tests/lib-format/mc_pr586_par2.ml b/testsuite/tests/lib-format/mc_pr586_par2.ml
+index 0ead3627b5..8a96be1456 100644
+--- a/testsuite/tests/lib-format/mc_pr586_par2.ml
++++ b/testsuite/tests/lib-format/mc_pr586_par2.ml
+@@ -1,4 +1,7 @@
+-(* TEST *)
++(* TEST
++   * skip
++   reason = "OCaml 5 only"
++*)
+ 
+ let () =
+   let fmt_key = Format.synchronized_formatter_of_out_channel stdout in
+diff --git a/testsuite/tests/lib-marshal/intext_par.ml b/testsuite/tests/lib-marshal/intext_par.ml
+index 2efb846665..68ad0e1edb 100644
+--- a/testsuite/tests/lib-marshal/intext_par.ml
++++ b/testsuite/tests/lib-marshal/intext_par.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+    modules = "intextaux_par.c"
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ (* Test for output_value / input_value *)
+diff --git a/testsuite/tests/lib-obj/reachable_words_np.ml b/testsuite/tests/lib-obj/reachable_words_np.ml
+new file mode 100644
+index 0000000000..8a50268d20
+--- /dev/null
++++ b/testsuite/tests/lib-obj/reachable_words_np.ml
+@@ -0,0 +1,21 @@
++(* TEST
++ * naked_pointers
++ ** bytecode
++ ** native
++*)
++
++let native =
++  match Sys.backend_type with
++  | Sys.Native -> true
++  | Sys.Bytecode -> false
++  | Sys.Other s -> print_endline s; assert false
++
++let size x = Obj.reachable_words (Obj.repr x)
++
++let expect_size s x =
++  let i = size x in
++  if i <> s then
++    Printf.printf "size = %i; expected = %i\n%!" i s
++
++let () =
++  expect_size (if native then 0 else 3) (1, 2)
+diff --git a/testsuite/tests/lib-random/parallel.ml b/testsuite/tests/lib-random/parallel.ml
+index 68f567abec..90a78e2250 100644
+--- a/testsuite/tests/lib-random/parallel.ml
++++ b/testsuite/tests/lib-random/parallel.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+    include unix
+-   * libunix
+-   ** bytecode
+-   ** native
++   * skip
++   reason = "OCaml 5 only"
++   ** libunix
++   *** bytecode
++   *** native
+  *)
+ 
+ let () = Random.init 42
+diff --git a/testsuite/tests/lib-runtime-events/test.ml b/testsuite/tests/lib-runtime-events/test.ml
+index db08937089..8ccaccdf25 100644
+--- a/testsuite/tests/lib-runtime-events/test.ml
++++ b/testsuite/tests/lib-runtime-events/test.ml
+@@ -1,6 +1,8 @@
+ (* TEST
+ modules = "stubs.c"
+ include runtime_events
++* skip
++reason = "OCaml 5 only"
+ *)
+ 
+ external start_runtime_events : unit -> unit = "start_runtime_events"
+diff --git a/testsuite/tests/lib-runtime-events/test_caml.ml b/testsuite/tests/lib-runtime-events/test_caml.ml
+index 1e96998149..6cc9474f2e 100644
+--- a/testsuite/tests/lib-runtime-events/test_caml.ml
++++ b/testsuite/tests/lib-runtime-events/test_caml.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+ include runtime_events
++* skip
++reason = "OCaml 5 only"
+ *)
+ open Runtime_events
+ 
+diff --git a/testsuite/tests/lib-runtime-events/test_caml_counters.ml b/testsuite/tests/lib-runtime-events/test_caml_counters.ml
+index af43fd47af..e64a4fec09 100644
+--- a/testsuite/tests/lib-runtime-events/test_caml_counters.ml
++++ b/testsuite/tests/lib-runtime-events/test_caml_counters.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+ include runtime_events
++* skip
++reason = "OCaml 5 only"
+ *)
+ open Runtime_events
+ 
+diff --git a/testsuite/tests/lib-runtime-events/test_caml_exception.ml b/testsuite/tests/lib-runtime-events/test_caml_exception.ml
+index e1df5aee0b..6738603ddd 100644
+--- a/testsuite/tests/lib-runtime-events/test_caml_exception.ml
++++ b/testsuite/tests/lib-runtime-events/test_caml_exception.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+ include runtime_events
++* skip
++reason = "OCaml 5 only"
+ *)
+ open Runtime_events
+ 
+diff --git a/testsuite/tests/lib-runtime-events/test_caml_parallel.ml b/testsuite/tests/lib-runtime-events/test_caml_parallel.ml
+index 76cad340d8..391186d007 100644
+--- a/testsuite/tests/lib-runtime-events/test_caml_parallel.ml
++++ b/testsuite/tests/lib-runtime-events/test_caml_parallel.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+ include runtime_events
++* skip
++reason = "OCaml 5 only"
+ *)
+ open Runtime_events
+ 
+diff --git a/testsuite/tests/lib-runtime-events/test_caml_reentry.ml b/testsuite/tests/lib-runtime-events/test_caml_reentry.ml
+index d69042e354..724466a63b 100644
+--- a/testsuite/tests/lib-runtime-events/test_caml_reentry.ml
++++ b/testsuite/tests/lib-runtime-events/test_caml_reentry.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+ include runtime_events
++* skip
++reason = "OCaml 5 only"
+ *)
+ open Runtime_events
+ 
+diff --git a/testsuite/tests/lib-runtime-events/test_caml_runparams.ml b/testsuite/tests/lib-runtime-events/test_caml_runparams.ml
+index a574e7d341..4dc607eed3 100644
+--- a/testsuite/tests/lib-runtime-events/test_caml_runparams.ml
++++ b/testsuite/tests/lib-runtime-events/test_caml_runparams.ml
+@@ -1,6 +1,8 @@
+ (* TEST
+ include runtime_events
+ ocamlrunparam += ",e=4"
++* skip
++reason = "OCaml 5 only"
+ *)
+ 
+ (* We set the ring buffer size smaller and witness that we do indeed
+diff --git a/testsuite/tests/lib-runtime-events/test_caml_slot_reuse.ml b/testsuite/tests/lib-runtime-events/test_caml_slot_reuse.ml
+index 34b034a8e8..8656ca2e59 100644
+--- a/testsuite/tests/lib-runtime-events/test_caml_slot_reuse.ml
++++ b/testsuite/tests/lib-runtime-events/test_caml_slot_reuse.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+ include runtime_events
++* skip
++reason = "OCaml 5 only"
+ *)
+ open Runtime_events
+ 
+diff --git a/testsuite/tests/lib-runtime-events/test_caml_stubs_gc.ml b/testsuite/tests/lib-runtime-events/test_caml_stubs_gc.ml
+index 35ddd983a1..d63066e646 100644
+--- a/testsuite/tests/lib-runtime-events/test_caml_stubs_gc.ml
++++ b/testsuite/tests/lib-runtime-events/test_caml_stubs_gc.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+ include runtime_events
++* skip
++reason = "OCaml 5 only"
+ *)
+ open Runtime_events
+ 
+diff --git a/testsuite/tests/lib-runtime-events/test_env_start.ml b/testsuite/tests/lib-runtime-events/test_env_start.ml
+index 6b6bca5b09..cbdf114e57 100644
+--- a/testsuite/tests/lib-runtime-events/test_env_start.ml
++++ b/testsuite/tests/lib-runtime-events/test_env_start.ml
+@@ -1,6 +1,8 @@
+ (* TEST
+ include runtime_events
+ set OCAML_RUNTIME_EVENTS_START = "1"
++* skip
++reason = "OCaml 5 only"
+ *)
+ 
+ (* In this test the runtime_events should already be started by the environment
+diff --git a/testsuite/tests/lib-runtime-events/test_external.ml b/testsuite/tests/lib-runtime-events/test_external.ml
+index ecea4b7e13..4f363941f4 100644
+--- a/testsuite/tests/lib-runtime-events/test_external.ml
++++ b/testsuite/tests/lib-runtime-events/test_external.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+    include runtime_events
+    include unix
+-   * libunix
+-   ** bytecode
+-   ** native *)
++   * skip
++   reason = "OCaml 5 only"
++   ** libunix
++   *** bytecode
++   *** native *)
+ 
+ let got_major = ref false
+ let got_minor = ref false
+diff --git a/testsuite/tests/lib-runtime-events/test_external_preserve.ml b/testsuite/tests/lib-runtime-events/test_external_preserve.ml
+index 18c2ac578b..76d66b1b66 100644
+--- a/testsuite/tests/lib-runtime-events/test_external_preserve.ml
++++ b/testsuite/tests/lib-runtime-events/test_external_preserve.ml
+@@ -2,9 +2,11 @@
+   include runtime_events
+   include unix
+   set OCAML_RUNTIME_EVENTS_PRESERVE = "1"
+-  * libunix
+-  ** bytecode
+-  ** native *)
++  * skip
++  reason = "OCaml 5 only"
++  ** libunix
++  *** bytecode
++  *** native *)
+ 
+   (* this tests the preservation of ring buffers after termination *)
+ 
+diff --git a/testsuite/tests/lib-runtime-events/test_fork.ml b/testsuite/tests/lib-runtime-events/test_fork.ml
+index 87f556a659..097905b626 100644
+--- a/testsuite/tests/lib-runtime-events/test_fork.ml
++++ b/testsuite/tests/lib-runtime-events/test_fork.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+    include runtime_events
+    include unix
+-   * libunix
+-   ** bytecode
+-   ** native *)
++   * skip
++   reason = "OCaml 5 only"
++   ** libunix
++   *** bytecode
++   *** native *)
+ 
+ let got_start = ref false
+ let got_fork_child = ref false
+diff --git a/testsuite/tests/lib-runtime-events/test_instrumented.ml b/testsuite/tests/lib-runtime-events/test_instrumented.ml
+index 94727d13fd..e353268013 100644
+--- a/testsuite/tests/lib-runtime-events/test_instrumented.ml
++++ b/testsuite/tests/lib-runtime-events/test_instrumented.ml
+@@ -2,8 +2,10 @@
+    include runtime_events
+    flags = "-runtime-variant=i"
+ 
+-   * instrumented-runtime
+-   ** native
++   * skip
++   reason = "OCaml 5 only"
++   ** instrumented-runtime
++   *** native
+ *)
+ 
+ open Runtime_events
+diff --git a/testsuite/tests/lib-runtime-events/test_user_event.ml b/testsuite/tests/lib-runtime-events/test_user_event.ml
+index a4cb09175b..51566e99ed 100644
+--- a/testsuite/tests/lib-runtime-events/test_user_event.ml
++++ b/testsuite/tests/lib-runtime-events/test_user_event.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+ include runtime_events
++* skip
++reason = "OCaml 5 only"
+ *)
+ open Runtime_events
+ 
+diff --git a/testsuite/tests/lib-runtime-events/test_user_event_unknown.ml b/testsuite/tests/lib-runtime-events/test_user_event_unknown.ml
+index f5a63d46fd..a6b5740ae7 100644
+--- a/testsuite/tests/lib-runtime-events/test_user_event_unknown.ml
++++ b/testsuite/tests/lib-runtime-events/test_user_event_unknown.ml
+@@ -2,9 +2,11 @@
+    include runtime_events
+    include unix
+    set OCAML_RUNTIME_EVENTS_PRESERVE = "1"
+-   * libunix
+-   ** bytecode
+-   ** native
++   * skip
++   reason = "OCaml 5 only"
++   ** libunix
++   *** bytecode
++   *** native
+ *)
+ open Runtime_events
+ 
+diff --git a/testsuite/tests/lib-str/parallel.ml b/testsuite/tests/lib-str/parallel.ml
+index 23f2a5f7de..08055698e7 100644
+--- a/testsuite/tests/lib-str/parallel.ml
++++ b/testsuite/tests/lib-str/parallel.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasstr
++* skip
++reason = "OCaml 5 only"
++** hasstr
+ include str
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ let total = Atomic.make 0
+diff --git a/testsuite/tests/lib-sync/prodcons.ml b/testsuite/tests/lib-sync/prodcons.ml
+index 2e2c09756c..093d8740be 100644
+--- a/testsuite/tests/lib-sync/prodcons.ml
++++ b/testsuite/tests/lib-sync/prodcons.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ (* Classic producer-consumer *)
+diff --git a/testsuite/tests/lib-sync/trylock.ml b/testsuite/tests/lib-sync/trylock.ml
+index 314f1142ca..b4719fff04 100644
+--- a/testsuite/tests/lib-sync/trylock.ml
++++ b/testsuite/tests/lib-sync/trylock.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ (* Test Mutex.try_lock *)
+diff --git a/testsuite/tests/lib-sync/trylock2.ml b/testsuite/tests/lib-sync/trylock2.ml
+index b31ace08b5..e29ee93f9e 100644
+--- a/testsuite/tests/lib-sync/trylock2.ml
++++ b/testsuite/tests/lib-sync/trylock2.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ (* Test Mutex.try_lock *)
+diff --git a/testsuite/tests/lib-systhreads/boundscheck.ml b/testsuite/tests/lib-systhreads/boundscheck.ml
+index 216dcebae7..124d054ec7 100644
+--- a/testsuite/tests/lib-systhreads/boundscheck.ml
++++ b/testsuite/tests/lib-systhreads/boundscheck.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+ 
+ include systhreads
+-* hassysthreads
+-** bytecode
+-** native
++* skip
++reason = "OCaml 5 only"
++** hassysthreads
++*** bytecode
++*** native
+ 
+ *)
+ 
+diff --git a/testsuite/tests/lib-systhreads/multicore_lifecycle.ml b/testsuite/tests/lib-systhreads/multicore_lifecycle.ml
+index f481464906..0138046146 100644
+--- a/testsuite/tests/lib-systhreads/multicore_lifecycle.ml
++++ b/testsuite/tests/lib-systhreads/multicore_lifecycle.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hassysthreads
++* skip
++reason = "OCaml 5 only"
++** hassysthreads
+ include systhreads
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ let _ =
+diff --git a/testsuite/tests/lib-systhreads/test_c_thread_register.ml b/testsuite/tests/lib-systhreads/test_c_thread_register.ml
+index a8ec98aa9a..784fe6945f 100644
+--- a/testsuite/tests/lib-systhreads/test_c_thread_register.ml
++++ b/testsuite/tests/lib-systhreads/test_c_thread_register.ml
+@@ -2,9 +2,10 @@
+    modules = "test_c_thread_register_cstubs.c"
+    * hassysthreads
+    include systhreads
+-   ** not-bsd
+-   *** bytecode
+-   *** native
++   ** not-windows
++   *** not-bsd
++   **** bytecode
++   **** native
+ *)
+ 
+ (* spins a external thread from C and register it to the OCaml runtime *)
+diff --git a/testsuite/tests/lib-threads/uncaught_exception_handler.reference b/testsuite/tests/lib-threads/uncaught_exception_handler.reference
+index 23ff3ade39..cd68534b54 100644
+--- a/testsuite/tests/lib-threads/uncaught_exception_handler.reference
++++ b/testsuite/tests/lib-threads/uncaught_exception_handler.reference
+@@ -1,15 +1,15 @@
+ Thread 1 killed on uncaught exception Uncaught_exception_handler.CallbackExn
+ Raised at Uncaught_exception_handler.fn in file "uncaught_exception_handler.ml", line 28, characters 12-113
+-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+ [thread 2] caught Uncaught_exception_handler.CallbackExn
+ Raised at Uncaught_exception_handler.fn in file "uncaught_exception_handler.ml", line 28, characters 12-113
+-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+ Thread 2 killed on uncaught exception Uncaught_exception_handler.CallbackExn
+ Raised at Uncaught_exception_handler.fn in file "uncaught_exception_handler.ml", line 28, characters 12-113
+-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+ Thread 2 uncaught exception handler raised Uncaught_exception_handler.UncaughtHandlerExn
+ Raised at Uncaught_exception_handler.handler in file "uncaught_exception_handler.ml", line 26, characters 2-17
+-Called from Thread.create.(fun) in file "thread.ml", line 57, characters 10-41
++Called from Thread.create.(fun) in file "thread.ml", line 64, characters 10-41
+ [thread 3] caught Uncaught_exception_handler.CallbackExn
+ Raised at Uncaught_exception_handler.fn in file "uncaught_exception_handler.ml", line 28, characters 12-113
+-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
+diff --git a/testsuite/tests/lib-unix/common/multicore_fork_domain_alone.ml b/testsuite/tests/lib-unix/common/multicore_fork_domain_alone.ml
+index 077a3dba66..78112d293e 100644
+--- a/testsuite/tests/lib-unix/common/multicore_fork_domain_alone.ml
++++ b/testsuite/tests/lib-unix/common/multicore_fork_domain_alone.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+ include unix
+-* hasunix
+-** not-windows
+-*** bytecode
+-*** native
++* skip
++reason = "OCaml 5 only"
++** hasunix
++*** not-windows
++**** bytecode
++**** native
+ *)
+ 
+ (* on Multicore, fork is not allowed is another domain is, and was running. *)
+diff --git a/testsuite/tests/lib-unix/common/multicore_fork_domain_alone2.ml b/testsuite/tests/lib-unix/common/multicore_fork_domain_alone2.ml
+index 929ed5ecf7..61f75dce4a 100644
+--- a/testsuite/tests/lib-unix/common/multicore_fork_domain_alone2.ml
++++ b/testsuite/tests/lib-unix/common/multicore_fork_domain_alone2.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+ include unix
+-* hasunix
+-** not-windows
+-*** bytecode
+-*** native
++* skip
++reason = "OCaml 5 only"
++** hasunix
++*** not-windows
++**** bytecode
++**** native
+ *)
+ 
+ (* on Multicore, fork is not allowed is another domain is, and was running. *)
+diff --git a/testsuite/tests/lib-unix/win-channel-of/parallel_channel_of.ml b/testsuite/tests/lib-unix/win-channel-of/parallel_channel_of.ml
+index 01ae4df1c3..fb17641f40 100644
+--- a/testsuite/tests/lib-unix/win-channel-of/parallel_channel_of.ml
++++ b/testsuite/tests/lib-unix/win-channel-of/parallel_channel_of.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+ modules = "fd_of_channel.c"
+-* libwin32unix
++reason = "OCaml 5 only"
++* skip
++** libwin32unix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ external fd_of_in_channel: in_channel -> int = "caml_fd_of_channel"
+diff --git a/testsuite/tests/lib-unix/win-symlink/parallel_symlink.ml b/testsuite/tests/lib-unix/win-symlink/parallel_symlink.ml
+index d27e7db02d..651e071303 100644
+--- a/testsuite/tests/lib-unix/win-symlink/parallel_symlink.ml
++++ b/testsuite/tests/lib-unix/win-symlink/parallel_symlink.ml
+@@ -2,8 +2,10 @@
+ * libwin32unix
+ include unix
+ ** has_symlink
+-*** bytecode
+-*** native
++*** skip
++reason = "OCaml 5 only"
++**** bytecode
++**** native
+ *)
+ 
+ let create_symlink barrier src dst () =
+diff --git a/testsuite/tests/memory-model/forbidden.ml b/testsuite/tests/memory-model/forbidden.ml
+index 5504d94f04..32a8d9fa8c 100644
+--- a/testsuite/tests/memory-model/forbidden.ml
++++ b/testsuite/tests/memory-model/forbidden.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+   modules="opt.ml barrier.ml hist.ml shared.ml run.ml outcome.ml"
+-  * not-bsd
+-  ** bytecode
+-  ** native
++  * skip
++  reason = "OCaml 5 only"
++  ** not-bsd
++  *** bytecode
++  *** native
+ *)
+ 
+ (* Memory model test:
+diff --git a/testsuite/tests/memory-model/publish.ml b/testsuite/tests/memory-model/publish.ml
+index 7f778307a1..94e08074d4 100644
+--- a/testsuite/tests/memory-model/publish.ml
++++ b/testsuite/tests/memory-model/publish.ml
+@@ -1,9 +1,11 @@
+ (* TEST
+   modules="opt.ml barrier.ml hist.ml shared.ml run.ml outcome.ml"
+-  * not-bsd
+-  ** not-windows
+-  *** bytecode
+-  ** native
++  * skip
++  reason = "OCaml 5 only"
++  ** not-bsd
++  *** not-windows
++  **** bytecode
++  **** native
+ *)
+ 
+ (* Memory model: test the _publish idiom *)
+diff --git a/testsuite/tests/parallel/atomics.ml b/testsuite/tests/parallel/atomics.ml
+index 823fb32dc2..de7aa2a5b4 100644
+--- a/testsuite/tests/parallel/atomics.ml
++++ b/testsuite/tests/parallel/atomics.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++* skip
++reason = "OCaml 5 only"
+ *)
+ 
+ type u = U of unit
+diff --git a/testsuite/tests/parallel/backup_thread.ml b/testsuite/tests/parallel/backup_thread.ml
+index 05b06cc47c..c69f164ce7 100644
+--- a/testsuite/tests/parallel/backup_thread.ml
++++ b/testsuite/tests/parallel/backup_thread.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ 
+diff --git a/testsuite/tests/parallel/backup_thread_pipe.ml b/testsuite/tests/parallel/backup_thread_pipe.ml
+index 41fd101c1f..d0c5bb6e35 100644
+--- a/testsuite/tests/parallel/backup_thread_pipe.ml
++++ b/testsuite/tests/parallel/backup_thread_pipe.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ 
+diff --git a/testsuite/tests/parallel/constpromote.ml b/testsuite/tests/parallel/constpromote.ml
+index 9bf7ede7a3..89e2f9aef4 100644
+--- a/testsuite/tests/parallel/constpromote.ml
++++ b/testsuite/tests/parallel/constpromote.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++* skip
++reason = "OCaml 5 only"
+ *)
+ 
+ (* when run with the bytecode debug runtime, this test
+diff --git a/testsuite/tests/parallel/deadcont.ml b/testsuite/tests/parallel/deadcont.ml
+index fcdfbec210..d162cd1993 100644
+--- a/testsuite/tests/parallel/deadcont.ml
++++ b/testsuite/tests/parallel/deadcont.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++* skip
++reason = "OCaml 5 only"
+ *)
+ 
+ (*
+diff --git a/testsuite/tests/parallel/domain_dls.ml b/testsuite/tests/parallel/domain_dls.ml
+index 72f4ddf0bd..3d313a288a 100644
+--- a/testsuite/tests/parallel/domain_dls.ml
++++ b/testsuite/tests/parallel/domain_dls.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++* skip
++reason = "OCaml 5 only"
+ *)
+ 
+ let check_dls () =
+diff --git a/testsuite/tests/parallel/domain_dls2.ml b/testsuite/tests/parallel/domain_dls2.ml
+index ae301bda36..fe19776342 100644
+--- a/testsuite/tests/parallel/domain_dls2.ml
++++ b/testsuite/tests/parallel/domain_dls2.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++* skip
++reason = "OCaml 5 only"
+ *)
+ 
+ let _ =
+diff --git a/testsuite/tests/parallel/domain_id.ml b/testsuite/tests/parallel/domain_id.ml
+index 540ca905fd..a38477147b 100644
+--- a/testsuite/tests/parallel/domain_id.ml
++++ b/testsuite/tests/parallel/domain_id.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++* skip
++reason = "OCaml 5 only"
+ *)
+ 
+ open Domain
+diff --git a/testsuite/tests/parallel/domain_parallel_spawn_burn.ml b/testsuite/tests/parallel/domain_parallel_spawn_burn.ml
+index ecc9d0b78f..2b6369bc3b 100644
+--- a/testsuite/tests/parallel/domain_parallel_spawn_burn.ml
++++ b/testsuite/tests/parallel/domain_parallel_spawn_burn.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++* skip
++reason = "OCaml 5 only"
+ *)
+ 
+ open Domain
+diff --git a/testsuite/tests/parallel/domain_parallel_spawn_burn_gc_set.ml b/testsuite/tests/parallel/domain_parallel_spawn_burn_gc_set.ml
+index 883ab1a5ab..245b0b73fb 100644
+--- a/testsuite/tests/parallel/domain_parallel_spawn_burn_gc_set.ml
++++ b/testsuite/tests/parallel/domain_parallel_spawn_burn_gc_set.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++* skip
++reason = "OCaml 5 only"
+ *)
+ 
+ open Domain
+diff --git a/testsuite/tests/parallel/domain_serial_spawn_burn.ml b/testsuite/tests/parallel/domain_serial_spawn_burn.ml
+index aeac4f71f7..ea63910f2f 100644
+--- a/testsuite/tests/parallel/domain_serial_spawn_burn.ml
++++ b/testsuite/tests/parallel/domain_serial_spawn_burn.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ open Domain
+diff --git a/testsuite/tests/parallel/fib_threads.ml b/testsuite/tests/parallel/fib_threads.ml
+index f6005729b7..3ab3dde90d 100644
+--- a/testsuite/tests/parallel/fib_threads.ml
++++ b/testsuite/tests/parallel/fib_threads.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hassysthreads
++* skip
++reason = "OCaml 5 only"
++** hassysthreads
+ include systhreads
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ 
+diff --git a/testsuite/tests/parallel/join.ml b/testsuite/tests/parallel/join.ml
+index ee85838527..f98dbcef64 100644
+--- a/testsuite/tests/parallel/join.ml
++++ b/testsuite/tests/parallel/join.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++* skip
++reason = "OCaml 5 only"
+ *)
+ 
+ let test_size =
+diff --git a/testsuite/tests/parallel/major_gc_wait_backup.ml b/testsuite/tests/parallel/major_gc_wait_backup.ml
+index e418500774..f11190aee3 100644
+--- a/testsuite/tests/parallel/major_gc_wait_backup.ml
++++ b/testsuite/tests/parallel/major_gc_wait_backup.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** native
+-** bytecode
++*** native
++*** bytecode
+ *)
+ 
+ type 'a tree = Empty | Node of 'a tree * 'a tree
+diff --git a/testsuite/tests/parallel/mctest.ml b/testsuite/tests/parallel/mctest.ml
+index c5d82d2dbd..bbebf9d4b8 100644
+--- a/testsuite/tests/parallel/mctest.ml
++++ b/testsuite/tests/parallel/mctest.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ (*
+diff --git a/testsuite/tests/parallel/multicore_systhreads.ml b/testsuite/tests/parallel/multicore_systhreads.ml
+index 2f0fcf20b0..5ce5ea86ea 100644
+--- a/testsuite/tests/parallel/multicore_systhreads.ml
++++ b/testsuite/tests/parallel/multicore_systhreads.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hassysthreads
++* skip
++reason = "OCaml 5 only"
++** hassysthreads
+ include systhreads
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ 
+diff --git a/testsuite/tests/parallel/pingpong.ml b/testsuite/tests/parallel/pingpong.ml
+index 1f29cb6b8b..70b7ed6f69 100644
+--- a/testsuite/tests/parallel/pingpong.ml
++++ b/testsuite/tests/parallel/pingpong.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++* skip
++reason = "OCaml 5 only"
+ *)
+ 
+ let r = ref (Some 0)
+diff --git a/testsuite/tests/parallel/poll.ml b/testsuite/tests/parallel/poll.ml
+index 4248ba10cf..98255fb08d 100644
+--- a/testsuite/tests/parallel/poll.ml
++++ b/testsuite/tests/parallel/poll.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ let continue = Atomic.make true
+diff --git a/testsuite/tests/parallel/prodcons_domains.ml b/testsuite/tests/parallel/prodcons_domains.ml
+index 2e2c09756c..2b86809df1 100644
+--- a/testsuite/tests/parallel/prodcons_domains.ml
++++ b/testsuite/tests/parallel/prodcons_domains.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++* skip
++reason = "OCaml 5 only"
+ *)
+ 
+ (* Classic producer-consumer *)
+diff --git a/testsuite/tests/parallel/recommended_domain_count.ml b/testsuite/tests/parallel/recommended_domain_count.ml
+index 8aedeba202..cb2c93cbf6 100644
+--- a/testsuite/tests/parallel/recommended_domain_count.ml
++++ b/testsuite/tests/parallel/recommended_domain_count.ml
+@@ -1,5 +1,7 @@
+ (* TEST
+ modules = "recommended_domain_count_cstubs.c"
++* skip
++reason = "OCaml 5 only"
+ *)
+ 
+ external get_max_domains : unit -> int = "caml_get_max_domains"
+diff --git a/testsuite/tests/parallel/recommended_domain_count_unix.ml b/testsuite/tests/parallel/recommended_domain_count_unix.ml
+index f26038a765..9bab6ccab9 100644
+--- a/testsuite/tests/parallel/recommended_domain_count_unix.ml
++++ b/testsuite/tests/parallel/recommended_domain_count_unix.ml
+@@ -1,8 +1,10 @@
+ (* TEST
+-* hasunix
++* skip
++reason = "OCaml 5 only"
++** hasunix
+ include unix
+-** bytecode
+-** native
++*** bytecode
++*** native
+ *)
+ 
+ let try_ext cmd =
+diff --git a/testsuite/tests/parallel/tak.ml b/testsuite/tests/parallel/tak.ml
+index a9b6874c4f..bdc4173266 100644
+--- a/testsuite/tests/parallel/tak.ml
++++ b/testsuite/tests/parallel/tak.ml
+@@ -1,4 +1,6 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+ *)
+ 
+ (* filling minor heaps in parallel to trigger
+diff --git a/testsuite/tests/parallel/test_c_thread_register.ml b/testsuite/tests/parallel/test_c_thread_register.ml
+index 352424a377..9e2073c4ef 100644
+--- a/testsuite/tests/parallel/test_c_thread_register.ml
++++ b/testsuite/tests/parallel/test_c_thread_register.ml
+@@ -1,9 +1,11 @@
+ (* TEST
++   * skip
++   reason = "OCaml 5 only"
+    modules = "test_c_thread_register_cstubs.c"
+-   * hassysthreads
++   ** hassysthreads
+    include systhreads
+-   ** bytecode
+-   ** native
++   *** bytecode
++   *** native
+ *)
+ 
+ (* spins a external thread from C and register it to the OCaml runtime *)
+diff --git a/testsuite/tests/parallel/test_issue_11094.ml b/testsuite/tests/parallel/test_issue_11094.ml
+index ffc6d4bedd..8b9fb98c50 100644
+--- a/testsuite/tests/parallel/test_issue_11094.ml
++++ b/testsuite/tests/parallel/test_issue_11094.ml
+@@ -1,6 +1,8 @@
+ (* TEST
+-* bytecode
+-* native
++* skip
++reason = "OCaml 5 only"
++** bytecode
++** native
+ *)
+ 
+ open Effect
+diff --git a/testsuite/tests/regression/pr9326/gc_set.ml b/testsuite/tests/regression/pr9326/gc_set.ml
+index 2570aec28e..e9d7dbcd4c 100644
+--- a/testsuite/tests/regression/pr9326/gc_set.ml
++++ b/testsuite/tests/regression/pr9326/gc_set.ml
+@@ -4,35 +4,32 @@
+ open Gc
+ 
+ let min_heap_sz = 524288 (* 512k *)
+-let space_overhead = 70
+-let stack_limit = 4194304 (* 4M *)
+-let custom_major_ratio = 40
+-let custom_minor_ratio = 99
+-let custom_minor_max_size = 4096
++let maj_heap_inc = 4194304 (* 4M *)
+ 
+ let _ =
+   let g1 = Gc.get() in
+   (* Do not use { g1 with ... }, so that the code will break if more fields
+      are added to the Gc.control record type *)
+   Gc.set { minor_heap_size = min_heap_sz;
+-           major_heap_increment = g1.major_heap_increment;
+-           space_overhead = space_overhead;
++           major_heap_increment = maj_heap_inc;
++           space_overhead = g1.space_overhead;
+            verbose = g1.verbose;
+            max_overhead = g1.max_overhead;
+-           stack_limit = stack_limit;
++           stack_limit = g1.stack_limit;
+            allocation_policy = g1.allocation_policy;
+            window_size = g1.window_size;
+-           custom_major_ratio = custom_major_ratio;
+-           custom_minor_ratio = custom_minor_ratio;
+-           custom_minor_max_size = custom_minor_max_size };
++           custom_major_ratio = g1.custom_major_ratio;
++           custom_minor_ratio = g1.custom_minor_ratio;
++           custom_minor_max_size = g1.custom_minor_max_size };
+   let g2 = Gc.get() in
+   assert (g2.minor_heap_size = min_heap_sz);
+-  assert (g2.space_overhead = space_overhead);
++  assert (g2.major_heap_increment = maj_heap_inc);
++  assert (g2.space_overhead = g1.space_overhead);
+   assert (g2.verbose = g1.verbose);
+   assert (g2.max_overhead = g1.max_overhead);
+-  assert (g2.stack_limit = stack_limit);
++  assert (g2.stack_limit = g1.stack_limit);
+   assert (g2.allocation_policy = g1.allocation_policy);
+   assert (g2.window_size = g1.window_size);
+-  assert (g2.custom_major_ratio = custom_major_ratio);
+-  assert (g2.custom_minor_ratio = custom_minor_ratio);
+-  assert (g2.custom_minor_max_size = custom_minor_max_size)
++  assert (g2.custom_major_ratio = g1.custom_major_ratio);
++  assert (g2.custom_minor_ratio = g1.custom_minor_ratio);
++  assert (g2.custom_minor_max_size = g1.custom_minor_max_size)
+diff --git a/testsuite/tests/runtime-naked-pointers/cstubs.c b/testsuite/tests/runtime-naked-pointers/cstubs.c
+new file mode 100644
+index 0000000000..e9315f3aea
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/cstubs.c
+@@ -0,0 +1,20 @@
++#include <string.h>
++#include "caml/mlvalues.h"
++#include "caml/gc.h"
++#include "caml/memory.h"
++
++static int colors[4] = { Caml_white, Caml_gray, Caml_blue, Caml_black };
++
++value make_block(value header_size, value color, value size)
++{
++  intnat sz = Nativeint_val(size);
++  value * p = caml_stat_alloc((1 + sz) * sizeof(value));
++  p[0] = Make_header(Nativeint_val(header_size), 0, colors[Int_val(color)]);
++  memset(p + 1, 0x80, sz * sizeof(value));
++  return (value) (p + 1);
++}
++
++value make_raw_pointer (value v)
++{
++  return (value) Nativeint_val(v);
++}
+diff --git a/testsuite/tests/runtime-naked-pointers/np.ml b/testsuite/tests/runtime-naked-pointers/np.ml
+new file mode 100644
+index 0000000000..1738934ff0
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/np.ml
+@@ -0,0 +1,11 @@
++type color = White | Gray | Blue | Black
++
++external make_block: nativeint -> color -> nativeint -> Obj.t
++         = "make_block"
++
++external make_raw_pointer: nativeint -> Obj.t
++         = "make_raw_pointer"
++
++let do_gc root =
++  Gc.compact();   (* full major + compaction *)
++  root
+diff --git a/testsuite/tests/runtime-naked-pointers/np1.ml b/testsuite/tests/runtime-naked-pointers/np1.ml
+new file mode 100644
+index 0000000000..be4c677a23
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/np1.ml
+@@ -0,0 +1,12 @@
++(* TEST
++   modules = "cstubs.c np.ml"
++   * bytecode
++   * native
++*)
++
++open Np
++
++(* Out-of-heap object with black header is accepted even in no-naked-pointers
++   mode.  GC doesn't scan black objects. *)
++
++let x = do_gc [ make_block 100n Black 100n ]
+diff --git a/testsuite/tests/runtime-naked-pointers/np2.ml b/testsuite/tests/runtime-naked-pointers/np2.ml
+new file mode 100644
+index 0000000000..f24c813c2b
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/np2.ml
+@@ -0,0 +1,13 @@
++(* TEST
++   modules = "cstubs.c np.ml"
++   * bytecode
++   * native
++*)
++
++open Np
++
++(* Out-of-heap object with black header is accepted even in no-naked-pointers
++   mode.  GC doesn't scan black objects.  However, if the size in the
++   head is crazily big, the naked pointer detector will warn. *)
++
++let x = do_gc [ make_block (-1n) Black 100n ]
+diff --git a/testsuite/tests/runtime-naked-pointers/np2.run b/testsuite/tests/runtime-naked-pointers/np2.run
+new file mode 100755
+index 0000000000..c03f6f688d
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/np2.run
+@@ -0,0 +1,3 @@
++#!/bin/sh
++
++exec ${test_source_directory}/runtest.sh
+diff --git a/testsuite/tests/runtime-naked-pointers/np3.ml b/testsuite/tests/runtime-naked-pointers/np3.ml
+new file mode 100644
+index 0000000000..d207279df1
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/np3.ml
+@@ -0,0 +1,15 @@
++(* TEST
++   modules = "cstubs.c np.ml"
++   * naked_pointers
++   ** bytecode
++   ** native
++*)
++
++open Np
++
++(* Out-of-heap object with non-black header is OK in naked pointers mode only *)
++(* Note that the header size can be wrong as it should not be used by the GC *)
++
++let x = do_gc [ make_block 10000n White 10n;
++                make_block 1n Blue 0n;
++                make_block (-1n) Gray 5n ]
+diff --git a/testsuite/tests/runtime-naked-pointers/np3.run b/testsuite/tests/runtime-naked-pointers/np3.run
+new file mode 100755
+index 0000000000..c03f6f688d
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/np3.run
+@@ -0,0 +1,3 @@
++#!/bin/sh
++
++exec ${test_source_directory}/runtest.sh
+diff --git a/testsuite/tests/runtime-naked-pointers/np4.ml b/testsuite/tests/runtime-naked-pointers/np4.ml
+new file mode 100644
+index 0000000000..98966ddffc
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/np4.ml
+@@ -0,0 +1,13 @@
++(* TEST
++   modules = "cstubs.c np.ml"
++   * naked_pointers
++   ** bytecode
++   ** native
++*)
++
++open Np
++
++(* Null pointers and bad pointers outside the heap are OK
++   in naked pointers mode only *)
++
++let x = do_gc [ make_raw_pointer 0n; make_raw_pointer 42n ]
+diff --git a/testsuite/tests/runtime-naked-pointers/np4.run b/testsuite/tests/runtime-naked-pointers/np4.run
+new file mode 100755
+index 0000000000..c03f6f688d
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/np4.run
+@@ -0,0 +1,3 @@
++#!/bin/sh
++
++exec ${test_source_directory}/runtest.sh
+diff --git a/testsuite/tests/runtime-naked-pointers/runtest.sh b/testsuite/tests/runtime-naked-pointers/runtest.sh
+new file mode 100755
+index 0000000000..f5d4df561c
+--- /dev/null
++++ b/testsuite/tests/runtime-naked-pointers/runtest.sh
+@@ -0,0 +1,10 @@
++#!/bin/sh
++
++if grep -q "#define NAKED_POINTERS_CHECKER" ${ocamlsrcdir}/runtime/caml/m.h \
++&& (echo ${program} | grep -q '\.opt')
++then
++  (${program} > ${output}) 2>&1 | grep -q '^Out-of-heap '
++  exit $?
++else
++  exec ${program} > ${output}
++fi
+diff --git a/testsuite/tests/shapes/comp_units.ml b/testsuite/tests/shapes/comp_units.ml
+index 3a1b9494a1..e706bd4c8e 100644
+--- a/testsuite/tests/shapes/comp_units.ml
++++ b/testsuite/tests/shapes/comp_units.ml
+@@ -25,7 +25,7 @@ module Mproj = Unit
+ module F (X : sig type t end) = X
+ [%%expect{|
+ {
+- "F"[module] -> Abs<.4>(X/279, X/279<.3>);
++ "F"[module] -> Abs<.4>(X/274, X/274<.3>);
+  }
+ module F : functor (X : sig type t end) -> sig type t = X.t end
+ |}]
+diff --git a/testsuite/tests/shapes/functors.ml b/testsuite/tests/shapes/functors.ml
+index 613e2fae88..12d9623b0c 100644
+--- a/testsuite/tests/shapes/functors.ml
++++ b/testsuite/tests/shapes/functors.ml
+@@ -17,7 +17,7 @@ module type S = sig type t val x : t end
+ module Falias (X : S) = X
+ [%%expect{|
+ {
+- "Falias"[module] -> Abs<.4>(X/281, X/281<.3>);
++ "Falias"[module] -> Abs<.4>(X/276, X/276<.3>);
+  }
+ module Falias : functor (X : S) -> sig type t = X.t val x : t end
+ |}]
+@@ -29,10 +29,10 @@ end
+ {
+  "Finclude"[module] ->
+    Abs<.6>
+-      (X/285,
++      (X/280,
+        {
+-        "t"[type] -> X/285<.5> . "t"[type];
+-        "x"[value] -> X/285<.5> . "x"[value];
++        "t"[type] -> X/280<.5> . "t"[type];
++        "x"[value] -> X/280<.5> . "x"[value];
+         });
+  }
+ module Finclude : functor (X : S) -> sig type t = X.t val x : t end
+@@ -45,7 +45,7 @@ end
+ [%%expect{|
+ {
+  "Fredef"[module] ->
+-   Abs<.10>(X/292, {
++   Abs<.10>(X/287, {
+                     "t"[type] -> <.8>;
+                     "x"[value] -> <.9>;
+                     });
+@@ -223,8 +223,8 @@ module Big_to_small1 : B2S = functor (X : Big) -> X
+ [%%expect{|
+ {
+  "Big_to_small1"[module] ->
+-   Abs<.40>(X/387, {<.39>
+-                    "t"[type] -> X/387<.39> . "t"[type];
++   Abs<.40>(X/382, {<.39>
++                    "t"[type] -> X/382<.39> . "t"[type];
+                     });
+  }
+ module Big_to_small1 : B2S
+@@ -234,8 +234,8 @@ module Big_to_small2 : B2S = functor (X : Big) -> struct include X end
+ [%%expect{|
+ {
+  "Big_to_small2"[module] ->
+-   Abs<.42>(X/390, {
+-                    "t"[type] -> X/390<.41> . "t"[type];
++   Abs<.42>(X/385, {
++                    "t"[type] -> X/385<.41> . "t"[type];
+                     });
+  }
+ module Big_to_small2 : B2S
+diff --git a/testsuite/tests/shapes/open_arg.ml b/testsuite/tests/shapes/open_arg.ml
+index a422cc8ece..b82be26527 100644
+--- a/testsuite/tests/shapes/open_arg.ml
++++ b/testsuite/tests/shapes/open_arg.ml
+@@ -22,7 +22,7 @@ end = struct end
+ 
+ [%%expect{|
+ {
+- "Make"[module] -> Abs<.3>(I/281, {
++ "Make"[module] -> Abs<.3>(I/276, {
+                                    });
+  }
+ module Make : functor (I : sig end) -> sig end
+diff --git a/testsuite/tests/shapes/recmodules.ml b/testsuite/tests/shapes/recmodules.ml
+index c6f743e4b4..fe47a48629 100644
+--- a/testsuite/tests/shapes/recmodules.ml
++++ b/testsuite/tests/shapes/recmodules.ml
+@@ -43,8 +43,8 @@ and B : sig
+ end = B
+ [%%expect{|
+ {
+- "A"[module] -> A/304<.11>;
+- "B"[module] -> B/305<.12>;
++ "A"[module] -> A/299<.11>;
++ "B"[module] -> B/300<.12>;
+  }
+ module rec A : sig type t = Leaf of B.t end
+ and B : sig type t = int end
+@@ -82,12 +82,12 @@ end = Set.Make(A)
+  "ASet"[module] ->
+    {
+     "compare"[value] ->
+-      CU Stdlib . "Set"[module] . "Make"[module](A/326<.19>) .
++      CU Stdlib . "Set"[module] . "Make"[module](A/321<.19>) .
+       "compare"[value];
+     "elt"[type] ->
+-      CU Stdlib . "Set"[module] . "Make"[module](A/326<.19>) . "elt"[type];
++      CU Stdlib . "Set"[module] . "Make"[module](A/321<.19>) . "elt"[type];
+     "t"[type] ->
+-      CU Stdlib . "Set"[module] . "Make"[module](A/326<.19>) . "t"[type];
++      CU Stdlib . "Set"[module] . "Make"[module](A/321<.19>) . "t"[type];
+     };
+  }
+ module rec A :
+diff --git a/testsuite/tests/shapes/rotor_example.ml b/testsuite/tests/shapes/rotor_example.ml
+index 5802595844..961d5d4e80 100644
+--- a/testsuite/tests/shapes/rotor_example.ml
++++ b/testsuite/tests/shapes/rotor_example.ml
+@@ -25,7 +25,7 @@ end
+ [%%expect{|
+ {
+  "Pair"[module] ->
+-   Abs<.9>(X/281, Y/282, {
++   Abs<.9>(X/276, Y/277, {
+                           "t"[type] -> <.5>;
+                           "to_string"[value] -> <.6>;
+                           });
+diff --git a/testsuite/tests/statmemprof/alloc_counts.ml b/testsuite/tests/statmemprof/alloc_counts.ml
+index de0d1e9e49..f8cbb5658d 100644
+--- a/testsuite/tests/statmemprof/alloc_counts.ml
++++ b/testsuite/tests/statmemprof/alloc_counts.ml
+@@ -1,7 +1,4 @@
+-(* TEST
+-* skip
+-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+-*)
++(* TEST *)
+ module MP = Gc.Memprof
+ 
+ let allocs_by_memprof f =
+diff --git a/testsuite/tests/statmemprof/arrays_in_major.ml b/testsuite/tests/statmemprof/arrays_in_major.ml
+index eb627324ba..78907a18e3 100644
+--- a/testsuite/tests/statmemprof/arrays_in_major.ml
++++ b/testsuite/tests/statmemprof/arrays_in_major.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    flags = "-g"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ *)
+ 
+ open Gc.Memprof
+diff --git a/testsuite/tests/statmemprof/arrays_in_major.reference b/testsuite/tests/statmemprof/arrays_in_major.reference
+new file mode 100644
+index 0000000000..1f34ad8ec8
+--- /dev/null
++++ b/testsuite/tests/statmemprof/arrays_in_major.reference
+@@ -0,0 +1,11 @@
++check_nosample
++check_counts_full_major
++check_counts_full_major
++check_no_nested
++check_distrib 300 3000 3 0.000010
++check_distrib 300 3000 1 0.000100
++check_distrib 300 3000 1 0.010000
++check_distrib 300 3000 1 0.900000
++check_distrib 300 300 100000 0.100000
++check_distrib 300000 300000 30 0.100000
++OK !
+diff --git a/testsuite/tests/statmemprof/arrays_in_minor.ml b/testsuite/tests/statmemprof/arrays_in_minor.ml
+index 4359642d0e..432f8b1d09 100644
+--- a/testsuite/tests/statmemprof/arrays_in_minor.ml
++++ b/testsuite/tests/statmemprof/arrays_in_minor.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    flags = "-g"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ *)
+ 
+ open Gc.Memprof
+diff --git a/testsuite/tests/statmemprof/arrays_in_minor.reference b/testsuite/tests/statmemprof/arrays_in_minor.reference
+new file mode 100644
+index 0000000000..1dad91939c
+--- /dev/null
++++ b/testsuite/tests/statmemprof/arrays_in_minor.reference
+@@ -0,0 +1,11 @@
++check_nosample
++check_counts_full_major
++check_counts_full_major
++check_no_nested
++check_distrib 1 250 1000 0.000010
++check_distrib 1 250 1000 0.000100
++check_distrib 1 250 1000 0.010000
++check_distrib 1 250 1000 0.900000
++check_distrib 1 1 10000000 0.010000
++check_distrib 250 250 100000 0.100000
++OK !
+diff --git a/testsuite/tests/statmemprof/blocking_in_callback.ml b/testsuite/tests/statmemprof/blocking_in_callback.ml
+index e1e40f1fb6..00f49cfc74 100644
+--- a/testsuite/tests/statmemprof/blocking_in_callback.ml
++++ b/testsuite/tests/statmemprof/blocking_in_callback.ml
+@@ -1,8 +1,6 @@
+ (* TEST
+ * hassysthreads
+ include systhreads
+-* skip
+-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ ** bytecode
+ ** native
+ *)
+diff --git a/testsuite/tests/statmemprof/callstacks.flat-float-array.reference b/testsuite/tests/statmemprof/callstacks.flat-float-array.reference
+index baea29a0d5..d71791641d 100644
+--- a/testsuite/tests/statmemprof/callstacks.flat-float-array.reference
++++ b/testsuite/tests/statmemprof/callstacks.flat-float-array.reference
+@@ -1,74 +1,74 @@
+ -----------
+ Raised by primitive operation at Callstacks.alloc_list_literal in file "callstacks.ml", line 18, characters 30-53
+ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
+ -----------
+ Raised by primitive operation at Callstacks.alloc_pair in file "callstacks.ml", line 21, characters 30-76
+ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
+ -----------
+ Raised by primitive operation at Callstacks.alloc_record in file "callstacks.ml", line 26, characters 12-66
+ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
+ -----------
+ Raised by primitive operation at Callstacks.alloc_some in file "callstacks.ml", line 29, characters 30-60
+ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
+ -----------
+ Raised by primitive operation at Callstacks.alloc_array_literal in file "callstacks.ml", line 32, characters 30-55
+ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
+ -----------
+ Raised by primitive operation at Callstacks.alloc_float_array_literal in file "callstacks.ml", line 36, characters 12-62
+ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
+ -----------
+ Raised by primitive operation at Callstacks.do_alloc_unknown_array_literal in file "callstacks.ml", line 39, characters 22-27
+ Called from Callstacks.alloc_unknown_array_literal in file "callstacks.ml", line 41, characters 30-65
+ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
+ -----------
+ Raised by primitive operation at Callstacks.alloc_small_array in file "callstacks.ml", line 44, characters 30-69
+ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
+ -----------
+ Raised by primitive operation at Callstacks.alloc_large_array in file "callstacks.ml", line 47, characters 30-73
+ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
+ -----------
+ Raised by primitive operation at Callstacks.alloc_closure.(fun) in file "callstacks.ml", line 51, characters 30-43
+ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
+ -----------
+ Raised by primitive operation at Callstacks.get0 in file "callstacks.ml", line 54, characters 28-33
+ Called from Callstacks.getfloatfield in file "callstacks.ml", line 56, characters 30-47
+ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
+ -----------
+ Raised by primitive operation at Stdlib__Marshal.from_bytes in file "marshal.ml", line 61, characters 9-35
+ Called from Callstacks.alloc_unmarshal in file "callstacks.ml", line 62, characters 12-87
+ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
+ -----------
+ Raised by primitive operation at Callstacks.alloc_ref in file "callstacks.ml", line 65, characters 30-59
+ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
+ -----------
+ Raised by primitive operation at Callstacks.prod_floats in file "callstacks.ml", line 68, characters 37-43
+ Called from Callstacks.alloc_boxedfloat in file "callstacks.ml", line 70, characters 30-49
+ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
+diff --git a/testsuite/tests/statmemprof/callstacks.ml b/testsuite/tests/statmemprof/callstacks.ml
+index e864a50019..ec5a4199f0 100644
+--- a/testsuite/tests/statmemprof/callstacks.ml
++++ b/testsuite/tests/statmemprof/callstacks.ml
+@@ -3,15 +3,11 @@
+ 
+    * flat-float-array
+      reference = "${test_source_directory}/callstacks.flat-float-array.reference"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+    ** native
+    ** bytecode
+ 
+    * no-flat-float-array
+      reference = "${test_source_directory}/callstacks.no-flat-float-array.reference"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+    ** native
+    ** bytecode
+ *)
+diff --git a/testsuite/tests/statmemprof/comballoc.byte.reference b/testsuite/tests/statmemprof/comballoc.byte.reference
+index 4db26f1c99..98c4fd718d 100644
+--- a/testsuite/tests/statmemprof/comballoc.byte.reference
++++ b/testsuite/tests/statmemprof/comballoc.byte.reference
+@@ -1,49 +1,49 @@
+ 2: 0.42 false
+ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 2-19
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ 3: 0.42 false
+ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 6-18
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ 4: 0.42 true
+ Raised by primitive operation at Comballoc.f4 in file "comballoc.ml", line 11, characters 11-20
+ Called from Comballoc.f in file "comballoc.ml", line 14, characters 13-17
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ 2: 0.01 false
+ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 2-19
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ 3: 0.01 false
+ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 6-18
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ 4: 0.01 true
+ Raised by primitive operation at Comballoc.f4 in file "comballoc.ml", line 11, characters 11-20
+ Called from Comballoc.f in file "comballoc.ml", line 14, characters 13-17
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ 2: 0.83 false
+ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 2-19
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ 3: 0.83 false
+ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 6-18
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ 4: 0.83 true
+ Raised by primitive operation at Comballoc.f4 in file "comballoc.ml", line 11, characters 11-20
+ Called from Comballoc.f in file "comballoc.ml", line 14, characters 13-17
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ OK
+diff --git a/testsuite/tests/statmemprof/comballoc.ml b/testsuite/tests/statmemprof/comballoc.ml
+index 60ca4a0123..22b2547101 100644
+--- a/testsuite/tests/statmemprof/comballoc.ml
++++ b/testsuite/tests/statmemprof/comballoc.ml
+@@ -1,10 +1,8 @@
+ (* TEST
+    flags = "-g"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+-   ** bytecode
++   * bytecode
+      reference = "${test_source_directory}/comballoc.byte.reference"
+-   ** native
++   * native
+      reference = "${test_source_directory}/comballoc.opt.reference"
+ *)
+ 
+diff --git a/testsuite/tests/statmemprof/comballoc.opt.reference b/testsuite/tests/statmemprof/comballoc.opt.reference
+index 3afd163aa8..b6bd4f18fe 100644
+--- a/testsuite/tests/statmemprof/comballoc.opt.reference
++++ b/testsuite/tests/statmemprof/comballoc.opt.reference
+@@ -1,49 +1,49 @@
+ 2: 0.42 false
+ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 2-19
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ 3: 0.42 false
+ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 6-18
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ 4: 0.42 true
+ Raised by primitive operation at Comballoc.f4 in file "comballoc.ml" (inlined), line 11, characters 11-20
+ Called from Comballoc.f in file "comballoc.ml", line 14, characters 13-17
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ 2: 0.01 false
+ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 2-19
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ 3: 0.01 false
+ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 6-18
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ 4: 0.01 true
+ Raised by primitive operation at Comballoc.f4 in file "comballoc.ml" (inlined), line 11, characters 11-20
+ Called from Comballoc.f in file "comballoc.ml", line 14, characters 13-17
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ 2: 0.83 false
+ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 2-19
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ 3: 0.83 false
+ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 6-18
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ 4: 0.83 true
+ Raised by primitive operation at Comballoc.f4 in file "comballoc.ml" (inlined), line 11, characters 11-20
+ Called from Comballoc.f in file "comballoc.ml", line 14, characters 13-17
+ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
+-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
+ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
+ OK
+diff --git a/testsuite/tests/statmemprof/custom.ml b/testsuite/tests/statmemprof/custom.ml
+index 41cf902ec8..f0ddfa7eed 100644
+--- a/testsuite/tests/statmemprof/custom.ml
++++ b/testsuite/tests/statmemprof/custom.ml
+@@ -1,7 +1,4 @@
+-(* TEST
+-* skip
+-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+-*)
++(* TEST *)
+ 
+ open Gc.Memprof
+ 
+diff --git a/testsuite/tests/statmemprof/exception_callback.ml b/testsuite/tests/statmemprof/exception_callback.ml
+index f9f02f690f..e1589372ab 100644
+--- a/testsuite/tests/statmemprof/exception_callback.ml
++++ b/testsuite/tests/statmemprof/exception_callback.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    exit_status = "2"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ *)
+ 
+ open Gc.Memprof
+diff --git a/testsuite/tests/statmemprof/exception_callback_minor.ml b/testsuite/tests/statmemprof/exception_callback_minor.ml
+index 0bb37782be..f514123276 100644
+--- a/testsuite/tests/statmemprof/exception_callback_minor.ml
++++ b/testsuite/tests/statmemprof/exception_callback_minor.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    exit_status = "2"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ *)
+ 
+ open Gc.Memprof
+diff --git a/testsuite/tests/statmemprof/intern.ml b/testsuite/tests/statmemprof/intern.ml
+index bebcc3c8ff..bce6f89c5c 100644
+--- a/testsuite/tests/statmemprof/intern.ml
++++ b/testsuite/tests/statmemprof/intern.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    flags = "-g"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ *)
+ 
+ open Gc.Memprof
+diff --git a/testsuite/tests/statmemprof/intern.reference b/testsuite/tests/statmemprof/intern.reference
+new file mode 100644
+index 0000000000..d83e8d6d50
+--- /dev/null
++++ b/testsuite/tests/statmemprof/intern.reference
+@@ -0,0 +1,10 @@
++check_nosample
++check_counts_full_major
++check_counts_full_major
++check_no_nested
++check_distrib 2 3000 3 0.000010
++check_distrib 2 3000 1 0.000100
++check_distrib 2 2000 1 0.010000
++check_distrib 2 2000 1 0.900000
++check_distrib 300000 300000 20 0.100000
++OK !
+diff --git a/testsuite/tests/statmemprof/lists_in_minor.ml b/testsuite/tests/statmemprof/lists_in_minor.ml
+index d08716c71b..ebd434857e 100644
+--- a/testsuite/tests/statmemprof/lists_in_minor.ml
++++ b/testsuite/tests/statmemprof/lists_in_minor.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    flags = "-g"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ *)
+ 
+ open Gc.Memprof
+diff --git a/testsuite/tests/statmemprof/lists_in_minor.reference b/testsuite/tests/statmemprof/lists_in_minor.reference
+new file mode 100644
+index 0000000000..11cfe0ca12
+--- /dev/null
++++ b/testsuite/tests/statmemprof/lists_in_minor.reference
+@@ -0,0 +1,8 @@
++check_distrib 10 1000000 0.010000
++check_distrib 1000000 10 0.000010
++check_distrib 1000000 10 0.000100
++check_distrib 1000000 10 0.001000
++check_distrib 1000000 10 0.010000
++check_distrib 100000 10 0.100000
++check_distrib 100000 10 0.900000
++OK !
+diff --git a/testsuite/tests/statmemprof/minor_no_postpone.ml b/testsuite/tests/statmemprof/minor_no_postpone.ml
+index 21c8bfb244..fcb94cf81d 100644
+--- a/testsuite/tests/statmemprof/minor_no_postpone.ml
++++ b/testsuite/tests/statmemprof/minor_no_postpone.ml
+@@ -1,7 +1,5 @@
+ (* TEST
+    modules = "minor_no_postpone_stub.c"
+-   * skip
+-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ *)
+ 
+ open Gc.Memprof
+diff --git a/testsuite/tests/statmemprof/moved_while_blocking.ml b/testsuite/tests/statmemprof/moved_while_blocking.ml
+index bb8dfc9848..8efc172aea 100644
+--- a/testsuite/tests/statmemprof/moved_while_blocking.ml
++++ b/testsuite/tests/statmemprof/moved_while_blocking.ml
+@@ -1,8 +1,6 @@
+ (* TEST
+ * hassysthreads
+ include systhreads
+-* skip
+-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ ** bytecode
+ ** native
+ *)
+diff --git a/testsuite/tests/statmemprof/thread_exit_in_callback.ml b/testsuite/tests/statmemprof/thread_exit_in_callback.ml
+index 28e2aabb8b..563be966a8 100644
+--- a/testsuite/tests/statmemprof/thread_exit_in_callback.ml
++++ b/testsuite/tests/statmemprof/thread_exit_in_callback.ml
+@@ -1,8 +1,6 @@
+ (* TEST
+ * hassysthreads
+ include systhreads
+-* skip
+-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
+ ** bytecode
+ ** native
+ *)
+@@ -12,7 +10,7 @@ let _ =
+   Gc.Memprof.(start ~callstack_size:10 ~sampling_rate:1.
+                 { null_tracker with alloc_minor = fun _ ->
+                       if Thread.id (Thread.self ()) <> main_thread then
+-                        Thread.exit ();
++                        raise Thread.Exit;
+                       None });
+   let t = Thread.create (fun () ->
+       ignore (Sys.opaque_identity (ref 1));
+@@ -21,6 +19,8 @@ let _ =
+   Thread.join t;
+   Gc.Memprof.stop ()
+ 
++[@@@ocaml.alert "-deprecated"]
++
+ let _ =
+   Gc.Memprof.(start ~callstack_size:10 ~sampling_rate:1.
+     { null_tracker with alloc_minor = fun _ -> Thread.exit (); None });
+diff --git a/testsuite/tests/typing-sigsubst/sigsubst.ml b/testsuite/tests/typing-sigsubst/sigsubst.ml
+index 6e3a30306e..7e48ca4534 100644
+--- a/testsuite/tests/typing-sigsubst/sigsubst.ml
++++ b/testsuite/tests/typing-sigsubst/sigsubst.ml
+@@ -24,11 +24,11 @@ end
+ Line 3, characters 2-36:
+ 3 |   include Comparable with type t = t
+       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+-Error: Illegal shadowing of included type t/286 by t/291
++Error: Illegal shadowing of included type t/281 by t/286
+        Line 2, characters 2-19:
+-         Type t/286 came from this include
++         Type t/281 came from this include
+        Line 3, characters 2-23:
+-         The value print has no valid type if t/286 is shadowed
++         The value print has no valid type if t/281 is shadowed
+ |}]
+ 
+ module type Sunderscore = sig
+diff --git a/testsuite/tests/unwind/unwind_test.reference b/testsuite/tests/unwind/unwind_test.reference
+index b3804d00e5..827cc4affc 100644
+--- a/testsuite/tests/unwind/unwind_test.reference
++++ b/testsuite/tests/unwind/unwind_test.reference
+@@ -1,5 +1,4 @@
+ ml_perform_stack_walk
+-caml_c_call
+ Mylib.baz
+ Driver.entry
+ caml_program
+diff --git a/testsuite/tests/weak-ephe-final/ephetest_par.ml b/testsuite/tests/weak-ephe-final/ephetest_par.ml
+index e3cab0e83e..26b5878c7a 100644
+--- a/testsuite/tests/weak-ephe-final/ephetest_par.ml
++++ b/testsuite/tests/weak-ephe-final/ephetest_par.ml
+@@ -1,4 +1,7 @@
+-(* TEST *)
++(* TEST
++   * skip
++   reason = "OCaml 5 only"
++ *)
+ 
+ (* Due to GCs running at non-deterministic places, the output from these tests
+  * are unreliable except the bad value checks and as a check for catastrophic
+diff --git a/testsuite/tests/weak-ephe-final/finaliser2.ml b/testsuite/tests/weak-ephe-final/finaliser2.ml
+index 666a55efeb..5a36157e0e 100644
+--- a/testsuite/tests/weak-ephe-final/finaliser2.ml
++++ b/testsuite/tests/weak-ephe-final/finaliser2.ml
+@@ -1,4 +1,7 @@
+-(* TEST *)
++(* TEST
++   * skip
++   reason = "OCaml 5 only"
++*)
+ 
+ let () = Out_channel.set_buffered stdout false
+ 
+diff --git a/testsuite/tests/weak-ephe-final/finaliser_handover.ml b/testsuite/tests/weak-ephe-final/finaliser_handover.ml
+index fa2d2efc43..752a7eeabf 100644
+--- a/testsuite/tests/weak-ephe-final/finaliser_handover.ml
++++ b/testsuite/tests/weak-ephe-final/finaliser_handover.ml
+@@ -1,4 +1,7 @@
+-(* TEST *)
++(* TEST
++   * skip
++   reason = "OCaml 5 only"
++*)
+ 
+ (* ocaml-multicore issues 528 and 468 *)
+ 
+diff --git a/testsuite/tests/weak-ephe-final/weaklifetime_par.ml b/testsuite/tests/weak-ephe-final/weaklifetime_par.ml
+index b42d399907..656e318473 100644
+--- a/testsuite/tests/weak-ephe-final/weaklifetime_par.ml
++++ b/testsuite/tests/weak-ephe-final/weaklifetime_par.ml
+@@ -1,3 +1,7 @@
++(* TEST
++   * skip
++   reason = "OCaml 5 only"
++*)
+ (* This test is currently disabled,
+    until the random failures have been investigated.
+ *)
+diff --git a/testsuite/tests/weak-ephe-final/weaktest_par_load.ml b/testsuite/tests/weak-ephe-final/weaktest_par_load.ml
+index f5e0711b79..8beb1f6433 100644
+--- a/testsuite/tests/weak-ephe-final/weaktest_par_load.ml
++++ b/testsuite/tests/weak-ephe-final/weaktest_par_load.ml
+@@ -1,4 +1,7 @@
+-(* TEST *)
++(* TEST
++* skip
++reason = "OCaml 5 only"
++*)
+ 
+ (* Testing unsynchronized, parallel Weak usage *)
+ 
+diff --git a/tools/ci/actions/runner.sh b/tools/ci/actions/runner.sh
+index de10bd1fd3..5f9e31bc66 100755
+--- a/tools/ci/actions/runner.sh
++++ b/tools/ci/actions/runner.sh
+@@ -40,19 +40,7 @@ EOF
+     --enable-debug-runtime \
+     $CONFIG_ARG"
+ 
+-  case $XARCH in
+-  x64)
+-    ./configure $configure_flags
+-    ;;
+-  i386)
+-    ./configure --build=x86_64-pc-linux-gnu --host=i386-pc-linux-gnu \
+-      $configure_flags
+-    ;;
+-  *)
+-    echo unknown arch
+-    exit 1
+-    ;;
+-  esac
++  ./configure $configure_flags
+ }
+ 
+ Build () {
+diff --git a/tools/ci/appveyor/appveyor_build.sh b/tools/ci/appveyor/appveyor_build.sh
+index 3292ad9c31..f69aeb342c 100644
+--- a/tools/ci/appveyor/appveyor_build.sh
++++ b/tools/ci/appveyor/appveyor_build.sh
+@@ -64,8 +64,8 @@ function set_configuration {
+         mingw64)
+             build='--build=i686-pc-cygwin'
+             host='--host=x86_64-w64-mingw32'
+-            dep='--disable-dependency-generation'
+-            man='--disable-stdlib-manpages'
++            # Explicitly test dependency generation on msvc64
++            dep='--enable-dependency-generation'
+         ;;
+         msvc32)
+             build='--build=i686-pc-cygwin'
+@@ -139,29 +139,40 @@ case "$1" in
+     ;;
+   test)
+     FULL_BUILD_PREFIX="$APPVEYOR_BUILD_FOLDER/../$BUILD_PREFIX"
+-    run 'ocamlc.opt -version' "$FULL_BUILD_PREFIX-$PORT/ocamlc.opt" -version
++    if [[ -e $FULL_BUILD_PREFIX-$PORT/ocamlc.opt.exe ]]; then
++      run 'ocamlc.opt -version' "$FULL_BUILD_PREFIX-$PORT/ocamlc.opt" -version
++    else
++      run 'ocamlc -version' \
++        "$FULL_BUILD_PREFIX-$PORT/runtime/ocamlrun.exe" \
++        "$(cygpath -w "$FULL_BUILD_PREFIX-$PORT/ocamlc.exe")" -version
++    fi
+     if [[ $PORT =~ mingw* ]] ; then
+       run "Check runtime symbols" \
+           "$FULL_BUILD_PREFIX-$PORT/tools/check-symbol-names" \
+           $FULL_BUILD_PREFIX-$PORT/runtime/*.a \
+           $FULL_BUILD_PREFIX-$PORT/otherlibs/*/lib*.a
+     fi
+-    # The testsuite is too slow to run on AppVeyor in full. Run the dynlink
+-    # tests now (to include natdynlink)
+-    run "test dynlink $PORT" \
+-        $MAKE -C "$FULL_BUILD_PREFIX-$PORT/testsuite" parallel-lib-dynlink
+-    # Now reconfigure ocamltest to run in bytecode-only mode
+-    sed -i '/native_/s/true/false/' \
+-           "$FULL_BUILD_PREFIX-$PORT/ocamltest/ocamltest_config.ml"
+-    $MAKE -C "$FULL_BUILD_PREFIX-$PORT/ocamltest" -j all allopt
+-    # And run the entire testsuite, skipping all the native-code tests
++    if [[ -e "$FULL_BUILD_PREFIX-$PORT/ocamlc.opt.exe" ]]; then
++      # The testsuite is too slow to run on AppVeyor in full. Run the dynlink
++      # tests now (to include natdynlink)
++      run "test dynlink $PORT" \
++          $MAKE -C "$FULL_BUILD_PREFIX-$PORT/testsuite" parallel-lib-dynlink
++      # Now reconfigure ocamltest to run in bytecode-only mode
++      sed -i '/native_/s/true/false/' \
++             "$FULL_BUILD_PREFIX-$PORT/ocamltest/ocamltest_config.ml"
++      $MAKE -C "$FULL_BUILD_PREFIX-$PORT/ocamltest" -j all allopt
++      # And run the entire testsuite, skipping all the native-code tests
++    fi
+     run "test $PORT" \
+         make -C "$FULL_BUILD_PREFIX-$PORT/testsuite" SHOW_TIMINGS=1 all
+     run "install $PORT" $MAKE -C "$FULL_BUILD_PREFIX-$PORT" install
+-    if [[ $PORT = 'msvc64' ]] ; then
++    if [[ $PORT = 'mingw64' ]] ; then
+       run "$MAKE check_all_arches" \
+            $MAKE -C "$FULL_BUILD_PREFIX-$PORT" check_all_arches
+       cd "$FULL_BUILD_PREFIX-$PORT"
++
++      git config --global safe.directory '*'
++
+       # Ensure that .gitignore is up-to-date - this will fail if any untracked
+       # or altered files exist. We revert the change from the bootstrap (that
+       # would have failed the build earlier if necessary)
+@@ -181,7 +192,7 @@ case "$1" in
+   *)
+     cd "$APPVEYOR_BUILD_FOLDER/../$BUILD_PREFIX-$PORT"
+ 
+-    if [[ $PORT = 'msvc64' ]] ; then
++    if [[ $PORT = 'mingw64' ]] ; then
+       # Ensure that make distclean can be run from an empty tree
+       run "$MAKE distclean" $MAKE distclean
+     fi
+@@ -205,7 +216,7 @@ case "$1" in
+         # For an explanation of the sed command, see
+         # https://github.com/appveyor/ci/issues/1824
+         script --quiet --return --command \
+-          "$MAKE -C ../$BUILD_PREFIX-$PORT world.opt" \
++          "$MAKE -C ../$BUILD_PREFIX-$PORT" \
+           "../$BUILD_PREFIX-$PORT/build.log" |
+             sed -e 's/\d027\[K//g' \
+                 -e 's/\d027\[m/\d027[0m/g' \
diff --git a/diff-against-trunk-system.diff b/diff-against-trunk-system.diff
new file mode 100644
index 0000000000..ecaf111301
--- /dev/null
+++ b/diff-against-trunk-system.diff
@@ -0,0 +1,10036 @@
+diff --git a/.Diff-of-diff.diff b/.Diff-of-diff.diff
+new file mode 100644
+index 0000000000..e69de29bb2
+diff --git a/.gitattributes b/.gitattributes
+index c972b3bc0b..18b5a6ee4f 100644
+--- a/.gitattributes
++++ b/.gitattributes
+@@ -142,6 +142,7 @@ testsuite/tests/lib-dynlink-domains/main.ml  typo.very-long-line
+ testsuite/tests/tool-ocamltest/norm*.reference binary
+ 
+ tools/magic                       typo.missing-header
++tools/eventlog_metadata.in        typo.missing-header
+ 
+ # TODO we should fix the long-line errors in yacc/*.c
+ /yacc/*.[ch]         typo.very-long-line=may
+diff --git a/Changes b/Changes
+index 8f3bc0d100..1f916a8992 100644
+--- a/Changes
++++ b/Changes
+@@ -548,6 +548,10 @@ Working version
+   types.
+   (Chris Casinghino, review by Gabriel Scherer)
+ 
++- #12264, #12289: Fix compact_allocate to avoid a pathological case
++  that causes very slow compaction.
++  (Damien Doligez, report by Arseniy Alekseyev, review by Sadiq Jaffer)
++
+ OCaml 5.0.0 (15 December 2022)
+ ------------------------------
+ 
+@@ -1084,11 +1088,6 @@ OCaml 5.0.0 (15 December 2022)
+   (Damien Doligez, report by Thierry Martinez and Vincent Laviron, review by
+    Xavier Leroy)
+ 
+-- #11508, #11509: make Bytes.escaped domain-safe
+-  (Christiano Haesbaert and Gabriel Scherer,
+-   review by Xavier Leroy,
+-   report by Jan Midtgaard and Tom Kelly)
+-
+ - #11516, #11524: Fix the `deprecated_mutable` attribute.
+   (Chris Casinghino, review by Nicolás Ojeda Bär and Florian Angeletti)
+ 
+@@ -1117,6 +1116,30 @@ OCaml 5.0.0 (15 December 2022)
+   (Gabriel Scherer, review by Jacques Garrigue and Florian Angeletti,
+    report by Yaron Minsky)
+ 
++OCaml 4.14 maintenance branch
++-----------------------------
++
++- #11508, #11509: make Bytes.escaped domain-safe
++  (Christiano Haesbaert and Gabriel Scherer,
++   review by Xavier Leroy,
++   report by Jan Midtgaard and Tom Kelly)
++
++### Manual and documentation:
++
++- #11045, #11409: document that the array argument to `caml_callbackN`
++  must not have been declared by `CAMLlocalN`.
++  (Xavier Leroy, report by Stephen Dolan, review by Gabriel Scherer.)
++
++### Bug fixes:
++
++- #11489, #11496: More prudent deallocation of alternate signal stack
++  (Xavier Leroy, report by @rajdakin, review by Florian Angeletti)
++
++- #11768, #11788: Fix crash at start-up of bytecode programs in
++  no-naked-pointers mode caused by wrong initialization of caml_global_data
++  (Xavier Leroy, report by Etienne Millon, review by Gabriel Scherer)
++
++
+ OCaml 4.14.0 (28 March 2022)
+ ----------------------------
+ 
+@@ -1152,13 +1175,13 @@ OCaml 4.14.0 (28 March 2022)
+ - #10549: Stack overflow detection and naked pointers checking for ARM64
+   (Xavier Leroy, review by Stephen Dolan)
+ 
+-* #10675: Emit deprecation warnings when old C runtime function names
++* #10675, #10937: Emit deprecation warnings when old C runtime function names
+   are used.  This will break C stub code that uses these old names and
+   treats warnings as errors.  The workaround is to use the new names.
+   (Xavier Leroy and David Allsopp, review by Sébastien Hinderer and
+    Damien Doligez)
+ 
+-- #10698, #10726: Free the alternate signal stack when the main OCaml
++- #10698, #10726, #10891: Free the alternate signal stack when the main OCaml
+    code or an OCaml thread stops
+   (Xavier Leroy, review by David Allsopp and Damien Doligez)
+ 
+@@ -1265,6 +1288,9 @@ OCaml 4.14.0 (28 March 2022)
+ - #10464: Add List.is_empty.
+   (Craig Ferguson, review by David Allsopp)
+ 
++* #10922: Add deprecation warnings on {Int32,Int64,Nativeint}.format.
++  (Nicolás Ojeda Bär, review by Xavier Leroy and Florian Angeletti)
++
+ ### Other libraries:
+ 
+ - #10192: Add support for Unix domain sockets on Windows and use them
+@@ -1528,6 +1554,9 @@ OCaml 4.14.0 (28 March 2022)
+ 
+ ### Build system:
+ 
++- #10828 Build native-code compilers on OpenBSD/aarch64
++  (Christopher Zimmermann)
++
+ - #10835 Disable DT_TEXTREL warnings on x86 32 bit architecture by passing
+   -Wl,-z,notext in mksharedlib and mkmaindll. Fixes relocation issues, reported
+   in #9800, making local patches in Debian, Alpine, and FreeBSD superfluous.
+diff --git a/Makefile b/Makefile
+index d7ac2bcb22..5f0fa3a427 100644
+--- a/Makefile
++++ b/Makefile
+@@ -605,7 +605,6 @@ partialclean::
+ ## Lists of source files
+ 
+ runtime_COMMON_C_SOURCES = \
+-  addrmap \
+   afl \
+   alloc \
+   array \
+@@ -613,24 +612,24 @@ runtime_COMMON_C_SOURCES = \
+   bigarray \
+   callback \
+   codefrag \
++  compact \
+   compare \
+   custom \
+   debugger \
+   domain \
+   dynlink \
++  eventlog \
+   extern \
+-  fiber \
+   finalise \
+   floats \
++  freelist \
+   gc_ctrl \
+-  gc_stats \
+   globroots \
+   hash \
+   intern \
+   ints \
+   io \
+   lexing \
+-  lf_skiplist \
+   main \
+   major_gc \
+   md5 \
+@@ -641,17 +640,12 @@ runtime_COMMON_C_SOURCES = \
+   misc \
+   obj \
+   parsing \
+-  platform \
+   printexc \
+   prng \
+-  roots \
+-  runtime_events \
+-  shared_heap \
+   signals \
+   skiplist \
+   startup_aux \
+   str \
+-  sync \
+   sys \
+   $(UNIX_OR_WIN32) \
+   weak
+@@ -661,6 +655,9 @@ runtime_BYTECODE_ONLY_C_SOURCES = \
+   fail_byt \
+   fix_code \
+   interp \
++  roots_byt \
++  signals_byt \
++  stacks \
+   startup_byt
+ runtime_BYTECODE_C_SOURCES = \
+   $(runtime_COMMON_C_SOURCES:%=runtime/%.c) \
+@@ -671,7 +668,7 @@ runtime_NATIVE_ONLY_C_SOURCES = \
+   clambda_checks \
+   dynlink_nat \
+   fail_nat \
+-  frame_descriptors \
++  roots_nat \
+   startup_nat \
+   signals_nat
+ runtime_NATIVE_C_SOURCES = \
+@@ -1066,12 +1063,14 @@ clean::
+ 
+ # Dependencies
+ 
+-subdirs = stdlib $(addprefix otherlibs/, $(ALL_OTHERLIBS)) \
++subdirs = \
++  stdlib $(addprefix otherlibs/, \
++    $(filter-out runtime_events, $(ALL_OTHERLIBS))) \
+   debugger ocamldoc ocamltest
+ 
+ .PHONY: alldepend
+ alldepend: depend
+-	for dir in $(subdirs); do \
++	for dir in $(filter-out %/runtime_events, $(subdirs)); do \
+ 	  $(MAKE) -C $$dir depend || exit; \
+ 	done
+ 
+@@ -1144,6 +1143,7 @@ $(ocamlyacc_PROGRAM)$(EXE): $(ocamlyacc_OBJECTS)
+ 	$(V_MKEXE)$(MKEXE) -o $@ $^
+ 
+ clean::
++	rm -f yacc/wstr.o yacc/wstr.obj
+ 	rm -f $(ocamlyacc_MODULES:=.o) $(ocamlyacc_MODULES:=.obj)
+ 
+ $(ocamlyacc_OTHER_MODULES:=.$(O)): yacc/defs.h
+@@ -1643,6 +1643,9 @@ endif
+ 	else \
+ 	  $(INSTALL_PROG) tools/ocamlcmt$(EXE) "$(INSTALL_BINDIR)"; \
+ 	fi
++	$(INSTALL_DATA) \
++	  tools/eventlog_metadata \
++	  "$(INSTALL_LIBDIR)"
+ 	$(INSTALL_DATA) \
+ 	   utils/*.cmi \
+ 	   parsing/*.cmi \
+diff --git a/Makefile.config.in b/Makefile.config.in
+index c8d6966c40..6a1cbd16a0 100644
+--- a/Makefile.config.in
++++ b/Makefile.config.in
+@@ -243,7 +243,7 @@ FLAT_FLOAT_ARRAY=@flat_float_array@
+ FUNCTION_SECTIONS=@function_sections@
+ AWK=@AWK@
+ STDLIB_MANPAGES=@stdlib_manpages@
+-NAKED_POINTERS=false
++NAKED_POINTERS=@naked_pointers@
+ 
+ # Deprecated variables
+ 
+diff --git a/VERSION b/VERSION
+index 1443e92a84..4ef434f979 100644
+--- a/VERSION
++++ b/VERSION
+@@ -1,4 +1,4 @@
+-5.1.0+dev1-2022-06-09
++5.0.0+jst-backport
+ 
+ # Starting with OCaml 4.14, although the version string that appears above is
+ # still correct and this file can thus still be used to figure it out,
+diff --git a/api_docgen/Makefile.docfiles b/api_docgen/Makefile.docfiles
+index ce0406e3d8..20f7595c89 100644
+--- a/api_docgen/Makefile.docfiles
++++ b/api_docgen/Makefile.docfiles
+@@ -31,7 +31,8 @@ str_MLIS := str.mli
+ unix_MLIS := unix.mli unixLabels.mli
+ dynlink_MLIS := dynlink.mli
+ thread_MLIS := \
+-  thread.mli event.mli
++  thread.mli condition.mli mutex.mli event.mli \
++  semaphore.mli
+ 
+ STDLIB=$(STDLIB_MODULES)
+ 
+diff --git a/asmcomp/amd64/emit.mlp b/asmcomp/amd64/emit.mlp
+index e2da778605..061e684bdc 100644
+--- a/asmcomp/amd64/emit.mlp
++++ b/asmcomp/amd64/emit.mlp
+@@ -62,6 +62,7 @@ let cfi_endproc () =
+ let cfi_adjust_cfa_offset n =
+   if Config.asm_cfi_supported then D.cfi_adjust_cfa_offset n
+ 
++(* BACKPORT
+ let cfi_remember_state () =
+   if Config.asm_cfi_supported then D.cfi_remember_state ()
+ 
+@@ -70,13 +71,16 @@ let cfi_restore_state () =
+ 
+ let cfi_def_cfa_register reg =
+   if Config.asm_cfi_supported then D.cfi_def_cfa_register reg
++*)
+ 
+ let emit_debug_info dbg =
+   emit_debug_info_gen dbg D.file D.loc
+ 
+ let fp = Config.with_frame_pointers
+ 
++(* BACKPORT
+ let stack_threshold_size = Config.stack_threshold * 8 (* bytes *)
++*)
+ 
+ let frame_size env =                     (* includes return address *)
+   if env.f.fun_frame_required then begin
+@@ -535,8 +539,9 @@ let emit_instr env fallthrough i =
+           end
+         end
+       end
+-  | Lop(Iextcall { func; alloc; stack_ofs }) ->
++  | Lop(Iextcall { func; alloc; stack_ofs = _ }) ->
+       add_used_symbol func;
++(* BACKPORT
+       let base_stack_size =
+         if Arch.win64 then
+           32 (* Windows x64 rcx+rdx+r8+r9 shadow stack *)
+@@ -548,11 +553,26 @@ let emit_instr env fallthrough i =
+         load_symbol_addr func rax;
+         emit_call "caml_c_call_stack_args";
+         record_frame env i.live (Dbg_other i.dbg);
+-      end else if alloc then begin
++      end else*) if alloc then begin
+         load_symbol_addr func rax;
+         emit_call "caml_c_call";
+         record_frame env i.live (Dbg_other i.dbg);
++(* BACKPORT BEGIN *)
++        if system <> S_win64 then begin
++
++          (* In amd64.S, "caml_c_call" tail-calls the C function (in order to
++             produce nicer backtraces), so we need to restore r15 manually after
++             it returns (note that this increases code size).
++
++             In amd64nt.asm (used for Win64), "caml_c_call" invokes the C
++             function via a regular call, and restores r15 itself, thus avoiding
++             the code size increase. *)
++
++          I.mov (domain_field Domainstate.Domain_young_ptr) r15
++        end
++(* BACKPORT END *)
+       end else begin
++(* BACKPORT
+         I.mov rsp rbx;
+         cfi_remember_state ();
+         cfi_def_cfa_register "rbx";
+@@ -560,10 +580,12 @@ let emit_instr env fallthrough i =
+            will not unwind through this unless we were to tag this
+            calling frame with cfi_signal_frame in it's definition. *)
+         I.mov (domain_field Domainstate.Domain_c_stack) rsp;
+-
++*)
+         emit_call func;
++(* BACKPORT
+         I.mov rbx rsp;
+         cfi_restore_state ();
++*)
+       end
+   | Lop(Istackoffset n) ->
+       if n < 0
+@@ -746,7 +768,10 @@ let emit_instr env fallthrough i =
+   | Lop(Ispecific(Izextend32)) ->
+       I.mov (arg32 i 0) (res32 i 0)
+   | Lop (Idls_get) ->
++      assert false
++(* BACKPORT
+       I.mov (domain_field Domainstate.Domain_dls_root) (res i 0)
++*)
+   | Lreloadretaddr ->
+       ()
+   | Lreturn ->
+@@ -850,12 +875,24 @@ let emit_instr env fallthrough i =
+       load_label_addr lbl_handler r11;
+       I.push r11;
+       cfi_adjust_cfa_offset 8;
++(* BACKPORT BEGIN
+       I.push (domain_field Domainstate.Domain_exn_handler);
++*)
++      I.push (domain_field Domainstate.Domain_exception_pointer);
++(* BACKPORT END *)
+       cfi_adjust_cfa_offset 8;
++(* BACKPORT BEGIN
+       I.mov rsp (domain_field Domainstate.Domain_exn_handler);
++*)
++      I.mov rsp (domain_field Domainstate.Domain_exception_pointer);
++(* BACKPORT END *)
+       env.stack_offset <- env.stack_offset + 16;
+   | Lpoptrap ->
++(* BACKPORT BEGIN
+       I.pop (domain_field Domainstate.Domain_exn_handler);
++*)
++      I.pop (domain_field Domainstate.Domain_exception_pointer);
++(* BACKPORT END *)
+       cfi_adjust_cfa_offset (-8);
+       I.add (int 8) rsp;
+       cfi_adjust_cfa_offset (-8);
+@@ -863,14 +900,26 @@ let emit_instr env fallthrough i =
+   | Lraise k ->
+       begin match k with
+       | Lambda.Raise_regular ->
++(* BACKPORT BEGIN *)
++          I.mov (int 0) (domain_field Domainstate.Domain_backtrace_pos);
++(* BACKPORT END *)
+           emit_call "caml_raise_exn";
+           record_frame env Reg.Set.empty (Dbg_raise i.dbg)
+       | Lambda.Raise_reraise ->
++(* BACKPORT BEGIN
+           emit_call "caml_reraise_exn";
++*)
++          emit_call "caml_raise_exn";
++(* BACKPORT END *)
+           record_frame env Reg.Set.empty (Dbg_raise i.dbg)
+       | Lambda.Raise_notrace ->
++(* BACKPORT BEGIN
+           I.mov (domain_field Domainstate.Domain_exn_handler) rsp;
+           I.pop (domain_field Domainstate.Domain_exn_handler);
++*)
++          I.mov (domain_field Domainstate.Domain_exception_pointer) rsp;
++          I.pop (domain_field Domainstate.Domain_exception_pointer);
++(* BACKPORT END *)
+           I.pop r11;
+           I.jmp r11
+       end
+@@ -903,6 +952,7 @@ let fundecl fundecl =
+   D.label (emit_symbol fundecl.fun_name);
+   emit_debug_info fundecl.fun_dbg;
+   cfi_startproc ();
++(* BACKPORT
+   if !Clflags.runtime_variant = "d" then
+     emit_call "caml_assert_stack_invariants";
+   let { max_frame_size; contains_nontail_calls} =
+@@ -920,9 +970,11 @@ let fundecl fundecl =
+       Some (overflow, ret)
+     end else None
+   in
++*)
+   emit_all env true fundecl.fun_body;
+   List.iter emit_call_gc env.call_gc_sites;
+   emit_call_bound_errors env;
++(* BACKPORT
+   begin match handle_overflow with
+   | None -> ()
+   | Some (overflow,ret) -> begin
+@@ -939,6 +991,7 @@ let fundecl fundecl =
+       I.jmp (label ret)
+     end
+   end;
++*)
+   if fundecl.fun_frame_required then begin
+     let n = (frame_size env) - 8 - (if fp then 8 else 0) in
+     if n <> 0
+diff --git a/asmcomp/amd64/proc.ml b/asmcomp/amd64/proc.ml
+index 56377b322c..f3453793cc 100644
+--- a/asmcomp/amd64/proc.ml
++++ b/asmcomp/amd64/proc.ml
+@@ -293,12 +293,20 @@ let destroyed_at_c_call =
+   if win64 then
+     (* Win64: rbx, rsi, rdi, r12-r15, xmm6-xmm15 preserved *)
+     Array.of_list(List.map phys_reg
++(* BACKPORT BEGIN
+       [0;4;5;6;7;10;11;12;
++*)
++      [0;4;5;6;7;10;11;
++(* BACKPORT END *)
+        100;101;102;103;104;105])
+   else
+     (* Unix: rbx, r12-r15 preserved *)
+     Array.of_list(List.map phys_reg
++(* BACKPORT BEGIN
+       [0;1;2;3;4;5;6;7;10;11;
++*)
++      [0;2;3;4;5;6;7;10;11;
++(* BACKPORT END *)
+        100;101;102;103;104;105;106;107;
+        108;109;110;111;112;113;114;115])
+ 
+diff --git a/asmcomp/arm64/emit.mlp b/asmcomp/arm64/emit.mlp
+index a0c9f62442..f335149b20 100644
+--- a/asmcomp/arm64/emit.mlp
++++ b/asmcomp/arm64/emit.mlp
+@@ -34,8 +34,10 @@ let reg_trap_ptr = phys_reg 23 (* x26 *)
+ let reg_alloc_ptr = phys_reg 24 (* x27 *)
+ let reg_tmp1 = phys_reg 26 (* x16 *)
+ let reg_x8 = phys_reg 8 (* x8 *)
++(* BACKPORT
+ let reg_stack_arg_begin = phys_reg 17  (* x20 *)
+ let reg_stack_arg_end  = phys_reg 18 (* x21 *)
++*)
+ 
+ (* Output a label *)
+ 
+@@ -461,24 +463,38 @@ module BR = Branch_relaxation.Make (struct
+     | Lop (Itailcall_ind) -> epilogue_size f
+     | Lop (Itailcall_imm { func; _ }) ->
+       if func = f.fun_name then 1 else epilogue_size f
+-    | Lop (Iextcall {alloc; stack_ofs} ) ->
++    | Lop (Iextcall {alloc; stack_ofs = _} ) ->
++(* BACKPORT
+       if stack_ofs > 0 then 5
+-      else if alloc then 3
++      else*) if alloc then 3
++(* BACKPORT BEGIN
+       else 5
++*)
++      else 1
++(* BACKPORT END *)
+     | Lop (Istackoffset _) -> 2
++(* BACKPORT BEGIN
+     | Lop (Iload  { memory_chunk; addressing_mode; is_atomic }) ->
+       let based = match addressing_mode with Iindexed _ -> 0 | Ibased _ -> 1
+       and barrier = if is_atomic then 1 else 0
+       and single = match memory_chunk with Single -> 2 | _ -> 1 in
+       based + barrier + single
+     | Lop (Istore (memory_chunk, addressing_mode, assignment)) ->
++*)
++    | Lop (Iload  { memory_chunk; addressing_mode })
++    | Lop (Istore (memory_chunk, addressing_mode, _)) ->
++(* BACKPORT END *)
+       let based = match addressing_mode with Iindexed _ -> 0 | Ibased _ -> 1
++      in
++      based + begin match memory_chunk with Single -> 2 | _ -> 1 end
++(* BACKPORT
+       and barrier =
+         match memory_chunk, assignment with
+         | (Word_int | Word_val), true -> 1
+         | _ -> 0
+       and single = match memory_chunk with Single -> 2 | _ -> 1 in
+       based + barrier + single
++*)
+     | Lop (Ialloc _) when f.fun_fast -> 5
+     | Lop (Ispecific (Ifar_alloc _)) when f.fun_fast -> 6
+     | Lop (Ipoll _) -> 3
+@@ -538,7 +554,11 @@ module BR = Branch_relaxation.Make (struct
+     | Lpoptrap -> 1
+     | Lraise k ->
+       begin match k with
++(* BACKPORT BEGIN
+       | Lambda.Raise_regular -> 1
++*)
++      | Lambda.Raise_regular -> 2
++(* BACKPORT END *)
+       | Lambda.Raise_reraise -> 1
+       | Lambda.Raise_notrace -> 4
+       end
+@@ -739,7 +759,8 @@ let emit_instr env i =
+           `	b	{emit_label env.f.fun_tailrec_entry_point_label}\n`
+         else
+           output_epilogue env (fun () -> `	b	{emit_symbol func}\n`)
+-    | Lop(Iextcall {func; alloc; stack_ofs}) ->
++    | Lop(Iextcall {func; alloc; stack_ofs = _}) ->
++(* BACKPORT BEGIN
+         if stack_ofs > 0 then begin
+           `	mov	{emit_reg reg_stack_arg_begin}, sp\n`;
+           `	add	{emit_reg reg_stack_arg_end}, sp, #{emit_int (Misc.align stack_ofs 16)}\n`;
+@@ -747,9 +768,18 @@ let emit_instr env i =
+           `	bl	{emit_symbol "caml_c_call_stack_args"}\n`;
+           `{record_frame env i.live (Dbg_other i.dbg)}\n`
+         end else if alloc then begin
++*)
++        if not alloc then
++        `	bl	{emit_symbol func}\n`
++        else begin
++(* BACKPORT END *)
+           emit_load_symbol_addr reg_x8 func;
+           `	bl	{emit_symbol "caml_c_call"}\n`;
+           `{record_frame env i.live (Dbg_other i.dbg)}\n`
++(* BACKPORT BEGIN *)
++        end
++(* BACKPORT END *)
++(* BACKPORT
+         end else begin
+           (* store ocaml stack in the frame pointer register
+              NB: no need to store previous x29 because OCaml frames don't
+@@ -764,6 +794,7 @@ let emit_instr env i =
+           `	mov	sp, x29\n`;
+           cfi_restore_state ()
+         end
++*)
+     | Lop(Istackoffset n) ->
+         assert (n mod 16 = 0);
+         emit_stack_adjustment (-n);
+@@ -804,7 +835,11 @@ let emit_instr env i =
+         | Double ->
+             `	ldr	{emit_reg dst}, {emit_addressing addressing_mode base}\n`
+         end
++(* BACKPORT BEGIN
+     | Lop(Istore(size, addr, assignment)) ->
++*)
++    | Lop(Istore(size, addr, _)) ->
++(* BACKPORT END *)
+         (* NB: assignments other than Word_int and Word_val do not follow the
+         Multicore OCaml memory model and so do not emit a barrier *)
+         let src = i.arg.(0) in
+@@ -827,7 +862,10 @@ let emit_instr env i =
+             `	str	s7, {emit_addressing addr base}\n`;
+         | Word_int | Word_val ->
+             (* memory model barrier for non-initializing store *)
++(* BACKPORT
++            if assignment then ` dmb ishld\n`;
+             if assignment then `	dmb	ishld\n`;
++*)
+             `	str	{emit_reg src}, {emit_addressing addr base}\n`
+         | Double ->
+             `	str	{emit_reg src}, {emit_addressing addr base}\n`
+@@ -956,8 +994,13 @@ let emit_instr env i =
+     | Lop(Ispecific(Isignext size)) ->
+         `	sbfm	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, #0, #{emit_int (size - 1)}\n`
+     | Lop(Idls_get) ->
++(* BACKPORT BEGIN *)
++        assert false
++(* BACKPORT END *)
++(* BACKPORT
+         let offset = Domainstate.(idx_of_field Domain_dls_root) * 8 in
+         `	ldr	{emit_reg i.res.(0)}, [{emit_reg reg_domain_state_ptr}, {emit_int offset}]\n`
++*)
+     | Lreloadretaddr ->
+         ()
+     | Lreturn ->
+@@ -1044,10 +1087,18 @@ let emit_instr env i =
+     | Lraise k ->
+         begin match k with
+         | Lambda.Raise_regular ->
++(* BACKPORT BEGIN *)
++          let offset = Domainstate.(idx_of_field Domain_backtrace_pos) * 8 in
++          `	str	xzr, [{emit_reg reg_domain_state_ptr}, {emit_int offset}]\n`;
++(* BACKPORT END *)
+           `	bl	{emit_symbol "caml_raise_exn"}\n`;
+           `{record_frame env Reg.Set.empty (Dbg_raise i.dbg)}\n`
+         | Lambda.Raise_reraise ->
++(* BACKPORT BEGIN
+           `	bl	{emit_symbol "caml_reraise_exn"}\n`;
++*)
++          `	bl	{emit_symbol "caml_raise_exn"}\n`;
++(* BACKPORT END *)
+           `{record_frame env Reg.Set.empty (Dbg_raise i.dbg)}\n`
+         | Lambda.Raise_notrace ->
+           `	mov	sp, {emit_reg reg_trap_ptr}\n`;
+@@ -1076,6 +1127,7 @@ let fundecl fundecl =
+     num_call_gc_and_check_bound_points env
+   in
+ 
++(* BACKPORT
+   (* Dynamic stack checking *)
+   let stack_threshold_size = Config.stack_threshold * 8 in (* bytes *)
+   let { max_frame_size; contains_nontail_calls} =
+@@ -1096,9 +1148,12 @@ let fundecl fundecl =
+       Some (overflow, ret), 5
+     end else None, 0
+   in
++*)
+ 
+   let max_out_of_line_code_offset =
++(* BACKPORT
+     stack_check_size +
++*)
+     max_out_of_line_code_offset ~num_call_gc
+       ~num_check_bound
+   in
+@@ -1111,6 +1166,7 @@ let fundecl fundecl =
+   assert (List.length env.call_gc_sites = num_call_gc);
+   assert (List.length env.bound_error_sites = num_check_bound);
+ 
++(* BACKPORT
+   begin match handle_overflow with
+   | None -> ()
+   | Some (overflow,ret) -> begin
+@@ -1125,6 +1181,7 @@ let fundecl fundecl =
+       `	b	{emit_label ret}\n`
+     end
+   end;
++*)
+ 
+   cfi_endproc();
+   emit_symbol_type emit_symbol fundecl.fun_name "function";
+diff --git a/asmcomp/asmlink.ml b/asmcomp/asmlink.ml
+index 7021f8c3d1..a10abb9502 100644
+--- a/asmcomp/asmlink.ml
++++ b/asmcomp/asmlink.ml
+@@ -236,7 +236,11 @@ let make_startup_file ~ppf_dump units_list ~crc_interfaces =
+   compile_phrase (Cmm_helpers.entry_point name_list);
+   let units = List.map (fun (info,_,_) -> info) units_list in
+   List.iter compile_phrase
++(* BACKPORT BEGIN
+     (Cmm_helpers.emit_preallocated_blocks [] (* add gc_roots (for dynlink) *)
++*)
++    (
++(* BACKPORT END *)
+       (Cmm_helpers.generic_functions false units));
+   Array.iteri
+     (fun i name -> compile_phrase (Cmm_helpers.predef_exception i name))
+@@ -262,7 +266,11 @@ let make_shared_startup_file ~ppf_dump units =
+   Compilenv.reset "_shared_startup";
+   Emit.begin_assembly ();
+   List.iter compile_phrase
++(* BACKPORT BEGIN
+     (Cmm_helpers.emit_preallocated_blocks [] (* add gc_roots (for dynlink) *)
++*)
++    (
++(* BACKPORT END *)
+       (Cmm_helpers.generic_functions true (List.map fst units)));
+   compile_phrase (Cmm_helpers.plugin_header units);
+   compile_phrase
+diff --git a/asmcomp/cmm_helpers.ml b/asmcomp/cmm_helpers.ml
+index ca57632f4a..567dba44cc 100644
+--- a/asmcomp/cmm_helpers.ml
++++ b/asmcomp/cmm_helpers.ml
+@@ -813,7 +813,11 @@ let make_alloc_generic set_fn dbg tag wordsize args =
+     | e1::el -> Csequence(set_fn (Cvar id) (Cconst_int (idx, dbg)) e1 dbg,
+                           fill_fields (idx + 2) el) in
+     Clet(VP.create id,
++(* BACKPORT BEGIN
+          Cop(Cextcall("caml_alloc_shr_check_gc", typ_val, [], true),
++*)
++         Cop(Cextcall("caml_alloc", typ_val, [], true),
++(* BACKPORT END *)
+                  [Cconst_int (wordsize, dbg); Cconst_int (tag, dbg)], dbg),
+          fill_fields 1 args)
+   end
+@@ -2113,8 +2117,13 @@ let assignment_kind
+     (init: Lambda.initialization_or_assignment) =
+   match init, ptr with
+   | Assignment, Pointer -> Caml_modify
++(* BACKPORT BEGIN
+   | Heap_initialization, Pointer
+   | Root_initialization, Pointer -> Caml_initialize
++*)
++  | Heap_initialization, Pointer -> Caml_initialize
++  | Root_initialization, Pointer -> Simple
++(* BACKPORT END *)
+   | Assignment, Immediate
+   | Heap_initialization, Immediate
+   | Root_initialization, Immediate -> Simple
+diff --git a/asmcomp/riscv/emit.mlp b/asmcomp/riscv/emit.mlp
+index bcc9d12947..5252fa4473 100644
+--- a/asmcomp/riscv/emit.mlp
++++ b/asmcomp/riscv/emit.mlp
+@@ -343,8 +343,10 @@ let emit_instr env i =
+         `	mv	s0, sp\n`;
+         cfi_remember_state ();
+         cfi_def_cfa_register ~reg:21;
++(* BACKPORT
+         let ofs = Domainstate.(idx_of_field Domain_c_stack) * 8 in
+         `	ld	sp, {emit_int ofs}({emit_reg reg_domain_state_ptr})\n`;
++*)
+         `	{emit_call func}\n`;
+         `	mv	sp, s0\n`;
+         cfi_restore_state ()
+@@ -500,8 +502,12 @@ let emit_instr env i =
+       let instr = name_for_specific sop in
+       `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(2)}\n`
+   | Lop (Idls_get) ->
++(* BACKPORT BEGIN
+       let ofs = Domainstate.(idx_of_field Domain_dls_root) * 8 in
+       `	ld	{emit_reg i.res.(0)}, {emit_int ofs}({emit_reg reg_domain_state_ptr})\n`
++*)
++      assert false
++(* BACKPORT END *)
+   | Lreloadretaddr ->
+       let n = frame_size env in
+       reload_ra n
+@@ -623,6 +629,7 @@ let fundecl fundecl =
+   emit_debug_info fundecl.fun_dbg;
+   cfi_startproc();
+ 
++(* BACKPORT
+   (* Dynamic stack checking *)
+   let stack_threshold_size = Config.stack_threshold * 8 in (* bytes *)
+   let { max_frame_size; contains_nontail_calls } =
+@@ -642,11 +649,13 @@ let fundecl fundecl =
+       Some (overflow, ret)
+     end else None
+   in
++*)
+ 
+   emit_all env fundecl.fun_body;
+   List.iter emit_call_gc env.call_gc_sites;
+   List.iter emit_call_bound_error env.bound_error_sites;
+ 
++(* BACKPORT
+   begin match handle_overflow with
+   | None -> ()
+   | Some (overflow, ret) ->
+@@ -663,6 +672,7 @@ let fundecl fundecl =
+       `	addi	sp, sp, 16\n`;
+       `	j	{emit_label ret}\n`
+   end;
++*)
+ 
+   cfi_endproc();
+   `	.size	{emit_symbol fundecl.fun_name}, .-{emit_symbol fundecl.fun_name}\n`;
+diff --git a/boot/ocamlc b/boot/ocamlc
+index 941a1d3bb4..a6a755d449 100755
+Binary files a/boot/ocamlc and b/boot/ocamlc differ
+diff --git a/boot/ocamllex b/boot/ocamllex
+index d247b24d65..5262c62a0a 100755
+Binary files a/boot/ocamllex and b/boot/ocamllex differ
+diff --git a/build-aux/config.guess b/build-aux/config.guess
+index e94095c5fb..b187213930 100755
+--- a/build-aux/config.guess
++++ b/build-aux/config.guess
+@@ -1,12 +1,14 @@
+ #! /bin/sh
+ # Attempt to guess a canonical system name.
+-#   Copyright 1992-2020 Free Software Foundation, Inc.
++#   Copyright 1992-2023 Free Software Foundation, Inc.
+ 
+-timestamp='2020-07-12'
++# shellcheck disable=SC2006,SC2268 # see below for rationale
++
++timestamp='2023-07-20'
+ 
+ # This file is free software; you can redistribute it and/or modify it
+ # under the terms of the GNU General Public License as published by
+-# the Free Software Foundation; either version 3 of the License, or
++# the Free Software Foundation, either version 3 of the License, or
+ # (at your option) any later version.
+ #
+ # This program is distributed in the hope that it will be useful, but
+@@ -27,17 +29,25 @@ timestamp='2020-07-12'
+ # Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
+ #
+ # You can get the latest version of this script from:
+-# https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
++# https://git.savannah.gnu.org/cgit/config.git/plain/config.guess
+ #
+ # Please send patches to <config-patches@gnu.org>.
+ 
+ 
++# The "shellcheck disable" line above the timestamp inhibits complaints
++# about features and limitations of the classic Bourne shell that were
++# superseded or lifted in POSIX.  However, this script identifies a wide
++# variety of pre-POSIX systems that do not have POSIX shells at all, and
++# even some reasonably current systems (Solaris 10 as case-in-point) still
++# have a pre-POSIX /bin/sh.
++
++
+ me=`echo "$0" | sed -e 's,.*/,,'`
+ 
+ usage="\
+ Usage: $0 [OPTION]
+ 
+-Output the configuration name of the system \`$me' is run on.
++Output the configuration name of the system '$me' is run on.
+ 
+ Options:
+   -h, --help         print this help, then exit
+@@ -50,13 +60,13 @@ version="\
+ GNU config.guess ($timestamp)
+ 
+ Originally written by Per Bothner.
+-Copyright 1992-2020 Free Software Foundation, Inc.
++Copyright 1992-2023 Free Software Foundation, Inc.
+ 
+ This is free software; see the source for copying conditions.  There is NO
+ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+ 
+ help="
+-Try \`$me --help' for more information."
++Try '$me --help' for more information."
+ 
+ # Parse command line
+ while test $# -gt 0 ; do
+@@ -84,13 +94,16 @@ if test $# != 0; then
+   exit 1
+ fi
+ 
++# Just in case it came from the environment.
++GUESS=
++
+ # CC_FOR_BUILD -- compiler used by this script. Note that the use of a
+ # compiler to aid in system detection is discouraged as it requires
+ # temporary files to be created and, as you can see below, it is a
+ # headache to deal with in a portable fashion.
+ 
+-# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
+-# use `HOST_CC' if defined, but it is deprecated.
++# Historically, 'CC_FOR_BUILD' used to be named 'HOST_CC'. We still
++# use 'HOST_CC' if defined, but it is deprecated.
+ 
+ # Portable tmp directory creation inspired by the Autoconf team.
+ 
+@@ -102,7 +115,7 @@ set_cc_for_build() {
+     # prevent multiple calls if $tmp is already set
+     test "$tmp" && return 0
+     : "${TMPDIR=/tmp}"
+-    # shellcheck disable=SC2039
++    # shellcheck disable=SC2039,SC3028
+     { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+ 	{ test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir "$tmp" 2>/dev/null) ; } ||
+ 	{ tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir "$tmp" 2>/dev/null) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+@@ -112,7 +125,7 @@ set_cc_for_build() {
+ 	,,)    echo "int x;" > "$dummy.c"
+ 	       for driver in cc gcc c89 c99 ; do
+ 		   if ($driver -c -o "$dummy.o" "$dummy.c") >/dev/null 2>&1 ; then
+-		       CC_FOR_BUILD="$driver"
++		       CC_FOR_BUILD=$driver
+ 		       break
+ 		   fi
+ 	       done
+@@ -133,14 +146,12 @@ fi
+ 
+ UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+ UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+-UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
++UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown
+ UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+ 
+-case "$UNAME_SYSTEM" in
++case $UNAME_SYSTEM in
+ Linux|GNU|GNU/*)
+-	# If the system lacks a compiler, then just pick glibc.
+-	# We could probably try harder.
+-	LIBC=gnu
++	LIBC=unknown
+ 
+ 	set_cc_for_build
+ 	cat <<-EOF > "$dummy.c"
+@@ -149,24 +160,37 @@ Linux|GNU|GNU/*)
+ 	LIBC=uclibc
+ 	#elif defined(__dietlibc__)
+ 	LIBC=dietlibc
+-	#else
++	#elif defined(__GLIBC__)
+ 	LIBC=gnu
++	#else
++	#include <stdarg.h>
++	/* First heuristic to detect musl libc.  */
++	#ifdef __DEFINED_va_list
++	LIBC=musl
++	#endif
+ 	#endif
+ 	EOF
+-	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`"
++	cc_set_libc=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
++	eval "$cc_set_libc"
+ 
+-	# If ldd exists, use it to detect musl libc.
+-	if command -v ldd >/dev/null && \
+-		ldd --version 2>&1 | grep -q ^musl
+-	then
+-	    LIBC=musl
++	# Second heuristic to detect musl libc.
++	if [ "$LIBC" = unknown ] &&
++	   command -v ldd >/dev/null &&
++	   ldd --version 2>&1 | grep -q ^musl; then
++		LIBC=musl
++	fi
++
++	# If the system lacks a compiler, then just pick glibc.
++	# We could probably try harder.
++	if [ "$LIBC" = unknown ]; then
++		LIBC=gnu
+ 	fi
+ 	;;
+ esac
+ 
+ # Note: order is significant - the case branches are not exclusive.
+ 
+-case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
++case $UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION in
+     *:NetBSD:*:*)
+ 	# NetBSD (nbsd) targets should (where applicable) match one or
+ 	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
+@@ -178,12 +202,12 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
+ 	#
+ 	# Note: NetBSD doesn't particularly care about the vendor
+ 	# portion of the name.  We always set it to "unknown".
+-	sysctl="sysctl -n hw.machine_arch"
+ 	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
+-	    "/sbin/$sysctl" 2>/dev/null || \
+-	    "/usr/sbin/$sysctl" 2>/dev/null || \
++	    /sbin/sysctl -n hw.machine_arch 2>/dev/null || \
++	    /usr/sbin/sysctl -n hw.machine_arch 2>/dev/null || \
+ 	    echo unknown)`
+-	case "$UNAME_MACHINE_ARCH" in
++	case $UNAME_MACHINE_ARCH in
++	    aarch64eb) machine=aarch64_be-unknown ;;
+ 	    armeb) machine=armeb-unknown ;;
+ 	    arm*) machine=arm-unknown ;;
+ 	    sh3el) machine=shl-unknown ;;
+@@ -192,13 +216,13 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
+ 	    earmv*)
+ 		arch=`echo "$UNAME_MACHINE_ARCH" | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
+ 		endian=`echo "$UNAME_MACHINE_ARCH" | sed -ne 's,^.*\(eb\)$,\1,p'`
+-		machine="${arch}${endian}"-unknown
++		machine=${arch}${endian}-unknown
+ 		;;
+-	    *) machine="$UNAME_MACHINE_ARCH"-unknown ;;
++	    *) machine=$UNAME_MACHINE_ARCH-unknown ;;
+ 	esac
+ 	# The Operating System including object format, if it has switched
+ 	# to ELF recently (or will in the future) and ABI.
+-	case "$UNAME_MACHINE_ARCH" in
++	case $UNAME_MACHINE_ARCH in
+ 	    earm*)
+ 		os=netbsdelf
+ 		;;
+@@ -219,7 +243,7 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
+ 		;;
+ 	esac
+ 	# Determine ABI tags.
+-	case "$UNAME_MACHINE_ARCH" in
++	case $UNAME_MACHINE_ARCH in
+ 	    earm*)
+ 		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
+ 		abi=`echo "$UNAME_MACHINE_ARCH" | sed -e "$expr"`
+@@ -230,7 +254,7 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
+ 	# thus, need a distinct triplet. However, they do not need
+ 	# kernel version information, so it can be replaced with a
+ 	# suitable tag, in the style of linux-gnu.
+-	case "$UNAME_VERSION" in
++	case $UNAME_VERSION in
+ 	    Debian*)
+ 		release='-gnu'
+ 		;;
+@@ -241,51 +265,57 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
+ 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
+ 	# contains redundant information, the shorter form:
+ 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
+-	echo "$machine-${os}${release}${abi-}"
+-	exit ;;
++	GUESS=$machine-${os}${release}${abi-}
++	;;
+     *:Bitrig:*:*)
+ 	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+-	echo "$UNAME_MACHINE_ARCH"-unknown-bitrig"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=$UNAME_MACHINE_ARCH-unknown-bitrig$UNAME_RELEASE
++	;;
+     *:OpenBSD:*:*)
+ 	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+-	echo "$UNAME_MACHINE_ARCH"-unknown-openbsd"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=$UNAME_MACHINE_ARCH-unknown-openbsd$UNAME_RELEASE
++	;;
++    *:SecBSD:*:*)
++	UNAME_MACHINE_ARCH=`arch | sed 's/SecBSD.//'`
++	GUESS=$UNAME_MACHINE_ARCH-unknown-secbsd$UNAME_RELEASE
++	;;
+     *:LibertyBSD:*:*)
+ 	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
+-	echo "$UNAME_MACHINE_ARCH"-unknown-libertybsd"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=$UNAME_MACHINE_ARCH-unknown-libertybsd$UNAME_RELEASE
++	;;
+     *:MidnightBSD:*:*)
+-	echo "$UNAME_MACHINE"-unknown-midnightbsd"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-midnightbsd$UNAME_RELEASE
++	;;
+     *:ekkoBSD:*:*)
+-	echo "$UNAME_MACHINE"-unknown-ekkobsd"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-ekkobsd$UNAME_RELEASE
++	;;
+     *:SolidBSD:*:*)
+-	echo "$UNAME_MACHINE"-unknown-solidbsd"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-solidbsd$UNAME_RELEASE
++	;;
+     *:OS108:*:*)
+-	echo "$UNAME_MACHINE"-unknown-os108_"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-os108_$UNAME_RELEASE
++	;;
+     macppc:MirBSD:*:*)
+-	echo powerpc-unknown-mirbsd"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=powerpc-unknown-mirbsd$UNAME_RELEASE
++	;;
+     *:MirBSD:*:*)
+-	echo "$UNAME_MACHINE"-unknown-mirbsd"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-mirbsd$UNAME_RELEASE
++	;;
+     *:Sortix:*:*)
+-	echo "$UNAME_MACHINE"-unknown-sortix
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-sortix
++	;;
+     *:Twizzler:*:*)
+-	echo "$UNAME_MACHINE"-unknown-twizzler
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-twizzler
++	;;
+     *:Redox:*:*)
+-	echo "$UNAME_MACHINE"-unknown-redox
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-redox
++	;;
+     mips:OSF1:*.*)
+-	echo mips-dec-osf1
+-	exit ;;
++	GUESS=mips-dec-osf1
++	;;
+     alpha:OSF1:*:*)
++	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
++	trap '' 0
+ 	case $UNAME_RELEASE in
+ 	*4.0)
+ 		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+@@ -299,7 +329,7 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
+ 	# covers most systems running today.  This code pipes the CPU
+ 	# types through head -n 1, so we only detect the type of CPU 0.
+ 	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+-	case "$ALPHA_CPU_TYPE" in
++	case $ALPHA_CPU_TYPE in
+ 	    "EV4 (21064)")
+ 		UNAME_MACHINE=alpha ;;
+ 	    "EV4.5 (21064)")
+@@ -336,117 +366,121 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
+ 	# A Tn.n version is a released field test version.
+ 	# A Xn.n version is an unreleased experimental baselevel.
+ 	# 1.2 uses "1.2" for uname -r.
+-	echo "$UNAME_MACHINE"-dec-osf"`echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`"
+-	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
+-	exitcode=$?
+-	trap '' 0
+-	exit $exitcode ;;
++	OSF_REL=`echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
++	GUESS=$UNAME_MACHINE-dec-osf$OSF_REL
++	;;
+     Amiga*:UNIX_System_V:4.0:*)
+-	echo m68k-unknown-sysv4
+-	exit ;;
++	GUESS=m68k-unknown-sysv4
++	;;
+     *:[Aa]miga[Oo][Ss]:*:*)
+-	echo "$UNAME_MACHINE"-unknown-amigaos
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-amigaos
++	;;
+     *:[Mm]orph[Oo][Ss]:*:*)
+-	echo "$UNAME_MACHINE"-unknown-morphos
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-morphos
++	;;
+     *:OS/390:*:*)
+-	echo i370-ibm-openedition
+-	exit ;;
++	GUESS=i370-ibm-openedition
++	;;
+     *:z/VM:*:*)
+-	echo s390-ibm-zvmoe
+-	exit ;;
++	GUESS=s390-ibm-zvmoe
++	;;
+     *:OS400:*:*)
+-	echo powerpc-ibm-os400
+-	exit ;;
++	GUESS=powerpc-ibm-os400
++	;;
+     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
+-	echo arm-acorn-riscix"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=arm-acorn-riscix$UNAME_RELEASE
++	;;
+     arm*:riscos:*:*|arm*:RISCOS:*:*)
+-	echo arm-unknown-riscos
+-	exit ;;
++	GUESS=arm-unknown-riscos
++	;;
+     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
+-	echo hppa1.1-hitachi-hiuxmpp
+-	exit ;;
++	GUESS=hppa1.1-hitachi-hiuxmpp
++	;;
+     Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
+ 	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
+-	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+-		echo pyramid-pyramid-sysv3
+-	else
+-		echo pyramid-pyramid-bsd
+-	fi
+-	exit ;;
++	case `(/bin/universe) 2>/dev/null` in
++	    att) GUESS=pyramid-pyramid-sysv3 ;;
++	    *)   GUESS=pyramid-pyramid-bsd   ;;
++	esac
++	;;
+     NILE*:*:*:dcosx)
+-	echo pyramid-pyramid-svr4
+-	exit ;;
++	GUESS=pyramid-pyramid-svr4
++	;;
+     DRS?6000:unix:4.0:6*)
+-	echo sparc-icl-nx6
+-	exit ;;
++	GUESS=sparc-icl-nx6
++	;;
+     DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
+ 	case `/usr/bin/uname -p` in
+-	    sparc) echo sparc-icl-nx7; exit ;;
+-	esac ;;
++	    sparc) GUESS=sparc-icl-nx7 ;;
++	esac
++	;;
+     s390x:SunOS:*:*)
+-	echo "$UNAME_MACHINE"-ibm-solaris2"`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`"
+-	exit ;;
++	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
++	GUESS=$UNAME_MACHINE-ibm-solaris2$SUN_REL
++	;;
+     sun4H:SunOS:5.*:*)
+-	echo sparc-hal-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+-	exit ;;
++	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
++	GUESS=sparc-hal-solaris2$SUN_REL
++	;;
+     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
+-	echo sparc-sun-solaris2"`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`"
+-	exit ;;
++	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
++	GUESS=sparc-sun-solaris2$SUN_REL
++	;;
+     i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
+-	echo i386-pc-auroraux"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=i386-pc-auroraux$UNAME_RELEASE
++	;;
+     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
+ 	set_cc_for_build
+ 	SUN_ARCH=i386
+ 	# If there is a compiler, see if it is configured for 64-bit objects.
+ 	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
+ 	# This test works for both compilers.
+-	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
++	if test "$CC_FOR_BUILD" != no_compiler_found; then
+ 	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
+-		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
++		(CCOPTS="" $CC_FOR_BUILD -m64 -E - 2>/dev/null) | \
+ 		grep IS_64BIT_ARCH >/dev/null
+ 	    then
+ 		SUN_ARCH=x86_64
+ 	    fi
+ 	fi
+-	echo "$SUN_ARCH"-pc-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+-	exit ;;
++	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
++	GUESS=$SUN_ARCH-pc-solaris2$SUN_REL
++	;;
+     sun4*:SunOS:6*:*)
+ 	# According to config.sub, this is the proper way to canonicalize
+ 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
+ 	# it's likely to be more like Solaris than SunOS4.
+-	echo sparc-sun-solaris3"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+-	exit ;;
++	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
++	GUESS=sparc-sun-solaris3$SUN_REL
++	;;
+     sun4*:SunOS:*:*)
+-	case "`/usr/bin/arch -k`" in
++	case `/usr/bin/arch -k` in
+ 	    Series*|S4*)
+ 		UNAME_RELEASE=`uname -v`
+ 		;;
+ 	esac
+-	# Japanese Language versions have a version number like `4.1.3-JL'.
+-	echo sparc-sun-sunos"`echo "$UNAME_RELEASE"|sed -e 's/-/_/'`"
+-	exit ;;
++	# Japanese Language versions have a version number like '4.1.3-JL'.
++	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/-/_/'`
++	GUESS=sparc-sun-sunos$SUN_REL
++	;;
+     sun3*:SunOS:*:*)
+-	echo m68k-sun-sunos"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=m68k-sun-sunos$UNAME_RELEASE
++	;;
+     sun*:*:4.2BSD:*)
+ 	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+ 	test "x$UNAME_RELEASE" = x && UNAME_RELEASE=3
+-	case "`/bin/arch`" in
++	case `/bin/arch` in
+ 	    sun3)
+-		echo m68k-sun-sunos"$UNAME_RELEASE"
++		GUESS=m68k-sun-sunos$UNAME_RELEASE
+ 		;;
+ 	    sun4)
+-		echo sparc-sun-sunos"$UNAME_RELEASE"
++		GUESS=sparc-sun-sunos$UNAME_RELEASE
+ 		;;
+ 	esac
+-	exit ;;
++	;;
+     aushp:SunOS:*:*)
+-	echo sparc-auspex-sunos"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=sparc-auspex-sunos$UNAME_RELEASE
++	;;
+     # The situation for MiNT is a little confusing.  The machine name
+     # can be virtually everything (everything which is not
+     # "atarist" or "atariste" at least should have a processor
+@@ -456,41 +490,41 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
+     # MiNT.  But MiNT is downward compatible to TOS, so this should
+     # be no problem.
+     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
+-	echo m68k-atari-mint"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=m68k-atari-mint$UNAME_RELEASE
++	;;
+     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
+-	echo m68k-atari-mint"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=m68k-atari-mint$UNAME_RELEASE
++	;;
+     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
+-	echo m68k-atari-mint"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=m68k-atari-mint$UNAME_RELEASE
++	;;
+     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
+-	echo m68k-milan-mint"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=m68k-milan-mint$UNAME_RELEASE
++	;;
+     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
+-	echo m68k-hades-mint"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=m68k-hades-mint$UNAME_RELEASE
++	;;
+     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
+-	echo m68k-unknown-mint"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=m68k-unknown-mint$UNAME_RELEASE
++	;;
+     m68k:machten:*:*)
+-	echo m68k-apple-machten"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=m68k-apple-machten$UNAME_RELEASE
++	;;
+     powerpc:machten:*:*)
+-	echo powerpc-apple-machten"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=powerpc-apple-machten$UNAME_RELEASE
++	;;
+     RISC*:Mach:*:*)
+-	echo mips-dec-mach_bsd4.3
+-	exit ;;
++	GUESS=mips-dec-mach_bsd4.3
++	;;
+     RISC*:ULTRIX:*:*)
+-	echo mips-dec-ultrix"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=mips-dec-ultrix$UNAME_RELEASE
++	;;
+     VAX*:ULTRIX*:*:*)
+-	echo vax-dec-ultrix"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=vax-dec-ultrix$UNAME_RELEASE
++	;;
+     2020:CLIX:*:* | 2430:CLIX:*:*)
+-	echo clipper-intergraph-clix"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=clipper-intergraph-clix$UNAME_RELEASE
++	;;
+     mips:*:*:UMIPS | mips:*:*:RISCos)
+ 	set_cc_for_build
+ 	sed 's/^	//' << EOF > "$dummy.c"
+@@ -518,75 +552,76 @@ EOF
+ 	  dummyarg=`echo "$UNAME_RELEASE" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+ 	  SYSTEM_NAME=`"$dummy" "$dummyarg"` &&
+ 	    { echo "$SYSTEM_NAME"; exit; }
+-	echo mips-mips-riscos"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=mips-mips-riscos$UNAME_RELEASE
++	;;
+     Motorola:PowerMAX_OS:*:*)
+-	echo powerpc-motorola-powermax
+-	exit ;;
++	GUESS=powerpc-motorola-powermax
++	;;
+     Motorola:*:4.3:PL8-*)
+-	echo powerpc-harris-powermax
+-	exit ;;
++	GUESS=powerpc-harris-powermax
++	;;
+     Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
+-	echo powerpc-harris-powermax
+-	exit ;;
++	GUESS=powerpc-harris-powermax
++	;;
+     Night_Hawk:Power_UNIX:*:*)
+-	echo powerpc-harris-powerunix
+-	exit ;;
++	GUESS=powerpc-harris-powerunix
++	;;
+     m88k:CX/UX:7*:*)
+-	echo m88k-harris-cxux7
+-	exit ;;
++	GUESS=m88k-harris-cxux7
++	;;
+     m88k:*:4*:R4*)
+-	echo m88k-motorola-sysv4
+-	exit ;;
++	GUESS=m88k-motorola-sysv4
++	;;
+     m88k:*:3*:R3*)
+-	echo m88k-motorola-sysv3
+-	exit ;;
++	GUESS=m88k-motorola-sysv3
++	;;
+     AViiON:dgux:*:*)
+ 	# DG/UX returns AViiON for all architectures
+ 	UNAME_PROCESSOR=`/usr/bin/uname -p`
+-	if [ "$UNAME_PROCESSOR" = mc88100 ] || [ "$UNAME_PROCESSOR" = mc88110 ]
++	if test "$UNAME_PROCESSOR" = mc88100 || test "$UNAME_PROCESSOR" = mc88110
+ 	then
+-	    if [ "$TARGET_BINARY_INTERFACE"x = m88kdguxelfx ] || \
+-	       [ "$TARGET_BINARY_INTERFACE"x = x ]
++	    if test "$TARGET_BINARY_INTERFACE"x = m88kdguxelfx || \
++	       test "$TARGET_BINARY_INTERFACE"x = x
+ 	    then
+-		echo m88k-dg-dgux"$UNAME_RELEASE"
++		GUESS=m88k-dg-dgux$UNAME_RELEASE
+ 	    else
+-		echo m88k-dg-dguxbcs"$UNAME_RELEASE"
++		GUESS=m88k-dg-dguxbcs$UNAME_RELEASE
+ 	    fi
+ 	else
+-	    echo i586-dg-dgux"$UNAME_RELEASE"
++	    GUESS=i586-dg-dgux$UNAME_RELEASE
+ 	fi
+-	exit ;;
++	;;
+     M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
+-	echo m88k-dolphin-sysv3
+-	exit ;;
++	GUESS=m88k-dolphin-sysv3
++	;;
+     M88*:*:R3*:*)
+ 	# Delta 88k system running SVR3
+-	echo m88k-motorola-sysv3
+-	exit ;;
++	GUESS=m88k-motorola-sysv3
++	;;
+     XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
+-	echo m88k-tektronix-sysv3
+-	exit ;;
++	GUESS=m88k-tektronix-sysv3
++	;;
+     Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
+-	echo m68k-tektronix-bsd
+-	exit ;;
++	GUESS=m68k-tektronix-bsd
++	;;
+     *:IRIX*:*:*)
+-	echo mips-sgi-irix"`echo "$UNAME_RELEASE"|sed -e 's/-/_/g'`"
+-	exit ;;
++	IRIX_REL=`echo "$UNAME_RELEASE" | sed -e 's/-/_/g'`
++	GUESS=mips-sgi-irix$IRIX_REL
++	;;
+     ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+-	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
+-	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
++	GUESS=romp-ibm-aix    # uname -m gives an 8 hex-code CPU id
++	;;                    # Note that: echo "'`uname -s`'" gives 'AIX '
+     i*86:AIX:*:*)
+-	echo i386-ibm-aix
+-	exit ;;
++	GUESS=i386-ibm-aix
++	;;
+     ia64:AIX:*:*)
+-	if [ -x /usr/bin/oslevel ] ; then
++	if test -x /usr/bin/oslevel ; then
+ 		IBM_REV=`/usr/bin/oslevel`
+ 	else
+-		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
++		IBM_REV=$UNAME_VERSION.$UNAME_RELEASE
+ 	fi
+-	echo "$UNAME_MACHINE"-ibm-aix"$IBM_REV"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-ibm-aix$IBM_REV
++	;;
+     *:AIX:2:3)
+ 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
+ 		set_cc_for_build
+@@ -603,16 +638,16 @@ EOF
+ EOF
+ 		if $CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"`
+ 		then
+-			echo "$SYSTEM_NAME"
++			GUESS=$SYSTEM_NAME
+ 		else
+-			echo rs6000-ibm-aix3.2.5
++			GUESS=rs6000-ibm-aix3.2.5
+ 		fi
+ 	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
+-		echo rs6000-ibm-aix3.2.4
++		GUESS=rs6000-ibm-aix3.2.4
+ 	else
+-		echo rs6000-ibm-aix3.2
++		GUESS=rs6000-ibm-aix3.2
+ 	fi
+-	exit ;;
++	;;
+     *:AIX:*:[4567])
+ 	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
+ 	if /usr/sbin/lsattr -El "$IBM_CPU_ID" | grep ' POWER' >/dev/null 2>&1; then
+@@ -620,56 +655,56 @@ EOF
+ 	else
+ 		IBM_ARCH=powerpc
+ 	fi
+-	if [ -x /usr/bin/lslpp ] ; then
+-		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
++	if test -x /usr/bin/lslpp ; then
++		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc | \
+ 			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
+ 	else
+-		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
++		IBM_REV=$UNAME_VERSION.$UNAME_RELEASE
+ 	fi
+-	echo "$IBM_ARCH"-ibm-aix"$IBM_REV"
+-	exit ;;
++	GUESS=$IBM_ARCH-ibm-aix$IBM_REV
++	;;
+     *:AIX:*:*)
+-	echo rs6000-ibm-aix
+-	exit ;;
++	GUESS=rs6000-ibm-aix
++	;;
+     ibmrt:4.4BSD:*|romp-ibm:4.4BSD:*)
+-	echo romp-ibm-bsd4.4
+-	exit ;;
++	GUESS=romp-ibm-bsd4.4
++	;;
+     ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
+-	echo romp-ibm-bsd"$UNAME_RELEASE"   # 4.3 with uname added to
+-	exit ;;                             # report: romp-ibm BSD 4.3
++	GUESS=romp-ibm-bsd$UNAME_RELEASE    # 4.3 with uname added to
++	;;                                  # report: romp-ibm BSD 4.3
+     *:BOSX:*:*)
+-	echo rs6000-bull-bosx
+-	exit ;;
++	GUESS=rs6000-bull-bosx
++	;;
+     DPX/2?00:B.O.S.:*:*)
+-	echo m68k-bull-sysv3
+-	exit ;;
++	GUESS=m68k-bull-sysv3
++	;;
+     9000/[34]??:4.3bsd:1.*:*)
+-	echo m68k-hp-bsd
+-	exit ;;
++	GUESS=m68k-hp-bsd
++	;;
+     hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
+-	echo m68k-hp-bsd4.4
+-	exit ;;
++	GUESS=m68k-hp-bsd4.4
++	;;
+     9000/[34678]??:HP-UX:*:*)
+-	HPUX_REV=`echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//'`
+-	case "$UNAME_MACHINE" in
++	HPUX_REV=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*.[0B]*//'`
++	case $UNAME_MACHINE in
+ 	    9000/31?)            HP_ARCH=m68000 ;;
+ 	    9000/[34]??)         HP_ARCH=m68k ;;
+ 	    9000/[678][0-9][0-9])
+-		if [ -x /usr/bin/getconf ]; then
++		if test -x /usr/bin/getconf; then
+ 		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
+ 		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+-		    case "$sc_cpu_version" in
++		    case $sc_cpu_version in
+ 		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
+ 		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
+ 		      532)                      # CPU_PA_RISC2_0
+-			case "$sc_kernel_bits" in
++			case $sc_kernel_bits in
+ 			  32) HP_ARCH=hppa2.0n ;;
+ 			  64) HP_ARCH=hppa2.0w ;;
+ 			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
+ 			esac ;;
+ 		    esac
+ 		fi
+-		if [ "$HP_ARCH" = "" ]; then
++		if test "$HP_ARCH" = ""; then
+ 		    set_cc_for_build
+ 		    sed 's/^		//' << EOF > "$dummy.c"
+ 
+@@ -708,7 +743,7 @@ EOF
+ 		    test -z "$HP_ARCH" && HP_ARCH=hppa
+ 		fi ;;
+ 	esac
+-	if [ "$HP_ARCH" = hppa2.0w ]
++	if test "$HP_ARCH" = hppa2.0w
+ 	then
+ 	    set_cc_for_build
+ 
+@@ -729,12 +764,12 @@ EOF
+ 		HP_ARCH=hppa64
+ 	    fi
+ 	fi
+-	echo "$HP_ARCH"-hp-hpux"$HPUX_REV"
+-	exit ;;
++	GUESS=$HP_ARCH-hp-hpux$HPUX_REV
++	;;
+     ia64:HP-UX:*:*)
+-	HPUX_REV=`echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//'`
+-	echo ia64-hp-hpux"$HPUX_REV"
+-	exit ;;
++	HPUX_REV=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*.[0B]*//'`
++	GUESS=ia64-hp-hpux$HPUX_REV
++	;;
+     3050*:HI-UX:*:*)
+ 	set_cc_for_build
+ 	sed 's/^	//' << EOF > "$dummy.c"
+@@ -764,36 +799,36 @@ EOF
+ EOF
+ 	$CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"` &&
+ 		{ echo "$SYSTEM_NAME"; exit; }
+-	echo unknown-hitachi-hiuxwe2
+-	exit ;;
++	GUESS=unknown-hitachi-hiuxwe2
++	;;
+     9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:*)
+-	echo hppa1.1-hp-bsd
+-	exit ;;
++	GUESS=hppa1.1-hp-bsd
++	;;
+     9000/8??:4.3bsd:*:*)
+-	echo hppa1.0-hp-bsd
+-	exit ;;
++	GUESS=hppa1.0-hp-bsd
++	;;
+     *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
+-	echo hppa1.0-hp-mpeix
+-	exit ;;
++	GUESS=hppa1.0-hp-mpeix
++	;;
+     hp7??:OSF1:*:* | hp8?[79]:OSF1:*:*)
+-	echo hppa1.1-hp-osf
+-	exit ;;
++	GUESS=hppa1.1-hp-osf
++	;;
+     hp8??:OSF1:*:*)
+-	echo hppa1.0-hp-osf
+-	exit ;;
++	GUESS=hppa1.0-hp-osf
++	;;
+     i*86:OSF1:*:*)
+-	if [ -x /usr/sbin/sysversion ] ; then
+-	    echo "$UNAME_MACHINE"-unknown-osf1mk
++	if test -x /usr/sbin/sysversion ; then
++	    GUESS=$UNAME_MACHINE-unknown-osf1mk
+ 	else
+-	    echo "$UNAME_MACHINE"-unknown-osf1
++	    GUESS=$UNAME_MACHINE-unknown-osf1
+ 	fi
+-	exit ;;
++	;;
+     parisc*:Lites*:*:*)
+-	echo hppa1.1-hp-lites
+-	exit ;;
++	GUESS=hppa1.1-hp-lites
++	;;
+     C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
+-	echo c1-convex-bsd
+-	exit ;;
++	GUESS=c1-convex-bsd
++	;;
+     C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
+ 	if getsysinfo -f scalar_acc
+ 	then echo c32-convex-bsd
+@@ -801,17 +836,18 @@ EOF
+ 	fi
+ 	exit ;;
+     C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
+-	echo c34-convex-bsd
+-	exit ;;
++	GUESS=c34-convex-bsd
++	;;
+     C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
+-	echo c38-convex-bsd
+-	exit ;;
++	GUESS=c38-convex-bsd
++	;;
+     C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
+-	echo c4-convex-bsd
+-	exit ;;
++	GUESS=c4-convex-bsd
++	;;
+     CRAY*Y-MP:*:*:*)
+-	echo ymp-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
+-	exit ;;
++	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
++	GUESS=ymp-cray-unicos$CRAY_REL
++	;;
+     CRAY*[A-Z]90:*:*:*)
+ 	echo "$UNAME_MACHINE"-cray-unicos"$UNAME_RELEASE" \
+ 	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+@@ -819,112 +855,153 @@ EOF
+ 	      -e 's/\.[^.]*$/.X/'
+ 	exit ;;
+     CRAY*TS:*:*:*)
+-	echo t90-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
+-	exit ;;
++	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
++	GUESS=t90-cray-unicos$CRAY_REL
++	;;
+     CRAY*T3E:*:*:*)
+-	echo alphaev5-cray-unicosmk"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
+-	exit ;;
++	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
++	GUESS=alphaev5-cray-unicosmk$CRAY_REL
++	;;
+     CRAY*SV1:*:*:*)
+-	echo sv1-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
+-	exit ;;
++	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
++	GUESS=sv1-cray-unicos$CRAY_REL
++	;;
+     *:UNICOS/mp:*:*)
+-	echo craynv-cray-unicosmp"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
+-	exit ;;
++	CRAY_REL=`echo "$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'`
++	GUESS=craynv-cray-unicosmp$CRAY_REL
++	;;
+     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
+ 	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+ 	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+ 	FUJITSU_REL=`echo "$UNAME_RELEASE" | sed -e 's/ /_/'`
+-	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+-	exit ;;
++	GUESS=${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}
++	;;
+     5000:UNIX_System_V:4.*:*)
+ 	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+ 	FUJITSU_REL=`echo "$UNAME_RELEASE" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
+-	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+-	exit ;;
++	GUESS=sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}
++	;;
+     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
+-	echo "$UNAME_MACHINE"-pc-bsdi"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-pc-bsdi$UNAME_RELEASE
++	;;
+     sparc*:BSD/OS:*:*)
+-	echo sparc-unknown-bsdi"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=sparc-unknown-bsdi$UNAME_RELEASE
++	;;
+     *:BSD/OS:*:*)
+-	echo "$UNAME_MACHINE"-unknown-bsdi"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-bsdi$UNAME_RELEASE
++	;;
+     arm:FreeBSD:*:*)
+ 	UNAME_PROCESSOR=`uname -p`
+ 	set_cc_for_build
+ 	if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+ 	    | grep -q __ARM_PCS_VFP
+ 	then
+-	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`"-gnueabi
++	    FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
++	    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabi
+ 	else
+-	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`"-gnueabihf
++	    FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
++	    GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL-gnueabihf
+ 	fi
+-	exit ;;
++	;;
+     *:FreeBSD:*:*)
+ 	UNAME_PROCESSOR=`/usr/bin/uname -p`
+-	case "$UNAME_PROCESSOR" in
++	case $UNAME_PROCESSOR in
+ 	    amd64)
+ 		UNAME_PROCESSOR=x86_64 ;;
+ 	    i386)
+ 		UNAME_PROCESSOR=i586 ;;
+ 	esac
+-	echo "$UNAME_PROCESSOR"-unknown-freebsd"`echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`"
+-	exit ;;
++	FREEBSD_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
++	GUESS=$UNAME_PROCESSOR-unknown-freebsd$FREEBSD_REL
++	;;
+     i*:CYGWIN*:*)
+-	echo "$UNAME_MACHINE"-pc-cygwin
+-	exit ;;
++	GUESS=$UNAME_MACHINE-pc-cygwin
++	;;
+     *:MINGW64*:*)
+-	echo "$UNAME_MACHINE"-pc-mingw64
+-	exit ;;
++	GUESS=$UNAME_MACHINE-pc-mingw64
++	;;
+     *:MINGW*:*)
+-	echo "$UNAME_MACHINE"-pc-mingw32
+-	exit ;;
++	GUESS=$UNAME_MACHINE-pc-mingw32
++	;;
+     *:MSYS*:*)
+-	echo "$UNAME_MACHINE"-pc-msys
+-	exit ;;
++	GUESS=$UNAME_MACHINE-pc-msys
++	;;
+     i*:PW*:*)
+-	echo "$UNAME_MACHINE"-pc-pw32
+-	exit ;;
++	GUESS=$UNAME_MACHINE-pc-pw32
++	;;
++    *:SerenityOS:*:*)
++        GUESS=$UNAME_MACHINE-pc-serenity
++        ;;
+     *:Interix*:*)
+-	case "$UNAME_MACHINE" in
++	case $UNAME_MACHINE in
+ 	    x86)
+-		echo i586-pc-interix"$UNAME_RELEASE"
+-		exit ;;
++		GUESS=i586-pc-interix$UNAME_RELEASE
++		;;
+ 	    authenticamd | genuineintel | EM64T)
+-		echo x86_64-unknown-interix"$UNAME_RELEASE"
+-		exit ;;
++		GUESS=x86_64-unknown-interix$UNAME_RELEASE
++		;;
+ 	    IA64)
+-		echo ia64-unknown-interix"$UNAME_RELEASE"
+-		exit ;;
++		GUESS=ia64-unknown-interix$UNAME_RELEASE
++		;;
+ 	esac ;;
+     i*:UWIN*:*)
+-	echo "$UNAME_MACHINE"-pc-uwin
+-	exit ;;
++	GUESS=$UNAME_MACHINE-pc-uwin
++	;;
+     amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
+-	echo x86_64-pc-cygwin
+-	exit ;;
++	GUESS=x86_64-pc-cygwin
++	;;
+     prep*:SunOS:5.*:*)
+-	echo powerpcle-unknown-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+-	exit ;;
++	SUN_REL=`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`
++	GUESS=powerpcle-unknown-solaris2$SUN_REL
++	;;
+     *:GNU:*:*)
+ 	# the GNU system
+-	echo "`echo "$UNAME_MACHINE"|sed -e 's,[-/].*$,,'`-unknown-$LIBC`echo "$UNAME_RELEASE"|sed -e 's,/.*$,,'`"
+-	exit ;;
++	GNU_ARCH=`echo "$UNAME_MACHINE" | sed -e 's,[-/].*$,,'`
++	GNU_REL=`echo "$UNAME_RELEASE" | sed -e 's,/.*$,,'`
++	GUESS=$GNU_ARCH-unknown-$LIBC$GNU_REL
++	;;
+     *:GNU/*:*:*)
+ 	# other systems with GNU libc and userland
+-	echo "$UNAME_MACHINE-unknown-`echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"``echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`-$LIBC"
+-	exit ;;
++	GNU_SYS=`echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"`
++	GNU_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
++	GUESS=$UNAME_MACHINE-unknown-$GNU_SYS$GNU_REL-$LIBC
++	;;
++    x86_64:[Mm]anagarm:*:*|i?86:[Mm]anagarm:*:*)
++	GUESS="$UNAME_MACHINE-pc-managarm-mlibc"
++	;;
++    *:[Mm]anagarm:*:*)
++	GUESS="$UNAME_MACHINE-unknown-managarm-mlibc"
++	;;
+     *:Minix:*:*)
+-	echo "$UNAME_MACHINE"-unknown-minix
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-minix
++	;;
+     aarch64:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	set_cc_for_build
++	CPU=$UNAME_MACHINE
++	LIBCABI=$LIBC
++	if test "$CC_FOR_BUILD" != no_compiler_found; then
++	    ABI=64
++	    sed 's/^	    //' << EOF > "$dummy.c"
++	    #ifdef __ARM_EABI__
++	    #ifdef __ARM_PCS_VFP
++	    ABI=eabihf
++	    #else
++	    ABI=eabi
++	    #endif
++	    #endif
++EOF
++	    cc_set_abi=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^ABI' | sed 's, ,,g'`
++	    eval "$cc_set_abi"
++	    case $ABI in
++		eabi | eabihf) CPU=armv8l; LIBCABI=$LIBC$ABI ;;
++	    esac
++	fi
++	GUESS=$CPU-unknown-linux-$LIBCABI
++	;;
+     aarch64_be:Linux:*:*)
+ 	UNAME_MACHINE=aarch64_be
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     alpha:Linux:*:*)
+ 	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' /proc/cpuinfo 2>/dev/null` in
+ 	  EV5)   UNAME_MACHINE=alphaev5 ;;
+@@ -937,60 +1014,72 @@ EOF
+ 	esac
+ 	objdump --private-headers /bin/sh | grep -q ld.so.1
+ 	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
+-    arc:Linux:*:* | arceb:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
++    arc:Linux:*:* | arceb:Linux:*:* | arc32:Linux:*:* | arc64:Linux:*:*)
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     arm*:Linux:*:*)
+ 	set_cc_for_build
+ 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
+ 	    | grep -q __ARM_EABI__
+ 	then
+-	    echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
++	    GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+ 	else
+ 	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+ 		| grep -q __ARM_PCS_VFP
+ 	    then
+-		echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"eabi
++		GUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabi
+ 	    else
+-		echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"eabihf
++		GUESS=$UNAME_MACHINE-unknown-linux-${LIBC}eabihf
+ 	    fi
+ 	fi
+-	exit ;;
++	;;
+     avr32*:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     cris:Linux:*:*)
+-	echo "$UNAME_MACHINE"-axis-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-axis-linux-$LIBC
++	;;
+     crisv32:Linux:*:*)
+-	echo "$UNAME_MACHINE"-axis-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-axis-linux-$LIBC
++	;;
+     e2k:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     frv:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     hexagon:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     i*86:Linux:*:*)
+-	echo "$UNAME_MACHINE"-pc-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-pc-linux-$LIBC
++	;;
+     ia64:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     k1om:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
++    kvx:Linux:*:*)
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
++    kvx:cos:*:*)
++	GUESS=$UNAME_MACHINE-unknown-cos
++	;;
++    kvx:mbr:*:*)
++	GUESS=$UNAME_MACHINE-unknown-mbr
++	;;
++    loongarch32:Linux:*:* | loongarch64:Linux:*:*)
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     m32r*:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     m68*:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     mips:Linux:*:* | mips64:Linux:*:*)
+ 	set_cc_for_build
+ 	IS_GLIBC=0
+@@ -1035,123 +1124,135 @@ EOF
+ 	#endif
+ 	#endif
+ EOF
+-	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU\|^MIPS_ENDIAN\|^LIBCABI'`"
++	cc_set_vars=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU\|^MIPS_ENDIAN\|^LIBCABI'`
++	eval "$cc_set_vars"
+ 	test "x$CPU" != x && { echo "$CPU${MIPS_ENDIAN}-unknown-linux-$LIBCABI"; exit; }
+ 	;;
+     mips64el:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     openrisc*:Linux:*:*)
+-	echo or1k-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=or1k-unknown-linux-$LIBC
++	;;
+     or32:Linux:*:* | or1k*:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     padre:Linux:*:*)
+-	echo sparc-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=sparc-unknown-linux-$LIBC
++	;;
+     parisc64:Linux:*:* | hppa64:Linux:*:*)
+-	echo hppa64-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=hppa64-unknown-linux-$LIBC
++	;;
+     parisc:Linux:*:* | hppa:Linux:*:*)
+ 	# Look for CPU level
+ 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
+-	  PA7*) echo hppa1.1-unknown-linux-"$LIBC" ;;
+-	  PA8*) echo hppa2.0-unknown-linux-"$LIBC" ;;
+-	  *)    echo hppa-unknown-linux-"$LIBC" ;;
++	  PA7*) GUESS=hppa1.1-unknown-linux-$LIBC ;;
++	  PA8*) GUESS=hppa2.0-unknown-linux-$LIBC ;;
++	  *)    GUESS=hppa-unknown-linux-$LIBC ;;
+ 	esac
+-	exit ;;
++	;;
+     ppc64:Linux:*:*)
+-	echo powerpc64-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=powerpc64-unknown-linux-$LIBC
++	;;
+     ppc:Linux:*:*)
+-	echo powerpc-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=powerpc-unknown-linux-$LIBC
++	;;
+     ppc64le:Linux:*:*)
+-	echo powerpc64le-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=powerpc64le-unknown-linux-$LIBC
++	;;
+     ppcle:Linux:*:*)
+-	echo powerpcle-unknown-linux-"$LIBC"
+-	exit ;;
+-    riscv32:Linux:*:* | riscv64:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=powerpcle-unknown-linux-$LIBC
++	;;
++    riscv32:Linux:*:* | riscv32be:Linux:*:* | riscv64:Linux:*:* | riscv64be:Linux:*:*)
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     s390:Linux:*:* | s390x:Linux:*:*)
+-	echo "$UNAME_MACHINE"-ibm-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-ibm-linux-$LIBC
++	;;
+     sh64*:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     sh*:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     sparc:Linux:*:* | sparc64:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     tile*:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     vax:Linux:*:*)
+-	echo "$UNAME_MACHINE"-dec-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-dec-linux-$LIBC
++	;;
+     x86_64:Linux:*:*)
+ 	set_cc_for_build
++	CPU=$UNAME_MACHINE
+ 	LIBCABI=$LIBC
+-	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+-	    if (echo '#ifdef __ILP32__'; echo IS_X32; echo '#endif') | \
+-		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+-		grep IS_X32 >/dev/null
+-	    then
+-		LIBCABI="$LIBC"x32
+-	    fi
++	if test "$CC_FOR_BUILD" != no_compiler_found; then
++	    ABI=64
++	    sed 's/^	    //' << EOF > "$dummy.c"
++	    #ifdef __i386__
++	    ABI=x86
++	    #else
++	    #ifdef __ILP32__
++	    ABI=x32
++	    #endif
++	    #endif
++EOF
++	    cc_set_abi=`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^ABI' | sed 's, ,,g'`
++	    eval "$cc_set_abi"
++	    case $ABI in
++		x86) CPU=i686 ;;
++		x32) LIBCABI=${LIBC}x32 ;;
++	    esac
+ 	fi
+-	echo "$UNAME_MACHINE"-pc-linux-"$LIBCABI"
+-	exit ;;
++	GUESS=$CPU-pc-linux-$LIBCABI
++	;;
+     xtensa*:Linux:*:*)
+-	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++	;;
+     i*86:DYNIX/ptx:4*:*)
+ 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
+ 	# earlier versions are messed up and put the nodename in both
+ 	# sysname and nodename.
+-	echo i386-sequent-sysv4
+-	exit ;;
++	GUESS=i386-sequent-sysv4
++	;;
+     i*86:UNIX_SV:4.2MP:2.*)
+ 	# Unixware is an offshoot of SVR4, but it has its own version
+ 	# number series starting with 2...
+ 	# I am not positive that other SVR4 systems won't match this,
+ 	# I just have to hope.  -- rms.
+ 	# Use sysv4.2uw... so that sysv4* matches it.
+-	echo "$UNAME_MACHINE"-pc-sysv4.2uw"$UNAME_VERSION"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-pc-sysv4.2uw$UNAME_VERSION
++	;;
+     i*86:OS/2:*:*)
+-	# If we were able to find `uname', then EMX Unix compatibility
++	# If we were able to find 'uname', then EMX Unix compatibility
+ 	# is probably installed.
+-	echo "$UNAME_MACHINE"-pc-os2-emx
+-	exit ;;
++	GUESS=$UNAME_MACHINE-pc-os2-emx
++	;;
+     i*86:XTS-300:*:STOP)
+-	echo "$UNAME_MACHINE"-unknown-stop
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-stop
++	;;
+     i*86:atheos:*:*)
+-	echo "$UNAME_MACHINE"-unknown-atheos
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-atheos
++	;;
+     i*86:syllable:*:*)
+-	echo "$UNAME_MACHINE"-pc-syllable
+-	exit ;;
++	GUESS=$UNAME_MACHINE-pc-syllable
++	;;
+     i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
+-	echo i386-unknown-lynxos"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=i386-unknown-lynxos$UNAME_RELEASE
++	;;
+     i*86:*DOS:*:*)
+-	echo "$UNAME_MACHINE"-pc-msdosdjgpp
+-	exit ;;
++	GUESS=$UNAME_MACHINE-pc-msdosdjgpp
++	;;
+     i*86:*:4.*:*)
+ 	UNAME_REL=`echo "$UNAME_RELEASE" | sed 's/\/MP$//'`
+ 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
+-		echo "$UNAME_MACHINE"-univel-sysv"$UNAME_REL"
++		GUESS=$UNAME_MACHINE-univel-sysv$UNAME_REL
+ 	else
+-		echo "$UNAME_MACHINE"-pc-sysv"$UNAME_REL"
++		GUESS=$UNAME_MACHINE-pc-sysv$UNAME_REL
+ 	fi
+-	exit ;;
++	;;
+     i*86:*:5:[678]*)
+ 	# UnixWare 7.x, OpenUNIX and OpenServer 6.
+ 	case `/bin/uname -X | grep "^Machine"` in
+@@ -1159,12 +1260,12 @@ EOF
+ 	    *Pentium)	     UNAME_MACHINE=i586 ;;
+ 	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
+ 	esac
+-	echo "$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
++	;;
+     i*86:*:3.2:*)
+ 	if test -f /usr/options/cb.name; then
+ 		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+-		echo "$UNAME_MACHINE"-pc-isc"$UNAME_REL"
++		GUESS=$UNAME_MACHINE-pc-isc$UNAME_REL
+ 	elif /bin/uname -X 2>/dev/null >/dev/null ; then
+ 		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
+ 		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
+@@ -1174,11 +1275,11 @@ EOF
+ 			&& UNAME_MACHINE=i686
+ 		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
+ 			&& UNAME_MACHINE=i686
+-		echo "$UNAME_MACHINE"-pc-sco"$UNAME_REL"
++		GUESS=$UNAME_MACHINE-pc-sco$UNAME_REL
+ 	else
+-		echo "$UNAME_MACHINE"-pc-sysv32
++		GUESS=$UNAME_MACHINE-pc-sysv32
+ 	fi
+-	exit ;;
++	;;
+     pc:*:*:*)
+ 	# Left here for compatibility:
+ 	# uname -m prints for DJGPP always 'pc', but it prints nothing about
+@@ -1186,31 +1287,31 @@ EOF
+ 	# Note: whatever this is, it MUST be the same as what config.sub
+ 	# prints for the "djgpp" host, or else GDB configure will decide that
+ 	# this is a cross-build.
+-	echo i586-pc-msdosdjgpp
+-	exit ;;
++	GUESS=i586-pc-msdosdjgpp
++	;;
+     Intel:Mach:3*:*)
+-	echo i386-pc-mach3
+-	exit ;;
++	GUESS=i386-pc-mach3
++	;;
+     paragon:*:*:*)
+-	echo i860-intel-osf1
+-	exit ;;
++	GUESS=i860-intel-osf1
++	;;
+     i860:*:4.*:*) # i860-SVR4
+ 	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
+-	  echo i860-stardent-sysv"$UNAME_RELEASE" # Stardent Vistra i860-SVR4
++	  GUESS=i860-stardent-sysv$UNAME_RELEASE    # Stardent Vistra i860-SVR4
+ 	else # Add other i860-SVR4 vendors below as they are discovered.
+-	  echo i860-unknown-sysv"$UNAME_RELEASE"  # Unknown i860-SVR4
++	  GUESS=i860-unknown-sysv$UNAME_RELEASE     # Unknown i860-SVR4
+ 	fi
+-	exit ;;
++	;;
+     mini*:CTIX:SYS*5:*)
+ 	# "miniframe"
+-	echo m68010-convergent-sysv
+-	exit ;;
++	GUESS=m68010-convergent-sysv
++	;;
+     mc68k:UNIX:SYSTEM5:3.51m)
+-	echo m68k-convergent-sysv
+-	exit ;;
++	GUESS=m68k-convergent-sysv
++	;;
+     M680?0:D-NIX:5.3:*)
+-	echo m68k-diab-dnix
+-	exit ;;
++	GUESS=m68k-diab-dnix
++	;;
+     M68*:*:R3V[5678]*:*)
+ 	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
+     3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
+@@ -1235,116 +1336,119 @@ EOF
+ 	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
+ 	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
+     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
+-	echo m68k-unknown-lynxos"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=m68k-unknown-lynxos$UNAME_RELEASE
++	;;
+     mc68030:UNIX_System_V:4.*:*)
+-	echo m68k-atari-sysv4
+-	exit ;;
++	GUESS=m68k-atari-sysv4
++	;;
+     TSUNAMI:LynxOS:2.*:*)
+-	echo sparc-unknown-lynxos"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=sparc-unknown-lynxos$UNAME_RELEASE
++	;;
+     rs6000:LynxOS:2.*:*)
+-	echo rs6000-unknown-lynxos"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=rs6000-unknown-lynxos$UNAME_RELEASE
++	;;
+     PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
+-	echo powerpc-unknown-lynxos"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=powerpc-unknown-lynxos$UNAME_RELEASE
++	;;
+     SM[BE]S:UNIX_SV:*:*)
+-	echo mips-dde-sysv"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=mips-dde-sysv$UNAME_RELEASE
++	;;
+     RM*:ReliantUNIX-*:*:*)
+-	echo mips-sni-sysv4
+-	exit ;;
++	GUESS=mips-sni-sysv4
++	;;
+     RM*:SINIX-*:*:*)
+-	echo mips-sni-sysv4
+-	exit ;;
++	GUESS=mips-sni-sysv4
++	;;
+     *:SINIX-*:*:*)
+ 	if uname -p 2>/dev/null >/dev/null ; then
+ 		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+-		echo "$UNAME_MACHINE"-sni-sysv4
++		GUESS=$UNAME_MACHINE-sni-sysv4
+ 	else
+-		echo ns32k-sni-sysv
++		GUESS=ns32k-sni-sysv
+ 	fi
+-	exit ;;
+-    PENTIUM:*:4.0*:*)	# Unisys `ClearPath HMP IX 4000' SVR4/MP effort
++	;;
++    PENTIUM:*:4.0*:*)	# Unisys 'ClearPath HMP IX 4000' SVR4/MP effort
+ 			# says <Richard.M.Bartel@ccMail.Census.GOV>
+-	echo i586-unisys-sysv4
+-	exit ;;
++	GUESS=i586-unisys-sysv4
++	;;
+     *:UNIX_System_V:4*:FTX*)
+ 	# From Gerald Hewes <hewes@openmarket.com>.
+ 	# How about differentiating between stratus architectures? -djm
+-	echo hppa1.1-stratus-sysv4
+-	exit ;;
++	GUESS=hppa1.1-stratus-sysv4
++	;;
+     *:*:*:FTX*)
+ 	# From seanf@swdc.stratus.com.
+-	echo i860-stratus-sysv4
+-	exit ;;
++	GUESS=i860-stratus-sysv4
++	;;
+     i*86:VOS:*:*)
+ 	# From Paul.Green@stratus.com.
+-	echo "$UNAME_MACHINE"-stratus-vos
+-	exit ;;
++	GUESS=$UNAME_MACHINE-stratus-vos
++	;;
+     *:VOS:*:*)
+ 	# From Paul.Green@stratus.com.
+-	echo hppa1.1-stratus-vos
+-	exit ;;
++	GUESS=hppa1.1-stratus-vos
++	;;
+     mc68*:A/UX:*:*)
+-	echo m68k-apple-aux"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=m68k-apple-aux$UNAME_RELEASE
++	;;
+     news*:NEWS-OS:6*:*)
+-	echo mips-sony-newsos6
+-	exit ;;
++	GUESS=mips-sony-newsos6
++	;;
+     R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
+-	if [ -d /usr/nec ]; then
+-		echo mips-nec-sysv"$UNAME_RELEASE"
++	if test -d /usr/nec; then
++		GUESS=mips-nec-sysv$UNAME_RELEASE
+ 	else
+-		echo mips-unknown-sysv"$UNAME_RELEASE"
++		GUESS=mips-unknown-sysv$UNAME_RELEASE
+ 	fi
+-	exit ;;
++	;;
+     BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
+-	echo powerpc-be-beos
+-	exit ;;
++	GUESS=powerpc-be-beos
++	;;
+     BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+-	echo powerpc-apple-beos
+-	exit ;;
++	GUESS=powerpc-apple-beos
++	;;
+     BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+-	echo i586-pc-beos
+-	exit ;;
++	GUESS=i586-pc-beos
++	;;
+     BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
+-	echo i586-pc-haiku
+-	exit ;;
+-    x86_64:Haiku:*:*)
+-	echo x86_64-unknown-haiku
+-	exit ;;
++	GUESS=i586-pc-haiku
++	;;
++    ppc:Haiku:*:*)	# Haiku running on Apple PowerPC
++	GUESS=powerpc-apple-haiku
++	;;
++    *:Haiku:*:*)	# Haiku modern gcc (not bound by BeOS compat)
++	GUESS=$UNAME_MACHINE-unknown-haiku
++	;;
+     SX-4:SUPER-UX:*:*)
+-	echo sx4-nec-superux"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=sx4-nec-superux$UNAME_RELEASE
++	;;
+     SX-5:SUPER-UX:*:*)
+-	echo sx5-nec-superux"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=sx5-nec-superux$UNAME_RELEASE
++	;;
+     SX-6:SUPER-UX:*:*)
+-	echo sx6-nec-superux"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=sx6-nec-superux$UNAME_RELEASE
++	;;
+     SX-7:SUPER-UX:*:*)
+-	echo sx7-nec-superux"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=sx7-nec-superux$UNAME_RELEASE
++	;;
+     SX-8:SUPER-UX:*:*)
+-	echo sx8-nec-superux"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=sx8-nec-superux$UNAME_RELEASE
++	;;
+     SX-8R:SUPER-UX:*:*)
+-	echo sx8r-nec-superux"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=sx8r-nec-superux$UNAME_RELEASE
++	;;
+     SX-ACE:SUPER-UX:*:*)
+-	echo sxace-nec-superux"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=sxace-nec-superux$UNAME_RELEASE
++	;;
+     Power*:Rhapsody:*:*)
+-	echo powerpc-apple-rhapsody"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=powerpc-apple-rhapsody$UNAME_RELEASE
++	;;
+     *:Rhapsody:*:*)
+-	echo "$UNAME_MACHINE"-apple-rhapsody"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-apple-rhapsody$UNAME_RELEASE
++	;;
+     arm64:Darwin:*:*)
+-	echo aarch64-apple-darwin"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=aarch64-apple-darwin$UNAME_RELEASE
++	;;
+     *:Darwin:*:*)
+ 	UNAME_PROCESSOR=`uname -p`
+ 	case $UNAME_PROCESSOR in
+@@ -1359,7 +1463,7 @@ EOF
+ 	else
+ 	    set_cc_for_build
+ 	fi
+-	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
++	if test "$CC_FOR_BUILD" != no_compiler_found; then
+ 	    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+ 		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+ 		   grep IS_64BIT_ARCH >/dev/null
+@@ -1380,109 +1484,119 @@ EOF
+ 	    # uname -m returns i386 or x86_64
+ 	    UNAME_PROCESSOR=$UNAME_MACHINE
+ 	fi
+-	echo "$UNAME_PROCESSOR"-apple-darwin"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=$UNAME_PROCESSOR-apple-darwin$UNAME_RELEASE
++	;;
+     *:procnto*:*:* | *:QNX:[0123456789]*:*)
+ 	UNAME_PROCESSOR=`uname -p`
+ 	if test "$UNAME_PROCESSOR" = x86; then
+ 		UNAME_PROCESSOR=i386
+ 		UNAME_MACHINE=pc
+ 	fi
+-	echo "$UNAME_PROCESSOR"-"$UNAME_MACHINE"-nto-qnx"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=$UNAME_PROCESSOR-$UNAME_MACHINE-nto-qnx$UNAME_RELEASE
++	;;
+     *:QNX:*:4*)
+-	echo i386-pc-qnx
+-	exit ;;
++	GUESS=i386-pc-qnx
++	;;
+     NEO-*:NONSTOP_KERNEL:*:*)
+-	echo neo-tandem-nsk"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=neo-tandem-nsk$UNAME_RELEASE
++	;;
+     NSE-*:NONSTOP_KERNEL:*:*)
+-	echo nse-tandem-nsk"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=nse-tandem-nsk$UNAME_RELEASE
++	;;
+     NSR-*:NONSTOP_KERNEL:*:*)
+-	echo nsr-tandem-nsk"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=nsr-tandem-nsk$UNAME_RELEASE
++	;;
+     NSV-*:NONSTOP_KERNEL:*:*)
+-	echo nsv-tandem-nsk"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=nsv-tandem-nsk$UNAME_RELEASE
++	;;
+     NSX-*:NONSTOP_KERNEL:*:*)
+-	echo nsx-tandem-nsk"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=nsx-tandem-nsk$UNAME_RELEASE
++	;;
+     *:NonStop-UX:*:*)
+-	echo mips-compaq-nonstopux
+-	exit ;;
++	GUESS=mips-compaq-nonstopux
++	;;
+     BS2000:POSIX*:*:*)
+-	echo bs2000-siemens-sysv
+-	exit ;;
++	GUESS=bs2000-siemens-sysv
++	;;
+     DS/*:UNIX_System_V:*:*)
+-	echo "$UNAME_MACHINE"-"$UNAME_SYSTEM"-"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-$UNAME_SYSTEM-$UNAME_RELEASE
++	;;
+     *:Plan9:*:*)
+ 	# "uname -m" is not consistent, so use $cputype instead. 386
+ 	# is converted to i386 for consistency with other x86
+ 	# operating systems.
+-	# shellcheck disable=SC2154
+-	if test "$cputype" = 386; then
++	if test "${cputype-}" = 386; then
+ 	    UNAME_MACHINE=i386
+-	else
+-	    UNAME_MACHINE="$cputype"
++	elif test "x${cputype-}" != x; then
++	    UNAME_MACHINE=$cputype
+ 	fi
+-	echo "$UNAME_MACHINE"-unknown-plan9
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-plan9
++	;;
+     *:TOPS-10:*:*)
+-	echo pdp10-unknown-tops10
+-	exit ;;
++	GUESS=pdp10-unknown-tops10
++	;;
+     *:TENEX:*:*)
+-	echo pdp10-unknown-tenex
+-	exit ;;
++	GUESS=pdp10-unknown-tenex
++	;;
+     KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
+-	echo pdp10-dec-tops20
+-	exit ;;
++	GUESS=pdp10-dec-tops20
++	;;
+     XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
+-	echo pdp10-xkl-tops20
+-	exit ;;
++	GUESS=pdp10-xkl-tops20
++	;;
+     *:TOPS-20:*:*)
+-	echo pdp10-unknown-tops20
+-	exit ;;
++	GUESS=pdp10-unknown-tops20
++	;;
+     *:ITS:*:*)
+-	echo pdp10-unknown-its
+-	exit ;;
++	GUESS=pdp10-unknown-its
++	;;
+     SEI:*:*:SEIUX)
+-	echo mips-sei-seiux"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=mips-sei-seiux$UNAME_RELEASE
++	;;
+     *:DragonFly:*:*)
+-	echo "$UNAME_MACHINE"-unknown-dragonfly"`echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`"
+-	exit ;;
++	DRAGONFLY_REL=`echo "$UNAME_RELEASE" | sed -e 's/[-(].*//'`
++	GUESS=$UNAME_MACHINE-unknown-dragonfly$DRAGONFLY_REL
++	;;
+     *:*VMS:*:*)
+ 	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+-	case "$UNAME_MACHINE" in
+-	    A*) echo alpha-dec-vms ; exit ;;
+-	    I*) echo ia64-dec-vms ; exit ;;
+-	    V*) echo vax-dec-vms ; exit ;;
++	case $UNAME_MACHINE in
++	    A*) GUESS=alpha-dec-vms ;;
++	    I*) GUESS=ia64-dec-vms ;;
++	    V*) GUESS=vax-dec-vms ;;
+ 	esac ;;
+     *:XENIX:*:SysV)
+-	echo i386-pc-xenix
+-	exit ;;
++	GUESS=i386-pc-xenix
++	;;
+     i*86:skyos:*:*)
+-	echo "$UNAME_MACHINE"-pc-skyos"`echo "$UNAME_RELEASE" | sed -e 's/ .*$//'`"
+-	exit ;;
++	SKYOS_REL=`echo "$UNAME_RELEASE" | sed -e 's/ .*$//'`
++	GUESS=$UNAME_MACHINE-pc-skyos$SKYOS_REL
++	;;
+     i*86:rdos:*:*)
+-	echo "$UNAME_MACHINE"-pc-rdos
+-	exit ;;
+-    i*86:AROS:*:*)
+-	echo "$UNAME_MACHINE"-pc-aros
+-	exit ;;
++	GUESS=$UNAME_MACHINE-pc-rdos
++	;;
++    i*86:Fiwix:*:*)
++	GUESS=$UNAME_MACHINE-pc-fiwix
++	;;
++    *:AROS:*:*)
++	GUESS=$UNAME_MACHINE-unknown-aros
++	;;
+     x86_64:VMkernel:*:*)
+-	echo "$UNAME_MACHINE"-unknown-esx
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-esx
++	;;
+     amd64:Isilon\ OneFS:*:*)
+-	echo x86_64-unknown-onefs
+-	exit ;;
++	GUESS=x86_64-unknown-onefs
++	;;
+     *:Unleashed:*:*)
+-	echo "$UNAME_MACHINE"-unknown-unleashed"$UNAME_RELEASE"
+-	exit ;;
++	GUESS=$UNAME_MACHINE-unknown-unleashed$UNAME_RELEASE
++	;;
+ esac
+ 
++# Do we have a guess based on uname results?
++if test "x$GUESS" != x; then
++    echo "$GUESS"
++    exit
++fi
++
+ # No uname command or uname output not recognized.
+ set_cc_for_build
+ cat > "$dummy.c" <<EOF
+@@ -1614,7 +1728,7 @@ main ()
+ }
+ EOF
+ 
+-$CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null && SYSTEM_NAME=`$dummy` &&
++$CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null && SYSTEM_NAME=`"$dummy"` &&
+ 	{ echo "$SYSTEM_NAME"; exit; }
+ 
+ # Apollos put the system type in the environment.
+@@ -1622,7 +1736,7 @@ test -d /usr/apollo && { echo "$ISP-apollo-$SYSTYPE"; exit; }
+ 
+ echo "$0: unable to guess system type" >&2
+ 
+-case "$UNAME_MACHINE:$UNAME_SYSTEM" in
++case $UNAME_MACHINE:$UNAME_SYSTEM in
+     mips:Linux | mips64:Linux)
+ 	# If we got here on MIPS GNU/Linux, output extra information.
+ 	cat >&2 <<EOF
+@@ -1639,14 +1753,16 @@ This script (version $timestamp), has failed to recognize the
+ operating system you are using. If your script is old, overwrite *all*
+ copies of config.guess and config.sub with the latest versions from:
+ 
+-  https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
++  https://git.savannah.gnu.org/cgit/config.git/plain/config.guess
+ and
+-  https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
++  https://git.savannah.gnu.org/cgit/config.git/plain/config.sub
+ EOF
+ 
+-year=`echo $timestamp | sed 's,-.*,,'`
++our_year=`echo $timestamp | sed 's,-.*,,'`
++thisyear=`date +%Y`
+ # shellcheck disable=SC2003
+-if test "`expr "\`date +%Y\`" - "$year"`" -lt 3 ; then
++script_age=`expr "$thisyear" - "$our_year"`
++if test "$script_age" -lt 3 ; then
+    cat >&2 <<EOF
+ 
+ If $0 has already been updated, send the following data and any
+diff --git a/build-aux/config.sub b/build-aux/config.sub
+index 3d9a8dc3d5..6ae2502753 100755
+--- a/build-aux/config.sub
++++ b/build-aux/config.sub
+@@ -1,12 +1,14 @@
+ #! /bin/sh
+ # Configuration validation subroutine script.
+-#   Copyright 1992-2020 Free Software Foundation, Inc.
++#   Copyright 1992-2023 Free Software Foundation, Inc.
+ 
+-timestamp='2020-07-10'
++# shellcheck disable=SC2006,SC2268 # see below for rationale
++
++timestamp='2023-07-31'
+ 
+ # This file is free software; you can redistribute it and/or modify it
+ # under the terms of the GNU General Public License as published by
+-# the Free Software Foundation; either version 3 of the License, or
++# the Free Software Foundation, either version 3 of the License, or
+ # (at your option) any later version.
+ #
+ # This program is distributed in the hope that it will be useful, but
+@@ -33,7 +35,7 @@ timestamp='2020-07-10'
+ # Otherwise, we print the canonical config type on stdout and succeed.
+ 
+ # You can get the latest version of this script from:
+-# https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
++# https://git.savannah.gnu.org/cgit/config.git/plain/config.sub
+ 
+ # This file is supposed to be the same for all GNU packages
+ # and recognize all the CPU types, system types and aliases
+@@ -50,6 +52,13 @@ timestamp='2020-07-10'
+ #	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+ # It is wrong to echo any other type of specification.
+ 
++# The "shellcheck disable" line above the timestamp inhibits complaints
++# about features and limitations of the classic Bourne shell that were
++# superseded or lifted in POSIX.  However, this script identifies a wide
++# variety of pre-POSIX systems that do not have POSIX shells at all, and
++# even some reasonably current systems (Solaris 10 as case-in-point) still
++# have a pre-POSIX /bin/sh.
++
+ me=`echo "$0" | sed -e 's,.*/,,'`
+ 
+ usage="\
+@@ -67,13 +76,13 @@ Report bugs and patches to <config-patches@gnu.org>."
+ version="\
+ GNU config.sub ($timestamp)
+ 
+-Copyright 1992-2020 Free Software Foundation, Inc.
++Copyright 1992-2023 Free Software Foundation, Inc.
+ 
+ This is free software; see the source for copying conditions.  There is NO
+ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+ 
+ help="
+-Try \`$me --help' for more information."
++Try '$me --help' for more information."
+ 
+ # Parse command line
+ while test $# -gt 0 ; do
+@@ -112,14 +121,16 @@ esac
+ 
+ # Split fields of configuration type
+ # shellcheck disable=SC2162
++saved_IFS=$IFS
+ IFS="-" read field1 field2 field3 field4 <<EOF
+ $1
+ EOF
++IFS=$saved_IFS
+ 
+ # Separate into logical components for further validation
+ case $1 in
+ 	*-*-*-*-*)
+-		echo Invalid configuration \`"$1"\': more than four components >&2
++		echo "Invalid configuration '$1': more than four components" >&2
+ 		exit 1
+ 		;;
+ 	*-*-*-*)
+@@ -134,7 +145,8 @@ case $1 in
+ 			nto-qnx* | linux-* | uclinux-uclibc* \
+ 			| uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* \
+ 			| netbsd*-eabi* | kopensolaris*-gnu* | cloudabi*-eabi* \
+-			| storm-chaos* | os2-emx* | rtmk-nova*)
++			| storm-chaos* | os2-emx* | rtmk-nova* | managarm-* \
++			| windows-* )
+ 				basic_machine=$field1
+ 				basic_os=$maybe_os
+ 				;;
+@@ -163,6 +175,10 @@ case $1 in
+ 						basic_machine=$field1
+ 						basic_os=$field2
+ 						;;
++					zephyr*)
++						basic_machine=$field1-unknown
++						basic_os=$field2
++						;;
+ 					# Manufacturers
+ 					dec* | mips* | sequent* | encore* | pc533* | sgi* | sony* \
+ 					| att* | 7300* | 3300* | delta* | motorola* | sun[234]* \
+@@ -922,11 +938,13 @@ case $basic_machine in
+ 
+ 	*-*)
+ 		# shellcheck disable=SC2162
++		saved_IFS=$IFS
+ 		IFS="-" read cpu vendor <<EOF
+ $basic_machine
+ EOF
++		IFS=$saved_IFS
+ 		;;
+-	# We use `pc' rather than `unknown'
++	# We use 'pc' rather than 'unknown'
+ 	# because (1) that's what they normally are, and
+ 	# (2) the word "unknown" tends to confuse beginning users.
+ 	i*86 | x86_64)
+@@ -1003,6 +1021,11 @@ case $cpu-$vendor in
+ 		;;
+ 
+ 	# Here we normalize CPU types with a missing or matching vendor
++	armh-unknown | armh-alt)
++		cpu=armv7l
++		vendor=alt
++		basic_os=${basic_os:-linux-gnueabihf}
++		;;
+ 	dpx20-unknown | dpx20-bull)
+ 		cpu=rs6000
+ 		vendor=bull
+@@ -1053,7 +1076,7 @@ case $cpu-$vendor in
+ 	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
+ 		cpu=i586
+ 		;;
+-	pentiumpro-* | p6-* | 6x86-* | athlon-* | athalon_*-*)
++	pentiumpro-* | p6-* | 6x86-* | athlon-* | athlon_*-*)
+ 		cpu=i686
+ 		;;
+ 	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
+@@ -1104,7 +1127,7 @@ case $cpu-$vendor in
+ 	xscale-* | xscalee[bl]-*)
+ 		cpu=`echo "$cpu" | sed 's/^xscale/arm/'`
+ 		;;
+-	arm64-*)
++	arm64-* | aarch64le-*)
+ 		cpu=aarch64
+ 		;;
+ 
+@@ -1165,7 +1188,7 @@ case $cpu-$vendor in
+ 			| alphapca5[67] | alpha64pca5[67] \
+ 			| am33_2.0 \
+ 			| amdgcn \
+-			| arc | arceb \
++			| arc | arceb | arc32 | arc64 \
+ 			| arm | arm[lb]e | arme[lb] | armv* \
+ 			| avr | avr32 \
+ 			| asmjs \
+@@ -1183,34 +1206,16 @@ case $cpu-$vendor in
+ 			| i370 | i*86 | i860 | i960 | ia16 | ia64 \
+ 			| ip2k | iq2000 \
+ 			| k1om \
++			| kvx \
+ 			| le32 | le64 \
+ 			| lm32 \
++			| loongarch32 | loongarch64 \
+ 			| m32c | m32r | m32rle \
+ 			| m5200 | m68000 | m680[012346]0 | m68360 | m683?2 | m68k \
+ 			| m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x \
+ 			| m88110 | m88k | maxq | mb | mcore | mep | metag \
+ 			| microblaze | microblazeel \
+-			| mips | mipsbe | mipseb | mipsel | mipsle \
+-			| mips16 \
+-			| mips64 | mips64eb | mips64el \
+-			| mips64octeon | mips64octeonel \
+-			| mips64orion | mips64orionel \
+-			| mips64r5900 | mips64r5900el \
+-			| mips64vr | mips64vrel \
+-			| mips64vr4100 | mips64vr4100el \
+-			| mips64vr4300 | mips64vr4300el \
+-			| mips64vr5000 | mips64vr5000el \
+-			| mips64vr5900 | mips64vr5900el \
+-			| mipsisa32 | mipsisa32el \
+-			| mipsisa32r2 | mipsisa32r2el \
+-			| mipsisa32r6 | mipsisa32r6el \
+-			| mipsisa64 | mipsisa64el \
+-			| mipsisa64r2 | mipsisa64r2el \
+-			| mipsisa64r6 | mipsisa64r6el \
+-			| mipsisa64sb1 | mipsisa64sb1el \
+-			| mipsisa64sr71k | mipsisa64sr71kel \
+-			| mipsr5900 | mipsr5900el \
+-			| mipstx39 | mipstx39el \
++			| mips* \
+ 			| mmix \
+ 			| mn10200 | mn10300 \
+ 			| moxie \
+@@ -1229,7 +1234,7 @@ case $cpu-$vendor in
+ 			| powerpc | powerpc64 | powerpc64le | powerpcle | powerpcspe \
+ 			| pru \
+ 			| pyramid \
+-			| riscv | riscv32 | riscv64 \
++			| riscv | riscv32 | riscv32be | riscv64 | riscv64be \
+ 			| rl78 | romp | rs6000 | rx \
+ 			| s390 | s390x \
+ 			| score \
+@@ -1241,6 +1246,7 @@ case $cpu-$vendor in
+ 			| sparcv8 | sparcv9 | sparcv9b | sparcv9v | sv1 | sx* \
+ 			| spu \
+ 			| tahoe \
++			| thumbv7* \
+ 			| tic30 | tic4x | tic54x | tic55x | tic6x | tic80 \
+ 			| tron \
+ 			| ubicom32 \
+@@ -1257,7 +1263,7 @@ case $cpu-$vendor in
+ 				;;
+ 
+ 			*)
+-				echo Invalid configuration \`"$1"\': machine \`"$cpu-$vendor"\' not recognized 1>&2
++				echo "Invalid configuration '$1': machine '$cpu-$vendor' not recognized" 1>&2
+ 				exit 1
+ 				;;
+ 		esac
+@@ -1278,34 +1284,44 @@ esac
+ 
+ # Decode manufacturer-specific aliases for certain operating systems.
+ 
+-if [ x$basic_os != x ]
++if test x$basic_os != x
+ then
+ 
+-# First recognize some ad-hoc caes, or perhaps split kernel-os, or else just
++# First recognize some ad-hoc cases, or perhaps split kernel-os, or else just
+ # set os.
+ case $basic_os in
+ 	gnu/linux*)
+ 		kernel=linux
+-		os=`echo $basic_os | sed -e 's|gnu/linux|gnu|'`
++		os=`echo "$basic_os" | sed -e 's|gnu/linux|gnu|'`
++		;;
++	os2-emx)
++		kernel=os2
++		os=`echo "$basic_os" | sed -e 's|os2-emx|emx|'`
+ 		;;
+ 	nto-qnx*)
+ 		kernel=nto
+-		os=`echo $basic_os | sed -e 's|nto-qnx|qnx|'`
++		os=`echo "$basic_os" | sed -e 's|nto-qnx|qnx|'`
+ 		;;
+ 	*-*)
+ 		# shellcheck disable=SC2162
++		saved_IFS=$IFS
+ 		IFS="-" read kernel os <<EOF
+ $basic_os
+ EOF
++		IFS=$saved_IFS
+ 		;;
+ 	# Default OS when just kernel was specified
+ 	nto*)
+ 		kernel=nto
+-		os=`echo $basic_os | sed -e 's|nto|qnx|'`
++		os=`echo "$basic_os" | sed -e 's|nto|qnx|'`
+ 		;;
+ 	linux*)
+ 		kernel=linux
+-		os=`echo $basic_os | sed -e 's|linux|gnu|'`
++		os=`echo "$basic_os" | sed -e 's|linux|gnu|'`
++		;;
++	managarm*)
++		kernel=managarm
++		os=`echo "$basic_os" | sed -e 's|managarm|mlibc|'`
+ 		;;
+ 	*)
+ 		kernel=
+@@ -1326,7 +1342,7 @@ case $os in
+ 		os=cnk
+ 		;;
+ 	solaris1 | solaris1.*)
+-		os=`echo $os | sed -e 's|solaris1|sunos4|'`
++		os=`echo "$os" | sed -e 's|solaris1|sunos4|'`
+ 		;;
+ 	solaris)
+ 		os=solaris2
+@@ -1355,7 +1371,7 @@ case $os in
+ 		os=sco3.2v4
+ 		;;
+ 	sco3.2.[4-9]*)
+-		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
++		os=`echo "$os" | sed -e 's/sco3.2./sco3.2v/'`
+ 		;;
+ 	sco*v* | scout)
+ 		# Don't match below
+@@ -1367,13 +1383,7 @@ case $os in
+ 		os=psos
+ 		;;
+ 	qnx*)
+-		case $cpu in
+-		    x86 | i*86)
+-			;;
+-		    *)
+-			os=nto-$os
+-			;;
+-		esac
++		os=qnx
+ 		;;
+ 	hiux*)
+ 		os=hiuxwe2
+@@ -1437,7 +1447,7 @@ case $os in
+ 		;;
+ 	# Preserve the version number of sinix5.
+ 	sinix5.*)
+-		os=`echo $os | sed -e 's|sinix|sysv|'`
++		os=`echo "$os" | sed -e 's|sinix|sysv|'`
+ 		;;
+ 	sinix*)
+ 		os=sysv4
+@@ -1683,11 +1693,14 @@ fi
+ 
+ # Now, validate our (potentially fixed-up) OS.
+ case $os in
+-	# Sometimes we do "kernel-abi", so those need to count as OSes.
+-	musl* | newlib* | uclibc*)
++	# Sometimes we do "kernel-libc", so those need to count as OSes.
++	musl* | newlib* | relibc* | uclibc*)
++		;;
++	# Likewise for "kernel-abi"
++	eabi* | gnueabi*)
+ 		;;
+-	# Likewise for "kernel-libc"
+-	eabi | eabihf | gnueabi | gnueabihf)
++	# VxWorks passes extra cpu info in the 4th filed.
++	simlinux | simwindows | spe)
+ 		;;
+ 	# Now accept the basic system types.
+ 	# The portable systems comes first.
+@@ -1697,19 +1710,19 @@ case $os in
+ 	     | hpux* | unos* | osf* | luna* | dgux* | auroraux* | solaris* \
+ 	     | sym* |  plan9* | psp* | sim* | xray* | os68k* | v88r* \
+ 	     | hiux* | abug | nacl* | netware* | windows* \
+-	     | os9* | macos* | osx* | ios* \
++	     | os9* | macos* | osx* | ios* | tvos* | watchos* \
+ 	     | mpw* | magic* | mmixware* | mon960* | lnews* \
+ 	     | amigaos* | amigados* | msdos* | newsos* | unicos* | aof* \
+ 	     | aos* | aros* | cloudabi* | sortix* | twizzler* \
+ 	     | nindy* | vxsim* | vxworks* | ebmon* | hms* | mvs* \
+ 	     | clix* | riscos* | uniplus* | iris* | isc* | rtu* | xenix* \
+ 	     | mirbsd* | netbsd* | dicos* | openedition* | ose* \
+-	     | bitrig* | openbsd* | solidbsd* | libertybsd* | os108* \
++	     | bitrig* | openbsd* | secbsd* | solidbsd* | libertybsd* | os108* \
+ 	     | ekkobsd* | freebsd* | riscix* | lynxos* | os400* \
+ 	     | bosx* | nextstep* | cxux* | aout* | elf* | oabi* \
+ 	     | ptx* | coff* | ecoff* | winnt* | domain* | vsta* \
+ 	     | udi* | lites* | ieee* | go32* | aux* | hcos* \
+-	     | chorusrdb* | cegcc* | glidix* \
++	     | chorusrdb* | cegcc* | glidix* | serenity* \
+ 	     | cygwin* | msys* | pe* | moss* | proelf* | rtems* \
+ 	     | midipix* | mingw32* | mingw64* | mint* \
+ 	     | uxpv* | beos* | mpeix* | udk* | moxiebox* \
+@@ -1722,7 +1735,8 @@ case $os in
+ 	     | skyos* | haiku* | rdos* | toppers* | drops* | es* \
+ 	     | onefs* | tirtos* | phoenix* | fuchsia* | redox* | bme* \
+ 	     | midnightbsd* | amdhsa* | unleashed* | emscripten* | wasi* \
+-	     | nsk* | powerunix* | genode* | zvmoe* )
++	     | nsk* | powerunix* | genode* | zvmoe* | qnx* | emx* | zephyr* \
++	     | fiwix* | mlibc* | cos* | mbr* )
+ 		;;
+ 	# This one is extra strict with allowed versions
+ 	sco3.2v2 | sco3.2v[4-9]* | sco5v6*)
+@@ -1730,8 +1744,11 @@ case $os in
+ 		;;
+ 	none)
+ 		;;
++	kernel* | msvc* )
++		# Restricted further below
++		;;
+ 	*)
+-		echo Invalid configuration \`"$1"\': OS \`"$os"\' not recognized 1>&2
++		echo "Invalid configuration '$1': OS '$os' not recognized" 1>&2
+ 		exit 1
+ 		;;
+ esac
+@@ -1739,25 +1756,52 @@ esac
+ # As a final step for OS-related things, validate the OS-kernel combination
+ # (given a valid OS), if there is a kernel.
+ case $kernel-$os in
+-	linux-gnu* | linux-dietlibc* | linux-android* | linux-newlib* | linux-musl* | linux-uclibc* )
++	linux-gnu* | linux-dietlibc* | linux-android* | linux-newlib* \
++		   | linux-musl* | linux-relibc* | linux-uclibc* | linux-mlibc* )
++		;;
++	uclinux-uclibc* )
++		;;
++	managarm-mlibc* | managarm-kernel* )
++		;;
++	windows*-gnu* | windows*-msvc*)
+ 		;;
+-	-dietlibc* | -newlib* | -musl* | -uclibc* )
++	-dietlibc* | -newlib* | -musl* | -relibc* | -uclibc* | -mlibc* )
+ 		# These are just libc implementations, not actual OSes, and thus
+ 		# require a kernel.
+-		echo "Invalid configuration \`$1': libc \`$os' needs explicit kernel." 1>&2
++		echo "Invalid configuration '$1': libc '$os' needs explicit kernel." 1>&2
++		exit 1
++		;;
++	-kernel* )
++		echo "Invalid configuration '$1': '$os' needs explicit kernel." 1>&2
++		exit 1
++		;;
++	*-kernel* )
++		echo "Invalid configuration '$1': '$kernel' does not support '$os'." 1>&2
++		exit 1
++		;;
++	*-msvc* )
++		echo "Invalid configuration '$1': '$os' needs 'windows'." 1>&2
+ 		exit 1
+ 		;;
+ 	kfreebsd*-gnu* | kopensolaris*-gnu*)
+ 		;;
++	vxworks-simlinux | vxworks-simwindows | vxworks-spe)
++		;;
+ 	nto-qnx*)
+ 		;;
++	os2-emx)
++		;;
+ 	*-eabi* | *-gnueabi*)
+ 		;;
++	none-coff* | none-elf*)
++		# None (no kernel, i.e. freestanding / bare metal),
++		# can be paired with an output format "OS"
++		;;
+ 	-*)
+ 		# Blank kernel with real OS is always fine.
+ 		;;
+ 	*-*)
+-		echo "Invalid configuration \`$1': Kernel \`$kernel' not known to work with OS \`$os'." 1>&2
++		echo "Invalid configuration '$1': Kernel '$kernel' not known to work with OS '$os'." 1>&2
+ 		exit 1
+ 		;;
+ esac
+diff --git a/build-aux/ocaml_version.m4 b/build-aux/ocaml_version.m4
+index 41776d2578..0a59107ea8 100644
+--- a/build-aux/ocaml_version.m4
++++ b/build-aux/ocaml_version.m4
+@@ -32,11 +32,11 @@ m4_define([OCAML__DEVELOPMENT_VERSION], [true])
+ # including the patchlevel, are mandatory.
+ 
+ m4_define([OCAML__VERSION_MAJOR], [5])
+-m4_define([OCAML__VERSION_MINOR], [1])
++m4_define([OCAML__VERSION_MINOR], [0])
+ m4_define([OCAML__VERSION_PATCHLEVEL], [0])
+ # Note that the OCAML__VERSION_EXTRA string defined below is always empty
+ # for officially-released versions of OCaml.
+-m4_define([OCAML__VERSION_EXTRA], [dev1-2022-06-09])
++m4_define([OCAML__VERSION_EXTRA], [jst-backport])
+ 
+ # The OCAML__VERSION_EXTRA_PREFIX macro defined below should be a
+ # single character:
+diff --git a/bytecomp/dll.ml b/bytecomp/dll.ml
+index 1675a6ca21..75809c8285 100644
+--- a/bytecomp/dll.ml
++++ b/bytecomp/dll.ml
+@@ -19,7 +19,11 @@ type dll_handle
+ type dll_address
+ type dll_mode = For_checking | For_execution
+ 
++(* BACKPORT BEGIN
+ external dll_open: string -> dll_handle = "caml_dynlink_open_lib"
++*)
++external dll_open: dll_mode -> string -> dll_handle = "caml_dynlink_open_lib"
++(* BACKPORT END *)
+ external dll_close: dll_handle -> unit = "caml_dynlink_close_lib"
+ external dll_sym: dll_handle -> string -> dll_address
+                 = "caml_dynlink_lookup_symbol"
+@@ -81,7 +85,11 @@ let open_dll mode name =
+           failwith (fullname ^ ": " ^ Binutils.error_to_string err)
+       end
+   | (None | Some (Checking _) as current), For_execution ->
++(* BACKPORT BEGIN
+       begin match dll_open fullname with
++*)
++      begin match dll_open For_execution fullname with
++(* BACKPORT END *)
+       | dll ->
+           let opened = match current with
+             | None -> List.remove_assoc fullname !opened_dlls
+diff --git a/bytecomp/emitcode.ml b/bytecomp/emitcode.ml
+index 8e600d7fa0..a71d53aecc 100644
+--- a/bytecomp/emitcode.ml
++++ b/bytecomp/emitcode.ml
+@@ -309,10 +309,14 @@ let emit_instr = function
+   | Kgetpubmet tag -> out opGETPUBMET; out_int tag; out_int 0
+   | Kgetdynmet -> out opGETDYNMET
+   | Kevent ev -> record_event ev
++(* BACKPORT BEGIN
+   | Kperform -> out opPERFORM
+   | Kresume -> out opRESUME
+   | Kresumeterm n -> out opRESUMETERM; out_int n
+   | Kreperformterm n -> out opREPERFORMTERM; out_int n
++*)
++  | Kperform | Kresume | Kresumeterm _ | Kreperformterm _ -> assert false
++(* BACKPORT END *)
+   | Kstop -> out opSTOP
+ 
+ (* Emission of a list of instructions. Include some peephole optimization. *)
+diff --git a/configure b/configure
+index b0c4c4ccfe..6a1e8a809c 100755
+Binary files a/configure and b/configure differ
+diff --git a/configure.ac b/configure.ac
+index ba0ecc38b6..66a2ecd848 100644
+--- a/configure.ac
++++ b/configure.ac
+@@ -210,6 +210,8 @@ AC_SUBST([mkexe_ldflags_exp])
+ AC_SUBST([PACKLD])
+ AC_SUBST([stdlib_manpages])
+ AC_SUBST([compute_deps])
++AC_SUBST([naked_pointers])
++AC_SUBST([naked_pointers_checker])
+ AC_SUBST([ocaml_bindir])
+ AC_SUBST([ocaml_libdir])
+ AC_SUBST([QS])
+@@ -221,6 +223,7 @@ AC_CONFIG_FILES([Makefile.config])
+ AC_CONFIG_FILES([stdlib/sys.ml])
+ AC_CONFIG_FILES([manual/src/version.tex])
+ AC_CONFIG_FILES([manual/src/html_processing/src/common.ml])
++AC_CONFIG_FILES([tools/eventlog_metadata])
+ AC_CONFIG_FILES([ocamltest/ocamltest_config.ml])
+ AC_CONFIG_FILES([utils/config.generated.ml])
+ AC_CONFIG_HEADERS([runtime/caml/m.h])
+@@ -369,15 +372,23 @@ AC_ARG_ENABLE([frame-pointers],
+   [AS_HELP_STRING([--enable-frame-pointers],
+     [use frame pointers in runtime and generated code])])
+ 
+-AC_ARG_ENABLE([naked-pointers], [],
+-  [AS_IF([test "x$enableval" != 'xno'],
+-    [AC_MSG_ERROR([Naked pointers were prohibited in OCaml 5.0.])])],
+-  [])
++dnl AC_ARG_ENABLE([naked-pointers], [],
++dnl   [AS_IF([test "x$enableval" != 'xno'],
++dnl     [AC_MSG_ERROR([Naked pointers were prohibited in OCaml 5.0.])])],
++dnl   [])
+ 
+-AC_ARG_ENABLE([naked-pointers-checker], [],
+-  [AS_IF([test "x$enableval" != 'xno'],
+-    [AC_MSG_ERROR([The naked pointers checker was removed in OCaml 5.0.])])],
+-  [])
++dnl AC_ARG_ENABLE([naked-pointers-checker], [],
++dnl   [AS_IF([test "x$enableval" != 'xno'],
++dnl     [AC_MSG_ERROR(m4_normalize([The naked pointers checker was removed in
++dnl       OCaml 5.0.]))])],
++dnl   [])
++AC_ARG_ENABLE([naked-pointers],
++  [AS_HELP_STRING([--disable-naked-pointers],
++    [do not allow naked pointers])])
++
++AC_ARG_ENABLE([naked-pointers-checker],
++  [AS_HELP_STRING([--enable-naked-pointers-checker],
++    [enable the naked pointers checker])])
+ 
+ AC_ARG_ENABLE([spacetime], [],
+   [AS_IF([test "x$enableval" != 'xno'],
+@@ -608,7 +619,8 @@ AS_CASE([$host],
+     [exeext=".exe"],
+   [exeext=''])
+ 
+-otherlibraries="dynlink runtime_events"
++dnl otherlibraries="dynlink runtime_events"
++otherlibraries="dynlink"
+ lib_dynlink=true
+ lib_runtime_events=true
+ AS_IF([test x"$enable_unix_lib" != "xno"],
+@@ -682,8 +694,9 @@ AS_CASE([$ocaml_cv_cc_vendor],
+     cc_warnings=''],
+   [outputobj='-o '
+   warn_error_flag='-Werror'
+-  cc_warnings="-Wall -Wint-conversion -Wstrict-prototypes \
+--Wold-style-definition"])
++  cc_warnings="-Wall"])
++dnl  cc_warnings="-Wall -Wint-conversion -Wstrict-prototypes \
++dnl -Wold-style-definition"])
+ 
+ AS_CASE([$enable_warn_error,OCAML__DEVELOPMENT_VERSION],
+   [yes,*|,true],
+@@ -1023,9 +1036,9 @@ AS_IF([! $arch64],
+ 
+ # Atomics library
+ 
+-AS_IF([! $arch64],
+-  [AS_CASE([$ocaml_cv_cc_vendor],
+-    [gcc-*], [cclibs="$cclibs -latomic"])])
++dnl AS_IF([! $arch64],
++dnl  [AS_CASE([$ocaml_cv_cc_vendor],
++dnl    [gcc-*], [cclibs="$cclibs -latomic"])])
+ 
+ # Support for C11 atomic types
+ 
+@@ -1183,13 +1196,14 @@ AS_CASE([$host],
+   [i686-pc-windows],
+     [arch=i386; system=win32],
+   [x86_64-pc-windows],
+-    [arch=amd64; system=win64],
++    [has_native_backend=yes; arch=amd64; system=win64],
+   [[powerpc64le*-*-linux*]],
+-    [arch=power; model=ppc64le; system=elf],
++    [has_native_backend=yes; arch=power; model=ppc64le; system=elf],
+   [[powerpc*-*-linux*]],
+-    [arch=power; AS_IF([$arch64],[model=ppc64],[model=ppc]); system=elf],
++    [has_native_backend=yes; arch=power
++    AS_IF([$arch64],[model=ppc64],[model=ppc]); system=elf],
+   [[s390x*-*-linux*]],
+-    [arch=s390x; model=z10; system=elf],
++    [has_native_backend=yes; arch=s390x; model=z10; system=elf],
+   # expected to match "gnueabihf" as well as "musleabihf"
+   [armv6*-*-linux-*eabihf],
+     [arch=arm; model=armv6; system=linux_eabihf],
+@@ -1226,9 +1240,9 @@ AS_CASE([$host],
+   [x86_64-*-linux*],
+     [has_native_backend=yes; arch=amd64; system=linux],
+   [x86_64-*-gnu*],
+-    [arch=amd64; system=gnu],
++    [has_native_backend=yes; arch=amd64; system=gnu],
+   [x86_64-*-dragonfly*],
+-    [arch=amd64; system=dragonfly],
++    [has_native_backend=yes; arch=amd64; system=dragonfly],
+   [x86_64-*-solaris*],
+     [has_native_backend=yes; arch=amd64; system=solaris],
+   [x86_64-*-freebsd*],
+@@ -1238,7 +1252,7 @@ AS_CASE([$host],
+   [x86_64-*-openbsd*],
+     [has_native_backend=yes; arch=amd64; system=openbsd],
+   [x86_64-*-haiku*],
+-    [arch=amd64; system=beos],
++    [has_native_backend=yes; arch=amd64; system=beos],
+   [arm64-*-darwin*],
+     [has_native_backend=yes; arch=arm64; system=macosx],
+   [aarch64-*-darwin*],
+@@ -1258,7 +1272,7 @@ AS_CASE([$host],
+   [x86_64-*-cygwin*],
+     [has_native_backend=yes; arch=amd64; system=cygwin],
+   [riscv64-*-linux*],
+-    [has_native_backend=yes; arch=riscv; model=riscv64; system=linux]
++    [arch=riscv; model=riscv64; system=linux]
+ )
+ 
+ AS_CASE([$ccomptype],
+@@ -1950,11 +1964,23 @@ AS_CASE([$enable_debug_runtime],
+   [no], [debug_runtime=false],
+   [debug_runtime=true])
+ 
++## Determine if system stack overflows can be detected
++
++AC_MSG_CHECKING([whether stack overflows can be detected])
++
++AS_CASE([$arch,$system],
++  [i386,linux_elf|amd64,linux|amd64,macosx \
++    |amd64,openbsd|i386,bsd_elf|arm64,linux|arm64,macosx],
++    [AC_DEFINE([HAS_STACK_OVERFLOW_DETECTION])
++    AC_MSG_RESULT([yes])],
++  [AC_MSG_RESULT([no])])
++
+ ## Determine how to link with the POSIX threads library
+ 
+ AS_CASE([$host],
+   [*-*-mingw32*|*-pc-windows],
+-    [PTHREAD_LIBS="-l:libpthread.a"],
++dnl    [PTHREAD_LIBS="-l:libpthread.a"],
++    [PTHREAD_LIBS=''],
+   [AX_PTHREAD(
+     [common_cflags="$common_cflags $PTHREAD_CFLAGS"
+     saved_CFLAGS="$CFLAGS"
+@@ -2005,6 +2031,30 @@ AS_IF([test x"$enable_frame_pointers" = "xyes"],
+   [AC_MSG_NOTICE([not using frame pointers])
+   frame_pointers=false])
+ 
++## No naked pointers
++
++AS_IF([test x"$enable_naked_pointers" = "xno" ],
++  [naked_pointers=false
++   AC_DEFINE([NO_NAKED_POINTERS])],
++  [naked_pointers=true])
++
++AS_IF([test x"$enable_naked_pointers_checker" = "xyes" ],
++  [AS_IF([test x"$enable_naked_pointers" = "xno" ],
++         [AC_MSG_ERROR(m4_normalize([
++               --enable-naked-pointers-checker and --disable-naked-pointers
++               are incompatible]))])
++   AS_CASE(["$arch","$system"],
++    [amd64,linux|amd64,macosx \
++    |amd64,openbsd|amd64,win64 \
++    |amd64,freebsd|amd64,solaris \
++    |arm64,linux|arm64,macosx],
++      [naked_pointers_checker=true
++      AC_DEFINE([NAKED_POINTERS_CHECKER])],
++    [*],
++      [AC_MSG_ERROR([naked pointers checker not supported on this platform])]
++  )],
++  [naked_pointers_checker=false])
++
+ ## Check for mmap support for huge pages and contiguous heap
+ OCAML_MMAP_SUPPORTS_HUGE_PAGES
+ 
+@@ -2151,8 +2201,10 @@ AC_CHECK_LIB(execinfo, backtrace, cclibs="$cclibs -lexecinfo",[])
+ 
+ AS_CASE([$host],
+   [*-*-mingw32*],
+-    [bytecclibs="-lws2_32 -lversion -l:libpthread.a -lgcc_eh"
+-    nativecclibs="-lws2_32 -lversion -l:libpthread.a -lgcc_eh"],
++dnl    [bytecclibs="-lws2_32 -lversion -l:libpthread.a -lgcc_eh"
++dnl    nativecclibs="-lws2_32 -lversion -l:libpthread.a -lgcc_eh"],
++    [bytecclibs="-lws2_32 -lversion -lgcc_eh"
++    nativecclibs="-lws2_32 -lversion -lgcc_eh"],
+   [*-pc-windows],
+     [bytecclibs="advapi32.lib ws2_32.lib version.lib"
+     nativecclibs="advapi32.lib ws2_32.lib version.lib"],
+diff --git a/debugger/debugcom.ml b/debugger/debugcom.ml
+index 5705cd73db..e852b3bb97 100644
+--- a/debugger/debugcom.ml
++++ b/debugger/debugcom.ml
+@@ -52,6 +52,7 @@ type pc =
+ module Sp = struct
+ 
+   (* Position in the debuggee's stack. *)
++(* BACKPORT BEGIN
+   type t = {
+     block : int;
+     offset : int;
+@@ -65,6 +66,13 @@ module Sp = struct
+     match Stdlib.compare sp1.block sp2.block with
+     | 0 -> Stdlib.compare sp1.offset sp2.offset
+     | x -> x
++*)
++  type t = int
++
++  let null = 0
++  let base _ _ = assert false
++  let compare = Int.compare
++(* BACKPORT END *)
+ 
+ end
+ 
+@@ -72,7 +80,11 @@ end
+    Numbering starts at 1 and the runtime registers 2 fragments before
+    the main program: one for uncaught exceptions and one for callbacks.
+ *)
++(* BACKPOR BEGIN
+ let main_frag = 3
++*)
++let main_frag = 0
++(* BACKPORT END *)
+ 
+ let set_event {frag; pos} =
+   output_char !conn.io_out 'e';
+@@ -137,13 +149,21 @@ let do_go_smallint n =
+          |  c  -> Misc.fatal_error (Printf.sprintf "Debugcom.do_go %c" c)
+        in
+        let event_counter = input_binary_int !conn.io_in in
++(* BACKPORT BEGIN
+        let block = input_binary_int !conn.io_in in
+        let offset = input_binary_int !conn.io_in in
++*)
++       let rep_stack_pointer = input_binary_int !conn.io_in in
++(* BACKPORT END *)
+        let frag = input_binary_int !conn.io_in in
+        let pos = input_binary_int !conn.io_in in
+        { rep_type = summary;
+          rep_event_count = Int64.of_int event_counter;
++(* BACKPORT BEGIN
+          rep_stack_pointer = Sp.{block; offset};
++*)
++         rep_stack_pointer;
++(* BACKPORT END *)
+          rep_program_pointer = {frag; pos} })
+ 
+ let rec do_go n =
+@@ -192,11 +212,19 @@ let wait_child chan =
+ let initial_frame () =
+   output_char !conn.io_out '0';
+   flush !conn.io_out;
++(* BACKPORT BEGIN
+   let block = input_binary_int !conn.io_in in
+   let offset = input_binary_int !conn.io_in in
++*)
++  let stack_pos = input_binary_int !conn.io_in in
++(* BACKPORT END *)
+   let frag = input_binary_int !conn.io_in in
+   let pos = input_binary_int !conn.io_in in
++(* BACKPORT BEGIN
+   (Sp.{block; offset}, {frag; pos})
++*)
++  (stack_pos, {frag; pos})
++(* BACKPOR END *)
+ 
+ let set_initial_frame () =
+   ignore(initial_frame ())
+@@ -209,9 +237,14 @@ let up_frame stacksize =
+   output_char !conn.io_out 'U';
+   output_binary_int !conn.io_out stacksize;
+   flush !conn.io_out;
++(* BACKPORT BEGIN
+   let block = input_binary_int !conn.io_in in
+   let offset = input_binary_int !conn.io_in in
++*)
++  let stack_pos = input_binary_int !conn.io_in in
++(* BACKPORT END *)
+   let frag, pos =
++(* BACKPORT BEGIN
+     if block = -1 then
+     begin
+       assert (offset = -1);
+@@ -221,31 +254,56 @@ let up_frame stacksize =
+       let pos = input_binary_int !conn.io_in in
+       frag, pos
+     end
++*)
++    if stack_pos = -1
++    then 0, 0
++    else let frag = input_binary_int !conn.io_in in
++         let pos = input_binary_int !conn.io_in in
++         frag, pos
++(* BACKPORT END *)
+   in
++(* BACKPORT BEGIN
+   (Sp.{block; offset}, { frag; pos })
++*)
++  (stack_pos, { frag; pos })
++(* BACKPORT END *)
+ 
+ (* Get and set the current frame position *)
+ 
+ let get_frame () =
+   output_char !conn.io_out 'f';
+   flush !conn.io_out;
++  let stack_pos = input_binary_int !conn.io_in in
++(*
+   let block = input_binary_int !conn.io_in in
+   let offset = input_binary_int !conn.io_in in
++*)
+   let frag = input_binary_int !conn.io_in in
+   let pos = input_binary_int !conn.io_in in
++(*
+   (Sp.{block; offset}, {frag; pos})
++*)
++  (stack_pos, {frag; pos})
+ 
+ let set_frame stack_pos =
+   output_char !conn.io_out 'S';
++(* BACKPORT BEGIN
+   output_binary_int !conn.io_out stack_pos.Sp.block;
+   output_binary_int !conn.io_out stack_pos.Sp.offset
++*)
++  output_binary_int !conn.io_out stack_pos
++(* BACKPORT END *)
+ 
+ (* Set the trap barrier to given stack position. *)
+ 
+ let set_trap_barrier pos =
+   output_char !conn.io_out 'b';
++(* BACKPORT BEGIN
+   output_binary_int !conn.io_out pos.Sp.block;
+   output_binary_int !conn.io_out pos.Sp.offset
++*)
++  output_binary_int !conn.io_out pos
++(* BACKPORT END *)
+ 
+ (* Handling of remote values *)
+ 
+diff --git a/debugger/debugcom.mli b/debugger/debugcom.mli
+index 4e022dbf10..e9d19edae1 100644
+--- a/debugger/debugcom.mli
++++ b/debugger/debugcom.mli
+@@ -17,7 +17,11 @@
+ (* Low-level communication with the debuggee *)
+ 
+ module Sp : sig
++(* BACKPORT BEGIN
+   type t
++*)
++  type t = int
++(* BACKPORT END *)
+   val null : t
+   val base : t -> int -> t
+   val compare : t -> t -> int
+diff --git a/debugger/frames.ml b/debugger/frames.ml
+index d590367d6d..364fa4ca71 100644
+--- a/debugger/frames.ml
++++ b/debugger/frames.ml
+@@ -53,7 +53,11 @@ let selected_event_is_before () =
+ let rec move_up frame_count event =
+   if frame_count <= 0 then event else begin
+     let (sp, pc) = up_frame event.ev_ev.ev_stacksize in
++(* BACKPORT BEGIN
+     if sp = Sp.null then raise Not_found;
++*)
++    if sp < Sp.null then raise Not_found;
++(* BACKPORT END *)
+     move_up (frame_count - 1) (any_event_at_pc pc)
+   end
+ 
+@@ -113,7 +117,11 @@ let do_backtrace action =
+       begin try
+         while action (Some !event) do
+           let (sp, pc) = up_frame !event.ev_ev.ev_stacksize in
++(* BACKPORT BEGIN
+           if sp = Sp.null then raise Exit;
++*)
++          if sp < Sp.null then raise Exit;
++(* BACKPORT END *)
+           event := any_event_at_pc pc
+         done
+       with Exit -> ()
+diff --git a/debugger/time_travel.ml b/debugger/time_travel.ml
+index b05d05767b..7a2665d305 100644
+--- a/debugger/time_travel.ml
++++ b/debugger/time_travel.ml
+@@ -555,7 +555,11 @@ let finish () =
+   | Some {ev_ev={ev_stacksize}} ->
+       set_initial_frame();
+       let (frame, pc) = up_frame ev_stacksize in
++(* BACKPORT BEGIN
+       if frame = Sp.null then begin
++*)
++      if frame < Sp.null then begin
++(* BACKPORT END *)
+         prerr_endline "`finish' not meaningful in outermost frame.";
+         raise Toplevel
+       end;
+@@ -598,9 +602,14 @@ let next_1 () =
+         | Some {ev_ev={ev_stacksize=ev_stacksize2}} ->
+             let (frame2, _pc2) = initial_frame() in
+             (* Call `finish' if we've entered a function. *)
++(* BACKPORT BEGIN
+             if frame1 <> Sp.null && frame2 <> Sp.null &&
+                Sp.(compare (base frame2 ev_stacksize2)
+                      (base frame1 ev_stacksize1)) > 0
++*)
++            if frame1 >= 0 && frame2 >= 0 &&
++               frame2 - ev_stacksize2 > frame1 - ev_stacksize1
++(* BACKPORT END *)
+             then finish()
+       end
+ 
+@@ -623,7 +632,11 @@ let start () =
+   | Some {ev_ev={ev_stacksize}} ->
+       let (frame, _) = initial_frame() in
+       let (frame', pc) = up_frame ev_stacksize in
++(* BACKPORT BEGIN
+       if frame' = Sp.null then begin
++*)
++      if frame' < Sp.null then begin
++(* BACKPORT END *)
+         prerr_endline "`start not meaningful in outermost frame.";
+         raise Toplevel
+       end;
+@@ -645,7 +658,11 @@ let start () =
+             step _minus1;
+             (not !interrupted)
+               &&
++(* BACKPORT BEGIN
+             Sp.(compare (base frame' nargs) (base frame ev_stacksize)) > 0
++*)
++            (frame' - nargs > frame - ev_stacksize)
++(* BACKPORT END *)
+         | _ ->
+             false
+       do
+@@ -667,9 +684,14 @@ let previous_1 () =
+         | Some {ev_ev={ev_stacksize=ev_stacksize2}} ->
+             let (frame2, _pc2) = initial_frame() in
+             (* Call `start' if we've entered a function. *)
++(* BACKPORT BEGIN
+             if frame1 <> Sp.null && frame2 <> Sp.null &&
+               Sp.(compare (base frame2 ev_stacksize2)
+                     (base frame1 ev_stacksize1)) > 0
++*)
++            if frame1 >= 0 && frame2 >= 0 &&
++               frame2 - ev_stacksize2 > frame1 - ev_stacksize1
++(* BACKPORT END *)
+             then start()
+       end
+ 
+diff --git a/diff-against-4.14-runtime.diff b/diff-against-4.14-runtime.diff
+new file mode 100644
+index 0000000000..7fe9834336
+--- /dev/null
++++ b/diff-against-4.14-runtime.diff
+@@ -0,0 +1,2452 @@
++diff --git a/otherlibs/systhreads/st_posix.h b/otherlibs/systhreads/st_posix.h
++index 957f4717b6..09b243f6a5 100644
++--- a/otherlibs/systhreads/st_posix.h
+++++ b/otherlibs/systhreads/st_posix.h
++@@ -446,7 +446,7 @@ static value st_encode_sigset(sigset_t * set)
++ 
++ static int sigmask_cmd[3] = { SIG_SETMASK, SIG_BLOCK, SIG_UNBLOCK };
++ 
++-value caml_thread_sigmask(value cmd, value sigs) /* ML */
+++value caml_thread_sigmask(value cmd, value sigs)
++ {
++   int how;
++   sigset_t set, oldset;
++@@ -463,7 +463,7 @@ value caml_thread_sigmask(value cmd, value sigs) /* ML */
++   return st_encode_sigset(&oldset);
++ }
++ 
++-value caml_wait_signal(value sigs) /* ML */
+++value caml_wait_signal(value sigs)
++ {
++ #ifdef HAS_SIGWAIT
++   sigset_t set;
++diff --git a/otherlibs/systhreads/st_stubs.c b/otherlibs/systhreads/st_stubs.c
++index 043e07031e..9dc38727a5 100644
++--- a/otherlibs/systhreads/st_stubs.c
+++++ b/otherlibs/systhreads/st_stubs.c
++@@ -430,7 +430,7 @@ static void caml_thread_reinitialize(void)
++ 
++ /* Initialize the thread machinery */
++ 
++-CAMLprim value caml_thread_initialize(value unit)   /* ML */
+++CAMLprim value caml_thread_initialize(value unit)
++ {
++   /* Protect against repeated initialization (PR#3532) */
++   if (curr_thread != NULL) return Val_unit;
++@@ -483,7 +483,7 @@ CAMLprim value caml_thread_initialize(value unit)   /* ML */
++    thread take 25ms on average / 50ms in the worst case, so we don't do it on
++    program exit. */
++ 
++-CAMLprim value caml_thread_cleanup(value unit)   /* ML */
+++CAMLprim value caml_thread_cleanup(value unit)
++ {
++   if (caml_tick_thread_running){
++     caml_tick_thread_stop = 1;
++@@ -556,7 +556,7 @@ static ST_THREAD_FUNCTION caml_thread_start(void * arg)
++   return 0;
++ }
++ 
++-CAMLprim value caml_thread_new(value clos)          /* ML */
+++CAMLprim value caml_thread_new(value clos)
++ {
++   caml_thread_t th;
++   st_retcode err;
++@@ -663,7 +663,7 @@ CAMLexport int caml_c_thread_unregister(void)
++ 
++ /* Return the current thread */
++ 
++-CAMLprim value caml_thread_self(value unit)         /* ML */
+++CAMLprim value caml_thread_self(value unit)
++ {
++   if (curr_thread == NULL)
++     caml_invalid_argument("Thread.self: not initialized");
++@@ -672,14 +672,14 @@ CAMLprim value caml_thread_self(value unit)         /* ML */
++ 
++ /* Return the identifier of a thread */
++ 
++-CAMLprim value caml_thread_id(value th)          /* ML */
+++CAMLprim value caml_thread_id(value th)
++ {
++   return Ident(th);
++ }
++ 
++ /* Print uncaught exception and backtrace */
++ 
++-CAMLprim value caml_thread_uncaught_exception(value exn)  /* ML */
+++CAMLprim value caml_thread_uncaught_exception(value exn)
++ {
++   char * msg = caml_format_exception(exn);
++   fprintf(stderr, "Thread %d killed on uncaught exception %s\n",
++@@ -692,7 +692,7 @@ CAMLprim value caml_thread_uncaught_exception(value exn)  /* ML */
++ 
++ /* Terminate current thread */
++ 
++-CAMLprim value caml_thread_exit(value unit)   /* ML */
+++CAMLprim value caml_thread_exit(value unit)
++ {
++   struct longjmp_buffer * exit_buf = NULL;
++ 
++@@ -723,7 +723,7 @@ CAMLprim value caml_thread_exit(value unit)   /* ML */
++ 
++ /* Allow re-scheduling */
++ 
++-CAMLprim value caml_thread_yield(value unit)        /* ML */
+++CAMLprim value caml_thread_yield(value unit)
++ {
++   if (st_masterlock_waiters(&caml_master_lock) == 0) return Val_unit;
++ 
++@@ -744,7 +744,7 @@ CAMLprim value caml_thread_yield(value unit)        /* ML */
++ 
++ /* Suspend the current thread until another thread terminates */
++ 
++-CAMLprim value caml_thread_join(value th)          /* ML */
+++CAMLprim value caml_thread_join(value th)
++ {
++   st_retcode rc = caml_threadstatus_wait(Terminated(th));
++   st_check_error(rc, "Thread.join");
++@@ -783,7 +783,7 @@ static struct custom_operations caml_mutex_ops = {
++   custom_fixed_length_default
++ };
++ 
++-CAMLprim value caml_mutex_new(value unit)        /* ML */
+++CAMLprim value caml_mutex_new(value unit)
++ {
++   st_mutex mut = NULL;          /* suppress warning */
++   value wrapper;
++@@ -794,7 +794,7 @@ CAMLprim value caml_mutex_new(value unit)        /* ML */
++   return wrapper;
++ }
++ 
++-CAMLprim value caml_mutex_lock(value wrapper)     /* ML */
+++CAMLprim value caml_mutex_lock(value wrapper)
++ {
++   st_mutex mut = Mutex_val(wrapper);
++   st_retcode retcode;
++@@ -811,7 +811,7 @@ CAMLprim value caml_mutex_lock(value wrapper)     /* ML */
++   return Val_unit;
++ }
++ 
++-CAMLprim value caml_mutex_unlock(value wrapper)           /* ML */
+++CAMLprim value caml_mutex_unlock(value wrapper)
++ {
++   st_mutex mut = Mutex_val(wrapper);
++   st_retcode retcode;
++@@ -821,7 +821,7 @@ CAMLprim value caml_mutex_unlock(value wrapper)           /* ML */
++   return Val_unit;
++ }
++ 
++-CAMLprim value caml_mutex_try_lock(value wrapper)           /* ML */
+++CAMLprim value caml_mutex_try_lock(value wrapper)
++ {
++   st_mutex mut = Mutex_val(wrapper);
++   st_retcode retcode;
++@@ -863,7 +863,7 @@ static struct custom_operations caml_condition_ops = {
++   custom_fixed_length_default
++ };
++ 
++-CAMLprim value caml_condition_new(value unit)        /* ML */
+++CAMLprim value caml_condition_new(value unit)
++ {
++   st_condvar cond = NULL;       /* suppress warning */
++   value wrapper;
++@@ -874,7 +874,7 @@ CAMLprim value caml_condition_new(value unit)        /* ML */
++   return wrapper;
++ }
++ 
++-CAMLprim value caml_condition_wait(value wcond, value wmut)           /* ML */
+++CAMLprim value caml_condition_wait(value wcond, value wmut)
++ {
++   st_condvar cond = Condition_val(wcond);
++   st_mutex mut = Mutex_val(wmut);
++@@ -889,14 +889,14 @@ CAMLprim value caml_condition_wait(value wcond, value wmut)           /* ML */
++   return Val_unit;
++ }
++ 
++-CAMLprim value caml_condition_signal(value wrapper)           /* ML */
+++CAMLprim value caml_condition_signal(value wrapper)
++ {
++   st_check_error(st_condvar_signal(Condition_val(wrapper)),
++                  "Condition.signal");
++   return Val_unit;
++ }
++ 
++-CAMLprim value caml_condition_broadcast(value wrapper)           /* ML */
+++CAMLprim value caml_condition_broadcast(value wrapper)
++ {
++   st_check_error(st_condvar_broadcast(Condition_val(wrapper)),
++                  "Condition.broadcast");
++diff --git a/otherlibs/systhreads/st_win32.h b/otherlibs/systhreads/st_win32.h
++index 3f598a715d..21eb674fc5 100644
++--- a/otherlibs/systhreads/st_win32.h
+++++ b/otherlibs/systhreads/st_win32.h
++@@ -525,13 +525,13 @@ static DWORD st_atfork(void (*fn)(void))
++ 
++ /* Signal handling -- none under Win32 */
++ 
++-value caml_thread_sigmask(value cmd, value sigs) /* ML */
+++value caml_thread_sigmask(value cmd, value sigs)
++ {
++   caml_invalid_argument("Thread.sigmask not implemented");
++   return Val_int(0);            /* not reached */
++ }
++ 
++-value caml_wait_signal(value sigs) /* ML */
+++value caml_wait_signal(value sigs)
++ {
++   caml_invalid_argument("Thread.wait_signal not implemented");
++   return Val_int(0);            /* not reached */
++diff --git a/runtime/HACKING.adoc b/runtime/HACKING.adoc
++new file mode 100644
++index 0000000000..bf18b5a7d1
++--- /dev/null
+++++ b/runtime/HACKING.adoc
++@@ -0,0 +1,156 @@
+++= Tips on hacking the OCaml runtime system =
+++
+++== Linking a test program with the debug runtime ==
+++
+++Suppose you have a self-contained OCaml program `test.ml` that
+++crashes, you are working on a development repository (not an installed
+++version of your system). You probably want to run `test.ml` against
+++the "debug runtime", which in particular activates the `CAMLassert`
+++debug assertions.
+++
+++If you want to use the bytecode compiler:
+++
+++----
+++# build the runtime
+++make runtime -j
+++
+++# compile as usual
+++./ocamlc.opt -nostdlib -I stdlib test.ml -o test
+++
+++# run with the debug runtime (ocamlrund)
+++./runtime/ocamlrund ./test
+++----
+++
+++If you want to use the native compiler:
+++
+++----
+++# build the native runtime
+++make runtimeopt -j
+++
+++# compile with "-runtime-variant d"
+++./ocamlopt.opt -nostdlib -I stdlib -runtime-variant d -I runtime test.ml -o test
+++
+++./test
+++----
+++
+++Note that the debug runtime does extra work, so it may slow down your
+++program -- and sometimes make the issue you are trying to debug
+++vanish.
+++
+++== GC messages ==
+++
+++The GC can send various messages about what it is doing, enabled with
+++the "v" option of OCAMLRUNPARAM. Various options are more or less
+++documented in
+++link:https://ocaml.org/manual/runtime.html#s:ocamlrun-options[].
+++You can enable all printing with
+++
+++----
+++OCAMLRUNPARAM="v=0xffffffff" ./test
+++----
+++
+++Note: `caml_gc_log` can be used to show log messages prefixed with the
+++thread number, and it corresponds to the more precise setting
+++`v=0x800`.
+++
+++== Heap verification ==
+++
+++Another useful OCAMLRUNPARAM setting is `V=1`, which enables
+++additional sanity checks on the heap during major GC cycles.
+++
+++----
+++OCAMLRUNPARAM="V=1" ./test
+++----
+++
+++== Getting stack traces after assertion failures (Linux) ==
+++
+++The output of a crashing OCaml program may end up like this:
+++
+++----
+++[03] file domain.c; line 404 ### Assertion failed: domain_state->young_start == NULL
+++Aborted (core dumped)
+++----
+++
+++The message "core dumped" indicates that some debugging information was kept on the disk.
+++
+++On Linux, systemd-enabled systems tend to use a systemd tool (of course!) to store core dumps.
+++
+++----
+++# ask your system how core dumps are handled.
+++$ cat /proc/sys/kernel/core_pattern
+++|/usr/lib/systemd/systemd-coredump %P %u %g %s %t %c %h
+++----
+++
+++If your system is also using `systemd-coredump`, then the command
+++`coredumpctl dump` will show you information about the last "core
+++dump".
+++
+++----
+++$ $ coredumpctl dump
+++           PID: 678260 (Domain0)
+++           UID: 1000 (gasche)
+++           GID: 1000 (gasche)
+++        Signal: 6 (ABRT)
+++     Timestamp: Fri 2022-02-25 09:30:32 CET (4min 30s ago)
+++  Command Line: ./test
+++    Executable: /home/gasche/Prog/ocaml/github-max_domains/test
+++ Control Group: [...]
+++                [...]
+++     Disk Size: 133.0K
+++       Message: Process 678260 (Domain0) of user 1000 dumped core.
+++
+++                Stack trace of thread 678266:
+++                #0  0x00007f60ee4842a2 raise (libc.so.6 + 0x3d2a2)
+++                #1  0x00007f60ee46d8a4 abort (libc.so.6 + 0x268a4)
+++                #2  0x0000000000475022 n/a (/home/gasche/Prog/ocaml/github-max_domains/test + 0x75022)
+++Refusing to dump core to tty (use shell redirection or specify --output).
+++----
+++
+++You can get a full backtrace using `echo bt | coredumpctl debug`:
+++
+++----
+++$ echo bt | coredumpctl debug
+++[...]
+++Core was generated by `./test'.
+++Program terminated with signal SIGABRT, Aborted.
+++#0  0x00007f60ee4842a2 in raise () from /lib64/libc.so.6
+++[Current thread is 1 (Thread 0x7f60d77fe640 (LWP 678266))]
+++Missing separate debuginfos, use: dnf debuginfo-install glibc-2.33-20.fc34.x86_64
+++(gdb) #0  0x00007f60ee4842a2 in raise () from /lib64/libc.so.6
+++#1  0x00007f60ee46d8a4 in abort () from /lib64/libc.so.6
+++#2  0x0000000000475022 in caml_failed_assert (
+++    expr=expr@entry=0x488498 "domain_state->young_start == NULL",
+++    file_os=file_os@entry=0x488218 "domain.c", line=line@entry=404) at misc.c:56
+++#3  0x0000000000461831 in caml_free_minor_heap () at domain.c:404
+++#4  0x000000000046237b in caml_reallocate_minor_heap (wsize=wsize@entry=786432) at domain.c:469
+++#5  0x0000000000474404 in caml_set_minor_heap_size (wsize=wsize@entry=786432) at minor_gc.c:130
+++#6  0x00000000004696b3 in caml_gc_set (v=<optimized out>) at gc_ctrl.c:222
+++#7  <signal handler called>
+++#8  0x000000000042a3b2 in camlTest__set_gc_280 () at test.ml:17
+++#9  0x000000000042a818 in camlTest__fun_529 () at test.ml:39
+++#10 0x000000000044947a in camlStdlib__Domain__body_694 () at domain.ml:204
+++#11 <signal handler called>
+++#12 0x000000000045fe38 in caml_callback_exn (closure=<optimized out>, arg=<optimized out>, arg@entry=1) at callback.c:169
+++#13 0x0000000000460369 in caml_callback (closure=<optimized out>, arg=arg@entry=1) at callback.c:253
+++#14 0x0000000000461f6a in domain_thread_func (v=0x7ffdd7357bb0) at domain.c:1034
+++#15 0x00007f60ee61f299 in start_thread () from /lib64/libpthread.so.0
+++#16 0x00007f60ee547353 in clone () from /lib64/libc.so.6
+++(gdb) quit
+++----
+++
+++== Using `rr` for deterministic replay debugging ==
+++
+++There is a lot of information on how to use `rr` to debug the OCaml
+++runtime on the OCaml Multicore wiki:
+++link:https://github.com/ocaml-multicore/ocaml-multicore/wiki/Debugging-the-OCaml-Multicore-runtime#rr[].
+++
+++TODO: it would be nice to migrate some information here.
+++
+++== Compiling with sanitizers ==
+++
+++TODO: I would be curious to know!
+++
+++(For the brave there are some scripts in
+++link:../tools/ci/inria/sanitizers/script[], but you probably don't
+++want to run them directly, in particular they will `git clean -xfd`,
+++destroying changed/uncommitted files in your development repository!)
++diff --git a/runtime/Makefile b/runtime/Makefile
++deleted file mode 100644
++index f5c08d8798..0000000000
++--- a/runtime/Makefile
+++++ /dev/null
++@@ -1,421 +0,0 @@
++-#**************************************************************************
++-#*                                                                        *
++-#*                                 OCaml                                  *
++-#*                                                                        *
++-#*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *
++-#*                                                                        *
++-#*   Copyright 1999 Institut National de Recherche en Informatique et     *
++-#*     en Automatique.                                                    *
++-#*                                                                        *
++-#*   All rights reserved.  This file is distributed under the terms of    *
++-#*   the GNU Lesser General Public License version 2.1, with the          *
++-#*   special exception on linking described in the file LICENSE.          *
++-#*                                                                        *
++-#**************************************************************************
++-
++-ROOTDIR = ..
++-
++-include $(ROOTDIR)/Makefile.common
++-
++-# Lists of source files
++-
++-BYTECODE_C_SOURCES := $(addsuffix .c, \
++-  interp misc stacks fix_code startup_aux startup_byt freelist major_gc \
++-  minor_gc memory alloc roots_byt globroots fail_byt signals \
++-  signals_byt printexc backtrace_byt backtrace compare ints eventlog \
++-  floats str array io extern intern hash sys meta parsing gc_ctrl md5 obj \
++-  lexing callback debugger weak compact finalise custom dynlink \
++-  afl $(UNIX_OR_WIN32) bigarray main memprof domain \
++-  skiplist codefrag)
++-
++-NATIVE_C_SOURCES := $(addsuffix .c, \
++-  startup_aux startup_nat main fail_nat roots_nat signals \
++-  signals_nat misc freelist major_gc minor_gc memory alloc compare ints \
++-  floats str array io extern intern hash sys parsing gc_ctrl eventlog md5 obj \
++-  lexing $(UNIX_OR_WIN32) printexc callback weak compact finalise custom \
++-  globroots backtrace_nat backtrace dynlink_nat debugger meta \
++-  dynlink clambda_checks afl bigarray \
++-  memprof domain skiplist codefrag)
++-
++-# Header files generated by configure
++-CONFIGURED_HEADERS := caml/m.h caml/s.h caml/version.h
++-
++-# Header files generated by make
++-BUILT_HEADERS := caml/opnames.h caml/jumptbl.h build_config.h
++-
++-ifeq "$(TOOLCHAIN)" "msvc"
++-ASM_EXT := asm
++-ASM_SOURCES := $(ARCH)nt.$(ASM_EXT)
++-else
++-ASM_EXT := S
++-ASM_SOURCES := $(ARCH).$(ASM_EXT)
++-endif
++-
++-# Targets to build and install
++-
++-PROGRAMS := ocamlrun$(EXE)
++-BYTECODE_STATIC_LIBRARIES := ld.conf libcamlrun.$(A)
++-BYTECODE_SHARED_LIBRARIES :=
++-NATIVE_STATIC_LIBRARIES := libasmrun.$(A)
++-NATIVE_SHARED_LIBRARIES :=
++-
++-ifeq "$(RUNTIMED)" "true"
++-PROGRAMS += ocamlrund$(EXE)
++-BYTECODE_STATIC_LIBRARIES += libcamlrund.$(A)
++-NATIVE_STATIC_LIBRARIES += libasmrund.$(A)
++-endif
++-
++-ifeq "$(INSTRUMENTED_RUNTIME)" "true"
++-PROGRAMS += ocamlruni$(EXE)
++-BYTECODE_STATIC_LIBRARIES += libcamlruni.$(A)
++-NATIVE_STATIC_LIBRARIES += libasmruni.$(A)
++-endif
++-
++-ifeq "$(UNIX_OR_WIN32)" "unix"
++-ifeq "$(SUPPORTS_SHARED_LIBRARIES)" "true"
++-BYTECODE_STATIC_LIBRARIES += libcamlrun_pic.$(A)
++-BYTECODE_SHARED_LIBRARIES += libcamlrun_shared.$(SO)
++-NATIVE_STATIC_LIBRARIES += libasmrun_pic.$(A)
++-NATIVE_SHARED_LIBRARIES += libasmrun_shared.$(SO)
++-endif
++-endif
++-
++-# List of object files for each target
++-
++-ASM_OBJECTS := $(ASM_SOURCES:.$(ASM_EXT)=.$(O))
++-
++-libcamlrun_OBJECTS := $(BYTECODE_C_SOURCES:.c=.b.$(O))
++-
++-libcamlrun_non_shared_OBJECTS := \
++-  $(subst $(UNIX_OR_WIN32).b.$(O),$(UNIX_OR_WIN32)_non_shared.b.$(O), \
++-          $(libcamlrun_OBJECTS))
++-
++-libcamlrund_OBJECTS := $(BYTECODE_C_SOURCES:.c=.bd.$(O)) \
++-  instrtrace.bd.$(O)
++-
++-libcamlruni_OBJECTS := $(BYTECODE_C_SOURCES:.c=.bi.$(O))
++-
++-libcamlrunpic_OBJECTS := $(BYTECODE_C_SOURCES:.c=.bpic.$(O))
++-
++-libasmrun_OBJECTS := $(NATIVE_C_SOURCES:.c=.n.$(O)) $(ASM_OBJECTS)
++-
++-libasmrund_OBJECTS := $(NATIVE_C_SOURCES:.c=.nd.$(O)) $(ASM_OBJECTS)
++-
++-libasmruni_OBJECTS := $(NATIVE_C_SOURCES:.c=.ni.$(O)) $(ASM_OBJECTS)
++-
++-libasmrunpic_OBJECTS := $(NATIVE_C_SOURCES:.c=.npic.$(O)) \
++-  $(ASM_OBJECTS:.$(O)=_libasmrunpic.$(O))
++-
++-# General (non target-specific) assembler and compiler flags
++-
++-ifneq "$(CCOMPTYPE)" "msvc"
++-OC_CFLAGS += -g
++-endif
++-
++-OC_CPPFLAGS += -DCAMLDLLIMPORT=
++-
++-OC_NATIVE_CPPFLAGS = -DNATIVE_CODE -DTARGET_$(ARCH)
++-
++-ifeq "$(UNIX_OR_WIN32)" "unix"
++-OC_NATIVE_CPPFLAGS += -DMODEL_$(MODEL)
++-endif
++-
++-OC_NATIVE_CPPFLAGS += -DSYS_$(SYSTEM)
++-
++-OC_DEBUG_CPPFLAGS=-DDEBUG
++-OC_INSTR_CPPFLAGS=-DCAML_INSTR
++-
++-ifeq "$(TOOLCHAIN)" "msvc"
++-ASMFLAGS=
++-endif
++-
++-ASPPFLAGS = -DSYS_$(SYSTEM) -I$(ROOTDIR)/runtime
++-ifeq "$(UNIX_OR_WIN32)" "unix"
++-ASPPFLAGS += -DMODEL_$(MODEL)
++-endif
++-
++-# Commands used to build native libraries
++-
++-LIBS := $(BYTECCLIBS)
++-
++-ifeq "$(UNIX_OR_WIN32)" "win32"
++-LIBS += $(EXTRALIBS)
++-endif
++-
++-# Build, install and clean targets
++-
++-.PHONY: all
++-all: $(BYTECODE_STATIC_LIBRARIES) $(BYTECODE_SHARED_LIBRARIES) $(PROGRAMS) \
++-     sak$(EXE)
++-
++-.PHONY: allopt
++-ifneq "$(NATIVE_COMPILER)" "false"
++-allopt: $(NATIVE_STATIC_LIBRARIES) $(NATIVE_SHARED_LIBRARIES)
++-else
++-allopt:
++-	$(error The build has been configured with --disable-native-compiler)
++-endif
++-
++-INSTALL_INCDIR=$(INSTALL_LIBDIR)/caml
++-.PHONY: install
++-install:
++-	$(INSTALL_PROG) $(PROGRAMS) "$(INSTALL_BINDIR)"
++-	$(INSTALL_DATA) $(BYTECODE_STATIC_LIBRARIES) "$(INSTALL_LIBDIR)"
++-ifneq "$(BYTECODE_SHARED_LIBRARIES)" ""
++-	$(INSTALL_PROG) $(BYTECODE_SHARED_LIBRARIES) "$(INSTALL_LIBDIR)"
++-endif
++-	mkdir -p "$(INSTALL_INCDIR)"
++-	$(INSTALL_DATA) caml/domain_state.tbl caml/*.h "$(INSTALL_INCDIR)"
++-
++-.PHONY: installopt
++-installopt:
++-	$(INSTALL_DATA) $(NATIVE_STATIC_LIBRARIES) "$(INSTALL_LIBDIR)"
++-ifneq "$(NATIVE_SHARED_LIBRARIES)" ""
++-	$(INSTALL_PROG) $(NATIVE_SHARED_LIBRARIES) "$(INSTALL_LIBDIR)"
++-endif
++-
++-.PHONY: clean
++-clean:
++-	rm -f *.o *.obj *.a *.lib *.so *.dll ld.conf
++-	rm -f ocamlrun ocamlrund ocamlruni ocamlruns sak
++-	rm -f ocamlrun.exe ocamlrund.exe ocamlruni.exe ocamlruns.exe sak.exe
++-	rm -f primitives primitives.new prims.c $(BUILT_HEADERS)
++-	rm -f domain_state*.inc
++-	rm -rf $(DEPDIR)
++-
++-.PHONY: distclean
++-distclean: clean
++-	rm -f $(CONFIGURED_HEADERS)
++-
++-# Generated non-object files
++-
++-ld.conf: $(ROOTDIR)/Makefile.config
++-	echo "$(STUBLIBDIR)" > $@
++-	echo "$(LIBDIR)" >> $@
++-
++-# If primitives contain duplicated lines (e.g. because the code is defined
++-# like
++-# #ifdef X
++-# CAMLprim value caml_foo() ...
++-# #else
++-# CAMLprim value caml_foo() ...
++-# end), horrible things will happen (duplicated entries in Runtimedef ->
++-# double registration in Symtable -> empty entry in the PRIM table ->
++-# the bytecode interpreter is confused).
++-# We sort the primitive file and remove duplicates to avoid this problem.
++-
++-# Warning: we use "sort | uniq" instead of "sort -u" because in the MSVC
++-# port, the "sort" program in the path is Microsoft's and not cygwin's
++-
++-# Warning: POSIX sort is locale dependent, that's why we set LC_ALL explicitly.
++-# Sort is unstable for "is_directory" and "isatty"
++-# see http://pubs.opengroup.org/onlinepubs/9699919799/utilities/sort.html:
++-# "using sort to process pathnames, it is recommended that LC_ALL .. set to C"
++-
++-# To speed up builds, we avoid changing "primitives" when files
++-# containing primitives change but the primitives table does not
++-primitives: $(shell ./gen_primitives.sh > primitives.new; \
++-                    cmp -s primitives primitives.new || echo primitives.new)
++-	cp $^ $@
++-
++-prims.c : primitives
++-	(echo '#define CAML_INTERNALS'; \
++-         echo '#include "caml/mlvalues.h"'; \
++-	 echo '#include "caml/prims.h"'; \
++-	 sed -e 's/.*/extern value &();/' primitives; \
++-	 echo 'c_primitive caml_builtin_cprim[] = {'; \
++-	 sed -e 's/.*/  &,/' primitives; \
++-	 echo '  0 };'; \
++-	 echo 'char * caml_names_of_builtin_cprim[] = {'; \
++-	 sed -e 's/.*/  "&",/' primitives; \
++-	 echo '  0 };') > prims.c
++-
++-caml/opnames.h : caml/instruct.h
++-	tr -d '\r' < $< | \
++-	sed -e '/\/\*/d' \
++-	    -e '/^#/d' \
++-	    -e 's/enum /static char * names_of_/' \
++-	    -e 's/{$$/[] = {/' \
++-	    -e 's/\([[:upper:]][[:upper:]_0-9]*\)/"\1"/g' > $@
++-
++-# caml/jumptbl.h is required only if you have GCC 2.0 or later
++-caml/jumptbl.h : caml/instruct.h
++-	tr -d '\r' < $< | \
++-	sed -n -e '/^  /s/ \([A-Z]\)/ \&\&lbl_\1/gp' \
++-	       -e '/^}/q' > $@
++-# These are provided as a temporary shim to allow cross-compilation systems
++-# to supply a host C compiler and different flags and a linking macro.
++-SAK_CC ?= $(CC)
++-SAK_CFLAGS ?= $(OC_CFLAGS) $(CFLAGS) $(OC_CPPFLAGS) $(CPPFLAGS)
++-SAK_LINK ?= $(MKEXE_USING_COMPILER)
++-
++-sak$(EXE): sak.$(O)
++-	$(call SAK_LINK,$@,$^)
++-
++-sak.$(O): sak.c caml/misc.h caml/config.h
++-	$(SAK_CC) -c $(SAK_CFLAGS) $(OUTPUTOBJ)$@ $<
++-
++-C_LITERAL = $(shell ./sak$(EXE) encode-C-literal '$(1)')
++-
++-build_config.h: $(ROOTDIR)/Makefile.config sak$(EXE)
++-	echo '/* This file is generated from $(ROOTDIR)/Makefile.config */' > $@
++-	echo '#define OCAML_STDLIB_DIR $(call C_LITERAL,$(LIBDIR))' >> $@
++-	echo '#define HOST "$(HOST)"' >> $@
++-
++-# Libraries and programs
++-
++-ocamlrun$(EXE): prims.$(O) libcamlrun.$(A)
++-	$(MKEXE) -o $@ $^ $(LIBS)
++-
++-ocamlruns$(EXE): prims.$(O) libcamlrun_non_shared.$(A)
++-	$(call MKEXE_USING_COMPILER,$@,$^ $(LIBS))
++-
++-libcamlrun.$(A): $(libcamlrun_OBJECTS)
++-	$(call MKLIB,$@, $^)
++-
++-libcamlrun_non_shared.$(A): $(libcamlrun_non_shared_OBJECTS)
++-	$(call MKLIB,$@, $^)
++-
++-ocamlrund$(EXE): prims.$(O) libcamlrund.$(A)
++-	$(MKEXE) $(MKEXEDEBUGFLAG) -o $@ $^ $(LIBS)
++-
++-libcamlrund.$(A): $(libcamlrund_OBJECTS)
++-	$(call MKLIB,$@, $^)
++-
++-ocamlruni$(EXE): prims.$(O) libcamlruni.$(A)
++-	$(MKEXE) -o $@ $^ $(INSTRUMENTED_RUNTIME_LIBS) $(LIBS)
++-
++-libcamlruni.$(A): $(libcamlruni_OBJECTS)
++-	$(call MKLIB,$@, $^)
++-
++-libcamlrun_pic.$(A): $(libcamlrunpic_OBJECTS)
++-	$(call MKLIB,$@, $^)
++-
++-libcamlrun_shared.$(SO): $(libcamlrunpic_OBJECTS)
++-	$(MKDLL) -o $@ $^ $(BYTECCLIBS)
++-
++-libasmrun.$(A): $(libasmrun_OBJECTS)
++-	$(call MKLIB,$@, $^)
++-
++-libasmrund.$(A): $(libasmrund_OBJECTS)
++-	$(call MKLIB,$@, $^)
++-
++-libasmruni.$(A): $(libasmruni_OBJECTS)
++-	$(call MKLIB,$@, $^)
++-
++-libasmrun_pic.$(A): $(libasmrunpic_OBJECTS)
++-	$(call MKLIB,$@, $^)
++-
++-libasmrun_shared.$(SO): $(libasmrunpic_OBJECTS)
++-	$(MKDLL) -o $@ $^ $(NATIVECCLIBS)
++-
++-# Target-specific preprocessor and compiler flags
++-
++-%.bd.$(O): OC_CPPFLAGS += $(OC_DEBUG_CPPFLAGS)
++-%.bd.$(D): OC_CPPFLAGS += $(OC_DEBUG_CPPFLAGS)
++-
++-%.bi.$(O): OC_CPPFLAGS += $(OC_INSTR_CPPFLAGS)
++-%.bi.$(D): OC_CPPFLAGS += $(OC_INSTR_CPPFLAGS)
++-
++-%.bpic.$(O): OC_CFLAGS += $(SHAREDLIB_CFLAGS)
++-
++-%.n.$(O): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS)
++-%.n.$(D): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS)
++-
++-%.nd.$(O): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS) $(OC_DEBUG_CPPFLAGS)
++-%.nd.$(D): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS) $(OC_DEBUG_CPPFLAGS)
++-
++-%.ni.$(O): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS) $(OC_INSTR_CPPFLAGS)
++-%.ni.$(D): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS) $(OC_INSTR_CPPFLAGS)
++-
++-%.npic.$(O): OC_CFLAGS += $(SHAREDLIB_CFLAGS)
++-%.npic.$(O): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS)
++-%.npic.$(D): OC_CPPFLAGS += $(OC_NATIVE_CPPFLAGS)
++-
++-# Compilation of C files
++-
++-# The COMPILE_C_FILE macro below receives as argument the pattern
++-# that corresponds to the name of the generated object file
++-# (without the extension, which is added by the macro)
++-define COMPILE_C_FILE
++-ifneq "$(COMPUTE_DEPS)" "false"
++-ifneq "$(1)" "%"
++-# -MG would ensure that the dependencies are generated even if the files listed
++-# in $$(BUILT_HEADERS) haven't been assembled yet. However, this goes subtly
++-# wrong if the user has the headers installed, as gcc will pick up a dependency
++-# on those instead and the local ones will not be generated. For this reason, we
++-# don't use -MG and instead include $(BUILT_HEADERS) in the order only
++-# dependencies to ensure that they exist before dependencies are computed.
++-$(DEPDIR)/$(1).$(D): %.c | $(DEPDIR) $(BUILT_HEADERS)
++-	$$(DEP_CC) $$(OC_CPPFLAGS) $$(CPPFLAGS) $$< -MT \
++-	  '$$*$(subst %,,$(1)).$(O)' -MF $$@
++-endif # ifneq "$(1)" "%"
++-$(1).$(O): $(2).c
++-else
++-$(1).$(O): $(2).c $(CONFIGURED_HEADERS) $(BUILT_HEADERS) $(RUNTIME_HEADERS)
++-endif # ifneq "$(COMPUTE_DEPS)" "false"
++-	$$(CC) -c $$(OC_CFLAGS) $$(CFLAGS) $$(OC_CPPFLAGS) $$(CPPFLAGS) \
++-	  $$(OUTPUTOBJ)$$@ $$<
++-endef
++-
++-object_types := % %.b %.bd %.bi %.bpic
++-ifneq "$(NATIVE_COMPILER)" "false"
++-object_types += %.n %.nd %.ni %.np %.npic
++-endif
++-
++-$(foreach object_type, $(object_types), \
++-  $(eval $(call COMPILE_C_FILE,$(object_type),%)))
++-
++-$(UNIX_OR_WIN32)_non_shared.%.$(O): OC_CPPFLAGS += -DBUILDING_LIBCAMLRUNS
++-
++-$(eval $(call COMPILE_C_FILE,$(UNIX_OR_WIN32)_non_shared.%,$(UNIX_OR_WIN32)))
++-
++-$(foreach object_type,$(subst %,,$(object_types)), \
++-  $(eval dynlink$(object_type).$(O): $(ROOTDIR)/Makefile.config))
++-
++-# Compilation of assembly files
++-
++-%.o: %.S
++-	$(ASPP) $(ASPPFLAGS) -o $@ $< || \
++-	{ echo "If your assembler produced syntax errors, it is probably";\
++-          echo "unhappy with the preprocessor. Check your assembler, or";\
++-          echo "try producing $*.o by hand.";\
++-          exit 2; }
++-
++-%_libasmrunpic.o: %.S
++-	$(ASPP) $(ASPPFLAGS) $(SHAREDLIB_CFLAGS) -o $@ $<
++-
++-domain_state64.inc: caml/domain_state.tbl gen_domain_state64_inc.awk
++-	$(AWK) -f ./gen_domain_state64_inc.awk $< > $@
++-
++-domain_state32.inc: caml/domain_state.tbl gen_domain_state32_inc.awk
++-	$(AWK) -f ./gen_domain_state32_inc.awk $< > $@
++-
++-amd64nt.obj: amd64nt.asm domain_state64.inc
++-	$(ASM)$@ $(ASMFLAGS) $<
++-
++-i386nt.obj: i386nt.asm domain_state32.inc
++-	$(ASM)$@ $(ASMFLAGS) $<
++-
++-%_libasmrunpic.obj: %.asm
++-	$(ASM)$@ $(ASMFLAGS) $<
++-
++-# Dependencies
++-
++-DEP_FILES := $(addsuffix .b, $(basename $(BYTECODE_C_SOURCES) instrtrace))
++-ifneq "$(NATIVE_COMPILER)" "false"
++-DEP_FILES += $(addsuffix .n, $(basename $(NATIVE_C_SOURCES)))
++-endif
++-DEP_FILES += $(addsuffix d, $(DEP_FILES)) \
++-             $(addsuffix i, $(DEP_FILES)) \
++-             $(addsuffix pic, $(DEP_FILES))
++-DEP_FILES := $(addsuffix .$(D), $(DEP_FILES))
++-
++-ifeq "$(COMPUTE_DEPS)" "true"
++-include $(addprefix $(DEPDIR)/, $(DEP_FILES))
++-endif
++-
++-# This empty target is here for AppVeyor to allow dependencies to be built
++-# without doing anything else.
++-.PHONY: setup-depend
++-setup-depend:
++diff --git a/runtime/amd64.S b/runtime/amd64.S
++index 756d4a5a0a..8081087c68 100644
++--- a/runtime/amd64.S
+++++ b/runtime/amd64.S
++@@ -295,13 +295,13 @@
++         .text
++ 
++ #if defined(FUNCTION_SECTIONS)
++-        TEXT_SECTION(caml_hot__code_begin)
++-        .globl  G(caml_hot__code_begin)
++-G(caml_hot__code_begin):
+++        TEXT_SECTION(caml_hot.code_begin)
+++        .globl  G(caml_hot.code_begin)
+++G(caml_hot.code_begin):
++ 
++-        TEXT_SECTION(caml_hot__code_end)
++-        .globl  G(caml_hot__code_end)
++-G(caml_hot__code_end):
+++        TEXT_SECTION(caml_hot.code_end)
+++        .globl  G(caml_hot.code_end)
+++G(caml_hot.code_end):
++ #endif
++ 
++         TEXT_SECTION(caml_system__code_begin)
++@@ -664,9 +664,9 @@ ENDFUNCTION(G(caml_ml_array_bound_error))
++ G(caml_system__code_end):
++ 
++         .data
++-        .globl  G(caml_system__frametable)
+++        .globl  G(caml_system.frametable)
++         .align  EIGHT_ALIGN
++-G(caml_system__frametable):
+++G(caml_system.frametable):
++         .quad   1           /* one descriptor */
++         .quad   LBL(107)    /* return address into callback */
++         .value  -1          /* negative frame size => use callback link */
++diff --git a/runtime/arm.S b/runtime/arm.S
++index 612757a104..d2632bfceb 100644
++--- a/runtime/arm.S
+++++ b/runtime/arm.S
++@@ -113,13 +113,13 @@ domain_state_ptr  .req    r11
++ name:
++ 
++ #if defined(FUNCTION_SECTIONS)
++-        TEXT_SECTION(caml_hot__code_begin)
++-        .globl  caml_hot__code_begin
++-caml_hot__code_begin:
+++        TEXT_SECTION(caml_hot.code_begin)
+++        .globl  caml_hot.code_begin
+++caml_hot.code_begin:
++ 
++-        TEXT_SECTION(caml_hot__code_end)
++-        .globl  caml_hot__code_end
++-caml_hot__code_end:
+++        TEXT_SECTION(caml_hot.code_end)
+++        .globl  caml_hot.code_end
+++caml_hot.code_end:
++ #endif
++ 
++         .set    domain_curr_field, 0
++@@ -433,15 +433,15 @@ caml_system__code_end:
++ 
++         .data
++         .align  2
++-        .globl  caml_system__frametable
++-caml_system__frametable:
+++        .globl  caml_system.frametable
+++caml_system.frametable:
++         .word   1               /* one descriptor */
++         .word   .Lcaml_retaddr  /* return address into callback */
++         .short  -1              /* negative frame size => use callback link */
++         .short  0               /* no roots */
++         .align  2
++-        .type   caml_system__frametable, %object
++-        .size   caml_system__frametable, .-caml_system__frametable
+++        .type   caml_system.frametable, %object
+++        .size   caml_system.frametable, .-caml_system.frametable
++ 
++ /* Mark stack as non-executable */
++         .section .note.GNU-stack,"",%progbits
++diff --git a/runtime/arm64.S b/runtime/arm64.S
++index 02a7ba0832..abb38be6e7 100644
++--- a/runtime/arm64.S
+++++ b/runtime/arm64.S
++@@ -100,13 +100,13 @@
++ #endif
++ 
++ #if defined(FUNCTION_SECTIONS)
++-        TEXT_SECTION(caml_hot__code_begin)
++-        .globl  G(caml_hot__code_begin)
++-G(caml_hot__code_begin):
+++        TEXT_SECTION(caml_hot.code_begin)
+++        .globl  G(caml_hot.code_begin)
+++G(caml_hot.code_begin):
++ 
++-        TEXT_SECTION(caml_hot__code_end)
++-        .globl  G(caml_hot__code_end)
++-G(caml_hot__code_end):
+++        TEXT_SECTION(caml_hot.code_end)
+++        .globl  G(caml_hot.code_end)
+++G(caml_hot.code_end):
++ #endif
++ 
++ #if defined(SYS_macosx)
++@@ -533,13 +533,13 @@ G(caml_system__code_end):
++ 
++ /* GC roots for callback */
++ 
++-OBJECT(caml_system__frametable)
+++OBJECT(caml_system.frametable)
++         .quad   1               /* one descriptor */
++         .quad   L(caml_retaddr) /* return address into callback */
++         .short  -1              /* negative frame size => use callback link */
++         .short  0               /* no roots */
++         .align  3
++-        END_OBJECT(caml_system__frametable)
+++        END_OBJECT(caml_system.frametable)
++ 
++ #if !defined(SYS_macosx)
++ /* Mark stack as non-executable */
++diff --git a/runtime/bigarray.c b/runtime/bigarray.c
++index ed4ff67d21..03151f6946 100644
++--- a/runtime/bigarray.c
+++++ b/runtime/bigarray.c
++@@ -89,7 +89,7 @@ CAMLexport value
++ caml_ba_alloc(int flags, int num_dims, void * data, intnat * dim)
++ {
++   uintnat num_elts, asize, size;
++-  int i;
+++  int i, is_managed;
++   value res;
++   struct caml_ba_array * b;
++   intnat dimcopy[CAML_BA_MAX_NUM_DIMS];
++@@ -97,23 +97,23 @@ caml_ba_alloc(int flags, int num_dims, void * data, intnat * dim)
++   CAMLassert(num_dims >= 0 && num_dims <= CAML_BA_MAX_NUM_DIMS);
++   CAMLassert((flags & CAML_BA_KIND_MASK) <= CAML_BA_CHAR);
++   for (i = 0; i < num_dims; i++) dimcopy[i] = dim[i];
++-  size = 0;
++-  if (data == NULL) {
++-    num_elts = 1;
++-    for (i = 0; i < num_dims; i++) {
++-      if (caml_umul_overflow(num_elts, dimcopy[i], &num_elts))
++-        caml_raise_out_of_memory();
++-    }
++-    if (caml_umul_overflow(num_elts,
++-                           caml_ba_element_size[flags & CAML_BA_KIND_MASK],
++-                           &size))
+++  num_elts = 1;
+++  for (i = 0; i < num_dims; i++) {
+++    if (caml_umul_overflow(num_elts, dimcopy[i], &num_elts))
++       caml_raise_out_of_memory();
+++  }
+++  if (caml_umul_overflow(num_elts,
+++                         caml_ba_element_size[flags & CAML_BA_KIND_MASK],
+++                         &size))
+++    caml_raise_out_of_memory();
+++  if (data == NULL) {
++     data = malloc(size);
++     if (data == NULL && size != 0) caml_raise_out_of_memory();
++     flags |= CAML_BA_MANAGED;
++   }
++   asize = SIZEOF_BA_ARRAY + num_dims * sizeof(intnat);
++-  res = caml_alloc_custom_mem(&caml_ba_ops, asize, size);
+++  is_managed = ((flags & CAML_BA_MANAGED_MASK) == CAML_BA_MANAGED);
+++  res = caml_alloc_custom_mem(&caml_ba_ops, asize, is_managed ? size : 0);
++   b = Caml_ba_array_val(res);
++   b->data = data;
++   b->num_dims = num_dims;
++diff --git a/runtime/caml/alloc.h b/runtime/caml/alloc.h
++index 13f0fac2fb..816da799bb 100644
++--- a/runtime/caml/alloc.h
+++++ b/runtime/caml/alloc.h
++@@ -17,9 +17,6 @@
++ #define CAML_ALLOC_H
++ 
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "misc.h"
++ #include "mlvalues.h"
++ 
++diff --git a/runtime/caml/bigarray.h b/runtime/caml/bigarray.h
++index fc1fb14570..1664ae3f6e 100644
++--- a/runtime/caml/bigarray.h
+++++ b/runtime/caml/bigarray.h
++@@ -16,9 +16,6 @@
++ #ifndef CAML_BIGARRAY_H
++ #define CAML_BIGARRAY_H
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "config.h"
++ #include "mlvalues.h"
++ 
++diff --git a/runtime/caml/callback.h b/runtime/caml/callback.h
++index eef3342ec7..5c45995b8a 100644
++--- a/runtime/caml/callback.h
+++++ b/runtime/caml/callback.h
++@@ -18,9 +18,6 @@
++ #ifndef CAML_CALLBACK_H
++ #define CAML_CALLBACK_H
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "mlvalues.h"
++ 
++ #ifdef __cplusplus
++diff --git a/runtime/caml/camlatomic.h b/runtime/caml/camlatomic.h
++new file mode 100644
++index 0000000000..7206f0579a
++--- /dev/null
+++++ b/runtime/caml/camlatomic.h
++@@ -0,0 +1,85 @@
+++/**************************************************************************/
+++/*                                                                        */
+++/*                                 OCaml                                  */
+++/*                                                                        */
+++/*      KC Sivaramakrishnan, Indian Institute of Technology, Madras       */
+++/*                Stephen Dolan, University of Cambridge                  */
+++/*                                                                        */
+++/*   Copyright 2018 Indian Institute of Technology, Madras                */
+++/*   Copyright 2018 University of Cambridge                               */
+++/*                                                                        */
+++/*   All rights reserved.  This file is distributed under the terms of    */
+++/*   the GNU Lesser General Public License version 2.1, with the          */
+++/*   special exception on linking described in the file LICENSE.          */
+++/*                                                                        */
+++/**************************************************************************/
+++#ifndef CAML_ATOMIC_H
+++#define CAML_ATOMIC_H
+++
+++#include "config.h"
+++
+++/* On platforms supporting C11 atomics, this file just includes <stdatomic.h>.
+++
+++   On other platforms, this file includes platform-specific stubs for
+++   the subset of C11 atomics needed by the OCaml runtime
+++ */
+++
+++#ifdef __cplusplus
+++
+++extern "C++" {
+++#include <atomic>
+++#define ATOMIC_UINTNAT_INIT(x) (x)
+++typedef std::atomic<uintnat> atomic_uintnat;
+++typedef std::atomic<intnat> atomic_intnat;
+++using std::memory_order_relaxed;
+++using std::memory_order_acquire;
+++using std::memory_order_release;
+++using std::memory_order_acq_rel;
+++using std::memory_order_seq_cst;
+++}
+++
+++#elif defined(HAS_STDATOMIC_H)
+++
+++#include <stdatomic.h>
+++#define ATOMIC_UINTNAT_INIT(x) (x)
+++typedef _Atomic uintnat atomic_uintnat;
+++typedef _Atomic intnat atomic_intnat;
+++
+++#elif defined(__GNUC__)
+++
+++/* Support for versions of gcc which have built-in atomics but do not
+++   expose stdatomic.h (e.g. gcc 4.8) */
+++typedef enum memory_order {
+++  memory_order_relaxed = __ATOMIC_RELAXED,
+++  memory_order_acquire = __ATOMIC_ACQUIRE,
+++  memory_order_release = __ATOMIC_RELEASE,
+++  memory_order_acq_rel = __ATOMIC_ACQ_REL,
+++  memory_order_seq_cst = __ATOMIC_SEQ_CST
+++} memory_order;
+++
+++#define ATOMIC_UINTNAT_INIT(x) { (x) }
+++typedef struct { uintnat repr; } atomic_uintnat;
+++typedef struct { intnat repr; } atomic_intnat;
+++
+++#define atomic_load_explicit(x, m) __atomic_load_n(&(x)->repr, (m))
+++#define atomic_load(x) atomic_load_explicit((x), memory_order_seq_cst)
+++#define atomic_store_explicit(x, v, m) __atomic_store_n(&(x)->repr, (v), (m))
+++#define atomic_store(x, v) atomic_store_explicit((x), (v), memory_order_seq_cst)
+++#define atomic_compare_exchange_strong(x, oldv, newv) \
+++  __atomic_compare_exchange_n( \
+++    &(x)->repr, \
+++    (oldv), (newv), 0, \
+++    memory_order_seq_cst, memory_order_seq_cst)
+++#define atomic_exchange(x, newv) \
+++  __atomic_exchange_n(&(x)->repr, (newv), memory_order_seq_cst)
+++#define atomic_fetch_add(x, n) \
+++  __atomic_fetch_add(&(x)->repr, (n), memory_order_seq_cst)
+++#define atomic_fetch_or(x, n) \
+++  __atomic_fetch_or(&(x)->repr, (n), memory_order_seq_cst)
+++#define atomic_thread_fence __atomic_thread_fence
+++
+++#else
+++#error "C11 atomics are unavailable on this platform. See camlatomic.h"
+++#endif
+++
+++#endif /* CAML_ATOMIC_H */
++diff --git a/runtime/caml/compatibility.h b/runtime/caml/compatibility.h
++deleted file mode 100644
++index 1c109aa470..0000000000
++--- a/runtime/caml/compatibility.h
+++++ /dev/null
++@@ -1,373 +0,0 @@
++-/**************************************************************************/
++-/*                                                                        */
++-/*                                 OCaml                                  */
++-/*                                                                        */
++-/*           Damien Doligez, projet Moscova, INRIA Rocquencourt           */
++-/*                                                                        */
++-/*   Copyright 2003 Institut National de Recherche en Informatique et     */
++-/*     en Automatique.                                                    */
++-/*                                                                        */
++-/*   All rights reserved.  This file is distributed under the terms of    */
++-/*   the GNU Lesser General Public License version 2.1, with the          */
++-/*   special exception on linking described in the file LICENSE.          */
++-/*                                                                        */
++-/**************************************************************************/
++-
++-/* definitions for compatibility with old identifiers */
++-
++-#ifndef CAML_COMPATIBILITY_H
++-#define CAML_COMPATIBILITY_H
++-
++-/* internal global variables renamed between 4.02.1 and 4.03.0 */
++-#define caml_stat_top_heap_size Bsize_wsize(caml_stat_top_heap_wsz)
++-#define caml_stat_heap_size Bsize_wsize(caml_stat_heap_wsz)
++-
++-#ifndef CAML_NAME_SPACE
++-
++-/*
++-   #define --> CAMLextern  (defined with CAMLexport or CAMLprim)
++-   (rien)  --> CAMLprim
++-   g       --> global C identifier
++-   x       --> special case
++-
++-   SP* signals the special cases:
++-   - when the identifier was not simply prefixed with [caml_]
++-   - when the [caml_] version was already used for something else, and
++-     was renamed out of the way (watch out for [caml_alloc] and
++-     [caml_array_bound_error] in *.s)
++-*/
++-
++-/* a faire:
++-   - ui_*   (reverifier que win32.c n'en depend pas)
++-*/
++-
++-
++-/* **** alloc.c */
++-#define alloc CAML_DEPRECATED("alloc", "caml_alloc") caml_alloc /*SP*/
++-#define alloc_small CAML_DEPRECATED("alloc_small", "caml_alloc_small") caml_alloc_small
++-#define alloc_tuple CAML_DEPRECATED("alloc_tuple", "caml_alloc_tuple") caml_alloc_tuple
++-#define alloc_string CAML_DEPRECATED("alloc_string", "caml_alloc_string") caml_alloc_string
++-#define alloc_final CAML_DEPRECATED("alloc_final", "caml_alloc_final") caml_alloc_final
++-#define copy_string CAML_DEPRECATED("copy_string", "caml_copy_string") caml_copy_string
++-#define alloc_array CAML_DEPRECATED("alloc_array", "caml_alloc_array") caml_alloc_array
++-#define copy_string_array CAML_DEPRECATED("copy_string_array", "caml_copy_string_array") caml_copy_string_array
++-#define convert_flag_list CAML_DEPRECATED("convert_flag_list", "caml_convert_flag_list") caml_convert_flag_list
++-
++-/* **** array.c */
++-
++-/* **** backtrace.c */
++-#define backtrace_active CAML_DEPRECATED("backtrace_active", "caml_backtrace_active") caml_backtrace_active
++-#define backtrace_pos CAML_DEPRECATED("backtrace_pos", "caml_backtrace_pos") caml_backtrace_pos
++-#define backtrace_buffer CAML_DEPRECATED("backtrace_buffer", "caml_backtrace_buffer") caml_backtrace_buffer
++-#define backtrace_last_exn CAML_DEPRECATED("backtrace_last_exn", "caml_backtrace_last_exn") caml_backtrace_last_exn
++-#define print_exception_backtrace CAML_DEPRECATED("print_exception_backtrace", "caml_print_exception_backtrace") caml_print_exception_backtrace
++-
++-/* **** callback.c */
++-#define callback_depth CAML_DEPRECATED("callback_depth", "caml_callback_depth") caml_callback_depth
++-#define callbackN_exn CAML_DEPRECATED("callbackN_exn", "caml_callbackN_exn") caml_callbackN_exn
++-#define callback_exn CAML_DEPRECATED("callback_exn", "caml_callback_exn") caml_callback_exn
++-#define callback2_exn CAML_DEPRECATED("callback2_exn", "caml_callback2_exn") caml_callback2_exn
++-#define callback3_exn CAML_DEPRECATED("callback3_exn", "caml_callback3_exn") caml_callback3_exn
++-#define callback CAML_DEPRECATED("callback", "caml_callback") caml_callback
++-#define callback2 CAML_DEPRECATED("callback2", "caml_callback2") caml_callback2
++-#define callback3 CAML_DEPRECATED("callback3", "caml_callback3") caml_callback3
++-#define callbackN CAML_DEPRECATED("callbackN", "caml_callbackN") caml_callbackN
++-
++-/* **** compact.c */
++-
++-/* **** compare.c */
++-#define compare_unordered CAML_DEPRECATED("compare_unordered", "caml_compare_unordered") caml_compare_unordered
++-
++-/* **** custom.c */
++-#define alloc_custom CAML_DEPRECATED("alloc_custom", "caml_alloc_custom") caml_alloc_custom
++-#define register_custom_operations CAML_DEPRECATED("register_custom_operations", "caml_register_custom_operations") caml_register_custom_operations
++-
++-/* **** debugger.c */
++-
++-/* **** dynlink.c */
++-
++-/* **** extern.c */
++-#define output_val CAML_DEPRECATED("output_val", "caml_output_val") caml_output_val
++-#define output_value_to_malloc CAML_DEPRECATED("output_value_to_malloc", "caml_output_value_to_malloc") caml_output_value_to_malloc
++-#define output_value_to_block CAML_DEPRECATED("output_value_to_block", "caml_output_value_to_block") caml_output_value_to_block
++-#define serialize_int_1 CAML_DEPRECATED("serialize_int_1", "caml_serialize_int_1") caml_serialize_int_1
++-#define serialize_int_2 CAML_DEPRECATED("serialize_int_2", "caml_serialize_int_2") caml_serialize_int_2
++-#define serialize_int_4 CAML_DEPRECATED("serialize_int_4", "caml_serialize_int_4") caml_serialize_int_4
++-#define serialize_int_8 CAML_DEPRECATED("serialize_int_8", "caml_serialize_int_8") caml_serialize_int_8
++-#define serialize_float_4 CAML_DEPRECATED("serialize_float_4", "caml_serialize_float_4") caml_serialize_float_4
++-#define serialize_float_8 CAML_DEPRECATED("serialize_float_8", "caml_serialize_float_8") caml_serialize_float_8
++-#define serialize_block_1 CAML_DEPRECATED("serialize_block_1", "caml_serialize_block_1") caml_serialize_block_1
++-#define serialize_block_2 CAML_DEPRECATED("serialize_block_2", "caml_serialize_block_2") caml_serialize_block_2
++-#define serialize_block_4 CAML_DEPRECATED("serialize_block_4", "caml_serialize_block_4") caml_serialize_block_4
++-#define serialize_block_8 CAML_DEPRECATED("serialize_block_8", "caml_serialize_block_8") caml_serialize_block_8
++-#define serialize_block_float_8 CAML_DEPRECATED("serialize_block_float_8", "caml_serialize_block_float_8") caml_serialize_block_float_8
++-
++-/* **** fail.c */
++-#define external_raise CAML_DEPRECATED("external_raise", "caml_external_raise") caml_external_raise
++-#define mlraise CAML_DEPRECATED("mlraise", "caml_raise") caml_raise /*SP*/
++-#define raise_constant CAML_DEPRECATED("raise_constant", "caml_raise_constant") caml_raise_constant
++-#define raise_with_arg CAML_DEPRECATED("raise_with_arg", "caml_raise_with_arg") caml_raise_with_arg
++-#define raise_with_string CAML_DEPRECATED("raise_with_string", "caml_raise_with_string") caml_raise_with_string
++-#define failwith CAML_DEPRECATED("failwith", "caml_failwith") caml_failwith
++-#define invalid_argument CAML_DEPRECATED("invalid_argument", "caml_invalid_argument") caml_invalid_argument
++-#define array_bound_error CAML_DEPRECATED("array_bound_error", "caml_array_bound_error") caml_array_bound_error /*SP*/
++-#define raise_out_of_memory CAML_DEPRECATED("raise_out_of_memory", "caml_raise_out_of_memory") caml_raise_out_of_memory
++-#define raise_stack_overflow CAML_DEPRECATED("raise_stack_overflow", "caml_raise_stack_overflow") caml_raise_stack_overflow
++-#define raise_sys_error CAML_DEPRECATED("raise_sys_error", "caml_raise_sys_error") caml_raise_sys_error
++-#define raise_end_of_file CAML_DEPRECATED("raise_end_of_file", "caml_raise_end_of_file") caml_raise_end_of_file
++-#define raise_zero_divide CAML_DEPRECATED("raise_zero_divide", "caml_raise_zero_divide") caml_raise_zero_divide
++-#define raise_not_found CAML_DEPRECATED("raise_not_found", "caml_raise_not_found") caml_raise_not_found
++-#define raise_sys_blocked_io CAML_DEPRECATED("raise_sys_blocked_io", "caml_raise_sys_blocked_io") caml_raise_sys_blocked_io
++-/* **** runtime/fail_nat.c */
++-/* **** runtime/<arch>.s */
++-
++-/* **** finalise.c */
++-
++-/* **** fix_code.c */
++-
++-/* **** floats.c */
++-/*#define Double_val caml_Double_val             done in mlvalues.h as needed */
++-/*#define Store_double_val caml_Store_double_val done in mlvalues.h as needed */
++-#define copy_double CAML_DEPRECATED("copy_double", "caml_copy_double") caml_copy_double
++-
++-/* **** freelist.c */
++-
++-/* **** gc_ctrl.c */
++-
++-/* **** globroots.c */
++-#define register_global_root CAML_DEPRECATED("register_global_root", "caml_register_global_root") caml_register_global_root
++-#define remove_global_root CAML_DEPRECATED("remove_global_root", "caml_remove_global_root") caml_remove_global_root
++-
++-/* **** hash.c */
++-#define hash_variant CAML_DEPRECATED("hash_variant", "caml_hash_variant") caml_hash_variant
++-
++-/* **** instrtrace.c */
++-
++-/* **** intern.c */
++-#define input_val CAML_DEPRECATED("input_val", "caml_input_val") caml_input_val
++-#define input_val_from_string CAML_DEPRECATED("input_val_from_string", "caml_input_val_from_string") caml_input_val_from_string
++-#define input_value_from_malloc CAML_DEPRECATED("input_value_from_malloc", "caml_input_value_from_malloc") caml_input_value_from_malloc
++-#define input_value_from_block CAML_DEPRECATED("input_value_from_block", "caml_input_value_from_block") caml_input_value_from_block
++-#define deserialize_uint_1 CAML_DEPRECATED("deserialize_uint_1", "caml_deserialize_uint_1") caml_deserialize_uint_1
++-#define deserialize_sint_1 CAML_DEPRECATED("deserialize_sint_1", "caml_deserialize_sint_1") caml_deserialize_sint_1
++-#define deserialize_uint_2 CAML_DEPRECATED("deserialize_uint_2", "caml_deserialize_uint_2") caml_deserialize_uint_2
++-#define deserialize_sint_2 CAML_DEPRECATED("deserialize_sint_2", "caml_deserialize_sint_2") caml_deserialize_sint_2
++-#define deserialize_uint_4 CAML_DEPRECATED("deserialize_uint_4", "caml_deserialize_uint_4") caml_deserialize_uint_4
++-#define deserialize_sint_4 CAML_DEPRECATED("deserialize_sint_4", "caml_deserialize_sint_4") caml_deserialize_sint_4
++-#define deserialize_uint_8 CAML_DEPRECATED("deserialize_uint_8", "caml_deserialize_uint_8") caml_deserialize_uint_8
++-#define deserialize_sint_8 CAML_DEPRECATED("deserialize_sint_8", "caml_deserialize_sint_8") caml_deserialize_sint_8
++-#define deserialize_float_4 CAML_DEPRECATED("deserialize_float_4", "caml_deserialize_float_4") caml_deserialize_float_4
++-#define deserialize_float_8 CAML_DEPRECATED("deserialize_float_8", "caml_deserialize_float_8") caml_deserialize_float_8
++-#define deserialize_block_1 CAML_DEPRECATED("deserialize_block_1", "caml_deserialize_block_1") caml_deserialize_block_1
++-#define deserialize_block_2 CAML_DEPRECATED("deserialize_block_2", "caml_deserialize_block_2") caml_deserialize_block_2
++-#define deserialize_block_4 CAML_DEPRECATED("deserialize_block_4", "caml_deserialize_block_4") caml_deserialize_block_4
++-#define deserialize_block_8 CAML_DEPRECATED("deserialize_block_8", "caml_deserialize_block_8") caml_deserialize_block_8
++-#define deserialize_block_float_8 CAML_DEPRECATED("deserialize_block_float_8", "caml_deserialize_block_float_8") caml_deserialize_block_float_8
++-#define deserialize_error CAML_DEPRECATED("deserialize_error", "caml_deserialize_error") caml_deserialize_error
++-
++-/* **** interp.c */
++-
++-/* **** ints.c */
++-#define int32_ops CAML_DEPRECATED("int32_ops", "caml_int32_ops") caml_int32_ops
++-#define copy_int32 CAML_DEPRECATED("copy_int32", "caml_copy_int32") caml_copy_int32
++-/*#define Int64_val caml_Int64_val   *** done in mlvalues.h as needed */
++-#define int64_ops CAML_DEPRECATED("int64_ops", "caml_int64_ops") caml_int64_ops
++-#define copy_int64 CAML_DEPRECATED("copy_int64", "caml_copy_int64") caml_copy_int64
++-#define nativeint_ops CAML_DEPRECATED("nativeint_ops", "caml_nativeint_ops") caml_nativeint_ops
++-#define copy_nativeint CAML_DEPRECATED("copy_nativeint", "caml_copy_nativeint") caml_copy_nativeint
++-
++-/* **** io.c */
++-#define channel_mutex_free CAML_DEPRECATED("channel_mutex_free", "caml_channel_mutex_free") caml_channel_mutex_free
++-#define channel_mutex_lock CAML_DEPRECATED("channel_mutex_lock", "caml_channel_mutex_lock") caml_channel_mutex_lock
++-#define channel_mutex_unlock CAML_DEPRECATED("channel_mutex_unlock", "caml_channel_mutex_unlock") caml_channel_mutex_unlock
++-#define channel_mutex_unlock_exn CAML_DEPRECATED("channel_mutex_unlock_exn", "caml_channel_mutex_unlock_exn") caml_channel_mutex_unlock_exn
++-#define all_opened_channels CAML_DEPRECATED("all_opened_channels", "caml_all_opened_channels") caml_all_opened_channels
++-#define open_descriptor_in CAML_DEPRECATED("open_descriptor_in", "caml_open_descriptor_in") caml_open_descriptor_in /*SP*/
++-#define open_descriptor_out CAML_DEPRECATED("open_descriptor_out", "caml_open_descriptor_out") caml_open_descriptor_out /*SP*/
++-#define close_channel CAML_DEPRECATED("close_channel", "caml_close_channel") caml_close_channel /*SP*/
++-#define channel_size CAML_DEPRECATED("channel_size", "caml_channel_size") caml_channel_size /*SP*/
++-#define channel_binary_mode CAML_DEPRECATED("channel_binary_mode", "caml_channel_binary_mode") caml_channel_binary_mode
++-#define flush_partial CAML_DEPRECATED("flush_partial", "caml_flush_partial") caml_flush_partial /*SP*/
++-#define flush CAML_DEPRECATED("flush", "caml_flush") caml_flush /*SP*/
++-#define putword CAML_DEPRECATED("putword", "caml_putword") caml_putword
++-#define putblock CAML_DEPRECATED("putblock", "caml_putblock") caml_putblock
++-#define really_putblock CAML_DEPRECATED("really_putblock", "caml_really_putblock") caml_really_putblock
++-#define seek_out CAML_DEPRECATED("seek_out", "caml_seek_out") caml_seek_out /*SP*/
++-#define pos_out CAML_DEPRECATED("pos_out", "caml_pos_out") caml_pos_out /*SP*/
++-#define do_read CAML_DEPRECATED("do_read", "caml_do_read") caml_do_read
++-#define refill CAML_DEPRECATED("refill", "caml_refill") caml_refill
++-#define getword CAML_DEPRECATED("getword", "caml_getword") caml_getword
++-#define getblock CAML_DEPRECATED("getblock", "caml_getblock") caml_getblock
++-#define really_getblock CAML_DEPRECATED("really_getblock", "caml_really_getblock") caml_really_getblock
++-#define seek_in CAML_DEPRECATED("seek_in", "caml_seek_in") caml_seek_in /*SP*/
++-#define pos_in CAML_DEPRECATED("pos_in", "caml_pos_in") caml_pos_in /*SP*/
++-#define input_scan_line CAML_DEPRECATED("input_scan_line", "caml_input_scan_line") caml_input_scan_line /*SP*/
++-#define finalize_channel CAML_DEPRECATED("finalize_channel", "caml_finalize_channel") caml_finalize_channel
++-#define alloc_channel CAML_DEPRECATED("alloc_channel", "caml_alloc_channel") caml_alloc_channel
++-/*#define Val_file_offset caml_Val_file_offset   *** done in io.h as needed */
++-/*#define File_offset_val caml_File_offset_val   *** done in io.h as needed */
++-
++-/* **** lexing.c */
++-
++-/* **** main.c */
++-/* *** no change */
++-
++-/* **** major_gc.c */
++-#define heap_start CAML_DEPRECATED("heap_start", "caml_heap_start") caml_heap_start
++-#define page_table CAML_DEPRECATED("page_table", "caml_page_table") caml_page_table
++-
++-/* **** md5.c */
++-#define md5_string CAML_DEPRECATED("md5_string", "caml_md5_string") caml_md5_string
++-#define md5_chan CAML_DEPRECATED("md5_chan", "caml_md5_chan") caml_md5_chan
++-#define MD5Init CAML_DEPRECATED("MD5Init", "caml_MD5Init") caml_MD5Init
++-#define MD5Update CAML_DEPRECATED("MD5Update", "caml_MD5Update") caml_MD5Update
++-#define MD5Final CAML_DEPRECATED("MD5Final", "caml_MD5Final") caml_MD5Final
++-#define MD5Transform CAML_DEPRECATED("MD5Transform", "caml_MD5Transform") caml_MD5Transform
++-
++-/* **** memory.c */
++-#define alloc_shr CAML_DEPRECATED("alloc_shr", "caml_alloc_shr") caml_alloc_shr
++-#define initialize CAML_DEPRECATED("initialize", "caml_initialize") caml_initialize
++-#define modify CAML_DEPRECATED("modify", "caml_modify") caml_modify
++-#define stat_alloc CAML_DEPRECATED("stat_alloc", "caml_stat_alloc") caml_stat_alloc
++-#define stat_free CAML_DEPRECATED("stat_free", "caml_stat_free") caml_stat_free
++-#define stat_resize CAML_DEPRECATED("stat_resize", "caml_stat_resize") caml_stat_resize
++-
++-/* **** meta.c */
++-
++-/* **** minor_gc.c */
++-#define young_start CAML_DEPRECATED("young_start", "caml_young_start") caml_young_start
++-#define young_end CAML_DEPRECATED("young_end", "caml_young_end") caml_young_end
++-#define young_ptr CAML_DEPRECATED("young_ptr", "caml_young_ptr") caml_young_ptr
++-#define young_limit CAML_DEPRECATED("young_limit", "caml_young_limit") caml_young_limit
++-#define ref_table CAML_DEPRECATED("ref_table", "caml_ref_table") caml_ref_table
++-#define minor_collection CAML_DEPRECATED("minor_collection", "caml_minor_collection") caml_minor_collection
++-#define check_urgent_gc CAML_DEPRECATED("check_urgent_gc", "caml_check_urgent_gc") caml_check_urgent_gc
++-
++-/* **** misc.c */
++-
++-/* **** obj.c */
++-
++-/* **** parsing.c */
++-
++-/* **** prims.c */
++-
++-/* **** printexc.c */
++-#define format_caml_exception CAML_DEPRECATED("format_caml_exception", "caml_format_exception") caml_format_exception /*SP*/
++-
++-/* **** roots.c */
++-#define local_roots CAML_DEPRECATED("local_roots", "caml_local_roots") caml_local_roots
++-#define scan_roots_hook CAML_DEPRECATED("scan_roots_hook", "caml_scan_roots_hook") caml_scan_roots_hook
++-#define do_local_roots CAML_DEPRECATED("do_local_roots", "caml_do_local_roots") caml_do_local_roots
++-
++-/* **** signals.c */
++-#define pending_signals CAML_DEPRECATED("pending_signals", "caml_pending_signals") caml_pending_signals
++-#define something_to_do CAML_DEPRECATED("something_to_do", "caml_something_to_do") caml_something_to_do
++-#define enter_blocking_section_hook CAML_DEPRECATED("enter_blocking_section_hook", "caml_enter_blocking_section_hook") caml_enter_blocking_section_hook
++-#define leave_blocking_section_hook CAML_DEPRECATED("leave_blocking_section_hook", "caml_leave_blocking_section_hook") caml_leave_blocking_section_hook
++-#define enter_blocking_section CAML_DEPRECATED("enter_blocking_section", "caml_enter_blocking_section") caml_enter_blocking_section
++-#define leave_blocking_section CAML_DEPRECATED("leave_blocking_section", "caml_leave_blocking_section") caml_leave_blocking_section
++-#define convert_signal_number CAML_DEPRECATED("convert_signal_number", "caml_convert_signal_number") caml_convert_signal_number
++-
++-/* **** runtime/signals.c */
++-#define garbage_collection CAML_DEPRECATED("garbage_collection", "caml_garbage_collection") caml_garbage_collection
++-
++-/* **** stacks.c */
++-#define stack_low CAML_DEPRECATED("stack_low", "caml_stack_low") caml_stack_low
++-#define stack_high CAML_DEPRECATED("stack_high", "caml_stack_high") caml_stack_high
++-#define stack_threshold CAML_DEPRECATED("stack_threshold", "caml_stack_threshold") caml_stack_threshold
++-#define extern_sp CAML_DEPRECATED("extern_sp", "caml_extern_sp") caml_extern_sp
++-#define trapsp CAML_DEPRECATED("trapsp", "caml_trapsp") caml_trapsp
++-#define trap_barrier CAML_DEPRECATED("trap_barrier", "caml_trap_barrier") caml_trap_barrier
++-
++-/* **** startup.c */
++-#define atom_table CAML_DEPRECATED("atom_table", "caml_atom_table") caml_atom_table
++-/* **** runtime/startup_nat.c */
++-#define static_data_start CAML_DEPRECATED("static_data_start", "caml_static_data_start") caml_static_data_start
++-#define static_data_end CAML_DEPRECATED("static_data_end", "caml_static_data_end") caml_static_data_end
++-
++-/* **** str.c */
++-#define string_length CAML_DEPRECATED("string_length", "caml_string_length") caml_string_length
++-
++-/* **** sys.c */
++-#define sys_error CAML_DEPRECATED("sys_error", "caml_sys_error") caml_sys_error
++-
++-/* **** terminfo.c */
++-
++-/* **** unix.c  &  win32.c */
++-#define search_exe_in_path CAML_DEPRECATED("search_exe_in_path", "caml_search_exe_in_path") caml_search_exe_in_path
++-
++-/* **** weak.c */
++-
++-/* **** asmcomp/asmlink.ml */
++-
++-/* **** asmcomp/cmmgen.ml */
++-
++-/* **** asmcomp/asmlink.ml, asmcomp/cmmgen.ml, asmcomp/compilenv.ml */
++-
++-/* ************************************************************* */
++-
++-/* **** otherlibs/bigarray */
++-#define int8 caml_ba_int8
++-#define uint8 caml_ba_uint8
++-#define int16 caml_ba_int16
++-#define uint16 caml_ba_uint16
++-#define MAX_NUM_DIMS CAML_DEPRECATED("MAX_NUM_DIMS", "CAML_BA_MAX_NUM_DIMS") CAML_BA_MAX_NUM_DIMS
++-#define caml_bigarray_kind CAML_DEPRECATED("caml_bigarray_kind", "caml_ba_kind") caml_ba_kind
++-#define BIGARRAY_FLOAT32 CAML_DEPRECATED("BIGARRAY_FLOAT32", "CAML_BA_FLOAT32") CAML_BA_FLOAT32
++-#define BIGARRAY_FLOAT64 CAML_DEPRECATED("BIGARRAY_FLOAT64", "CAML_BA_FLOAT64") CAML_BA_FLOAT64
++-#define BIGARRAY_SINT8 CAML_DEPRECATED("BIGARRAY_SINT8", "CAML_BA_SINT8") CAML_BA_SINT8
++-#define BIGARRAY_UINT8 CAML_DEPRECATED("BIGARRAY_UINT8", "CAML_BA_UINT8") CAML_BA_UINT8
++-#define BIGARRAY_SINT16 CAML_DEPRECATED("BIGARRAY_SINT16", "CAML_BA_SINT16") CAML_BA_SINT16
++-#define BIGARRAY_UINT16 CAML_DEPRECATED("BIGARRAY_UINT16", "CAML_BA_UINT16") CAML_BA_UINT16
++-#define BIGARRAY_INT32 CAML_DEPRECATED("BIGARRAY_INT32", "CAML_BA_INT32") CAML_BA_INT32
++-#define BIGARRAY_INT64 CAML_DEPRECATED("BIGARRAY_INT64", "CAML_BA_INT64") CAML_BA_INT64
++-#define BIGARRAY_CAML_INT CAML_DEPRECATED("BIGARRAY_CAML_INT", "CAML_BA_CAML_INT") CAML_BA_CAML_INT
++-#define BIGARRAY_NATIVE_INT CAML_DEPRECATED("BIGARRAY_NATIVE_INT", "CAML_BA_NATIVE_INT") CAML_BA_NATIVE_INT
++-#define BIGARRAY_COMPLEX32 CAML_DEPRECATED("BIGARRAY_COMPLEX32", "CAML_BA_COMPLEX32") CAML_BA_COMPLEX32
++-#define BIGARRAY_COMPLEX64 CAML_DEPRECATED("BIGARRAY_COMPLEX64", "CAML_BA_COMPLEX64") CAML_BA_COMPLEX64
++-#define BIGARRAY_KIND_MASK CAML_DEPRECATED("BIGARRAY_KIND_MASK", "CAML_BA_KIND_MASK") CAML_BA_KIND_MASK
++-#define caml_bigarray_layout CAML_DEPRECATED("caml_bigarray_layout", "caml_ba_layout") caml_ba_layout
++-#define BIGARRAY_C_LAYOUT CAML_DEPRECATED("BIGARRAY_C_LAYOUT", "CAML_BA_C_LAYOUT") CAML_BA_C_LAYOUT
++-#define BIGARRAY_FORTRAN_LAYOUT CAML_DEPRECATED("BIGARRAY_FORTRAN_LAYOUT", "CAML_BA_FORTRAN_LAYOUT") CAML_BA_FORTRAN_LAYOUT
++-#define BIGARRAY_LAYOUT_MASK CAML_DEPRECATED("BIGARRAY_LAYOUT_MASK", "CAML_BA_LAYOUT_MASK") CAML_BA_LAYOUT_MASK
++-#define caml_bigarray_managed CAML_DEPRECATED("caml_bigarray_managed", "caml_ba_managed") caml_ba_managed
++-#define BIGARRAY_EXTERNAL CAML_DEPRECATED("BIGARRAY_EXTERNAL", "CAML_BA_EXTERNAL") CAML_BA_EXTERNAL
++-#define BIGARRAY_MANAGED CAML_DEPRECATED("BIGARRAY_MANAGED", "CAML_BA_MANAGED") CAML_BA_MANAGED
++-#define BIGARRAY_MAPPED_FILE CAML_DEPRECATED("BIGARRAY_MAPPED_FILE", "CAML_BA_MAPPED_FILE") CAML_BA_MAPPED_FILE
++-#define BIGARRAY_MANAGED_MASK CAML_DEPRECATED("BIGARRAY_MANAGED_MASK", "CAML_BA_MANAGED_MASK") CAML_BA_MANAGED_MASK
++-#define caml_bigarray_proxy CAML_DEPRECATED("caml_bigarray_proxy", "caml_ba_proxy") caml_ba_proxy
++-#define caml_bigarray CAML_DEPRECATED("caml_bigarray", "caml_ba_array") caml_ba_array
++-#define Bigarray_val CAML_DEPRECATED("Bigarray_val", "Caml_ba_array_val") Caml_ba_array_val
++-#define Data_bigarray_val CAML_DEPRECATED("Data_bigarray_val", "Caml_ba_data_val") Caml_ba_data_val
++-#define alloc_bigarray CAML_DEPRECATED("alloc_bigarray", "caml_ba_alloc") caml_ba_alloc
++-#define alloc_bigarray_dims CAML_DEPRECATED("alloc_bigarray_dims", "caml_ba_alloc_dims") caml_ba_alloc_dims
++-#define bigarray_map_file CAML_DEPRECATED("bigarray_map_file", "caml_ba_map_file") caml_ba_map_file
++-#define bigarray_unmap_file CAML_DEPRECATED("bigarray_unmap_file", "caml_ba_unmap_file") caml_ba_unmap_file
++-#define bigarray_element_size CAML_DEPRECATED("bigarray_element_size", "caml_ba_element_size") caml_ba_element_size
++-#define bigarray_byte_size CAML_DEPRECATED("bigarray_byte_size", "caml_ba_byte_size") caml_ba_byte_size
++-#define bigarray_deserialize CAML_DEPRECATED("bigarray_deserialize", "caml_ba_deserialize") caml_ba_deserialize
++-#define MAX_BIGARRAY_MEMORY CAML_DEPRECATED("MAX_BIGARRAY_MEMORY", "CAML_BA_MAX_MEMORY") CAML_BA_MAX_MEMORY
++-#define bigarray_create CAML_DEPRECATED("bigarray_create", "caml_ba_create") caml_ba_create
++-#define bigarray_get_N CAML_DEPRECATED("bigarray_get_N", "caml_ba_get_N") caml_ba_get_N
++-#define bigarray_get_1 CAML_DEPRECATED("bigarray_get_1", "caml_ba_get_1") caml_ba_get_1
++-#define bigarray_get_2 CAML_DEPRECATED("bigarray_get_2", "caml_ba_get_2") caml_ba_get_2
++-#define bigarray_get_3 CAML_DEPRECATED("bigarray_get_3", "caml_ba_get_3") caml_ba_get_3
++-#define bigarray_get_generic CAML_DEPRECATED("bigarray_get_generic", "caml_ba_get_generic") caml_ba_get_generic
++-#define bigarray_set_1 CAML_DEPRECATED("bigarray_set_1", "caml_ba_set_1") caml_ba_set_1
++-#define bigarray_set_2 CAML_DEPRECATED("bigarray_set_2", "caml_ba_set_2") caml_ba_set_2
++-#define bigarray_set_3 CAML_DEPRECATED("bigarray_set_3", "caml_ba_set_3") caml_ba_set_3
++-#define bigarray_set_N CAML_DEPRECATED("bigarray_set_N", "caml_ba_set_N") caml_ba_set_N
++-#define bigarray_set_generic CAML_DEPRECATED("bigarray_set_generic", "caml_ba_set_generic") caml_ba_set_generic
++-#define bigarray_num_dims CAML_DEPRECATED("bigarray_num_dims", "caml_ba_num_dims") caml_ba_num_dims
++-#define bigarray_dim CAML_DEPRECATED("bigarray_dim", "caml_ba_dim") caml_ba_dim
++-#define bigarray_kind CAML_DEPRECATED("bigarray_kind", "caml_ba_kind") caml_ba_kind
++-#define bigarray_layout CAML_DEPRECATED("bigarray_layout", "caml_ba_layout") caml_ba_layout
++-#define bigarray_slice CAML_DEPRECATED("bigarray_slice", "caml_ba_slice") caml_ba_slice
++-#define bigarray_sub CAML_DEPRECATED("bigarray_sub", "caml_ba_sub") caml_ba_sub
++-#define bigarray_blit CAML_DEPRECATED("bigarray_blit", "caml_ba_blit") caml_ba_blit
++-#define bigarray_fill CAML_DEPRECATED("bigarray_fill", "caml_ba_fill") caml_ba_fill
++-#define bigarray_reshape CAML_DEPRECATED("bigarray_reshape", "caml_ba_reshape") caml_ba_reshape
++-#define bigarray_init CAML_DEPRECATED("bigarray_init", "caml_ba_init") caml_ba_init
++-
++-#endif /* CAML_NAME_SPACE */
++-#endif /* CAML_COMPATIBILITY_H */
++diff --git a/runtime/caml/config.h b/runtime/caml/config.h
++index 471a6bc6f4..a7e56be8d9 100644
++--- a/runtime/caml/config.h
+++++ b/runtime/caml/config.h
++@@ -16,6 +16,15 @@
++ #ifndef CAML_CONFIG_H
++ #define CAML_CONFIG_H
++ 
+++/* CAML_NAME_SPACE was introduced in OCaml 3.08 to declare compatibility with
+++   the newly caml_-prefixed names of C runtime functions and to disable the
+++   definition of compatibility macros for the un-prefixed names. The
+++   compatibility layer was removed in OCaml 5.00, so CAML_NAME_SPACE is the
+++   default. */
+++#ifndef CAML_NAME_SPACE
+++#define CAML_NAME_SPACE
+++#endif
+++
++ #include "m.h"
++ 
++ /* If supported, tell gcc that we can use 32-bit code addresses for
++@@ -41,10 +50,6 @@
++ 
++ #include "s.h"
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++-
++ #ifndef CAML_CONFIG_H_NO_TYPEDEFS
++ 
++ #include <stddef.h>
++diff --git a/runtime/caml/custom.h b/runtime/caml/custom.h
++index 420121f43e..231019aef7 100644
++--- a/runtime/caml/custom.h
+++++ b/runtime/caml/custom.h
++@@ -17,9 +17,6 @@
++ #define CAML_CUSTOM_H
++ 
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "mlvalues.h"
++ 
++ struct custom_fixed_length {
++diff --git a/runtime/caml/domain_state.h b/runtime/caml/domain_state.h
++index 84e677d041..2ee932459a 100644
++--- a/runtime/caml/domain_state.h
+++++ b/runtime/caml/domain_state.h
++@@ -29,11 +29,7 @@ typedef value extra_params_area[NUM_EXTRA_PARAMS];
++  * via native code, which is why the indices are important */
++ 
++ typedef struct {
++-#ifdef CAML_NAME_SPACE
++ #define DOMAIN_STATE(type, name) CAMLalign(8) type name;
++-#else
++-#define DOMAIN_STATE(type, name) CAMLalign(8) type _##name;
++-#endif
++ #include "domain_state.tbl"
++ #undef DOMAIN_STATE
++ } caml_domain_state;
++@@ -45,11 +41,7 @@ enum {
++ #undef DOMAIN_STATE
++ };
++ 
++-#ifdef CAML_NAME_SPACE
++ #define LAST_DOMAIN_STATE_MEMBER extra_params
++-#else
++-#define LAST_DOMAIN_STATE_MEMBER _extra_params
++-#endif
++ 
++ /* Check that the structure was laid out without padding,
++    since the runtime assumes this in computing offsets */
++@@ -57,11 +49,8 @@ CAML_STATIC_ASSERT(
++     offsetof(caml_domain_state, LAST_DOMAIN_STATE_MEMBER) ==
++     (Domain_state_num_fields - 1) * 8);
++ 
++-CAMLextern caml_domain_state* Caml_state;
++-#ifdef CAML_NAME_SPACE
+++CAMLextern caml_domain_state* caml_state;
+++#define Caml_state caml_state
++ #define Caml_state_field(field) Caml_state->field
++-#else
++-#define Caml_state_field(field) Caml_state->_##field
++-#endif
++ 
++ #endif /* CAML_STATE_H */
++diff --git a/runtime/caml/fail.h b/runtime/caml/fail.h
++index 822c603260..887ef9c227 100644
++--- a/runtime/caml/fail.h
+++++ b/runtime/caml/fail.h
++@@ -20,9 +20,6 @@
++ #include <setjmp.h>
++ #endif /* CAML_INTERNALS */
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "misc.h"
++ #include "mlvalues.h"
++ 
++diff --git a/runtime/caml/fix_code.h b/runtime/caml/fix_code.h
++index 2eafaa814b..83c393a17d 100644
++--- a/runtime/caml/fix_code.h
+++++ b/runtime/caml/fix_code.h
++@@ -34,7 +34,8 @@ void caml_set_instruction (code_t pos, opcode_t instr);
++ int caml_is_instruction (opcode_t instr1, opcode_t instr2);
++ 
++ #ifdef THREADED_CODE
++-void caml_init_thread_code(void ** instr_table, void * instr_base);
+++extern char ** caml_instr_table;
+++extern char * caml_instr_base;
++ void caml_thread_code (code_t code, asize_t len);
++ #endif
++ 
++diff --git a/runtime/caml/intext.h b/runtime/caml/intext.h
++index a2a3fb8248..b68030aad8 100644
++--- a/runtime/caml/intext.h
+++++ b/runtime/caml/intext.h
++@@ -18,9 +18,6 @@
++ #ifndef CAML_INTEXT_H
++ #define CAML_INTEXT_H
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "misc.h"
++ #include "mlvalues.h"
++ 
++diff --git a/runtime/caml/m.h.in b/runtime/caml/m.h.in
++index 1c3dee1779..ba0074318d 100644
++--- a/runtime/caml/m.h.in
+++++ b/runtime/caml/m.h.in
++@@ -90,7 +90,7 @@
++ 
++ #undef CAML_WITH_FPIC
++ 
++-#undef CAML_SAFE_STRING
+++#define CAML_SAFE_STRING 1
++ 
++ #undef FLAT_FLOAT_ARRAY
++ 
++diff --git a/runtime/caml/memory.h b/runtime/caml/memory.h
++index d9e58bc2d0..8837d33d25 100644
++--- a/runtime/caml/memory.h
+++++ b/runtime/caml/memory.h
++@@ -18,9 +18,6 @@
++ #ifndef CAML_MEMORY_H
++ #define CAML_MEMORY_H
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "config.h"
++ #ifdef CAML_INTERNALS
++ #include "gc.h"
++@@ -329,7 +326,7 @@ struct caml__roots_block {
++   #define CAMLunused_start __attribute__ ((unused))
++   #define CAMLunused_end
++   #define CAMLunused __attribute__ ((unused))
++-#elif defined(_MSC_VER) && _MSC_VER >= 1500
+++#elif _MSC_VER >= 1500
++   #define CAMLunused_start  __pragma( warning (push) )           \
++     __pragma( warning (disable:4189 ) )
++   #define CAMLunused_end __pragma( warning (pop))
++diff --git a/runtime/caml/misc.h b/runtime/caml/misc.h
++index c605f8711e..b97d20c2bd 100644
++--- a/runtime/caml/misc.h
+++++ b/runtime/caml/misc.h
++@@ -18,9 +18,6 @@
++ #ifndef CAML_MISC_H
++ #define CAML_MISC_H
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "config.h"
++ 
++ /* Standard definitions */
++@@ -29,13 +26,15 @@
++ #include <stdlib.h>
++ #include <stdarg.h>
++ 
+++#include "camlatomic.h"
+++
++ /* Deprecation warnings */
++ 
++ #if defined(__GNUC__) || defined(__clang__)
++   /* Supported since at least GCC 3.1 */
++   #define CAMLdeprecated_typedef(name, type) \
++     typedef type name __attribute ((deprecated))
++-#elif defined(_MSC_VER) && _MSC_VER >= 1310
+++#elif _MSC_VER >= 1310
++   /* NB deprecated("message") only supported from _MSC_VER >= 1400 */
++   #define CAMLdeprecated_typedef(name, type) \
++     typedef __declspec(deprecated) type name
++@@ -43,8 +42,7 @@
++   #define CAMLdeprecated_typedef(name, type) typedef type name
++ #endif
++ 
++-#if defined(__GNUC__) && __STDC_VERSION__ >= 199901L \
++- || defined(_MSC_VER) && _MSC_VER >= 1925
+++#if defined(__GNUC__) && __STDC_VERSION__ >= 199901L || _MSC_VER >= 1925
++ 
++ #define CAML_STRINGIFY(x) #x
++ #ifdef _MSC_VER
++@@ -91,7 +89,7 @@ CAMLdeprecated_typedef(addr, char *);
++   #define CAMLnoreturn_start
++   #define CAMLnoreturn_end __attribute__ ((noreturn))
++   #define Noreturn __attribute__ ((noreturn))
++-#elif defined(_MSC_VER) && _MSC_VER >= 1500
+++#elif _MSC_VER >= 1500
++   #define CAMLnoreturn_start __declspec(noreturn)
++   #define CAMLnoreturn_end
++   #define Noreturn
++@@ -139,12 +137,11 @@ CAMLdeprecated_typedef(addr, char *);
++ /* we need to be able to compute the exact offset of each member. */
++ #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
++ #define CAMLalign(n) _Alignas(n)
++-#elif defined(__cplusplus) \
++-   && (__cplusplus >= 201103L || defined(_MSC_VER) && _MSC_VER >= 1900)
+++#elif defined(__cplusplus) && (__cplusplus >= 201103L || _MSC_VER >= 1900)
++ #define CAMLalign(n) alignas(n)
++ #elif defined(SUPPORTS_ALIGNED_ATTRIBUTE)
++ #define CAMLalign(n) __attribute__((aligned(n)))
++-#elif defined(_MSC_VER) && _MSC_VER >= 1500
+++#elif _MSC_VER >= 1500
++ #define CAMLalign(n) __declspec(align(n))
++ #else
++ #error "How do I align values on this platform?"
++@@ -172,7 +169,7 @@ CAMLdeprecated_typedef(addr, char *);
++   #define CAMLunused_start __attribute__ ((unused))
++   #define CAMLunused_end
++   #define CAMLunused __attribute__ ((unused))
++-#elif defined(_MSC_VER) && _MSC_VER >= 1500
+++#elif _MSC_VER >= 1500
++   #define CAMLunused_start  __pragma( warning (push) )           \
++     __pragma( warning (disable:4189 ) )
++   #define CAMLunused_end __pragma( warning (pop))
++diff --git a/runtime/caml/mlvalues.h b/runtime/caml/mlvalues.h
++index 677e44e183..00143e5ea0 100644
++--- a/runtime/caml/mlvalues.h
+++++ b/runtime/caml/mlvalues.h
++@@ -16,9 +16,6 @@
++ #ifndef CAML_MLVALUES_H
++ #define CAML_MLVALUES_H
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "config.h"
++ #include "misc.h"
++ 
++@@ -286,11 +283,7 @@ CAMLextern value caml_hash_variant(char const * tag);
++ 
++ /* Strings. */
++ #define String_tag 252
++-#ifdef CAML_SAFE_STRING
++ #define String_val(x) ((const char *) Bp_val(x))
++-#else
++-#define String_val(x) ((char *) Bp_val(x))
++-#endif
++ #define Bytes_val(x) ((unsigned char *) Bp_val(x))
++ CAMLextern mlsize_t caml_string_length (value);   /* size in bytes */
++ CAMLextern int caml_string_is_c_safe (value);
++diff --git a/runtime/caml/s.h.in b/runtime/caml/s.h.in
++index 8e4efdcc72..9a5d9f4a91 100644
++--- a/runtime/caml/s.h.in
+++++ b/runtime/caml/s.h.in
++@@ -60,6 +60,8 @@
++ /* Define HAS_WORKING_ROUND is the round function is correctly implemented. This
++    hatch exists primarily for https://sourceforge.net/p/mingw-w64/bugs/573/ */
++ 
+++#undef HAS_GETENTROPY
+++
++ #undef HAS_GETRUSAGE
++ 
++ #undef HAS_TIMES
++@@ -70,6 +72,8 @@
++ 
++ #undef HAS_ISSETUGID
++ 
+++#undef HAS_STDATOMIC_H
+++
++ /* 2. For the Unix library. */
++ 
++ #undef HAS_SOCKETS
++diff --git a/runtime/caml/signals.h b/runtime/caml/signals.h
++index 62b0e7fafa..0b8cc50064 100644
++--- a/runtime/caml/signals.h
+++++ b/runtime/caml/signals.h
++@@ -20,9 +20,6 @@
++ #include<signal.h>
++ #endif
++ 
++-#ifndef CAML_NAME_SPACE
++-#include "compatibility.h"
++-#endif
++ #include "misc.h"
++ #include "mlvalues.h"
++ 
++diff --git a/runtime/caml/sys.h b/runtime/caml/sys.h
++index 75b97818c1..3b2d537ac4 100644
++--- a/runtime/caml/sys.h
+++++ b/runtime/caml/sys.h
++@@ -24,6 +24,8 @@
++ extern "C" {
++ #endif
++ 
+++CAMLextern char * caml_strerror(int errnum, char * buf, size_t buflen);
+++
++ #define NO_ARG Val_int(0)
++ 
++ CAMLnoreturn_start
++diff --git a/runtime/caml/winsupport.h b/runtime/caml/winsupport.h
++index 6851457e29..2978195337 100644
++--- a/runtime/caml/winsupport.h
+++++ b/runtime/caml/winsupport.h
++@@ -60,6 +60,11 @@ typedef struct _REPARSE_DATA_BUFFER
++ } REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
++ #endif
++ 
+++typedef union {
+++  FILETIME ft;
+++  ULONGLONG ul;
+++} CAML_ULONGLONG_FILETIME;
+++
++ #endif
++ 
++ #endif /* CAML_WINSUPPORT_H */
++diff --git a/runtime/debugger.c b/runtime/debugger.c
++index 97d22832a0..c10c7d0f8f 100644
++--- a/runtime/debugger.c
+++++ b/runtime/debugger.c
++@@ -30,6 +30,7 @@
++ #include "caml/misc.h"
++ #include "caml/osdeps.h"
++ #include "caml/skiplist.h"
+++#include "caml/sys.h"
++ 
++ int caml_debugger_in_use = 0;
++ uintnat caml_event_count;
++@@ -110,6 +111,7 @@ static struct skiplist event_points_table = SKIPLIST_STATIC_INITIALIZER;
++ 
++ static void open_connection(void)
++ {
+++  char buf[1024];
++ #ifdef _WIN32
++   /* Set socket to synchronous mode (= non-overlapped) so that file
++      descriptor-oriented functions (read()/write() etc.) can be
++@@ -133,7 +135,7 @@ static void open_connection(void)
++     caml_fatal_error("cannot connect to debugger at %s\n"
++                      "error: %s",
++                      (dbg_addr ? dbg_addr : "(none)"),
++-                     strerror (errno));
+++                     caml_strerror(errno, buf, sizeof(buf)));
++   dbg_in = caml_open_descriptor_in(dbg_socket);
++   dbg_out = caml_open_descriptor_out(dbg_socket);
++   /* The code in this file does not bracket channel I/O operations with
++diff --git a/runtime/domain.c b/runtime/domain.c
++index d4d8de53fc..a6f0a3028e 100644
++--- a/runtime/domain.c
+++++ b/runtime/domain.c
++@@ -19,7 +19,7 @@
++ #include "caml/domain_state.h"
++ #include "caml/memory.h"
++ 
++-CAMLexport caml_domain_state* Caml_state;
+++CAMLexport caml_domain_state* caml_state;
++ 
++ void caml_init_domain ()
++ {
++diff --git a/runtime/dune b/runtime/dune
++index 78c39300ed..23eb1d1e8a 100644
++--- a/runtime/dune
+++++ b/runtime/dune
++@@ -21,7 +21,7 @@
++      interp.c ints.c io.c
++    lexing.c md5.c meta.c memprof.c obj.c parsing.c signals.c str.c sys.c
++      callback.c weak.c
++-   finalise.c stacks.c dynlink.c backtrace_byt.c backtrace.c
+++   finalise.c dynlink.c backtrace_byt.c backtrace.c
++      afl.c
++    bigarray.c eventlog.c)
++  (action  (with-stdout-to %{targets} (run %{dep:gen_primitives.sh}))))
++@@ -36,7 +36,7 @@
++    ../Makefile.common Makefile
++    (glob_files caml/*.h)
++    ; matches the line structure of files in Makefile/BYTECODE_C_SOURCES
++-   interp.c misc.c stacks.c fix_code.c startup_aux.c startup_byt.c freelist.c
+++   interp.c misc.c fix_code.c startup_aux.c startup_byt.c freelist.c
++      major_gc.c
++    minor_gc.c memory.c alloc.c roots_byt.c globroots.c fail_byt.c signals.c
++    signals_byt.c printexc.c backtrace_byt.c backtrace.c compare.c ints.c
++diff --git a/runtime/dynlink_nat.c b/runtime/dynlink_nat.c
++index dba30c3848..628d837208 100644
++--- a/runtime/dynlink_nat.c
+++++ b/runtime/dynlink_nat.c
++@@ -43,7 +43,7 @@ static value Val_handle(void* handle) {
++ }
++ 
++ static void *getsym(void *handle, const char *module, const char *name){
++-  char *fullname = caml_stat_strconcat(3, "caml", module, name);
+++  char *fullname = caml_stat_strconcat(4, "caml", module, ".", name);
++   void *sym;
++   sym = caml_dlsym (handle, fullname);
++   /*  printf("%s => %lx\n", fullname, (uintnat) sym); */
++@@ -105,26 +105,27 @@ CAMLprim value caml_natdynlink_run(value handle_v, value symbol) {
++ 
++   unit = String_val(symbol);
++ 
++-  sym = optsym("__frametable");
+++  sym = optsym("frametable");
++   if (NULL != sym) caml_register_frametable(sym);
++ 
++-  sym = optsym("__gc_roots");
+++  sym = optsym("gc_roots");
++   if (NULL != sym) caml_register_dyn_global(sym);
++ 
++-  sym = optsym("__data_begin");
++-  sym2 = optsym("__data_end");
+++  sym = optsym("data_begin");
+++  sym2 = optsym("data_end");
++   if (NULL != sym && NULL != sym2)
++     caml_page_table_add(In_static_data, sym, sym2);
++ 
++-  sym = optsym("__code_begin");
++-  sym2 = optsym("__code_end");
++-  if (NULL != sym && NULL != sym2)
+++  sym = optsym("code_begin");
+++  sym2 = optsym("code_end");
+++  /* Do not register empty code fragments */
+++  if (NULL != sym && NULL != sym2 && sym != sym2)
++     caml_register_code_fragment((char *) sym, (char *) sym2,
++                                 DIGEST_LATER, NULL);
++ 
++   if( caml_natdynlink_hook != NULL ) caml_natdynlink_hook(handle,unit);
++ 
++-  entrypoint = optsym("__entry");
+++  entrypoint = optsym("entry");
++   if (NULL != entrypoint) result = caml_callback((value)(&entrypoint), 0);
++   else result = Val_unit;
++ 
++diff --git a/runtime/fix_code.c b/runtime/fix_code.c
++index 5584019867..aa059be5df 100644
++--- a/runtime/fix_code.c
+++++ b/runtime/fix_code.c
++@@ -82,14 +82,8 @@ void caml_fixup_endianness(code_t code, asize_t len)
++ 
++ #ifdef THREADED_CODE
++ 
++-static char ** caml_instr_table;
++-static char * caml_instr_base;
++-
++-void caml_init_thread_code(void ** instr_table, void * instr_base)
++-{
++-  caml_instr_table = (char **) instr_table;
++-  caml_instr_base = (char *) instr_base;
++-}
+++char ** caml_instr_table;
+++char * caml_instr_base;
++ 
++ static int* opcode_nargs = NULL;
++ int* caml_init_opcode_nargs(void)
++diff --git a/runtime/gen_primitives.sh b/runtime/gen_primitives.sh
++index a727d5c25c..01644a8a17 100755
++--- a/runtime/gen_primitives.sh
+++++ b/runtime/gen_primitives.sh
++@@ -25,10 +25,11 @@ export LC_ALL=C
++       alloc array compare extern floats gc_ctrl hash intern interp ints io \
++       lexing md5 meta memprof obj parsing signals str sys callback weak \
++       finalise stacks dynlink backtrace_byt backtrace afl \
++-      bigarray eventlog
+++      bigarray eventlog prng
++   do
++-      sed -n -e 's/^CAMLprim value \([a-z0-9_][a-z0-9_]*\).*/\1/p' "$prim.c"
+++      sed -n -e 's/^CAMLprim value \([a-z0-9_][a-z0-9_]*\).*/\1/p' \
+++        "runtime/$prim.c"
++   done
++   sed -n -e 's/^CAMLprim_int64_[0-9](\([a-z0-9_][a-z0-9_]*\)).*/caml_int64_\1\
++-caml_int64_\1_native/p' ints.c
+++caml_int64_\1_native/p' runtime/ints.c
++ ) | sort | uniq
++diff --git a/runtime/hash.c b/runtime/hash.c
++index f33634c227..da111db629 100644
++--- a/runtime/hash.c
+++++ b/runtime/hash.c
++@@ -301,6 +301,15 @@ CAMLprim value caml_hash(value count, value limit, value seed, value obj)
++   return Val_int(h & 0x3FFFFFFFU);
++ }
++ 
+++CAMLprim value caml_string_hash(value seed, value string)
+++{
+++  uint32_t h;
+++  h = Int_val(seed);
+++  h = caml_hash_mix_string (h, string);
+++  FINAL_MIX(h);
+++  return Val_int(h & 0x3FFFFFFFU);
+++}
+++
++ /* Hashing variant tags */
++ 
++ CAMLexport value caml_hash_variant(char const * tag)
++diff --git a/runtime/i386.S b/runtime/i386.S
++index 4d273c9f04..585c2e4c5b 100644
++--- a/runtime/i386.S
+++++ b/runtime/i386.S
++@@ -98,13 +98,13 @@
++ 
++         .text
++ #if defined(FUNCTION_SECTIONS)
++-        TEXT_SECTION(caml_hot__code_begin)
++-        .globl  G(caml_hot__code_begin)
++-G(caml_hot__code_begin):
+++        TEXT_SECTION(caml_hot.code_begin)
+++        .globl  G(caml_hot.code_begin)
+++G(caml_hot.code_begin):
++ 
++-        TEXT_SECTION(caml_hot__code_end)
++-        .globl  G(caml_hot__code_end)
++-G(caml_hot__code_end):
+++        TEXT_SECTION(caml_hot.code_end)
+++        .globl  G(caml_hot.code_end)
+++G(caml_hot.code_end):
++ #endif
++ 
++ /* Allocation */
++@@ -116,7 +116,7 @@ FUNCTION(caml_call_gc)
++         CFI_STARTPROC
++ LBL(caml_call_gc):
++     /* Record lowest stack address and return address */
++-        movl    G(Caml_state), %ebx
+++        movl    G(caml_state), %ebx
++         movl    (%esp), %eax
++         movl    %eax, CAML_STATE(last_return_address, %ebx)
++         leal    4(%esp), %eax
++@@ -128,7 +128,7 @@ LBL(caml_call_gc):
++         movl    %eax, 0(%esp)
++         addl    $(STACK_PROBE_SIZE), %esp; CFI_ADJUST(-STACK_PROBE_SIZE);
++ #endif
++-    /* Build array of registers, save it into Caml_state->gc_regs */
+++    /* Build array of registers, save it into caml_state->gc_regs */
++         pushl   %ebp; CFI_ADJUST(4)
++         pushl   %edi; CFI_ADJUST(4)
++         pushl   %esi; CFI_ADJUST(4)
++@@ -156,7 +156,7 @@ LBL(caml_call_gc):
++ 
++ FUNCTION(caml_alloc1)
++         CFI_STARTPROC
++-        movl    G(Caml_state), %ebx
+++        movl    G(caml_state), %ebx
++         movl    CAML_STATE(young_ptr, %ebx), %eax
++         subl    $8, %eax
++         movl    %eax, CAML_STATE(young_ptr, %ebx)
++@@ -168,7 +168,7 @@ FUNCTION(caml_alloc1)
++ 
++ FUNCTION(caml_alloc2)
++         CFI_STARTPROC
++-        movl    G(Caml_state), %ebx
+++        movl    G(caml_state), %ebx
++         movl    CAML_STATE(young_ptr, %ebx), %eax
++         subl    $12, %eax
++         movl    %eax, CAML_STATE(young_ptr, %ebx)
++@@ -180,7 +180,7 @@ FUNCTION(caml_alloc2)
++ 
++ FUNCTION(caml_alloc3)
++         CFI_STARTPROC
++-        movl    G(Caml_state), %ebx
+++        movl    G(caml_state), %ebx
++         movl    CAML_STATE(young_ptr, %ebx), %eax
++         subl    $16, %eax
++         movl    %eax, CAML_STATE(young_ptr, %ebx)
++@@ -192,10 +192,10 @@ FUNCTION(caml_alloc3)
++ 
++ FUNCTION(caml_allocN)
++         CFI_STARTPROC
++-        movl    G(Caml_state), %ebx
++-        /* eax = size - Caml_state->young_ptr */
+++        movl    G(caml_state), %ebx
+++        /* eax = size - caml_state->young_ptr */
++         subl    CAML_STATE(young_ptr, %ebx), %eax
++-        negl    %eax              /* eax = Caml_state->young_ptr - size */
+++        negl    %eax              /* eax = caml_state->young_ptr - size */
++         movl    %eax, CAML_STATE(young_ptr, %ebx)
++         cmpl    CAML_STATE(young_limit, %ebx), %eax
++         jb      LBL(caml_call_gc)
++@@ -209,7 +209,7 @@ FUNCTION(caml_c_call)
++         CFI_STARTPROC
++     /* Record lowest stack address and return address */
++     /* ecx and edx are destroyed at C call. Use them as temp. */
++-        movl    G(Caml_state), %ecx
+++        movl    G(caml_state), %ecx
++         movl    (%esp), %edx
++         movl    %edx, CAML_STATE(last_return_address, %ecx)
++         leal    4(%esp), %edx
++@@ -239,7 +239,7 @@ FUNCTION(caml_start_program)
++         movl    $ G(caml_program), %esi
++     /* Common code for caml_start_program and caml_callback* */
++ LBL(106):
++-        movl    G(Caml_state), %edi
+++        movl    G(caml_state), %edi
++     /* Build a callback link */
++         pushl   CAML_STATE(gc_regs, %edi); CFI_ADJUST(4)
++         pushl   CAML_STATE(last_return_address, %edi); CFI_ADJUST(4)
++@@ -253,12 +253,12 @@ LBL(106):
++     /* Call the OCaml code */
++         call    *%esi
++ LBL(107):
++-        movl    G(Caml_state), %edi
+++        movl    G(caml_state), %edi
++     /* Pop the exception handler */
++         popl    CAML_STATE(exception_pointer, %edi); CFI_ADJUST(-4)
++         addl    $12, %esp       ; CFI_ADJUST(-12)
++ LBL(109):
++-        movl    G(Caml_state), %edi /* Reload for LBL(109) entry */
+++        movl    G(caml_state), %edi /* Reload for LBL(109) entry */
++     /* Pop the callback link, restoring the global variables */
++         popl    CAML_STATE(bottom_of_stack, %edi); CFI_ADJUST(-4)
++         popl    CAML_STATE(last_return_address, %edi); CFI_ADJUST(-4)
++@@ -282,7 +282,7 @@ LBL(108):
++ 
++ FUNCTION(caml_raise_exn)
++         CFI_STARTPROC
++-        movl    G(Caml_state), %ebx
+++        movl    G(caml_state), %ebx
++         testl   $1, CAML_STATE(backtrace_active, %ebx)
++         jne     LBL(110)
++         movl    CAML_STATE(exception_pointer, %ebx), %esp
++@@ -312,7 +312,7 @@ LBL(110):
++ 
++ FUNCTION(caml_raise_exception)
++         CFI_STARTPROC
++-        movl    G(Caml_state), %ebx
+++        movl    G(caml_state), %ebx
++         testl   $1, CAML_STATE(backtrace_active, %ebx)
++         jne     LBL(112)
++         movl    8(%esp), %eax
++@@ -405,7 +405,7 @@ FUNCTION(caml_ml_array_bound_error)
++         ffree   %st(6)
++         ffree   %st(7)
++     /* Record lowest stack address and return address */
++-        movl    G(Caml_state), %ebx
+++        movl    G(caml_state), %ebx
++         movl    (%esp), %edx
++         movl    %edx, CAML_STATE(last_return_address, %ebx)
++         leal    4(%esp), %edx
++@@ -422,8 +422,8 @@ FUNCTION(caml_ml_array_bound_error)
++ G(caml_system__code_end):
++ 
++         .data
++-        .globl  G(caml_system__frametable)
++-G(caml_system__frametable):
+++        .globl  G(caml_system.frametable)
+++G(caml_system.frametable):
++         .long   1               /* one descriptor */
++         .long   LBL(107)        /* return address into callback */
++ #ifndef SYS_solaris
++diff --git a/runtime/interp.c b/runtime/interp.c
++index e6700994bc..a59811c87d 100644
++--- a/runtime/interp.c
+++++ b/runtime/interp.c
++@@ -50,9 +50,9 @@ sp is a local copy of the global variable Caml_state->extern_sp. */
++ #ifdef THREADED_CODE
++ #  define Instruct(name) lbl_##name
++ #  if defined(ARCH_SIXTYFOUR) && !defined(ARCH_CODE32)
++-#    define Jumptbl_base &&lbl_ACC0
+++#    define Jumptbl_base ((char *) &&lbl_ACC0)
++ #  else
++-#    define Jumptbl_base 0
+++#    define Jumptbl_base ((char *) 0)
++ #    define jumptbl_base ((char *) 0)
++ #  endif
++ #  ifdef DEBUG
++@@ -249,7 +249,8 @@ value caml_interprete(code_t prog, asize_t prog_size)
++ 
++   if (prog == NULL) {           /* Interpreter is initializing */
++ #ifdef THREADED_CODE
++-    caml_init_thread_code(jumptable, Jumptbl_base);
+++    caml_instr_table = (char **) jumptable;
+++    caml_instr_base = Jumptbl_base;
++ #endif
++     return Val_unit;
++   }
++diff --git a/runtime/power.S b/runtime/power.S
++index 4ca1a14538..68486cb7dc 100644
++--- a/runtime/power.S
+++++ b/runtime/power.S
++@@ -645,9 +645,9 @@ caml_system__code_end:
++ /* Frame table */
++ 
++         .section ".data"
++-        .globl  caml_system__frametable
++-        .type   caml_system__frametable, @object
++-caml_system__frametable:
+++        .globl  caml_system.frametable
+++        .type   caml_system.frametable, @object
+++caml_system.frametable:
++         datag   1               /* one descriptor */
++         datag   .L105 + 4       /* return address into callback */
++         .short  -1              /* negative size count => use callback link */
++diff --git a/runtime/prng.c b/runtime/prng.c
++new file mode 100644
++index 0000000000..4357afbbfb
++--- /dev/null
+++++ b/runtime/prng.c
++@@ -0,0 +1,69 @@
+++/**************************************************************************/
+++/*                                                                        */
+++/*                                 OCaml                                  */
+++/*                                                                        */
+++/*          Xavier Leroy, projet Cambium, College de France and Inria     */
+++/*                                                                        */
+++/*   Copyright 2021 Institut National de Recherche en Informatique et     */
+++/*     en Automatique.                                                    */
+++/*                                                                        */
+++/*   All rights reserved.  This file is distributed under the terms of    */
+++/*   the GNU Lesser General Public License version 2.1, with the          */
+++/*   special exception on linking described in the file LICENSE.          */
+++/*                                                                        */
+++/**************************************************************************/
+++
+++#include <string.h>
+++#include "caml/alloc.h"
+++#include "caml/bigarray.h"
+++#include "caml/mlvalues.h"
+++
+++/* The L64X128 member of the LXM family.  Taken from figure 1 in
+++   "LXM: Better Splittable Pseudorandom Number Generators
+++    (and Almost as Fast)" by Guy L. Steele Jr. and Sebastiano Vigna,
+++    OOPSLA 2021.  */
+++
+++static const uint64_t M = 0xd1342543de82ef95;
+++
+++struct LXM_state {
+++  uint64_t a;            /* per-instance additive parameter (odd) */
+++  uint64_t s;            /* state of the LCG subgenerator */
+++  uint64_t x[2];         /* state of the XBG subgenerator (not 0) */
+++};
+++
+++/* In OCaml, states are represented as a 1D big array of 64-bit integers */
+++
+++#define LXM_val(v) ((struct LXM_state *) Caml_ba_data_val(v))
+++
+++Caml_inline uint64_t rotl(const uint64_t x, int k) {
+++  return (x << k) | (x >> (64 - k));
+++}
+++
+++CAMLprim uint64_t caml_lxm_next_unboxed(value v)
+++{
+++  uint64_t z, q0, q1;
+++  struct LXM_state * st = LXM_val(v);
+++
+++  /* Combining operation */
+++  z = st->s + st->x[0];
+++  /* Mixing function */
+++  z = (z ^ (z >> 32)) * 0xdaba0b6eb09322e3;
+++  z = (z ^ (z >> 32)) * 0xdaba0b6eb09322e3;
+++  z = (z ^ (z >> 32));
+++  /* LCG update */
+++  st->s = st->s * M + st->a;
+++  /* XBG update */
+++  q0 = st->x[0]; q1 = st->x[1];
+++  q1 ^= q0;
+++  q0 = rotl(q0, 24);
+++  q0 = q0 ^ q1 ^ (q1 << 16);
+++  q1 = rotl(q1, 37);
+++  st->x[0] = q0; st->x[1] = q1;
+++  /* Return result */
+++  return z;
+++}
+++
+++CAMLprim value caml_lxm_next(value v)
+++{
+++  return caml_copy_int64(caml_lxm_next_unboxed(v));
+++}
++diff --git a/runtime/riscv.S b/runtime/riscv.S
++index 25b624b56b..112627726f 100644
++--- a/runtime/riscv.S
+++++ b/runtime/riscv.S
++@@ -442,12 +442,12 @@ caml_system__code_end:
++ 
++         .section .data
++         .align  3
++-        .globl  caml_system__frametable
++-        .type   caml_system__frametable, @object
++-caml_system__frametable:
+++        .globl  caml_system.frametable
+++        .type   caml_system.frametable, @object
+++caml_system.frametable:
++         .quad   1               /* one descriptor */
++         .quad   .Lcaml_retaddr  /* return address into callback */
++         .short  -1              /* negative frame size => use callback link */
++         .short  0               /* no roots */
++         .align  3
++-        .size   caml_system__frametable, .-caml_system__frametable
+++        .size   caml_system.frametable, .-caml_system.frametable
++diff --git a/runtime/s390x.S b/runtime/s390x.S
++index aab63e9b24..a05f721836 100644
++--- a/runtime/s390x.S
+++++ b/runtime/s390x.S
++@@ -342,9 +342,9 @@ caml_system__code_end:
++ 
++         .section ".data"
++         .align 8
++-        .globl  caml_system__frametable
++-        .type   caml_system__frametable, @object
++-caml_system__frametable:
+++        .globl  caml_system.frametable
+++        .type   caml_system.frametable, @object
+++caml_system.frametable:
++         .quad   1               /* one descriptor */
++         .quad   .L105           /* return address into callback */
++         .short  -1              /* negative size count => use callback link */
++diff --git a/runtime/sak.c b/runtime/sak.c
++index b7e5c721c2..7499dbf46f 100644
++--- a/runtime/sak.c
+++++ b/runtime/sak.c
++@@ -34,7 +34,9 @@
++ #define printf_os wprintf
++ #else
++ #define strncmp_os strncmp
++-#define toupper_os toupper
+++/* NOTE: See CAVEATS section in https://man.netbsd.org/ctype.3 */
+++/* and NOTE section in https://man7.org/linux/man-pages/man3/toupper.3.html */
+++#define toupper_os(x) toupper((unsigned char)x)
++ #define printf_os printf
++ #endif
++ 
++diff --git a/runtime/sys.c b/runtime/sys.c
++index a77fd9d1cf..9508d3f903 100644
++--- a/runtime/sys.c
+++++ b/runtime/sys.c
++@@ -45,6 +45,9 @@
++ #ifdef HAS_GETTIMEOFDAY
++ #include <sys/time.h>
++ #endif
+++#ifdef __APPLE__
+++#include <sys/random.h> /* for getentropy */
+++#endif
++ #include "caml/alloc.h"
++ #include "caml/debugger.h"
++ #include "caml/fail.h"
++@@ -61,9 +64,21 @@
++ #include "caml/callback.h"
++ #include "caml/startup_aux.h"
++ 
++-static char * error_message(void)
+++CAMLexport char * caml_strerror(int errnum, char * buf, size_t buflen)
++ {
++-  return strerror(errno);
+++#ifdef _WIN32
+++  /* Windows has a thread-safe strerror */
+++  return strerror(errnum);
+++#else
+++  int res = strerror_r(errnum, buf, buflen);
+++  /* glibc<2.13 returns -1/sets errno, >2.13 returns +ve errno.
+++     We assume that buffer size is large enough not to get ERANGE,
+++     so we assume we got EINVAL. */
+++  if (res != 0) {
+++    snprintf(buf, buflen, "Unknown error %d", errnum);
+++  }
+++  return buf;
+++#endif
++ }
++ 
++ #ifndef EAGAIN
++@@ -77,9 +92,10 @@ CAMLexport void caml_sys_error(value arg)
++ {
++   CAMLparam1 (arg);
++   char * err;
+++  char buf[1024];
++   CAMLlocal1 (str);
++ 
++-  err = error_message();
+++  err = caml_strerror(errno, buf, sizeof(buf));
++   if (arg == NO_ARG) {
++     str = caml_copy_string(err);
++   } else {
++@@ -236,7 +252,7 @@ CAMLprim value caml_sys_close(value fd_v)
++   return Val_unit;
++ }
++ 
++-CAMLprim value caml_sys_file_exists(value name)
+++static int caml_sys_file_mode(value name)
++ {
++ #ifdef _WIN32
++   struct _stati64 st;
++@@ -246,39 +262,42 @@ CAMLprim value caml_sys_file_exists(value name)
++   char_os * p;
++   int ret;
++ 
++-  if (! caml_string_is_c_safe(name)) return Val_false;
+++  if (! caml_string_is_c_safe(name)) { errno = ENOENT; return -1; }
++   p = caml_stat_strdup_to_os(String_val(name));
++   caml_enter_blocking_section();
++   ret = stat_os(p, &st);
++   caml_leave_blocking_section();
++   caml_stat_free(p);
+++  if (ret == -1) return -1; else return st.st_mode;
+++}
++ 
++-  return Val_bool(ret == 0);
+++CAMLprim value caml_sys_file_exists(value name)
+++{
+++  int mode = caml_sys_file_mode(name);
+++  return (Val_bool(mode != -1));
++ }
++ 
++ CAMLprim value caml_sys_is_directory(value name)
++ {
++   CAMLparam1(name);
++-#ifdef _WIN32
++-  struct _stati64 st;
+++  int mode = caml_sys_file_mode(name);
+++  if (mode == -1) caml_sys_error(name);
+++#ifdef S_ISDIR
+++  CAMLreturn(Val_bool(S_ISDIR(mode)));
++ #else
++-  struct stat st;
+++  CAMLreturn(Val_bool(mode & S_IFDIR));
++ #endif
++-  char_os * p;
++-  int ret;
++-
++-  caml_sys_check_path(name);
++-  p = caml_stat_strdup_to_os(String_val(name));
++-  caml_enter_blocking_section();
++-  ret = stat_os(p, &st);
++-  caml_leave_blocking_section();
++-  caml_stat_free(p);
+++}
++ 
++-  if (ret == -1) caml_sys_error(name);
++-#ifdef S_ISDIR
++-  CAMLreturn(Val_bool(S_ISDIR(st.st_mode)));
+++CAMLprim value caml_sys_is_regular_file(value name)
+++{
+++  CAMLparam1(name);
+++  int mode = caml_sys_file_mode(name);
+++  if (mode == -1) caml_sys_error(name);
+++#ifdef S_ISREG
+++  CAMLreturn(Val_bool(S_ISREG(mode)));
++ #else
++-  CAMLreturn(Val_bool(st.st_mode & S_IFDIR));
+++  CAMLreturn(Val_bool(mode & S_IFREG));
++ #endif
++ }
++ 
++@@ -565,20 +584,27 @@ extern int caml_win32_random_seed (intnat data[16]);
++ #else
++ int caml_unix_random_seed(intnat data[16])
++ {
++-  int fd;
++   int n = 0;
++-
++-  /* Try /dev/urandom first */
++-  fd = open("/dev/urandom", O_RDONLY, 0);
++-  if (fd != -1) {
++-    unsigned char buffer[12];
++-    int nread = read(fd, buffer, 12);
++-    close(fd);
++-    while (nread > 0) data[n++] = buffer[--nread];
+++  unsigned char buffer[12];
+++  int nread = 0;
+++
+++  /* Try kernel entropy first */
+++#if defined(HAS_GETENTROPY) || defined(__APPLE__)
+++  if (getentropy(buffer, 12) != -1) {
+++    nread = 12;
+++  } else
+++#endif
+++  { int fd = open("/dev/urandom", O_RDONLY, 0);
+++    if (fd != -1) {
+++      nread = read(fd, buffer, 12);
+++      close(fd);
+++    }
++   }
++-  /* If the read from /dev/urandom fully succeeded, we now have 96 bits
+++  while (nread > 0) data[n++] = buffer[--nread];
+++  /* If the kernel provided enough entropy, we now have 96 bits
++      of good random data and can stop here. */
++   if (n >= 12) return n;
+++
++   /* Otherwise, complement whatever we got (probably nothing)
++      with some not-very-random data. */
++   {
+diff --git a/diff-against-trunk-support.diff b/diff-against-trunk-support.diff
+new file mode 100644
+index 0000000000..381be8cdc2
+--- /dev/null
++++ b/diff-against-trunk-support.diff
+@@ -0,0 +1,3974 @@
++diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
++index 59b5162a2f..13cd6abde1 100644
++--- a/.github/workflows/build.yml
+++++ b/.github/workflows/build.yml
++@@ -57,7 +57,7 @@ jobs:
++          '${{ github.event.repository.full_name }}'
++       - name: Configure tree
++         run: |
++-          MAKE_ARG=-j XARCH=x64 CONFIG_ARG='--enable-flambda --enable-cmm-invariants --enable-dependency-generation --enable-native-toplevel' OCAMLRUNPARAM=b,v=0 bash -xe tools/ci/actions/runner.sh configure
+++          MAKE_ARG=-j CONFIG_ARG='--enable-flambda --enable-cmm-invariants --enable-dependency-generation --enable-native-toplevel' OCAMLRUNPARAM=b,v=0 bash -xe tools/ci/actions/runner.sh configure
++       - name: Build
++         run: |
++           MAKE_ARG=-j bash -xe tools/ci/actions/runner.sh build
++@@ -125,7 +125,7 @@ jobs:
++         run: brew install parallel
++       - name: configure tree
++         run: |
++-          CONFIG_ARG=${{ matrix.config_arg }} MAKE_ARG=-j XARCH=x64 bash -xe tools/ci/actions/runner.sh configure
+++          CONFIG_ARG=${{ matrix.config_arg }} MAKE_ARG=-j bash -xe tools/ci/actions/runner.sh configure
++       - name: Build
++         run: |
++           MAKE_ARG=-j bash -xe tools/ci/actions/runner.sh build
++@@ -146,7 +146,7 @@ jobs:
++   i386:
++     runs-on: ubuntu-latest
++     container:
++-      image: i386/ubuntu:18.04
+++      image: debian:10
++       options: --platform linux/i386 --user root
++     steps:
++       - name: OS Dependencies
++@@ -158,7 +158,7 @@ jobs:
++         uses: actions/checkout@v1
++       - name: configure tree
++         run: |
++-          MAKE_ARG=-j XARCH=i386 bash -xe tools/ci/actions/runner.sh configure
+++          MAKE_ARG=-j bash -xe tools/ci/actions/runner.sh configure
++       - name: Build
++         run: |
++           MAKE_ARG=-j bash -xe tools/ci/actions/runner.sh build
++diff --git a/appveyor.yml b/appveyor.yml
++index 333bcad1af..94ee1cfe3d 100644
++--- a/appveyor.yml
+++++ b/appveyor.yml
++@@ -31,9 +31,10 @@ environment:
++     FORCE_CYGWIN_UPGRADE: 0
++     BUILD_MODE: world.opt
++   matrix:
+++    - PORT: mingw32
+++      BOOTSTRAP_FLEXDLL: true
++     - PORT: mingw64
++       BOOTSTRAP_FLEXDLL: true
++-# OCaml 5.0 does not yet support MSVC
++ #    - PORT: msvc64
++ #      BOOTSTRAP_FLEXDLL: false
++ #      BUILD_MODE: steps
++@@ -43,8 +44,8 @@ environment:
++ #      SDK: |-
++ #        "C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\SetEnv.cmd" /x86
++ 
++-matrix:
++-  fast_finish: true
+++#matrix:
+++#  fast_finish: true
++ 
++ cache:
++   - C:\cygwin64\var\cache\setup
++diff --git a/ocamltest/builtin_actions.ml b/ocamltest/builtin_actions.ml
++index 0bc17bc281..faae83cf0e 100644
++--- a/ocamltest/builtin_actions.ml
+++++ b/ocamltest/builtin_actions.ml
++@@ -204,6 +204,13 @@ let function_sections = make
++      "Target supports function sections"
++      "Target does not support function sections")
++ 
+++let naked_pointers = make
+++  ~name:"naked_pointers"
+++  ~description:"Pass if target supports naked pointers"
+++  (Actions_helpers.pass_or_skip (Ocamltest_config.naked_pointers)
+++     "Runtime system supports naked pointers"
+++     "Runtime system does not support naked pointers")
+++
++ let frame_pointers = make
++   ~name:"frame_pointers"
++   ~description:"Pass if frame pointers are available"
++@@ -343,6 +350,7 @@ let _ =
++     arch_i386;
++     arch_power;
++     function_sections;
+++    naked_pointers;
++     frame_pointers;
++     file_exists;
++     copy;
++diff --git a/ocamltest/ocamltest_config.ml.in b/ocamltest/ocamltest_config.ml.in
++index 282090b4c3..dfda7b1f87 100644
++--- a/ocamltest/ocamltest_config.ml.in
+++++ b/ocamltest/ocamltest_config.ml.in
++@@ -90,4 +90,6 @@ let function_sections = @function_sections@
++ 
++ let instrumented_runtime = @instrumented_runtime@
++ 
+++let naked_pointers = @naked_pointers@
+++
++ let frame_pointers = @frame_pointers@
++diff --git a/ocamltest/ocamltest_config.mli b/ocamltest/ocamltest_config.mli
++index cbe1432466..d20ec18ff3 100644
++--- a/ocamltest/ocamltest_config.mli
+++++ b/ocamltest/ocamltest_config.mli
++@@ -125,5 +125,8 @@ val function_sections : bool
++ val instrumented_runtime : bool
++ (** Whether the instrumented runtime is available *)
++ 
+++val naked_pointers : bool
+++(** Whether the runtime system supports naked pointers outside the heap *)
+++
++ val frame_pointers : bool
++ (** Whether frame-pointers have been enabled at configure time *)
++diff --git a/ocamltest/run_unix.c b/ocamltest/run_unix.c
++index 80eac2d727..f8f264f471 100644
++--- a/ocamltest/run_unix.c
+++++ b/ocamltest/run_unix.c
++@@ -349,7 +349,9 @@ int run_command(const command_settings *settings)
++       myperror("fork");
++       return -1;
++     case 0: /* child process */
+++#if 0
++       caml_atfork_hook();
+++#endif
++       exit( run_command_child(settings) );
++     default:
++       return run_command_parent(settings, child_pid);
++diff --git a/testsuite/tests/asmcomp/is_in_static_data.c b/testsuite/tests/asmcomp/is_in_static_data.c
++new file mode 100644
++index 0000000000..ccf0582c0a
++--- /dev/null
+++++ b/testsuite/tests/asmcomp/is_in_static_data.c
++@@ -0,0 +1,5 @@
+++#include "caml/address_class.h"
+++
+++value caml_is_in_static_data(value v) {
+++  return(Val_bool(Is_in_static_data(v)));
+++}
++diff --git a/testsuite/tests/asmcomp/is_static.ml b/testsuite/tests/asmcomp/is_static.ml
++new file mode 100644
++index 0000000000..b8a3bef006
++--- /dev/null
+++++ b/testsuite/tests/asmcomp/is_static.ml
++@@ -0,0 +1,40 @@
+++(* TEST
+++   modules = "is_in_static_data.c"
+++   * naked_pointers
+++   ** native
+++*)
+++
+++(* Data that should be statically allocated by the compiler (all versions) *)
+++
+++external is_in_static_data : 'a -> bool = "caml_is_in_static_data"
+++
+++(* Basic constant blocks should be static *)
+++let block1 = (1,2)
+++let () = assert(is_in_static_data block1)
+++
+++(* as pattern shouldn't prevent it *)
+++let (a, b) as block2 = (1,2)
+++let () = assert(is_in_static_data block2)
+++
+++(* Also in functions *)
+++let f () =
+++  let block = (1,2) in
+++  assert(is_in_static_data block)
+++
+++let () = (f [@inlined never]) ()
+++
+++(* Closed functions should be static *)
+++let closed_function x = x + 1 (* + is a primitive, it cannot be in the closure*)
+++let () = assert(is_in_static_data closed_function)
+++
+++(* And functions using closed functions *)
+++let almost_closed_function x =
+++  (closed_function [@inlined never]) x
+++let () = assert(is_in_static_data almost_closed_function)
+++
+++(* Recursive constant functions should be static *)
+++let rec f1 a = g1 a
+++and g1 a = f1 a
+++let () =
+++  assert(is_in_static_data f1);
+++  assert(is_in_static_data g1)
++diff --git a/testsuite/tests/asmcomp/is_static_flambda.ml b/testsuite/tests/asmcomp/is_static_flambda.ml
++new file mode 100644
++index 0000000000..63e53cfc42
++--- /dev/null
+++++ b/testsuite/tests/asmcomp/is_static_flambda.ml
++@@ -0,0 +1,207 @@
+++(* TEST
+++   modules = "is_in_static_data.c is_static_flambda_dep.ml"
+++   * flambda
+++   ** naked_pointers
+++   *** native
+++*)
+++
+++(* Data that should be statically allocated by the compiler (flambda only) *)
+++
+++external is_in_static_data : 'a -> bool = "caml_is_in_static_data"
+++
+++(* Also after inlining *)
+++let g x =
+++  let block = (1,x) in
+++  assert(is_in_static_data block)
+++
+++let () = (g [@inlined always]) 2
+++
+++(* Toplevel immutable blocks should be static *)
+++let block3 = (Sys.opaque_identity 1, Sys.opaque_identity 2)
+++let () = assert(is_in_static_data block3)
+++
+++(* Not being bound shouldn't prevent it *)
+++let () =
+++  assert(is_in_static_data (Sys.opaque_identity 1, Sys.opaque_identity 2))
+++
+++(* Only with rounds >= 2 currently !
+++(* Also after inlining *)
+++let h x =
+++  let block = (Sys.opaque_identity 1,x) in
+++  assert(is_in_static_data block)
+++
+++let () = (h [@inlined always]) (Sys.opaque_identity 2)
+++*)
+++
+++(* Recursive constant values should be static *)
+++let rec a = 1 :: b
+++and b = 2 :: a
+++let () =
+++  assert(is_in_static_data a);
+++  assert(is_in_static_data b)
+++
+++(* And a mix *)
+++type e = E : 'a -> e
+++
+++let rec f1 a = E (g1 a, l1)
+++and g1 a = E (f1 a, l2)
+++and l1 = E (f1, l2)
+++and l2 = E (g1, l1)
+++
+++let () =
+++  assert(is_in_static_data f1);
+++  assert(is_in_static_data g1);
+++  assert(is_in_static_data l1);
+++  assert(is_in_static_data l2)
+++
+++(* Also in functions *)
+++let i () =
+++  let rec f1 a = E (g1 a, l1)
+++  and g1 a = E (f1 a, l2)
+++  and l1 = E (f1, l2)
+++  and l2 = E (g1, l1) in
+++
+++  assert(is_in_static_data f1);
+++  assert(is_in_static_data g1);
+++  assert(is_in_static_data l1);
+++  assert(is_in_static_data l2)
+++
+++let () = (i [@inlined never]) ()
+++
+++module type P = module type of Stdlib
+++(* Top-level modules should be static *)
+++let () = assert(is_in_static_data (module Stdlib:P))
+++
+++(* Not constant let rec to test extraction to initialize_symbol *)
+++let r = ref 0
+++let rec a = (incr r; !r) :: b
+++and b = (incr r; !r) :: a
+++
+++let next =
+++  let r = ref 0 in
+++  fun () -> incr r; !r
+++
+++let () =
+++  assert(is_in_static_data next)
+++
+++(* Exceptions without arguments should be static *)
+++exception No_argument
+++let () = assert(is_in_static_data No_argument)
+++
+++(* And also with constant arguments *)
+++exception Some_argument of string
+++let () = assert(is_in_static_data (Some_argument "some string"))
+++
+++(* Even when exposed by inlining *)
+++let () =
+++  let exn =
+++    try (failwith [@inlined always]) "some other string" with exn -> exn
+++  in
+++  assert(is_in_static_data exn)
+++
+++(* Verify that approximation intersection correctly loads exported
+++   approximations.
+++
+++   Is_static_flambda_dep.pair is a pair with 1 as first element. The
+++   intersection of approximations should return a block with
+++   approximation: [tag 0: [tag 0: Int 1, Unknown], Unknown] *)
+++let f x =
+++  let pair =
+++    if Sys.opaque_identity x then
+++      (1, 2), 3
+++    else
+++      Is_static_flambda_dep.pair, 4
+++  in
+++  let n = fst (fst pair) in
+++  let res = n, n in
+++  assert(is_in_static_data res)
+++  [@@inline never]
+++
+++let () =
+++  f true;
+++  f false
+++
+++(* Verify that physical equality/inequality is correctly propagated *)
+++
+++(* In these tests, tuple can be statically allocated only if it is a
+++   known constant since the function is never inlined (hence this
+++   code is never at toplevel) *)
+++
+++let () =
+++  let f () =
+++    let v = (1, 2) in
+++    (* eq is supposed to be considered always true since v is a
+++       constant, hence aliased to a symbol.
+++       It is not yet optimized away if it is not constant *)
+++    let eq = v == v in
+++    let n = if eq then 1 else 2 in
+++    let tuple = (n,n) in
+++    assert(is_in_static_data tuple)
+++  in
+++  (f [@inlined never]) ()
+++
+++let () =
+++  let f () =
+++    let v = (1, 2) in
+++    (* same with inequality *)
+++    let eq = v != v in
+++    let n = if eq then 1 else 2 in
+++    let tuple = (n,n) in
+++    assert(is_in_static_data tuple)
+++  in
+++  (f [@inlined never]) ()
+++
+++let () =
+++  let f x =
+++    let v1 = Some x in
+++    let v2 = None in
+++    let eq = v1 == v2 in
+++    (* The values are structurally different, so must be physically
+++       different *)
+++    let n = if eq then 1 else 2 in
+++    let tuple = (n,n) in
+++    assert(is_in_static_data tuple)
+++  in
+++  (f [@inlined never]) ()
+++
+++let () =
+++  let f x =
+++    let v1 = Some x in
+++    let v2 = None in
+++    let eq = v1 != v2 in
+++    (* same with inequality *)
+++    let n = if eq then 1 else 2 in
+++    let tuple = (n,n) in
+++    assert(is_in_static_data tuple)
+++  in
+++  (f [@inlined never]) ()
+++
+++let () =
+++  let f x =
+++    let v1 = (1, 2) in
+++    let v2 = (3, 2) in
+++    let eq = v1 == v2 in
+++    (* difference is deeper *)
+++    let n = if eq then 1 else 2 in
+++    let tuple = (n,n) in
+++    assert(is_in_static_data tuple)
+++  in
+++  (f [@inlined never]) ()
+++
+++module Int = struct
+++  type t = int
+++  let compare (a:int) b = compare a b
+++end
+++module IntMap = Map.Make (Int)
+++
+++let () =
+++  let f () =
+++    let a = IntMap.empty in
+++    let b = (IntMap.add [@inlined]) 1 (Some 1) a in
+++    assert(is_in_static_data b);
+++    let c = (IntMap.add [@inlined]) 1 (Some 2) b in
+++    assert(is_in_static_data c);
+++    let d = (IntMap.add [@inlined]) 1 (Some 2) c in
+++    assert(is_in_static_data d);
+++  in
+++  (f [@inlined never]) ()
++diff --git a/testsuite/tests/asmcomp/is_static_flambda_dep.ml b/testsuite/tests/asmcomp/is_static_flambda_dep.ml
++new file mode 100644
++index 0000000000..3a50f7cad4
++--- /dev/null
+++++ b/testsuite/tests/asmcomp/is_static_flambda_dep.ml
++@@ -0,0 +1 @@
+++let pair = 1, 12
++diff --git a/testsuite/tests/asmcomp/polling.c b/testsuite/tests/asmcomp/polling.c
++index b10b9fa4ea..b4680dcd04 100644
++--- a/testsuite/tests/asmcomp/polling.c
+++++ b/testsuite/tests/asmcomp/polling.c
++@@ -14,11 +14,18 @@ CAMLprim value request_minor_gc(value v) {
++     tests are only run in a single domain, so we're probably
++     good.
++   */
+++#if 0
++   Caml_state->young_limit = (uintnat)Caml_state->young_end;
+++#endif
+++  caml_something_to_do = 1;
+++  Caml_state->young_limit = Caml_state->young_alloc_end;
++ 
++   return Val_unit;
++ }
++ 
++ CAMLprim value minor_gcs(value v) {
+++#if 0
++   return Val_long(atomic_load(&caml_minor_collections_count));
+++#endif
+++  return Val_long(Caml_state->stat_minor_collections);
++ }
++diff --git a/testsuite/tests/asmcomp/simple_float_const.ml b/testsuite/tests/asmcomp/simple_float_const.ml
++new file mode 100644
++index 0000000000..1aca414f7e
++--- /dev/null
+++++ b/testsuite/tests/asmcomp/simple_float_const.ml
++@@ -0,0 +1 @@
+++let f = 3.14
++diff --git a/testsuite/tests/asmcomp/simple_float_const_opaque.ml b/testsuite/tests/asmcomp/simple_float_const_opaque.ml
++new file mode 100644
++index 0000000000..1aca414f7e
++--- /dev/null
+++++ b/testsuite/tests/asmcomp/simple_float_const_opaque.ml
++@@ -0,0 +1 @@
+++let f = 3.14
++diff --git a/testsuite/tests/asmcomp/static_float_array_flambda.ml b/testsuite/tests/asmcomp/static_float_array_flambda.ml
++new file mode 100644
++index 0000000000..824a12ca89
++--- /dev/null
+++++ b/testsuite/tests/asmcomp/static_float_array_flambda.ml
++@@ -0,0 +1,26 @@
+++(* TEST
+++   modules = "is_in_static_data.c simple_float_const.ml"
+++   * flambda
+++   ** flat-float-array
+++   *** naked_pointers
+++   **** native
+++*)
+++
+++external is_in_static_data : 'a -> bool = "caml_is_in_static_data"
+++
+++let a = [|0.; 1.|]
+++let f = 1.23
+++let b = [|0.; f; f|]
+++let g = Sys.opaque_identity 1.23
+++let c = [|0.; g|]
+++let d = [|0.; Simple_float_const.f|]
+++
+++let () = assert(is_in_static_data a)
+++let () = assert(is_in_static_data f)
+++let () = assert(is_in_static_data b)
+++
+++let () = assert(not (is_in_static_data c))
+++(* In fact this one could be static by preallocating the array then
+++   patching it when g is available *)
+++
+++let () = assert(is_in_static_data d)
++diff --git a/testsuite/tests/asmcomp/static_float_array_flambda_opaque.ml b/testsuite/tests/asmcomp/static_float_array_flambda_opaque.ml
++new file mode 100644
++index 0000000000..56ea9e1793
++--- /dev/null
+++++ b/testsuite/tests/asmcomp/static_float_array_flambda_opaque.ml
++@@ -0,0 +1,30 @@
+++(* TEST
+++   modules = "is_in_static_data.c simple_float_const_opaque.ml"
+++   flags = "-opaque"
+++   * flambda
+++   ** flat-float-array
+++   *** naked_pointers
+++   **** native
+++*)
+++
+++external is_in_static_data : 'a -> bool = "caml_is_in_static_data"
+++
+++let a = [|0.; 1.|]
+++let f = 1.23
+++let b = [|0.; f; f|]
+++let g = Sys.opaque_identity 1.23
+++let c = [|0.; g|]
+++let d = [|0.; Simple_float_const_opaque.f|]
+++
+++let () = assert(is_in_static_data a)
+++let () = assert(is_in_static_data f)
+++let () = assert(is_in_static_data b)
+++
+++let () = assert(not (is_in_static_data c))
+++(* In fact this one could be static by preallocating the array then
+++   patching it when g is available *)
+++
+++let () = assert(not (is_in_static_data d))
+++(* The dependency Simple_float_const_opaque is built with opaque,
+++   hence the value of Simple_float_const_opaque.f cannot be known
+++   preventing the static allocation of d *)
++diff --git a/testsuite/tests/backtrace/backtrace2.reference b/testsuite/tests/backtrace/backtrace2.reference
++index 62ae0cb77b..816405ff78 100644
++--- a/testsuite/tests/backtrace/backtrace2.reference
+++++ b/testsuite/tests/backtrace/backtrace2.reference
++@@ -35,7 +35,7 @@ Uncaught exception Invalid_argument("index out of bounds")
++ Raised by primitive operation at Backtrace2.run in file "backtrace2.ml", line 62, characters 14-22
++ test_Not_found
++ Uncaught exception Not_found
++-Raised at Stdlib__Hashtbl.find in file "hashtbl.ml", line 542, characters 13-28
+++Raised at Stdlib__Hashtbl.find in file "hashtbl.ml", line 550, characters 13-28
++ Called from Backtrace2.test_Not_found in file "backtrace2.ml", line 43, characters 9-42
++ Re-raised at Backtrace2.test_Not_found in file "backtrace2.ml", line 43, characters 61-70
++ Called from Backtrace2.run in file "backtrace2.ml", line 62, characters 11-23
++@@ -46,13 +46,13 @@ Called from Backtrace2.test_lazy.aux in file "backtrace2.ml", line 47, character
++ Called from Backtrace2.test_lazy.aux in file "backtrace2.ml", line 47, characters 43-52
++ Called from Backtrace2.test_lazy.aux in file "backtrace2.ml", line 47, characters 43-52
++ Called from Backtrace2.test_lazy.aux in file "backtrace2.ml", line 47, characters 43-52
++-Called from CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 49, characters 17-27
++-Re-raised at CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 56, characters 4-11
+++Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 119, characters 17-27
+++Re-raised at CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 124, characters 4-11
++ Called from Backtrace2.run in file "backtrace2.ml", line 62, characters 11-23
++ Uncaught exception Not_found
++-Raised at Stdlib__Hashtbl.find in file "hashtbl.ml", line 542, characters 13-28
+++Raised at Stdlib__Hashtbl.find in file "hashtbl.ml", line 550, characters 13-28
++ Called from Backtrace2.test_lazy.exception_raised_internally in file "backtrace2.ml", line 50, characters 8-41
++-Re-raised at CamlinternalLazy.do_force_block.(fun) in file "camlinternalLazy.ml", line 54, characters 43-50
++-Called from CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 49, characters 17-27
++-Re-raised at CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 56, characters 4-11
+++Re-raised at CamlinternalLazy.force_lazy_block.(fun) in file "camlinternalLazy.ml", line 123, characters 56-63
+++Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 119, characters 17-27
+++Re-raised at CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 124, characters 4-11
++ Called from Backtrace2.run in file "backtrace2.ml", line 62, characters 11-23
++diff --git a/testsuite/tests/backtrace/backtrace_c_exn.ml b/testsuite/tests/backtrace/backtrace_c_exn.ml
++index 9b0077d509..1680c23f7b 100644
++--- a/testsuite/tests/backtrace/backtrace_c_exn.ml
+++++ b/testsuite/tests/backtrace/backtrace_c_exn.ml
++@@ -2,6 +2,8 @@
++    modules = "backtrace_c_exn_.c"
++    flags = "-g"
++    ocamlrunparam += ",b=1"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ (* https://github.com/ocaml-multicore/ocaml-multicore/issues/498 *)
++diff --git a/testsuite/tests/backtrace/backtrace_dynlink.flambda.reference b/testsuite/tests/backtrace/backtrace_dynlink.flambda.reference
++index 3dc0656252..77a0d85598 100644
++--- a/testsuite/tests/backtrace/backtrace_dynlink.flambda.reference
+++++ b/testsuite/tests/backtrace/backtrace_dynlink.flambda.reference
++@@ -1,20 +1,24 @@
++ Raised by primitive operation at Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 6, characters 13-38
++-Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 87, characters 12-29
+++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 12-29
++ Called from Stdlib__List.iter in file "list.ml" (inlined), line 112, characters 12-15
++-Called from Dynlink.Native.run in file "otherlibs/dynlink/native/dynlink.ml", line 86, characters 4-273
++-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 363, characters 13-56
+++Called from Dynlink.Native.run in file "otherlibs/dynlink/native/dynlink.ml", line 88, characters 4-273
+++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
++ Called from Stdlib__List.iter in file "list.ml" (inlined), line 112, characters 12-15
++-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
++-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
+++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
+++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
++ Called from Backtrace_dynlink in file "backtrace_dynlink.ml", line 39, characters 4-52
++ execution of module initializers in the shared library failed: Failure("SUCCESS")
++-Raised by primitive operation at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 87, characters 12-29
++-Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 10-149
+++Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+++Called from Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 3, characters 4-22
+++Re-raised at Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 8, characters 5-12
+++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 12-29
+++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 12-29
+++Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 91, characters 10-149
++ Called from Stdlib__List.iter in file "list.ml" (inlined), line 112, characters 12-15
++-Called from Dynlink.Native.run in file "otherlibs/dynlink/native/dynlink.ml", line 86, characters 4-273
++-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 363, characters 13-56
+++Called from Dynlink.Native.run in file "otherlibs/dynlink/native/dynlink.ml", line 88, characters 4-273
+++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
++ Called from Stdlib__List.iter in file "list.ml" (inlined), line 112, characters 12-15
++-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
++-Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 8-17
++-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
+++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
+++Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 381, characters 8-17
+++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
++ Called from Backtrace_dynlink in file "backtrace_dynlink.ml", line 39, characters 4-52
++diff --git a/testsuite/tests/backtrace/backtrace_dynlink.reference b/testsuite/tests/backtrace/backtrace_dynlink.reference
++index 3f4fa74593..d469a6fc9d 100644
++--- a/testsuite/tests/backtrace/backtrace_dynlink.reference
+++++ b/testsuite/tests/backtrace/backtrace_dynlink.reference
++@@ -1,18 +1,22 @@
++ Raised by primitive operation at Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 6, characters 13-38
++-Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 87, characters 12-29
+++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 12-29
++ Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 363, characters 13-56
+++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
++ Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
++-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
+++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
+++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
++ Called from Backtrace_dynlink in file "backtrace_dynlink.ml", line 39, characters 4-52
++ execution of module initializers in the shared library failed: Failure("SUCCESS")
++-Raised by primitive operation at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 87, characters 12-29
++-Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 10-149
+++Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+++Called from Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 3, characters 4-22
+++Re-raised at Backtrace_dynlink_plugin in file "backtrace_dynlink_plugin.ml", line 8, characters 5-12
+++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 12-29
+++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 12-29
+++Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 91, characters 10-149
++ Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 363, characters 13-56
+++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
++ Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
++-Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 8-17
++-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
+++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
+++Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 381, characters 8-17
+++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
++ Called from Backtrace_dynlink in file "backtrace_dynlink.ml", line 39, characters 4-52
++diff --git a/testsuite/tests/backtrace/backtrace_effects.ml b/testsuite/tests/backtrace/backtrace_effects.ml
++index 352b32cbd7..bafd2259e8 100644
++--- a/testsuite/tests/backtrace/backtrace_effects.ml
+++++ b/testsuite/tests/backtrace/backtrace_effects.ml
++@@ -2,6 +2,8 @@
++    flags = "-g"
++    ocamlrunparam += ",b=1"
++    exit_status = "2"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ open Effect
++diff --git a/testsuite/tests/backtrace/backtrace_effects_nested.ml b/testsuite/tests/backtrace/backtrace_effects_nested.ml
++index 37638a200a..2a2a630160 100644
++--- a/testsuite/tests/backtrace/backtrace_effects_nested.ml
+++++ b/testsuite/tests/backtrace/backtrace_effects_nested.ml
++@@ -1,12 +1,14 @@
++ (* TEST
++ 
++ flags = "-g"
++-* bytecode
++-* no-flambda
++-** native
++-* flambda
+++* skip
+++reason = "OCaml 5 only"
+++** bytecode
+++** no-flambda
+++*** native
+++** flambda
++ reference = "${test_source_directory}/backtrace_effects_nested.flambda.reference"
++-** native
+++*** native
++ 
++ *)
++ 
++diff --git a/testsuite/tests/backtrace/backtrace_systhreads.reference b/testsuite/tests/backtrace/backtrace_systhreads.reference
++index a7feaa8690..815506e7ea 100644
++--- a/testsuite/tests/backtrace/backtrace_systhreads.reference
+++++ b/testsuite/tests/backtrace/backtrace_systhreads.reference
++@@ -2,24 +2,24 @@ Thread 2 killed on uncaught exception Failure("0")
++ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++ Called from Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 14, characters 6-37
++ Re-raised at Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 18, characters 5-14
++-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++ Thread 3 killed on uncaught exception Failure("1")
++ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++ Called from Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 14, characters 6-37
++ Re-raised at Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 18, characters 5-14
++-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++ Thread 4 killed on uncaught exception Failure("2")
++ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++ Called from Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 14, characters 6-37
++ Re-raised at Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 18, characters 5-14
++-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++ Thread 5 killed on uncaught exception Failure("3")
++ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++ Called from Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 14, characters 6-37
++ Re-raised at Backtrace_systhreads.thread_func in file "backtrace_systhreads.ml", line 18, characters 5-14
++-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++ Thread 1 killed on uncaught exception Failure("backtrace")
++ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++ Called from Backtrace_systhreads.thread_backtrace in file "backtrace_systhreads.ml", line 22, characters 6-27
++ Re-raised at Backtrace_systhreads.thread_backtrace in file "backtrace_systhreads.ml", line 26, characters 5-14
++-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++diff --git a/testsuite/tests/backtrace/callstack.reference b/testsuite/tests/backtrace/callstack.reference
++index c762728d14..8287432b20 100644
++--- a/testsuite/tests/backtrace/callstack.reference
+++++ b/testsuite/tests/backtrace/callstack.reference
++@@ -12,4 +12,4 @@ Raised by primitive operation at Callstack.f0 in file "callstack.ml", line 11, c
++ Called from Callstack.f1 in file "callstack.ml", line 12, characters 27-32
++ Called from Callstack.f2 in file "callstack.ml", line 13, characters 27-32
++ Called from Callstack.f3 in file "callstack.ml", line 14, characters 27-32
++-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++diff --git a/testsuite/tests/backtrace/lazy.reference b/testsuite/tests/backtrace/lazy.reference
++index 5e8f53482f..af15509686 100644
++--- a/testsuite/tests/backtrace/lazy.reference
+++++ b/testsuite/tests/backtrace/lazy.reference
++@@ -1,14 +1,12 @@
++ Uncaught exception Not_found
++ Raised at Lazy.l1 in file "lazy.ml", line 7, characters 28-45
++-Called from CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 49, characters 17-27
++-Re-raised at CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 56, characters 4-11
++-Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml" (inlined), line 78, characters 27-67
+++Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 119, characters 17-27
+++Re-raised at CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 124, characters 4-11
++ Called from Lazy.test1 in file "lazy.ml", line 10, characters 11-24
++ Called from Lazy.run in file "lazy.ml", line 19, characters 4-11
++ Uncaught exception Not_found
++ Raised at Lazy.l2 in file "lazy.ml", line 12, characters 28-45
++-Called from CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 49, characters 17-27
++-Re-raised at CamlinternalLazy.do_force_block in file "camlinternalLazy.ml", line 56, characters 4-11
++-Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml" (inlined), line 78, characters 27-67
+++Called from CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 119, characters 17-27
+++Re-raised at CamlinternalLazy.force_lazy_block in file "camlinternalLazy.ml", line 124, characters 4-11
++ Called from Lazy.test2 in file "lazy.ml", line 15, characters 6-15
++ Called from Lazy.run in file "lazy.ml", line 19, characters 4-11
++diff --git a/testsuite/tests/basic/patmatch_for_multiple.ml b/testsuite/tests/basic/patmatch_for_multiple.ml
++index 0f532c5b5f..8e9081ebdb 100644
++--- a/testsuite/tests/basic/patmatch_for_multiple.ml
+++++ b/testsuite/tests/basic/patmatch_for_multiple.ml
++@@ -26,15 +26,15 @@ match (3, 2, 1) with
++ | _ -> false
++ ;;
++ [%%expect{|
++-(let (*match*/276 = 3 *match*/277 = 2 *match*/278 = 1)
+++(let (*match*/271 = 3 *match*/272 = 2 *match*/273 = 1)
++   (catch
++     (catch
++-      (catch (if (!= *match*/277 3) (exit 3) (exit 1)) with (3)
++-        (if (!= *match*/276 1) (exit 2) (exit 1)))
+++      (catch (if (!= *match*/272 3) (exit 3) (exit 1)) with (3)
+++        (if (!= *match*/271 1) (exit 2) (exit 1)))
++      with (2) 0)
++    with (1) 1))
++-(let (*match*/276 = 3 *match*/277 = 2 *match*/278 = 1)
++-  (catch (if (!= *match*/277 3) (if (!= *match*/276 1) 0 (exit 1)) (exit 1))
+++(let (*match*/271 = 3 *match*/272 = 2 *match*/273 = 1)
+++  (catch (if (!= *match*/272 3) (if (!= *match*/271 1) 0 (exit 1)) (exit 1))
++    with (1) 1))
++ - : bool = false
++ |}];;
++@@ -47,26 +47,26 @@ match (3, 2, 1) with
++ | _ -> false
++ ;;
++ [%%expect{|
++-(let (*match*/281 = 3 *match*/282 = 2 *match*/283 = 1)
+++(let (*match*/276 = 3 *match*/277 = 2 *match*/278 = 1)
++   (catch
++     (catch
++       (catch
++-        (if (!= *match*/282 3) (exit 6)
++-          (let (x/285 =a (makeblock 0 *match*/281 *match*/282 *match*/283))
++-            (exit 4 x/285)))
+++        (if (!= *match*/277 3) (exit 6)
+++          (let (x/280 =a (makeblock 0 *match*/276 *match*/277 *match*/278))
+++            (exit 4 x/280)))
++        with (6)
++-        (if (!= *match*/281 1) (exit 5)
++-          (let (x/284 =a (makeblock 0 *match*/281 *match*/282 *match*/283))
++-            (exit 4 x/284))))
+++        (if (!= *match*/276 1) (exit 5)
+++          (let (x/279 =a (makeblock 0 *match*/276 *match*/277 *match*/278))
+++            (exit 4 x/279))))
++      with (5) 0)
++-   with (4 x/279) (seq (ignore x/279) 1)))
++-(let (*match*/281 = 3 *match*/282 = 2 *match*/283 = 1)
+++   with (4 x/274) (seq (ignore x/274) 1)))
+++(let (*match*/276 = 3 *match*/277 = 2 *match*/278 = 1)
++   (catch
++-    (if (!= *match*/282 3)
++-      (if (!= *match*/281 1) 0
++-        (exit 4 (makeblock 0 *match*/281 *match*/282 *match*/283)))
++-      (exit 4 (makeblock 0 *match*/281 *match*/282 *match*/283)))
++-   with (4 x/279) (seq (ignore x/279) 1)))
+++    (if (!= *match*/277 3)
+++      (if (!= *match*/276 1) 0
+++        (exit 4 (makeblock 0 *match*/276 *match*/277 *match*/278)))
+++      (exit 4 (makeblock 0 *match*/276 *match*/277 *match*/278)))
+++   with (4 x/274) (seq (ignore x/274) 1)))
++ - : bool = false
++ |}];;
++ 
++@@ -76,8 +76,8 @@ let _ = fun a b ->
++   | ((true, _) as _g)
++   | ((false, _) as _g) -> ()
++ [%%expect{|
++-(function a/286[int] b/287 : int 0)
++-(function a/286[int] b/287 : int 0)
+++(function a/281[int] b/282 : int 0)
+++(function a/281[int] b/282 : int 0)
++ - : bool -> 'a -> unit = <fun>
++ |}];;
++ 
++@@ -96,8 +96,8 @@ let _ = fun a b -> match a, b with
++ | (false, _) as p -> p
++ (* outside, trivial *)
++ [%%expect {|
++-(function a/290[int] b/291 (let (p/292 =a (makeblock 0 a/290 b/291)) p/292))
++-(function a/290[int] b/291 (makeblock 0 a/290 b/291))
+++(function a/285[int] b/286 (let (p/287 =a (makeblock 0 a/285 b/286)) p/287))
+++(function a/285[int] b/286 (makeblock 0 a/285 b/286))
++ - : bool -> 'a -> bool * 'a = <fun>
++ |}]
++ 
++@@ -106,8 +106,8 @@ let _ = fun a b -> match a, b with
++ | ((false, _) as p) -> p
++ (* inside, trivial *)
++ [%%expect{|
++-(function a/294[int] b/295 (let (p/296 =a (makeblock 0 a/294 b/295)) p/296))
++-(function a/294[int] b/295 (makeblock 0 a/294 b/295))
+++(function a/289[int] b/290 (let (p/291 =a (makeblock 0 a/289 b/290)) p/291))
+++(function a/289[int] b/290 (makeblock 0 a/289 b/290))
++ - : bool -> 'a -> bool * 'a = <fun>
++ |}];;
++ 
++@@ -116,11 +116,11 @@ let _ = fun a b -> match a, b with
++ | (false as x, _) as p -> x, p
++ (* outside, simple *)
++ [%%expect {|
++-(function a/300[int] b/301
++-  (let (x/302 =a[int] a/300 p/303 =a (makeblock 0 a/300 b/301))
++-    (makeblock 0 (int,*) x/302 p/303)))
++-(function a/300[int] b/301
++-  (makeblock 0 (int,*) a/300 (makeblock 0 a/300 b/301)))
+++(function a/295[int] b/296
+++  (let (x/297 =a[int] a/295 p/298 =a (makeblock 0 a/295 b/296))
+++    (makeblock 0 (int,*) x/297 p/298)))
+++(function a/295[int] b/296
+++  (makeblock 0 (int,*) a/295 (makeblock 0 a/295 b/296)))
++ - : bool -> 'a -> bool * (bool * 'a) = <fun>
++ |}]
++ 
++@@ -129,11 +129,11 @@ let _ = fun a b -> match a, b with
++ | ((false as x, _) as p) -> x, p
++ (* inside, simple *)
++ [%%expect {|
++-(function a/306[int] b/307
++-  (let (x/308 =a[int] a/306 p/309 =a (makeblock 0 a/306 b/307))
++-    (makeblock 0 (int,*) x/308 p/309)))
++-(function a/306[int] b/307
++-  (makeblock 0 (int,*) a/306 (makeblock 0 a/306 b/307)))
+++(function a/301[int] b/302
+++  (let (x/303 =a[int] a/301 p/304 =a (makeblock 0 a/301 b/302))
+++    (makeblock 0 (int,*) x/303 p/304)))
+++(function a/301[int] b/302
+++  (makeblock 0 (int,*) a/301 (makeblock 0 a/301 b/302)))
++ - : bool -> 'a -> bool * (bool * 'a) = <fun>
++ |}]
++ 
++@@ -142,15 +142,15 @@ let _ = fun a b -> match a, b with
++ | (false, x) as p -> x, p
++ (* outside, complex *)
++ [%%expect{|
++-(function a/316[int] b/317[int]
++-  (if a/316
++-    (let (x/318 =a[int] a/316 p/319 =a (makeblock 0 a/316 b/317))
++-      (makeblock 0 (int,*) x/318 p/319))
++-    (let (x/320 =a b/317 p/321 =a (makeblock 0 a/316 b/317))
++-      (makeblock 0 (int,*) x/320 p/321))))
++-(function a/316[int] b/317[int]
++-  (if a/316 (makeblock 0 (int,*) a/316 (makeblock 0 a/316 b/317))
++-    (makeblock 0 (int,*) b/317 (makeblock 0 a/316 b/317))))
+++(function a/311[int] b/312[int]
+++  (if a/311
+++    (let (x/313 =a[int] a/311 p/314 =a (makeblock 0 a/311 b/312))
+++      (makeblock 0 (int,*) x/313 p/314))
+++    (let (x/315 =a b/312 p/316 =a (makeblock 0 a/311 b/312))
+++      (makeblock 0 (int,*) x/315 p/316))))
+++(function a/311[int] b/312[int]
+++  (if a/311 (makeblock 0 (int,*) a/311 (makeblock 0 a/311 b/312))
+++    (makeblock 0 (int,*) b/312 (makeblock 0 a/311 b/312))))
++ - : bool -> bool -> bool * (bool * bool) = <fun>
++ |}]
++ 
++@@ -160,19 +160,19 @@ let _ = fun a b -> match a, b with
++   -> x, p
++ (* inside, complex *)
++ [%%expect{|
++-(function a/322[int] b/323[int]
+++(function a/317[int] b/318[int]
++   (catch
++-    (if a/322
++-      (let (x/330 =a[int] a/322 p/331 =a (makeblock 0 a/322 b/323))
++-        (exit 10 x/330 p/331))
++-      (let (x/328 =a b/323 p/329 =a (makeblock 0 a/322 b/323))
++-        (exit 10 x/328 p/329)))
++-   with (10 x/324[int] p/325) (makeblock 0 (int,*) x/324 p/325)))
++-(function a/322[int] b/323[int]
+++    (if a/317
+++      (let (x/325 =a[int] a/317 p/326 =a (makeblock 0 a/317 b/318))
+++        (exit 10 x/325 p/326))
+++      (let (x/323 =a b/318 p/324 =a (makeblock 0 a/317 b/318))
+++        (exit 10 x/323 p/324)))
+++   with (10 x/319[int] p/320) (makeblock 0 (int,*) x/319 p/320)))
+++(function a/317[int] b/318[int]
++   (catch
++-    (if a/322 (exit 10 a/322 (makeblock 0 a/322 b/323))
++-      (exit 10 b/323 (makeblock 0 a/322 b/323)))
++-   with (10 x/324[int] p/325) (makeblock 0 (int,*) x/324 p/325)))
+++    (if a/317 (exit 10 a/317 (makeblock 0 a/317 b/318))
+++      (exit 10 b/318 (makeblock 0 a/317 b/318)))
+++   with (10 x/319[int] p/320) (makeblock 0 (int,*) x/319 p/320)))
++ - : bool -> bool -> bool * (bool * bool) = <fun>
++ |}]
++ 
++@@ -185,15 +185,15 @@ let _ = fun a b -> match a, b with
++ | (false as x, _) as p -> x, p
++ (* outside, onecase *)
++ [%%expect {|
++-(function a/332[int] b/333[int]
++-  (if a/332
++-    (let (x/334 =a[int] a/332 _p/335 =a (makeblock 0 a/332 b/333))
++-      (makeblock 0 (int,*) x/334 [0: 1 1]))
++-    (let (x/336 =a[int] a/332 p/337 =a (makeblock 0 a/332 b/333))
++-      (makeblock 0 (int,*) x/336 p/337))))
++-(function a/332[int] b/333[int]
++-  (if a/332 (makeblock 0 (int,*) a/332 [0: 1 1])
++-    (makeblock 0 (int,*) a/332 (makeblock 0 a/332 b/333))))
+++(function a/327[int] b/328[int]
+++  (if a/327
+++    (let (x/329 =a[int] a/327 _p/330 =a (makeblock 0 a/327 b/328))
+++      (makeblock 0 (int,*) x/329 [0: 1 1]))
+++    (let (x/331 =a[int] a/327 p/332 =a (makeblock 0 a/327 b/328))
+++      (makeblock 0 (int,*) x/331 p/332))))
+++(function a/327[int] b/328[int]
+++  (if a/327 (makeblock 0 (int,*) a/327 [0: 1 1])
+++    (makeblock 0 (int,*) a/327 (makeblock 0 a/327 b/328))))
++ - : bool -> bool -> bool * (bool * bool) = <fun>
++ |}]
++ 
++@@ -202,11 +202,11 @@ let _ = fun a b -> match a, b with
++ | ((false as x, _) as p) -> x, p
++ (* inside, onecase *)
++ [%%expect{|
++-(function a/338[int] b/339
++-  (let (x/340 =a[int] a/338 p/341 =a (makeblock 0 a/338 b/339))
++-    (makeblock 0 (int,*) x/340 p/341)))
++-(function a/338[int] b/339
++-  (makeblock 0 (int,*) a/338 (makeblock 0 a/338 b/339)))
+++(function a/333[int] b/334
+++  (let (x/335 =a[int] a/333 p/336 =a (makeblock 0 a/333 b/334))
+++    (makeblock 0 (int,*) x/335 p/336)))
+++(function a/333[int] b/334
+++  (makeblock 0 (int,*) a/333 (makeblock 0 a/333 b/334)))
++ - : bool -> 'a -> bool * (bool * 'a) = <fun>
++ |}]
++ 
++@@ -223,14 +223,14 @@ let _ =fun a b -> match a, b with
++ | (_, _) as p -> p
++ (* outside, tuplist *)
++ [%%expect {|
++-(function a/351[int] b/352
+++(function a/346[int] b/347
++   (catch
++-    (if a/351 (if b/352 (let (p/353 =a (field_imm 0 b/352)) p/353) (exit 12))
+++    (if a/346 (if b/347 (let (p/348 =a (field_imm 0 b/347)) p/348) (exit 12))
++       (exit 12))
++-   with (12) (let (p/354 =a (makeblock 0 a/351 b/352)) p/354)))
++-(function a/351[int] b/352
++-  (catch (if a/351 (if b/352 (field_imm 0 b/352) (exit 12)) (exit 12))
++-   with (12) (makeblock 0 a/351 b/352)))
+++   with (12) (let (p/349 =a (makeblock 0 a/346 b/347)) p/349)))
+++(function a/346[int] b/347
+++  (catch (if a/346 (if b/347 (field_imm 0 b/347) (exit 12)) (exit 12))
+++   with (12) (makeblock 0 a/346 b/347)))
++ - : bool -> bool tuplist -> bool * bool tuplist = <fun>
++ |}]
++ 
++@@ -239,20 +239,20 @@ let _ = fun a b -> match a, b with
++ | ((_, _) as p) -> p
++ (* inside, tuplist *)
++ [%%expect{|
++-(function a/355[int] b/356
+++(function a/350[int] b/351
++   (catch
++     (catch
++-      (if a/355
++-        (if b/356 (let (p/360 =a (field_imm 0 b/356)) (exit 13 p/360))
+++      (if a/350
+++        (if b/351 (let (p/355 =a (field_imm 0 b/351)) (exit 13 p/355))
++           (exit 14))
++         (exit 14))
++-     with (14) (let (p/359 =a (makeblock 0 a/355 b/356)) (exit 13 p/359)))
++-   with (13 p/357) p/357))
++-(function a/355[int] b/356
+++     with (14) (let (p/354 =a (makeblock 0 a/350 b/351)) (exit 13 p/354)))
+++   with (13 p/352) p/352))
+++(function a/350[int] b/351
++   (catch
++     (catch
++-      (if a/355 (if b/356 (exit 13 (field_imm 0 b/356)) (exit 14)) (exit 14))
++-     with (14) (exit 13 (makeblock 0 a/355 b/356)))
++-   with (13 p/357) p/357))
+++      (if a/350 (if b/351 (exit 13 (field_imm 0 b/351)) (exit 14)) (exit 14))
+++     with (14) (exit 13 (makeblock 0 a/350 b/351)))
+++   with (13 p/352) p/352))
++ - : bool -> bool tuplist -> bool * bool tuplist = <fun>
++ |}]
++diff --git a/testsuite/tests/c-api/alloc_async.ml b/testsuite/tests/c-api/alloc_async.ml
++index b8c99a4b07..0ed35acf16 100644
++--- a/testsuite/tests/c-api/alloc_async.ml
+++++ b/testsuite/tests/c-api/alloc_async.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    modules = "alloc_async_stubs.c"
++-   * skip
++-   reason = "alloc async changes: https://github.com/ocaml/ocaml/pull/8897"
++ *)
++ 
++ external test : int ref -> unit = "stub"
++diff --git a/testsuite/tests/c-api/test_c_thread_has_lock.ml b/testsuite/tests/c-api/test_c_thread_has_lock.ml
++index e826001559..f3e4a20be8 100644
++--- a/testsuite/tests/c-api/test_c_thread_has_lock.ml
+++++ b/testsuite/tests/c-api/test_c_thread_has_lock.ml
++@@ -1,7 +1,9 @@
++ (* TEST
++    modules = "test_c_thread_has_lock_cstubs.c"
++-   * bytecode
++-   * native
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** bytecode
+++   ** native
++ *)
++ 
++ external test_with_lock : unit -> bool = "with_lock"
++diff --git a/testsuite/tests/c-api/test_c_thread_has_lock_systhread.ml b/testsuite/tests/c-api/test_c_thread_has_lock_systhread.ml
++index 65327be652..036068739a 100644
++--- a/testsuite/tests/c-api/test_c_thread_has_lock_systhread.ml
+++++ b/testsuite/tests/c-api/test_c_thread_has_lock_systhread.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++    modules = "test_c_thread_has_lock_cstubs.c"
++-   * hassysthreads
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** hassysthreads
++    include systhreads
++-   ** bytecode
++-   ** native
+++   *** bytecode
+++   *** native
++ *)
++ 
++ external test_with_lock : unit -> bool = "with_lock"
++diff --git a/testsuite/tests/callback/nested_fiber.ml b/testsuite/tests/callback/nested_fiber.ml
++index 3786e455ef..77478728df 100644
++--- a/testsuite/tests/callback/nested_fiber.ml
+++++ b/testsuite/tests/callback/nested_fiber.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++    include unix
++    modules = "nested_fiber_.c"
++-   * libunix
++-   ** bytecode
++-   ** native
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** libunix
+++   *** bytecode
+++   *** native
++ *)
++ 
++ external caml_to_c : (unit -> 'a) -> 'a = "caml_to_c"
++diff --git a/testsuite/tests/callback/stack_overflow.ml b/testsuite/tests/callback/stack_overflow.ml
++index 23691dcf6c..6281d76e2a 100644
++--- a/testsuite/tests/callback/stack_overflow.ml
+++++ b/testsuite/tests/callback/stack_overflow.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++    include unix
++    modules = "stack_overflow_.c"
++-   * libunix
++-   ** bytecode
++-   ** native
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** libunix
+++   *** bytecode
+++   *** native
++ *)
++ 
++ external caml_to_c : (unit -> 'a) -> 'a = "caml_to_c"
++diff --git a/testsuite/tests/callback/test7.ml b/testsuite/tests/callback/test7.ml
++index 8883a55f69..800c60e6de 100644
++--- a/testsuite/tests/callback/test7.ml
+++++ b/testsuite/tests/callback/test7.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++    include unix
++    modules = "test7_.c"
++-   * libunix
++-   ** bytecode
++-   ** native
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** libunix
+++   *** bytecode
+++   *** native
++ *)
++ 
++ (* Tests nested calls from C (main C) to OCaml (main OCaml) to C (caml_to_c) to
++diff --git a/testsuite/tests/callback/test_signalhandler.ml b/testsuite/tests/callback/test_signalhandler.ml
++index a2bbacee72..9250395618 100644
++--- a/testsuite/tests/callback/test_signalhandler.ml
+++++ b/testsuite/tests/callback/test_signalhandler.ml
++@@ -1,6 +1,6 @@
++ (* TEST
++    include unix
++-   modules = "test_signalhandler_.c"
+++   modules = "callbackprim.c"
++    * libunix
++    ** bytecode
++    ** native
++@@ -52,17 +52,19 @@ let sighandler signo =
++   (* Thoroughly wipe the minor heap *)
++   ignore (tak (18, 12, 6))
++ 
++-external mykill : int -> int -> unit = "mykill" [@@noalloc]
+++external raise_sigusr1 : unit -> unit = "raise_sigusr1" [@@noalloc]
+++(*external mykill : int -> int -> unit = "mykill" [@@noalloc]*)
++ 
++ let callbacksig () =
++-  let pid = Unix.getpid () in
+++  let _pid = Unix.getpid() in
++   (* Allocate a block in the minor heap *)
++   let s = String.make 5 'b' in
++   (* Send a signal to self.  We want s to remain in a register and
++      not be spilled on the stack, hence we use [mykill]
++      (which is [@@noalloc] and doesn't trigger signal handling)
++      instead of [Unix.kill]. *)
++-  mykill pid Sys.sigusr1;
+++  (*mykill pid Sys.sigusr1;*)
+++  raise_sigusr1 ();
++   (* Allocate some more so that the signal will be tested *)
++   let u = (s, s) in
++   fst u
++diff --git a/testsuite/tests/effects/backtrace.ml b/testsuite/tests/effects/backtrace.ml
++index 6257ba75c5..df6e11ac7a 100644
++--- a/testsuite/tests/effects/backtrace.ml
+++++ b/testsuite/tests/effects/backtrace.ml
++@@ -1,6 +1,8 @@
++ (* TEST
++    flags = "-g"
++    ocamlrunparam += ",b=1"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/cmphash.ml b/testsuite/tests/effects/cmphash.ml
++index 78481d6404..a36d20cb8c 100644
++--- a/testsuite/tests/effects/cmphash.ml
+++++ b/testsuite/tests/effects/cmphash.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/evenodd.ml b/testsuite/tests/effects/evenodd.ml
++index 035308b58f..85f178310b 100644
++--- a/testsuite/tests/effects/evenodd.ml
+++++ b/testsuite/tests/effects/evenodd.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/issue479.ml b/testsuite/tests/effects/issue479.ml
++index 228e098d2e..c00b55c6ff 100644
++--- a/testsuite/tests/effects/issue479.ml
+++++ b/testsuite/tests/effects/issue479.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++-   * toplevel
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** toplevel
++ *)
++ 
++ (* https://github.com/ocaml-multicore/ocaml-multicore/issues/479 *)
++diff --git a/testsuite/tests/effects/marshal.ml b/testsuite/tests/effects/marshal.ml
++index 89eee89457..02b9d4e4af 100644
++--- a/testsuite/tests/effects/marshal.ml
+++++ b/testsuite/tests/effects/marshal.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++* skip
+++reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/overflow.ml b/testsuite/tests/effects/overflow.ml
++index a187e9e10d..c12503863e 100644
++--- a/testsuite/tests/effects/overflow.ml
+++++ b/testsuite/tests/effects/overflow.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/partial.ml b/testsuite/tests/effects/partial.ml
++index 50e4b53cfc..010741b9fc 100644
++--- a/testsuite/tests/effects/partial.ml
+++++ b/testsuite/tests/effects/partial.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/reperform.ml b/testsuite/tests/effects/reperform.ml
++index 8aefdd0587..685b48b5dd 100644
++--- a/testsuite/tests/effects/reperform.ml
+++++ b/testsuite/tests/effects/reperform.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/sched.ml b/testsuite/tests/effects/sched.ml
++index 3dc14a2cfc..6065d21c70 100644
++--- a/testsuite/tests/effects/sched.ml
+++++ b/testsuite/tests/effects/sched.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/shallow_state.ml b/testsuite/tests/effects/shallow_state.ml
++index 56c61b0c3c..4d52362bc7 100644
++--- a/testsuite/tests/effects/shallow_state.ml
+++++ b/testsuite/tests/effects/shallow_state.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/shallow_state_io.ml b/testsuite/tests/effects/shallow_state_io.ml
++index 6b1fa649a7..6ca4fef8b1 100644
++--- a/testsuite/tests/effects/shallow_state_io.ml
+++++ b/testsuite/tests/effects/shallow_state_io.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/test1.ml b/testsuite/tests/effects/test1.ml
++index 5d05359f8a..65da5c8b90 100644
++--- a/testsuite/tests/effects/test1.ml
+++++ b/testsuite/tests/effects/test1.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/test10.ml b/testsuite/tests/effects/test10.ml
++index 29c5f47f25..9b10559cfd 100644
++--- a/testsuite/tests/effects/test10.ml
+++++ b/testsuite/tests/effects/test10.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/test11.ml b/testsuite/tests/effects/test11.ml
++index 6714473e0e..303cdd03c5 100644
++--- a/testsuite/tests/effects/test11.ml
+++++ b/testsuite/tests/effects/test11.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ (* Tests RESUMETERM with extra_args != 0 in bytecode,
++diff --git a/testsuite/tests/effects/test2.ml b/testsuite/tests/effects/test2.ml
++index e9b8289bb2..f4e805f1d0 100644
++--- a/testsuite/tests/effects/test2.ml
+++++ b/testsuite/tests/effects/test2.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Printf
++diff --git a/testsuite/tests/effects/test3.ml b/testsuite/tests/effects/test3.ml
++index d76130eaaa..2828f933a7 100644
++--- a/testsuite/tests/effects/test3.ml
+++++ b/testsuite/tests/effects/test3.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/test4.ml b/testsuite/tests/effects/test4.ml
++index f5cf78cbda..77320a1ab5 100644
++--- a/testsuite/tests/effects/test4.ml
+++++ b/testsuite/tests/effects/test4.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/test5.ml b/testsuite/tests/effects/test5.ml
++index 33ed2c23ca..98802a934e 100644
++--- a/testsuite/tests/effects/test5.ml
+++++ b/testsuite/tests/effects/test5.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/test6.ml b/testsuite/tests/effects/test6.ml
++index 40574561bf..451e9704bc 100644
++--- a/testsuite/tests/effects/test6.ml
+++++ b/testsuite/tests/effects/test6.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/test_lazy.ml b/testsuite/tests/effects/test_lazy.ml
++index 24f457f0af..036c7d5038 100644
++--- a/testsuite/tests/effects/test_lazy.ml
+++++ b/testsuite/tests/effects/test_lazy.ml
++@@ -1,4 +1,7 @@
++-(* TEST *)
+++(* TEST
+++   * skip
+++   reason = "OCaml 5 only"
+++*)
++ 
++ open Effect
++ open Effect.Deep
++diff --git a/testsuite/tests/effects/unhandled_unlinked.ml b/testsuite/tests/effects/unhandled_unlinked.ml
++index bc2badb8e8..094eaad6e8 100644
++--- a/testsuite/tests/effects/unhandled_unlinked.ml
+++++ b/testsuite/tests/effects/unhandled_unlinked.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++      exit_status= "2"
+++     * skip
+++     reason = "OCaml 5 only"
++ *)
++ 
++ open Effect
++diff --git a/testsuite/tests/effects/used_cont.ml b/testsuite/tests/effects/used_cont.ml
++index 71a33388ec..7972d000b7 100644
++--- a/testsuite/tests/effects/used_cont.ml
+++++ b/testsuite/tests/effects/used_cont.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++  *)
++ 
++ open Effect
++diff --git a/testsuite/tests/ephe-c-api/test.ml b/testsuite/tests/ephe-c-api/test.ml
++index ff1646835a..a29cd8516b 100644
++--- a/testsuite/tests/ephe-c-api/test.ml
+++++ b/testsuite/tests/ephe-c-api/test.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    modules = "stubs.c"
++-   * skip
++-   reason = "port the new Ephemeron C-api to multicore : https://github.com/ocaml/ocaml/pull/676"
++ *)
++ 
++ (* C version of ephetest.ml *)
++diff --git a/testsuite/tests/frame-pointers/c_call.ml b/testsuite/tests/frame-pointers/c_call.ml
++index c2493b3a99..e156e23d11 100644
++--- a/testsuite/tests/frame-pointers/c_call.ml
+++++ b/testsuite/tests/frame-pointers/c_call.ml
++@@ -1,7 +1,9 @@
++ (* TEST
++ 
++-* frame_pointers
++-** native
+++* skip
+++reason = "OCaml 5 only"
+++** frame_pointers
+++*** native
++ readonly_files = "fp_backtrace.c c_call_.c"
++ all_modules = "${readonly_files} c_call.ml"
++ 
++diff --git a/testsuite/tests/frame-pointers/effects.ml b/testsuite/tests/frame-pointers/effects.ml
++index e14633a374..03068242a4 100644
++--- a/testsuite/tests/frame-pointers/effects.ml
+++++ b/testsuite/tests/frame-pointers/effects.ml
++@@ -1,7 +1,9 @@
++ (* TEST
++ 
++-* frame_pointers
++-** native
+++* skip
+++reason - "OCaml 5 only"
+++** frame_pointers
+++*** native
++ readonly_files = "fp_backtrace.c"
++ all_modules = "${readonly_files} effects.ml"
++ 
++diff --git a/testsuite/tests/frame-pointers/exception_handler.ml b/testsuite/tests/frame-pointers/exception_handler.ml
++index 575f7329bf..56676119b7 100644
++--- a/testsuite/tests/frame-pointers/exception_handler.ml
+++++ b/testsuite/tests/frame-pointers/exception_handler.ml
++@@ -1,7 +1,9 @@
++ (* TEST
++ 
++-* frame_pointers
++-** native
+++* skip
+++reason = "OCaml 5 only"
+++** frame_pointers
+++*** native
++ readonly_files = "fp_backtrace.c"
++ all_modules = "${readonly_files} exception_handler.ml"
++ 
++diff --git a/testsuite/tests/frame-pointers/reperform.ml b/testsuite/tests/frame-pointers/reperform.ml
++index 1af8452e5f..5e7a76f0e3 100644
++--- a/testsuite/tests/frame-pointers/reperform.ml
+++++ b/testsuite/tests/frame-pointers/reperform.ml
++@@ -1,7 +1,9 @@
++ (* TEST
++ 
++-* frame_pointers
++-** native
+++* skip
+++reason - "OCaml 5 only"
+++** frame_pointers
+++*** native
++ 
++ readonly_files = "fp_backtrace.c"
++ all_modules = "${readonly_files} reperform.ml"
++diff --git a/testsuite/tests/frame-pointers/stack_realloc.ml b/testsuite/tests/frame-pointers/stack_realloc.ml
++index 79e70c2add..b36bcd3a70 100644
++--- a/testsuite/tests/frame-pointers/stack_realloc.ml
+++++ b/testsuite/tests/frame-pointers/stack_realloc.ml
++@@ -1,7 +1,9 @@
++ (* TEST
++ 
++-* frame_pointers
++-** native
+++* skip
+++reason - "OCaml 5 only"
+++** frame_pointers
+++*** native
++ 
++ readonly_files = "fp_backtrace.c stack_realloc_.c"
++ all_modules = "${readonly_files} stack_realloc.ml"
++diff --git a/testsuite/tests/frame-pointers/stack_realloc2.ml b/testsuite/tests/frame-pointers/stack_realloc2.ml
++index a3d21bf2bf..df4a074443 100644
++--- a/testsuite/tests/frame-pointers/stack_realloc2.ml
+++++ b/testsuite/tests/frame-pointers/stack_realloc2.ml
++@@ -1,7 +1,9 @@
++ (* TEST
++ 
++-* frame_pointers
++-** native
+++* skip
+++reason - "OCaml 5 only"
+++** frame_pointers
+++*** native
++ 
++ readonly_files = "fp_backtrace.c stack_realloc_.c"
++ all_modules = "${readonly_files} stack_realloc2.ml"
++diff --git a/testsuite/tests/gc-roots/globroots.ml b/testsuite/tests/gc-roots/globroots.ml
++index 56d1586331..6bdb7fdaf3 100644
++--- a/testsuite/tests/gc-roots/globroots.ml
+++++ b/testsuite/tests/gc-roots/globroots.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    modules = "globrootsprim.c"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ module type GLOBREF = sig
++diff --git a/testsuite/tests/gc-roots/globroots_parallel.ml b/testsuite/tests/gc-roots/globroots_parallel.ml
++index 9ef88575b2..4858ecc49b 100644
++--- a/testsuite/tests/gc-roots/globroots_parallel.ml
+++++ b/testsuite/tests/gc-roots/globroots_parallel.ml
++@@ -1,6 +1,8 @@
++ (* TEST
++    flags += " -w a "
++    modules = "globrootsprim.c globroots.ml"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ open Globroots
++diff --git a/testsuite/tests/gc-roots/globroots_parallel_spawn_burn.ml b/testsuite/tests/gc-roots/globroots_parallel_spawn_burn.ml
++index c8b36098ac..d548d6e540 100644
++--- a/testsuite/tests/gc-roots/globroots_parallel_spawn_burn.ml
+++++ b/testsuite/tests/gc-roots/globroots_parallel_spawn_burn.ml
++@@ -1,6 +1,8 @@
++ (* TEST
++    flags += " -w a "
++    modules = "globrootsprim.c globroots.ml"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ open Globroots
++diff --git a/testsuite/tests/gc-roots/globroots_sequential.ml b/testsuite/tests/gc-roots/globroots_sequential.ml
++index 6bf995bf96..dc732ce6a3 100644
++--- a/testsuite/tests/gc-roots/globroots_sequential.ml
+++++ b/testsuite/tests/gc-roots/globroots_sequential.ml
++@@ -1,6 +1,8 @@
++ (* TEST
++    flags += " -w a "
++    modules = "globrootsprim.c globroots.ml"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ open Globroots
++ 
++diff --git a/testsuite/tests/generalized-open/gpr1506.ml b/testsuite/tests/generalized-open/gpr1506.ml
++index 0041d91889..cf0eb4eed3 100644
++--- a/testsuite/tests/generalized-open/gpr1506.ml
+++++ b/testsuite/tests/generalized-open/gpr1506.ml
++@@ -103,9 +103,9 @@ include struct open struct type t = T end let x = T end
++ Line 1, characters 15-41:
++ 1 | include struct open struct type t = T end let x = T end
++                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
++-Error: The type t/339 introduced by this open appears in the signature
+++Error: The type t/334 introduced by this open appears in the signature
++        Line 1, characters 46-47:
++-         The value x has no valid type if t/339 is hidden
+++         The value x has no valid type if t/334 is hidden
++ |}];;
++ 
++ module A = struct
++@@ -123,9 +123,9 @@ Lines 3-6, characters 4-7:
++ 4 |       type t = T
++ 5 |       let x = T
++ 6 |     end
++-Error: The type t/344 introduced by this open appears in the signature
+++Error: The type t/339 introduced by this open appears in the signature
++        Line 7, characters 8-9:
++-         The value y has no valid type if t/344 is hidden
+++         The value y has no valid type if t/339 is hidden
++ |}];;
++ 
++ module A = struct
++@@ -142,9 +142,9 @@ Lines 3-5, characters 4-7:
++ 3 | ....open struct
++ 4 |       type t = T
++ 5 |     end
++-Error: The type t/349 introduced by this open appears in the signature
+++Error: The type t/344 introduced by this open appears in the signature
++        Line 6, characters 8-9:
++-         The value y has no valid type if t/349 is hidden
+++         The value y has no valid type if t/344 is hidden
++ |}]
++ 
++ (* It was decided to not allow this anymore. *)
++diff --git a/testsuite/tests/lazy/lazy2.ml b/testsuite/tests/lazy/lazy2.ml
++index cccbd96d71..35dd7fd85b 100644
++--- a/testsuite/tests/lazy/lazy2.ml
+++++ b/testsuite/tests/lazy/lazy2.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    ocamlopt_flags += " -O3 "
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ open Domain
++diff --git a/testsuite/tests/lazy/lazy3.ml b/testsuite/tests/lazy/lazy3.ml
++index a22a0893b9..737791b7db 100644
++--- a/testsuite/tests/lazy/lazy3.ml
+++++ b/testsuite/tests/lazy/lazy3.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    ocamlopt_flags += " -O3 "
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ let f count =
++diff --git a/testsuite/tests/lazy/lazy5.ml b/testsuite/tests/lazy/lazy5.ml
++index 217b84175e..e37b499268 100644
++--- a/testsuite/tests/lazy/lazy5.ml
+++++ b/testsuite/tests/lazy/lazy5.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    ocamlopt_flags += " -O3 "
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ let rec safe_force l =
++   try Lazy.force l with
++diff --git a/testsuite/tests/lazy/lazy6.ml b/testsuite/tests/lazy/lazy6.ml
++index 098848769a..29067f1a41 100644
++--- a/testsuite/tests/lazy/lazy6.ml
+++++ b/testsuite/tests/lazy/lazy6.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    ocamlopt_flags += " -O3 "
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ let flag1 = Atomic.make false
++diff --git a/testsuite/tests/lazy/lazy7.ml b/testsuite/tests/lazy/lazy7.ml
++index 6c96f32907..d9c9b82127 100644
++--- a/testsuite/tests/lazy/lazy7.ml
+++++ b/testsuite/tests/lazy/lazy7.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    ocamlopt_flags += " -O3 "
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ let num_domains = 4
++diff --git a/testsuite/tests/lazy/lazy8.ml b/testsuite/tests/lazy/lazy8.ml
++index c9b5781617..ddadf48a1b 100644
++--- a/testsuite/tests/lazy/lazy8.ml
+++++ b/testsuite/tests/lazy/lazy8.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    ocamlopt_flags += " -O3 "
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ exception E
++diff --git a/testsuite/tests/lazy/minor_major_force.ml b/testsuite/tests/lazy/minor_major_force.ml
++index 37f367a9c7..3b2c33af87 100644
++--- a/testsuite/tests/lazy/minor_major_force.ml
+++++ b/testsuite/tests/lazy/minor_major_force.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    ocamlopt_flags += " -O3 "
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ (*
++diff --git a/testsuite/tests/lf_skiplist/test.ml b/testsuite/tests/lf_skiplist/test.ml
++index f3b11bf411..4dcffc523d 100644
++--- a/testsuite/tests/lf_skiplist/test.ml
+++++ b/testsuite/tests/lf_skiplist/test.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    modules = "stubs.c"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ external test_skiplist_serial : unit -> unit = "test_skiplist_serial"
++diff --git a/testsuite/tests/lf_skiplist/test_parallel.ml b/testsuite/tests/lf_skiplist/test_parallel.ml
++index ac02717889..c882a8dac7 100644
++--- a/testsuite/tests/lf_skiplist/test_parallel.ml
+++++ b/testsuite/tests/lf_skiplist/test_parallel.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    modules = "stubs.c"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ external init_skiplist : unit -> unit = "init_skiplist"
++diff --git a/testsuite/tests/lib-bigarray-2/has-gfortran.sh b/testsuite/tests/lib-bigarray-2/has-gfortran.sh
++index 051122113a..7eef1e662e 100644
++--- a/testsuite/tests/lib-bigarray-2/has-gfortran.sh
+++++ b/testsuite/tests/lib-bigarray-2/has-gfortran.sh
++@@ -5,7 +5,7 @@ if ! which gfortran > /dev/null 2>&1; then
++ elif ! grep -q '^CC=gcc' ${ocamlsrcdir}/Makefile.config; then
++   echo "OCaml was not compiled with gcc" > ${ocamltest_response}
++   test_result=${TEST_SKIP}
++-elif gcc --version 2>&1 | grep 'Apple clang version'; then
+++elif gcc --version 2>&1 | grep -q 'Apple clang version'; then
++   echo "OCaml was not compiled with gcc" > ${ocamltest_response}
++   test_result=${TEST_SKIP}
++ else
++diff --git a/testsuite/tests/lib-channels/close_in.ml b/testsuite/tests/lib-channels/close_in.ml
++index 2986e5b8c9..8c51c7d52c 100644
++--- a/testsuite/tests/lib-channels/close_in.ml
+++++ b/testsuite/tests/lib-channels/close_in.ml
++@@ -1,4 +1,7 @@
++-(* TEST *)
+++(* TEST
+++* skip
+++reason = "OCaml 5 only"
+++ *)
++ 
++ (* Test that inputting bytes from a closed in_channel triggers an exception *)
++ 
++diff --git a/testsuite/tests/lib-channels/refcounting.ml b/testsuite/tests/lib-channels/refcounting.ml
++index bc0b8dfe66..deaba0a3ee 100644
++--- a/testsuite/tests/lib-channels/refcounting.ml
+++++ b/testsuite/tests/lib-channels/refcounting.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++-   * expect
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** expect
++ *)
++ 
++ (* Test the behavior of channel refcounting. *)
++diff --git a/testsuite/tests/lib-dynlink-domains/main.ml b/testsuite/tests/lib-dynlink-domains/main.ml
++index d87ddc24e4..a10828c80e 100644
++--- a/testsuite/tests/lib-dynlink-domains/main.ml
+++++ b/testsuite/tests/lib-dynlink-domains/main.ml
++@@ -4,169 +4,171 @@ include dynlink
++ libraries = ""
++ readonly_files = "store.ml main.ml Plugin_0.ml Plugin_0_0.ml Plugin_0_0_0.ml Plugin_0_0_0_0.ml Plugin_0_0_0_1.ml Plugin_0_0_0_2.ml Plugin_1.ml Plugin_1_0.ml Plugin_1_0_0.ml Plugin_1_0_0_0.ml Plugin_1_1.ml Plugin_1_2.ml Plugin_1_2_0.ml Plugin_1_2_0_0.ml Plugin_1_2_1.ml Plugin_1_2_2.ml Plugin_1_2_2_0.ml Plugin_1_2_3.ml Plugin_1_2_3_0.ml"
++ 
++-*01 not-windows
++-*02 shared-libraries
++-*03 setup-ocamlc.byte-build-env
++-*04 ocamlc.byte
+++* skip
+++reason = "OCaml 5 only"
+++**01 not-windows
+++**02 shared-libraries
+++**03 setup-ocamlc.byte-build-env
+++**04 ocamlc.byte
++ module = "store.ml"
++-*05 ocamlc.byte
+++**05 ocamlc.byte
++ module = "Plugin_0.ml"
++-*06 ocamlc.byte
+++**06 ocamlc.byte
++ module = "Plugin_0_0.ml"
++-*07 ocamlc.byte
+++**07 ocamlc.byte
++ module = "Plugin_0_0_0.ml"
++-*08 ocamlc.byte
+++**08 ocamlc.byte
++ module = "Plugin_0_0_0_0.ml"
++-*09 ocamlc.byte
+++**09 ocamlc.byte
++ module = "Plugin_0_0_0_1.ml"
++-*10 ocamlc.byte
+++**10 ocamlc.byte
++ module = "Plugin_0_0_0_2.ml"
++-*11 ocamlc.byte
+++**11 ocamlc.byte
++ module = "Plugin_1.ml"
++-*12 ocamlc.byte
+++**12 ocamlc.byte
++ module = "Plugin_1_0.ml"
++-*13 ocamlc.byte
+++**13 ocamlc.byte
++ module = "Plugin_1_0_0.ml"
++-*14 ocamlc.byte
+++**14 ocamlc.byte
++ module = "Plugin_1_0_0_0.ml"
++-*15 ocamlc.byte
+++**15 ocamlc.byte
++ module = "Plugin_1_1.ml"
++-*16 ocamlc.byte
+++**16 ocamlc.byte
++ module = "Plugin_1_2.ml"
++-*17 ocamlc.byte
+++**17 ocamlc.byte
++ module = "Plugin_1_2_0.ml"
++-*18 ocamlc.byte
+++**18 ocamlc.byte
++ module = "Plugin_1_2_0_0.ml"
++-*19 ocamlc.byte
+++**19 ocamlc.byte
++ module = "Plugin_1_2_1.ml"
++-*20 ocamlc.byte
+++**20 ocamlc.byte
++ module = "Plugin_1_2_2.ml"
++-*21 ocamlc.byte
+++**21 ocamlc.byte
++ module = "Plugin_1_2_2_0.ml"
++-*22 ocamlc.byte
+++**22 ocamlc.byte
++ module = "Plugin_1_2_3.ml"
++-*23 ocamlc.byte
+++**23 ocamlc.byte
++ module = "Plugin_1_2_3_0.ml"
++-*24 ocamlc.byte
+++**24 ocamlc.byte
++ module = "main.ml"
++-*25 ocamlc.byte
+++**25 ocamlc.byte
++ program = "./main.byte.exe"
++ libraries= "dynlink"
++ all_modules = "store.cmo main.cmo"
++ module = ""
++-*26 run
++-*27 check-program-output
+++**26 run
+++**27 check-program-output
++ 
++-*02 native-dynlink
++-*03 setup-ocamlopt.byte-build-env
++-*04 ocamlopt.byte
+++**02 native-dynlink
+++**03 setup-ocamlopt.byte-build-env
+++**04 ocamlopt.byte
++ flags = ""
++ module = "store.ml"
++-*05 ocamlopt.byte
+++**05 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_0.cmxs"
++ module = ""
++ all_modules = "Plugin_0.ml"
++-*06 ocamlopt.byte
+++**06 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_0_0.cmxs"
++ module = ""
++ all_modules = "Plugin_0_0.ml"
++-*07 ocamlopt.byte
+++**07 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_0_0_0.cmxs"
++ module = ""
++ all_modules = "Plugin_0_0_0.ml"
++-*08 ocamlopt.byte
+++**08 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_0_0_0_0.cmxs"
++ module = ""
++ all_modules = "Plugin_0_0_0_0.ml"
++-*09 ocamlopt.byte
+++**09 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_0_0_0_1.cmxs"
++ module = ""
++ all_modules = "Plugin_0_0_0_1.ml"
++-*10 ocamlopt.byte
+++**10 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_0_0_0_2.cmxs"
++ module = ""
++ all_modules = "Plugin_0_0_0_2.ml"
++-*11 ocamlopt.byte
+++**11 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1.cmxs"
++ module = ""
++ all_modules = "Plugin_1.ml"
++-*12 ocamlopt.byte
+++**12 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_0.cmxs"
++ module = ""
++ all_modules = "Plugin_1_0.ml"
++-*13 ocamlopt.byte
+++**13 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_0_0.cmxs"
++ module = ""
++ all_modules = "Plugin_1_0_0.ml"
++-*14 ocamlopt.byte
+++**14 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_0_0_0.cmxs"
++ module = ""
++ all_modules = "Plugin_1_0_0_0.ml"
++-*15 ocamlopt.byte
+++**15 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_1.cmxs"
++ module = ""
++ all_modules = "Plugin_1_1.ml"
++-*16 ocamlopt.byte
+++**16 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_2.cmxs"
++ module = ""
++ all_modules = "Plugin_1_2.ml"
++-*17 ocamlopt.byte
+++**17 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_2_0.cmxs"
++ module = ""
++ all_modules = "Plugin_1_2_0.ml"
++-*18 ocamlopt.byte
+++**18 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_2_0_0.cmxs"
++ module = ""
++ all_modules = "Plugin_1_2_0_0.ml"
++-*19 ocamlopt.byte
+++**19 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_2_1.cmxs"
++ module = ""
++ all_modules = "Plugin_1_2_1.ml"
++-*20 ocamlopt.byte
+++**20 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_2_2.cmxs"
++ module = ""
++ all_modules = "Plugin_1_2_2.ml"
++-*21 ocamlopt.byte
+++**21 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_2_2_0.cmxs"
++ module = ""
++ all_modules = "Plugin_1_2_2_0.ml"
++-*22 ocamlopt.byte
+++**22 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_2_3.cmxs"
++ module = ""
++ all_modules = "Plugin_1_2_3.ml"
++-*23 ocamlopt.byte
+++**23 ocamlopt.byte
++ flags = "-shared"
++ program= "Plugin_1_2_3_0.cmxs"
++ module = ""
++ all_modules = "Plugin_1_2_3_0.ml"
++-*24 ocamlopt.byte
+++**24 ocamlopt.byte
++ flags = ""
++ module = "main.ml"
++-*25 ocamlopt.byte
+++**25 ocamlopt.byte
++ program = "./main.exe"
++ libraries="dynlink"
++ all_modules = "store.cmx main.cmx"
++ module = ""
++-*26 run
++-*27 check-program-output
+++**26 run
+++**27 check-program-output
++ *)
++ 
++ (*  This module and all plugin modules are generated by a call to test_generator.ml with parameters:
++diff --git a/testsuite/tests/lib-dynlink-initializers/test10_main.byte.reference b/testsuite/tests/lib-dynlink-initializers/test10_main.byte.reference
++index f9157e7c43..01165c2489 100755
++--- a/testsuite/tests/lib-dynlink-initializers/test10_main.byte.reference
+++++ b/testsuite/tests/lib-dynlink-initializers/test10_main.byte.reference
++@@ -3,10 +3,10 @@ Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
++ Called from Test10_plugin.g in file "test10_plugin.ml", line 3, characters 2-21
++ Called from Test10_plugin.f in file "test10_plugin.ml", line 6, characters 2-6
++ Called from Test10_plugin in file "test10_plugin.ml", line 10, characters 2-6
++-Called from Dynlink.Bytecode.run in file "otherlibs/dynlink/dynlink.ml", line 149, characters 16-25
++-Re-raised at Dynlink.Bytecode.run in file "otherlibs/dynlink/dynlink.ml", line 151, characters 6-137
++-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 363, characters 13-56
+++Called from Dynlink.Bytecode.run in file "otherlibs/dynlink/dynlink.ml", line 152, characters 16-25
+++Re-raised at Dynlink.Bytecode.run in file "otherlibs/dynlink/dynlink.ml", line 154, characters 6-137
+++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
++ Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
++-Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 8-17
+++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
+++Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 381, characters 8-17
++ Called from Test10_main in file "test10_main.ml", line 51, characters 13-69
++diff --git a/testsuite/tests/lib-dynlink-initializers/test10_main.native.reference b/testsuite/tests/lib-dynlink-initializers/test10_main.native.reference
++index 89f1d20b39..287f9a8dba 100755
++--- a/testsuite/tests/lib-dynlink-initializers/test10_main.native.reference
+++++ b/testsuite/tests/lib-dynlink-initializers/test10_main.native.reference
++@@ -1,10 +1,14 @@
++ Error: Failure("Plugin error")
++-Raised by primitive operation at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 87, characters 12-29
++-Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 10-149
+++Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
+++Called from Test10_plugin.g in file "test10_plugin.ml", line 2, characters 15-38
+++Called from Test10_plugin in file "test10_plugin.ml", line 10, characters 2-6
+++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 12-29
+++Called from Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 89, characters 12-29
+++Re-raised at Dynlink.Native.run.(fun) in file "otherlibs/dynlink/native/dynlink.ml", line 91, characters 10-149
++ Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++-Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 363, characters 13-56
+++Called from Dynlink_common.Make.load.(fun) in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 13-56
++ Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++-Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 359, characters 8-392
++-Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 372, characters 8-17
++-Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 374, characters 26-45
+++Called from Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 368, characters 8-392
+++Re-raised at Dynlink_common.Make.load in file "otherlibs/dynlink/dynlink_common.ml", line 381, characters 8-17
+++Called from Dynlink_common.Make.loadfile in file "otherlibs/dynlink/dynlink_common.ml" (inlined), line 383, characters 26-45
++ Called from Test10_main in file "test10_main.ml", line 49, characters 30-87
++diff --git a/testsuite/tests/lib-format/domains.ml b/testsuite/tests/lib-format/domains.ml
++index 941aa681cf..0daaad5171 100644
++--- a/testsuite/tests/lib-format/domains.ml
+++++ b/testsuite/tests/lib-format/domains.ml
++@@ -1,4 +1,7 @@
++-(* TEST *)
+++(* TEST
+++* skip
+++reason = "OCaml 5 only"
+++*)
++ 
++ (** Test that domains stdout and stderr are flushed at domain exit *)
++ 
++diff --git a/testsuite/tests/lib-format/mc_pr586_par.ml b/testsuite/tests/lib-format/mc_pr586_par.ml
++index 456a306ce7..da5c148416 100644
++--- a/testsuite/tests/lib-format/mc_pr586_par.ml
+++++ b/testsuite/tests/lib-format/mc_pr586_par.ml
++@@ -1,4 +1,7 @@
++-(* TEST *)
+++(* TEST
+++   * skip
+++   reason = "OCaml 5 only"
+++*)
++ 
++ let () =
++   let domains = Array.init 7 (fun i ->
++diff --git a/testsuite/tests/lib-format/mc_pr586_par2.ml b/testsuite/tests/lib-format/mc_pr586_par2.ml
++index 0ead3627b5..8a96be1456 100644
++--- a/testsuite/tests/lib-format/mc_pr586_par2.ml
+++++ b/testsuite/tests/lib-format/mc_pr586_par2.ml
++@@ -1,4 +1,7 @@
++-(* TEST *)
+++(* TEST
+++   * skip
+++   reason = "OCaml 5 only"
+++*)
++ 
++ let () =
++   let fmt_key = Format.synchronized_formatter_of_out_channel stdout in
++diff --git a/testsuite/tests/lib-marshal/intext_par.ml b/testsuite/tests/lib-marshal/intext_par.ml
++index 2efb846665..68ad0e1edb 100644
++--- a/testsuite/tests/lib-marshal/intext_par.ml
+++++ b/testsuite/tests/lib-marshal/intext_par.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++    modules = "intextaux_par.c"
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ (* Test for output_value / input_value *)
++diff --git a/testsuite/tests/lib-obj/reachable_words_np.ml b/testsuite/tests/lib-obj/reachable_words_np.ml
++new file mode 100644
++index 0000000000..8a50268d20
++--- /dev/null
+++++ b/testsuite/tests/lib-obj/reachable_words_np.ml
++@@ -0,0 +1,21 @@
+++(* TEST
+++ * naked_pointers
+++ ** bytecode
+++ ** native
+++*)
+++
+++let native =
+++  match Sys.backend_type with
+++  | Sys.Native -> true
+++  | Sys.Bytecode -> false
+++  | Sys.Other s -> print_endline s; assert false
+++
+++let size x = Obj.reachable_words (Obj.repr x)
+++
+++let expect_size s x =
+++  let i = size x in
+++  if i <> s then
+++    Printf.printf "size = %i; expected = %i\n%!" i s
+++
+++let () =
+++  expect_size (if native then 0 else 3) (1, 2)
++diff --git a/testsuite/tests/lib-random/parallel.ml b/testsuite/tests/lib-random/parallel.ml
++index 68f567abec..90a78e2250 100644
++--- a/testsuite/tests/lib-random/parallel.ml
+++++ b/testsuite/tests/lib-random/parallel.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++    include unix
++-   * libunix
++-   ** bytecode
++-   ** native
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** libunix
+++   *** bytecode
+++   *** native
++  *)
++ 
++ let () = Random.init 42
++diff --git a/testsuite/tests/lib-runtime-events/test.ml b/testsuite/tests/lib-runtime-events/test.ml
++index db08937089..8ccaccdf25 100644
++--- a/testsuite/tests/lib-runtime-events/test.ml
+++++ b/testsuite/tests/lib-runtime-events/test.ml
++@@ -1,6 +1,8 @@
++ (* TEST
++ modules = "stubs.c"
++ include runtime_events
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ 
++ external start_runtime_events : unit -> unit = "start_runtime_events"
++diff --git a/testsuite/tests/lib-runtime-events/test_caml.ml b/testsuite/tests/lib-runtime-events/test_caml.ml
++index 1e96998149..6cc9474f2e 100644
++--- a/testsuite/tests/lib-runtime-events/test_caml.ml
+++++ b/testsuite/tests/lib-runtime-events/test_caml.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++ include runtime_events
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ open Runtime_events
++ 
++diff --git a/testsuite/tests/lib-runtime-events/test_caml_counters.ml b/testsuite/tests/lib-runtime-events/test_caml_counters.ml
++index af43fd47af..e64a4fec09 100644
++--- a/testsuite/tests/lib-runtime-events/test_caml_counters.ml
+++++ b/testsuite/tests/lib-runtime-events/test_caml_counters.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++ include runtime_events
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ open Runtime_events
++ 
++diff --git a/testsuite/tests/lib-runtime-events/test_caml_exception.ml b/testsuite/tests/lib-runtime-events/test_caml_exception.ml
++index e1df5aee0b..6738603ddd 100644
++--- a/testsuite/tests/lib-runtime-events/test_caml_exception.ml
+++++ b/testsuite/tests/lib-runtime-events/test_caml_exception.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++ include runtime_events
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ open Runtime_events
++ 
++diff --git a/testsuite/tests/lib-runtime-events/test_caml_parallel.ml b/testsuite/tests/lib-runtime-events/test_caml_parallel.ml
++index 76cad340d8..391186d007 100644
++--- a/testsuite/tests/lib-runtime-events/test_caml_parallel.ml
+++++ b/testsuite/tests/lib-runtime-events/test_caml_parallel.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++ include runtime_events
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ open Runtime_events
++ 
++diff --git a/testsuite/tests/lib-runtime-events/test_caml_reentry.ml b/testsuite/tests/lib-runtime-events/test_caml_reentry.ml
++index d69042e354..724466a63b 100644
++--- a/testsuite/tests/lib-runtime-events/test_caml_reentry.ml
+++++ b/testsuite/tests/lib-runtime-events/test_caml_reentry.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++ include runtime_events
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ open Runtime_events
++ 
++diff --git a/testsuite/tests/lib-runtime-events/test_caml_runparams.ml b/testsuite/tests/lib-runtime-events/test_caml_runparams.ml
++index a574e7d341..4dc607eed3 100644
++--- a/testsuite/tests/lib-runtime-events/test_caml_runparams.ml
+++++ b/testsuite/tests/lib-runtime-events/test_caml_runparams.ml
++@@ -1,6 +1,8 @@
++ (* TEST
++ include runtime_events
++ ocamlrunparam += ",e=4"
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ 
++ (* We set the ring buffer size smaller and witness that we do indeed
++diff --git a/testsuite/tests/lib-runtime-events/test_caml_slot_reuse.ml b/testsuite/tests/lib-runtime-events/test_caml_slot_reuse.ml
++index 34b034a8e8..8656ca2e59 100644
++--- a/testsuite/tests/lib-runtime-events/test_caml_slot_reuse.ml
+++++ b/testsuite/tests/lib-runtime-events/test_caml_slot_reuse.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++ include runtime_events
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ open Runtime_events
++ 
++diff --git a/testsuite/tests/lib-runtime-events/test_caml_stubs_gc.ml b/testsuite/tests/lib-runtime-events/test_caml_stubs_gc.ml
++index 35ddd983a1..d63066e646 100644
++--- a/testsuite/tests/lib-runtime-events/test_caml_stubs_gc.ml
+++++ b/testsuite/tests/lib-runtime-events/test_caml_stubs_gc.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++ include runtime_events
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ open Runtime_events
++ 
++diff --git a/testsuite/tests/lib-runtime-events/test_env_start.ml b/testsuite/tests/lib-runtime-events/test_env_start.ml
++index 6b6bca5b09..cbdf114e57 100644
++--- a/testsuite/tests/lib-runtime-events/test_env_start.ml
+++++ b/testsuite/tests/lib-runtime-events/test_env_start.ml
++@@ -1,6 +1,8 @@
++ (* TEST
++ include runtime_events
++ set OCAML_RUNTIME_EVENTS_START = "1"
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ 
++ (* In this test the runtime_events should already be started by the environment
++diff --git a/testsuite/tests/lib-runtime-events/test_external.ml b/testsuite/tests/lib-runtime-events/test_external.ml
++index ecea4b7e13..4f363941f4 100644
++--- a/testsuite/tests/lib-runtime-events/test_external.ml
+++++ b/testsuite/tests/lib-runtime-events/test_external.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++    include runtime_events
++    include unix
++-   * libunix
++-   ** bytecode
++-   ** native *)
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** libunix
+++   *** bytecode
+++   *** native *)
++ 
++ let got_major = ref false
++ let got_minor = ref false
++diff --git a/testsuite/tests/lib-runtime-events/test_external_preserve.ml b/testsuite/tests/lib-runtime-events/test_external_preserve.ml
++index 18c2ac578b..76d66b1b66 100644
++--- a/testsuite/tests/lib-runtime-events/test_external_preserve.ml
+++++ b/testsuite/tests/lib-runtime-events/test_external_preserve.ml
++@@ -2,9 +2,11 @@
++   include runtime_events
++   include unix
++   set OCAML_RUNTIME_EVENTS_PRESERVE = "1"
++-  * libunix
++-  ** bytecode
++-  ** native *)
+++  * skip
+++  reason = "OCaml 5 only"
+++  ** libunix
+++  *** bytecode
+++  *** native *)
++ 
++   (* this tests the preservation of ring buffers after termination *)
++ 
++diff --git a/testsuite/tests/lib-runtime-events/test_fork.ml b/testsuite/tests/lib-runtime-events/test_fork.ml
++index 87f556a659..097905b626 100644
++--- a/testsuite/tests/lib-runtime-events/test_fork.ml
+++++ b/testsuite/tests/lib-runtime-events/test_fork.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++    include runtime_events
++    include unix
++-   * libunix
++-   ** bytecode
++-   ** native *)
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** libunix
+++   *** bytecode
+++   *** native *)
++ 
++ let got_start = ref false
++ let got_fork_child = ref false
++diff --git a/testsuite/tests/lib-runtime-events/test_instrumented.ml b/testsuite/tests/lib-runtime-events/test_instrumented.ml
++index 94727d13fd..e353268013 100644
++--- a/testsuite/tests/lib-runtime-events/test_instrumented.ml
+++++ b/testsuite/tests/lib-runtime-events/test_instrumented.ml
++@@ -2,8 +2,10 @@
++    include runtime_events
++    flags = "-runtime-variant=i"
++ 
++-   * instrumented-runtime
++-   ** native
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** instrumented-runtime
+++   *** native
++ *)
++ 
++ open Runtime_events
++diff --git a/testsuite/tests/lib-runtime-events/test_user_event.ml b/testsuite/tests/lib-runtime-events/test_user_event.ml
++index a4cb09175b..51566e99ed 100644
++--- a/testsuite/tests/lib-runtime-events/test_user_event.ml
+++++ b/testsuite/tests/lib-runtime-events/test_user_event.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++ include runtime_events
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ open Runtime_events
++ 
++diff --git a/testsuite/tests/lib-runtime-events/test_user_event_unknown.ml b/testsuite/tests/lib-runtime-events/test_user_event_unknown.ml
++index f5a63d46fd..a6b5740ae7 100644
++--- a/testsuite/tests/lib-runtime-events/test_user_event_unknown.ml
+++++ b/testsuite/tests/lib-runtime-events/test_user_event_unknown.ml
++@@ -2,9 +2,11 @@
++    include runtime_events
++    include unix
++    set OCAML_RUNTIME_EVENTS_PRESERVE = "1"
++-   * libunix
++-   ** bytecode
++-   ** native
+++   * skip
+++   reason = "OCaml 5 only"
+++   ** libunix
+++   *** bytecode
+++   *** native
++ *)
++ open Runtime_events
++ 
++diff --git a/testsuite/tests/lib-str/parallel.ml b/testsuite/tests/lib-str/parallel.ml
++index 23f2a5f7de..08055698e7 100644
++--- a/testsuite/tests/lib-str/parallel.ml
+++++ b/testsuite/tests/lib-str/parallel.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasstr
+++* skip
+++reason = "OCaml 5 only"
+++** hasstr
++ include str
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ let total = Atomic.make 0
++diff --git a/testsuite/tests/lib-sync/prodcons.ml b/testsuite/tests/lib-sync/prodcons.ml
++index 2e2c09756c..093d8740be 100644
++--- a/testsuite/tests/lib-sync/prodcons.ml
+++++ b/testsuite/tests/lib-sync/prodcons.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ (* Classic producer-consumer *)
++diff --git a/testsuite/tests/lib-sync/trylock.ml b/testsuite/tests/lib-sync/trylock.ml
++index 314f1142ca..b4719fff04 100644
++--- a/testsuite/tests/lib-sync/trylock.ml
+++++ b/testsuite/tests/lib-sync/trylock.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ (* Test Mutex.try_lock *)
++diff --git a/testsuite/tests/lib-sync/trylock2.ml b/testsuite/tests/lib-sync/trylock2.ml
++index b31ace08b5..e29ee93f9e 100644
++--- a/testsuite/tests/lib-sync/trylock2.ml
+++++ b/testsuite/tests/lib-sync/trylock2.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ (* Test Mutex.try_lock *)
++diff --git a/testsuite/tests/lib-systhreads/boundscheck.ml b/testsuite/tests/lib-systhreads/boundscheck.ml
++index 216dcebae7..124d054ec7 100644
++--- a/testsuite/tests/lib-systhreads/boundscheck.ml
+++++ b/testsuite/tests/lib-systhreads/boundscheck.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++ 
++ include systhreads
++-* hassysthreads
++-** bytecode
++-** native
+++* skip
+++reason = "OCaml 5 only"
+++** hassysthreads
+++*** bytecode
+++*** native
++ 
++ *)
++ 
++diff --git a/testsuite/tests/lib-systhreads/multicore_lifecycle.ml b/testsuite/tests/lib-systhreads/multicore_lifecycle.ml
++index f481464906..0138046146 100644
++--- a/testsuite/tests/lib-systhreads/multicore_lifecycle.ml
+++++ b/testsuite/tests/lib-systhreads/multicore_lifecycle.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hassysthreads
+++* skip
+++reason = "OCaml 5 only"
+++** hassysthreads
++ include systhreads
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ let _ =
++diff --git a/testsuite/tests/lib-systhreads/test_c_thread_register.ml b/testsuite/tests/lib-systhreads/test_c_thread_register.ml
++index a8ec98aa9a..784fe6945f 100644
++--- a/testsuite/tests/lib-systhreads/test_c_thread_register.ml
+++++ b/testsuite/tests/lib-systhreads/test_c_thread_register.ml
++@@ -2,9 +2,10 @@
++    modules = "test_c_thread_register_cstubs.c"
++    * hassysthreads
++    include systhreads
++-   ** not-bsd
++-   *** bytecode
++-   *** native
+++   ** not-windows
+++   *** not-bsd
+++   **** bytecode
+++   **** native
++ *)
++ 
++ (* spins a external thread from C and register it to the OCaml runtime *)
++diff --git a/testsuite/tests/lib-threads/uncaught_exception_handler.reference b/testsuite/tests/lib-threads/uncaught_exception_handler.reference
++index 23ff3ade39..cd68534b54 100644
++--- a/testsuite/tests/lib-threads/uncaught_exception_handler.reference
+++++ b/testsuite/tests/lib-threads/uncaught_exception_handler.reference
++@@ -1,15 +1,15 @@
++ Thread 1 killed on uncaught exception Uncaught_exception_handler.CallbackExn
++ Raised at Uncaught_exception_handler.fn in file "uncaught_exception_handler.ml", line 28, characters 12-113
++-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++ [thread 2] caught Uncaught_exception_handler.CallbackExn
++ Raised at Uncaught_exception_handler.fn in file "uncaught_exception_handler.ml", line 28, characters 12-113
++-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++ Thread 2 killed on uncaught exception Uncaught_exception_handler.CallbackExn
++ Raised at Uncaught_exception_handler.fn in file "uncaught_exception_handler.ml", line 28, characters 12-113
++-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++ Thread 2 uncaught exception handler raised Uncaught_exception_handler.UncaughtHandlerExn
++ Raised at Uncaught_exception_handler.handler in file "uncaught_exception_handler.ml", line 26, characters 2-17
++-Called from Thread.create.(fun) in file "thread.ml", line 57, characters 10-41
+++Called from Thread.create.(fun) in file "thread.ml", line 64, characters 10-41
++ [thread 3] caught Uncaught_exception_handler.CallbackExn
++ Raised at Uncaught_exception_handler.fn in file "uncaught_exception_handler.ml", line 28, characters 12-113
++-Called from Thread.create.(fun) in file "thread.ml", line 48, characters 8-14
+++Called from Thread.create.(fun) in file "thread.ml", line 55, characters 8-14
++diff --git a/testsuite/tests/lib-unix/common/multicore_fork_domain_alone.ml b/testsuite/tests/lib-unix/common/multicore_fork_domain_alone.ml
++index 077a3dba66..78112d293e 100644
++--- a/testsuite/tests/lib-unix/common/multicore_fork_domain_alone.ml
+++++ b/testsuite/tests/lib-unix/common/multicore_fork_domain_alone.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++ include unix
++-* hasunix
++-** not-windows
++-*** bytecode
++-*** native
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
+++*** not-windows
+++**** bytecode
+++**** native
++ *)
++ 
++ (* on Multicore, fork is not allowed is another domain is, and was running. *)
++diff --git a/testsuite/tests/lib-unix/common/multicore_fork_domain_alone2.ml b/testsuite/tests/lib-unix/common/multicore_fork_domain_alone2.ml
++index 929ed5ecf7..61f75dce4a 100644
++--- a/testsuite/tests/lib-unix/common/multicore_fork_domain_alone2.ml
+++++ b/testsuite/tests/lib-unix/common/multicore_fork_domain_alone2.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++ include unix
++-* hasunix
++-** not-windows
++-*** bytecode
++-*** native
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
+++*** not-windows
+++**** bytecode
+++**** native
++ *)
++ 
++ (* on Multicore, fork is not allowed is another domain is, and was running. *)
++diff --git a/testsuite/tests/lib-unix/win-channel-of/parallel_channel_of.ml b/testsuite/tests/lib-unix/win-channel-of/parallel_channel_of.ml
++index 01ae4df1c3..fb17641f40 100644
++--- a/testsuite/tests/lib-unix/win-channel-of/parallel_channel_of.ml
+++++ b/testsuite/tests/lib-unix/win-channel-of/parallel_channel_of.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++ modules = "fd_of_channel.c"
++-* libwin32unix
+++reason = "OCaml 5 only"
+++* skip
+++** libwin32unix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ external fd_of_in_channel: in_channel -> int = "caml_fd_of_channel"
++diff --git a/testsuite/tests/lib-unix/win-symlink/parallel_symlink.ml b/testsuite/tests/lib-unix/win-symlink/parallel_symlink.ml
++index d27e7db02d..651e071303 100644
++--- a/testsuite/tests/lib-unix/win-symlink/parallel_symlink.ml
+++++ b/testsuite/tests/lib-unix/win-symlink/parallel_symlink.ml
++@@ -2,8 +2,10 @@
++ * libwin32unix
++ include unix
++ ** has_symlink
++-*** bytecode
++-*** native
+++*** skip
+++reason = "OCaml 5 only"
+++**** bytecode
+++**** native
++ *)
++ 
++ let create_symlink barrier src dst () =
++diff --git a/testsuite/tests/memory-model/forbidden.ml b/testsuite/tests/memory-model/forbidden.ml
++index 5504d94f04..32a8d9fa8c 100644
++--- a/testsuite/tests/memory-model/forbidden.ml
+++++ b/testsuite/tests/memory-model/forbidden.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++   modules="opt.ml barrier.ml hist.ml shared.ml run.ml outcome.ml"
++-  * not-bsd
++-  ** bytecode
++-  ** native
+++  * skip
+++  reason = "OCaml 5 only"
+++  ** not-bsd
+++  *** bytecode
+++  *** native
++ *)
++ 
++ (* Memory model test:
++diff --git a/testsuite/tests/memory-model/publish.ml b/testsuite/tests/memory-model/publish.ml
++index 7f778307a1..94e08074d4 100644
++--- a/testsuite/tests/memory-model/publish.ml
+++++ b/testsuite/tests/memory-model/publish.ml
++@@ -1,9 +1,11 @@
++ (* TEST
++   modules="opt.ml barrier.ml hist.ml shared.ml run.ml outcome.ml"
++-  * not-bsd
++-  ** not-windows
++-  *** bytecode
++-  ** native
+++  * skip
+++  reason = "OCaml 5 only"
+++  ** not-bsd
+++  *** not-windows
+++  **** bytecode
+++  **** native
++ *)
++ 
++ (* Memory model: test the _publish idiom *)
++diff --git a/testsuite/tests/parallel/atomics.ml b/testsuite/tests/parallel/atomics.ml
++index 823fb32dc2..de7aa2a5b4 100644
++--- a/testsuite/tests/parallel/atomics.ml
+++++ b/testsuite/tests/parallel/atomics.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ 
++ type u = U of unit
++diff --git a/testsuite/tests/parallel/backup_thread.ml b/testsuite/tests/parallel/backup_thread.ml
++index 05b06cc47c..c69f164ce7 100644
++--- a/testsuite/tests/parallel/backup_thread.ml
+++++ b/testsuite/tests/parallel/backup_thread.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ 
++diff --git a/testsuite/tests/parallel/backup_thread_pipe.ml b/testsuite/tests/parallel/backup_thread_pipe.ml
++index 41fd101c1f..d0c5bb6e35 100644
++--- a/testsuite/tests/parallel/backup_thread_pipe.ml
+++++ b/testsuite/tests/parallel/backup_thread_pipe.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ 
++diff --git a/testsuite/tests/parallel/constpromote.ml b/testsuite/tests/parallel/constpromote.ml
++index 9bf7ede7a3..89e2f9aef4 100644
++--- a/testsuite/tests/parallel/constpromote.ml
+++++ b/testsuite/tests/parallel/constpromote.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ 
++ (* when run with the bytecode debug runtime, this test
++diff --git a/testsuite/tests/parallel/deadcont.ml b/testsuite/tests/parallel/deadcont.ml
++index fcdfbec210..d162cd1993 100644
++--- a/testsuite/tests/parallel/deadcont.ml
+++++ b/testsuite/tests/parallel/deadcont.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ 
++ (*
++diff --git a/testsuite/tests/parallel/domain_dls.ml b/testsuite/tests/parallel/domain_dls.ml
++index 72f4ddf0bd..3d313a288a 100644
++--- a/testsuite/tests/parallel/domain_dls.ml
+++++ b/testsuite/tests/parallel/domain_dls.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ 
++ let check_dls () =
++diff --git a/testsuite/tests/parallel/domain_dls2.ml b/testsuite/tests/parallel/domain_dls2.ml
++index ae301bda36..fe19776342 100644
++--- a/testsuite/tests/parallel/domain_dls2.ml
+++++ b/testsuite/tests/parallel/domain_dls2.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ 
++ let _ =
++diff --git a/testsuite/tests/parallel/domain_id.ml b/testsuite/tests/parallel/domain_id.ml
++index 540ca905fd..a38477147b 100644
++--- a/testsuite/tests/parallel/domain_id.ml
+++++ b/testsuite/tests/parallel/domain_id.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ 
++ open Domain
++diff --git a/testsuite/tests/parallel/domain_parallel_spawn_burn.ml b/testsuite/tests/parallel/domain_parallel_spawn_burn.ml
++index ecc9d0b78f..2b6369bc3b 100644
++--- a/testsuite/tests/parallel/domain_parallel_spawn_burn.ml
+++++ b/testsuite/tests/parallel/domain_parallel_spawn_burn.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ 
++ open Domain
++diff --git a/testsuite/tests/parallel/domain_parallel_spawn_burn_gc_set.ml b/testsuite/tests/parallel/domain_parallel_spawn_burn_gc_set.ml
++index 883ab1a5ab..245b0b73fb 100644
++--- a/testsuite/tests/parallel/domain_parallel_spawn_burn_gc_set.ml
+++++ b/testsuite/tests/parallel/domain_parallel_spawn_burn_gc_set.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ 
++ open Domain
++diff --git a/testsuite/tests/parallel/domain_serial_spawn_burn.ml b/testsuite/tests/parallel/domain_serial_spawn_burn.ml
++index aeac4f71f7..ea63910f2f 100644
++--- a/testsuite/tests/parallel/domain_serial_spawn_burn.ml
+++++ b/testsuite/tests/parallel/domain_serial_spawn_burn.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ open Domain
++diff --git a/testsuite/tests/parallel/fib_threads.ml b/testsuite/tests/parallel/fib_threads.ml
++index f6005729b7..3ab3dde90d 100644
++--- a/testsuite/tests/parallel/fib_threads.ml
+++++ b/testsuite/tests/parallel/fib_threads.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hassysthreads
+++* skip
+++reason = "OCaml 5 only"
+++** hassysthreads
++ include systhreads
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ 
++diff --git a/testsuite/tests/parallel/join.ml b/testsuite/tests/parallel/join.ml
++index ee85838527..f98dbcef64 100644
++--- a/testsuite/tests/parallel/join.ml
+++++ b/testsuite/tests/parallel/join.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ 
++ let test_size =
++diff --git a/testsuite/tests/parallel/major_gc_wait_backup.ml b/testsuite/tests/parallel/major_gc_wait_backup.ml
++index e418500774..f11190aee3 100644
++--- a/testsuite/tests/parallel/major_gc_wait_backup.ml
+++++ b/testsuite/tests/parallel/major_gc_wait_backup.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** native
++-** bytecode
+++*** native
+++*** bytecode
++ *)
++ 
++ type 'a tree = Empty | Node of 'a tree * 'a tree
++diff --git a/testsuite/tests/parallel/mctest.ml b/testsuite/tests/parallel/mctest.ml
++index c5d82d2dbd..bbebf9d4b8 100644
++--- a/testsuite/tests/parallel/mctest.ml
+++++ b/testsuite/tests/parallel/mctest.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ (*
++diff --git a/testsuite/tests/parallel/multicore_systhreads.ml b/testsuite/tests/parallel/multicore_systhreads.ml
++index 2f0fcf20b0..5ce5ea86ea 100644
++--- a/testsuite/tests/parallel/multicore_systhreads.ml
+++++ b/testsuite/tests/parallel/multicore_systhreads.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hassysthreads
+++* skip
+++reason = "OCaml 5 only"
+++** hassysthreads
++ include systhreads
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ 
++diff --git a/testsuite/tests/parallel/pingpong.ml b/testsuite/tests/parallel/pingpong.ml
++index 1f29cb6b8b..70b7ed6f69 100644
++--- a/testsuite/tests/parallel/pingpong.ml
+++++ b/testsuite/tests/parallel/pingpong.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ 
++ let r = ref (Some 0)
++diff --git a/testsuite/tests/parallel/poll.ml b/testsuite/tests/parallel/poll.ml
++index 4248ba10cf..98255fb08d 100644
++--- a/testsuite/tests/parallel/poll.ml
+++++ b/testsuite/tests/parallel/poll.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ let continue = Atomic.make true
++diff --git a/testsuite/tests/parallel/prodcons_domains.ml b/testsuite/tests/parallel/prodcons_domains.ml
++index 2e2c09756c..2b86809df1 100644
++--- a/testsuite/tests/parallel/prodcons_domains.ml
+++++ b/testsuite/tests/parallel/prodcons_domains.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ 
++ (* Classic producer-consumer *)
++diff --git a/testsuite/tests/parallel/recommended_domain_count.ml b/testsuite/tests/parallel/recommended_domain_count.ml
++index 8aedeba202..cb2c93cbf6 100644
++--- a/testsuite/tests/parallel/recommended_domain_count.ml
+++++ b/testsuite/tests/parallel/recommended_domain_count.ml
++@@ -1,5 +1,7 @@
++ (* TEST
++ modules = "recommended_domain_count_cstubs.c"
+++* skip
+++reason = "OCaml 5 only"
++ *)
++ 
++ external get_max_domains : unit -> int = "caml_get_max_domains"
++diff --git a/testsuite/tests/parallel/recommended_domain_count_unix.ml b/testsuite/tests/parallel/recommended_domain_count_unix.ml
++index f26038a765..9bab6ccab9 100644
++--- a/testsuite/tests/parallel/recommended_domain_count_unix.ml
+++++ b/testsuite/tests/parallel/recommended_domain_count_unix.ml
++@@ -1,8 +1,10 @@
++ (* TEST
++-* hasunix
+++* skip
+++reason = "OCaml 5 only"
+++** hasunix
++ include unix
++-** bytecode
++-** native
+++*** bytecode
+++*** native
++ *)
++ 
++ let try_ext cmd =
++diff --git a/testsuite/tests/parallel/tak.ml b/testsuite/tests/parallel/tak.ml
++index a9b6874c4f..bdc4173266 100644
++--- a/testsuite/tests/parallel/tak.ml
+++++ b/testsuite/tests/parallel/tak.ml
++@@ -1,4 +1,6 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++ *)
++ 
++ (* filling minor heaps in parallel to trigger
++diff --git a/testsuite/tests/parallel/test_c_thread_register.ml b/testsuite/tests/parallel/test_c_thread_register.ml
++index 352424a377..9e2073c4ef 100644
++--- a/testsuite/tests/parallel/test_c_thread_register.ml
+++++ b/testsuite/tests/parallel/test_c_thread_register.ml
++@@ -1,9 +1,11 @@
++ (* TEST
+++   * skip
+++   reason = "OCaml 5 only"
++    modules = "test_c_thread_register_cstubs.c"
++-   * hassysthreads
+++   ** hassysthreads
++    include systhreads
++-   ** bytecode
++-   ** native
+++   *** bytecode
+++   *** native
++ *)
++ 
++ (* spins a external thread from C and register it to the OCaml runtime *)
++diff --git a/testsuite/tests/parallel/test_issue_11094.ml b/testsuite/tests/parallel/test_issue_11094.ml
++index ffc6d4bedd..8b9fb98c50 100644
++--- a/testsuite/tests/parallel/test_issue_11094.ml
+++++ b/testsuite/tests/parallel/test_issue_11094.ml
++@@ -1,6 +1,8 @@
++ (* TEST
++-* bytecode
++-* native
+++* skip
+++reason = "OCaml 5 only"
+++** bytecode
+++** native
++ *)
++ 
++ open Effect
++diff --git a/testsuite/tests/regression/pr9326/gc_set.ml b/testsuite/tests/regression/pr9326/gc_set.ml
++index 2570aec28e..e9d7dbcd4c 100644
++--- a/testsuite/tests/regression/pr9326/gc_set.ml
+++++ b/testsuite/tests/regression/pr9326/gc_set.ml
++@@ -4,35 +4,32 @@
++ open Gc
++ 
++ let min_heap_sz = 524288 (* 512k *)
++-let space_overhead = 70
++-let stack_limit = 4194304 (* 4M *)
++-let custom_major_ratio = 40
++-let custom_minor_ratio = 99
++-let custom_minor_max_size = 4096
+++let maj_heap_inc = 4194304 (* 4M *)
++ 
++ let _ =
++   let g1 = Gc.get() in
++   (* Do not use { g1 with ... }, so that the code will break if more fields
++      are added to the Gc.control record type *)
++   Gc.set { minor_heap_size = min_heap_sz;
++-           major_heap_increment = g1.major_heap_increment;
++-           space_overhead = space_overhead;
+++           major_heap_increment = maj_heap_inc;
+++           space_overhead = g1.space_overhead;
++            verbose = g1.verbose;
++            max_overhead = g1.max_overhead;
++-           stack_limit = stack_limit;
+++           stack_limit = g1.stack_limit;
++            allocation_policy = g1.allocation_policy;
++            window_size = g1.window_size;
++-           custom_major_ratio = custom_major_ratio;
++-           custom_minor_ratio = custom_minor_ratio;
++-           custom_minor_max_size = custom_minor_max_size };
+++           custom_major_ratio = g1.custom_major_ratio;
+++           custom_minor_ratio = g1.custom_minor_ratio;
+++           custom_minor_max_size = g1.custom_minor_max_size };
++   let g2 = Gc.get() in
++   assert (g2.minor_heap_size = min_heap_sz);
++-  assert (g2.space_overhead = space_overhead);
+++  assert (g2.major_heap_increment = maj_heap_inc);
+++  assert (g2.space_overhead = g1.space_overhead);
++   assert (g2.verbose = g1.verbose);
++   assert (g2.max_overhead = g1.max_overhead);
++-  assert (g2.stack_limit = stack_limit);
+++  assert (g2.stack_limit = g1.stack_limit);
++   assert (g2.allocation_policy = g1.allocation_policy);
++   assert (g2.window_size = g1.window_size);
++-  assert (g2.custom_major_ratio = custom_major_ratio);
++-  assert (g2.custom_minor_ratio = custom_minor_ratio);
++-  assert (g2.custom_minor_max_size = custom_minor_max_size)
+++  assert (g2.custom_major_ratio = g1.custom_major_ratio);
+++  assert (g2.custom_minor_ratio = g1.custom_minor_ratio);
+++  assert (g2.custom_minor_max_size = g1.custom_minor_max_size)
++diff --git a/testsuite/tests/runtime-naked-pointers/cstubs.c b/testsuite/tests/runtime-naked-pointers/cstubs.c
++new file mode 100644
++index 0000000000..e9315f3aea
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/cstubs.c
++@@ -0,0 +1,20 @@
+++#include <string.h>
+++#include "caml/mlvalues.h"
+++#include "caml/gc.h"
+++#include "caml/memory.h"
+++
+++static int colors[4] = { Caml_white, Caml_gray, Caml_blue, Caml_black };
+++
+++value make_block(value header_size, value color, value size)
+++{
+++  intnat sz = Nativeint_val(size);
+++  value * p = caml_stat_alloc((1 + sz) * sizeof(value));
+++  p[0] = Make_header(Nativeint_val(header_size), 0, colors[Int_val(color)]);
+++  memset(p + 1, 0x80, sz * sizeof(value));
+++  return (value) (p + 1);
+++}
+++
+++value make_raw_pointer (value v)
+++{
+++  return (value) Nativeint_val(v);
+++}
++diff --git a/testsuite/tests/runtime-naked-pointers/np.ml b/testsuite/tests/runtime-naked-pointers/np.ml
++new file mode 100644
++index 0000000000..1738934ff0
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/np.ml
++@@ -0,0 +1,11 @@
+++type color = White | Gray | Blue | Black
+++
+++external make_block: nativeint -> color -> nativeint -> Obj.t
+++         = "make_block"
+++
+++external make_raw_pointer: nativeint -> Obj.t
+++         = "make_raw_pointer"
+++
+++let do_gc root =
+++  Gc.compact();   (* full major + compaction *)
+++  root
++diff --git a/testsuite/tests/runtime-naked-pointers/np1.ml b/testsuite/tests/runtime-naked-pointers/np1.ml
++new file mode 100644
++index 0000000000..be4c677a23
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/np1.ml
++@@ -0,0 +1,12 @@
+++(* TEST
+++   modules = "cstubs.c np.ml"
+++   * bytecode
+++   * native
+++*)
+++
+++open Np
+++
+++(* Out-of-heap object with black header is accepted even in no-naked-pointers
+++   mode.  GC doesn't scan black objects. *)
+++
+++let x = do_gc [ make_block 100n Black 100n ]
++diff --git a/testsuite/tests/runtime-naked-pointers/np2.ml b/testsuite/tests/runtime-naked-pointers/np2.ml
++new file mode 100644
++index 0000000000..f24c813c2b
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/np2.ml
++@@ -0,0 +1,13 @@
+++(* TEST
+++   modules = "cstubs.c np.ml"
+++   * bytecode
+++   * native
+++*)
+++
+++open Np
+++
+++(* Out-of-heap object with black header is accepted even in no-naked-pointers
+++   mode.  GC doesn't scan black objects.  However, if the size in the
+++   head is crazily big, the naked pointer detector will warn. *)
+++
+++let x = do_gc [ make_block (-1n) Black 100n ]
++diff --git a/testsuite/tests/runtime-naked-pointers/np2.run b/testsuite/tests/runtime-naked-pointers/np2.run
++new file mode 100755
++index 0000000000..c03f6f688d
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/np2.run
++@@ -0,0 +1,3 @@
+++#!/bin/sh
+++
+++exec ${test_source_directory}/runtest.sh
++diff --git a/testsuite/tests/runtime-naked-pointers/np3.ml b/testsuite/tests/runtime-naked-pointers/np3.ml
++new file mode 100644
++index 0000000000..d207279df1
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/np3.ml
++@@ -0,0 +1,15 @@
+++(* TEST
+++   modules = "cstubs.c np.ml"
+++   * naked_pointers
+++   ** bytecode
+++   ** native
+++*)
+++
+++open Np
+++
+++(* Out-of-heap object with non-black header is OK in naked pointers mode only *)
+++(* Note that the header size can be wrong as it should not be used by the GC *)
+++
+++let x = do_gc [ make_block 10000n White 10n;
+++                make_block 1n Blue 0n;
+++                make_block (-1n) Gray 5n ]
++diff --git a/testsuite/tests/runtime-naked-pointers/np3.run b/testsuite/tests/runtime-naked-pointers/np3.run
++new file mode 100755
++index 0000000000..c03f6f688d
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/np3.run
++@@ -0,0 +1,3 @@
+++#!/bin/sh
+++
+++exec ${test_source_directory}/runtest.sh
++diff --git a/testsuite/tests/runtime-naked-pointers/np4.ml b/testsuite/tests/runtime-naked-pointers/np4.ml
++new file mode 100644
++index 0000000000..98966ddffc
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/np4.ml
++@@ -0,0 +1,13 @@
+++(* TEST
+++   modules = "cstubs.c np.ml"
+++   * naked_pointers
+++   ** bytecode
+++   ** native
+++*)
+++
+++open Np
+++
+++(* Null pointers and bad pointers outside the heap are OK
+++   in naked pointers mode only *)
+++
+++let x = do_gc [ make_raw_pointer 0n; make_raw_pointer 42n ]
++diff --git a/testsuite/tests/runtime-naked-pointers/np4.run b/testsuite/tests/runtime-naked-pointers/np4.run
++new file mode 100755
++index 0000000000..c03f6f688d
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/np4.run
++@@ -0,0 +1,3 @@
+++#!/bin/sh
+++
+++exec ${test_source_directory}/runtest.sh
++diff --git a/testsuite/tests/runtime-naked-pointers/runtest.sh b/testsuite/tests/runtime-naked-pointers/runtest.sh
++new file mode 100755
++index 0000000000..f5d4df561c
++--- /dev/null
+++++ b/testsuite/tests/runtime-naked-pointers/runtest.sh
++@@ -0,0 +1,10 @@
+++#!/bin/sh
+++
+++if grep -q "#define NAKED_POINTERS_CHECKER" ${ocamlsrcdir}/runtime/caml/m.h \
+++&& (echo ${program} | grep -q '\.opt')
+++then
+++  (${program} > ${output}) 2>&1 | grep -q '^Out-of-heap '
+++  exit $?
+++else
+++  exec ${program} > ${output}
+++fi
++diff --git a/testsuite/tests/shapes/comp_units.ml b/testsuite/tests/shapes/comp_units.ml
++index 3a1b9494a1..e706bd4c8e 100644
++--- a/testsuite/tests/shapes/comp_units.ml
+++++ b/testsuite/tests/shapes/comp_units.ml
++@@ -25,7 +25,7 @@ module Mproj = Unit
++ module F (X : sig type t end) = X
++ [%%expect{|
++ {
++- "F"[module] -> Abs<.4>(X/279, X/279<.3>);
+++ "F"[module] -> Abs<.4>(X/274, X/274<.3>);
++  }
++ module F : functor (X : sig type t end) -> sig type t = X.t end
++ |}]
++diff --git a/testsuite/tests/shapes/functors.ml b/testsuite/tests/shapes/functors.ml
++index 613e2fae88..12d9623b0c 100644
++--- a/testsuite/tests/shapes/functors.ml
+++++ b/testsuite/tests/shapes/functors.ml
++@@ -17,7 +17,7 @@ module type S = sig type t val x : t end
++ module Falias (X : S) = X
++ [%%expect{|
++ {
++- "Falias"[module] -> Abs<.4>(X/281, X/281<.3>);
+++ "Falias"[module] -> Abs<.4>(X/276, X/276<.3>);
++  }
++ module Falias : functor (X : S) -> sig type t = X.t val x : t end
++ |}]
++@@ -29,10 +29,10 @@ end
++ {
++  "Finclude"[module] ->
++    Abs<.6>
++-      (X/285,
+++      (X/280,
++        {
++-        "t"[type] -> X/285<.5> . "t"[type];
++-        "x"[value] -> X/285<.5> . "x"[value];
+++        "t"[type] -> X/280<.5> . "t"[type];
+++        "x"[value] -> X/280<.5> . "x"[value];
++         });
++  }
++ module Finclude : functor (X : S) -> sig type t = X.t val x : t end
++@@ -45,7 +45,7 @@ end
++ [%%expect{|
++ {
++  "Fredef"[module] ->
++-   Abs<.10>(X/292, {
+++   Abs<.10>(X/287, {
++                     "t"[type] -> <.8>;
++                     "x"[value] -> <.9>;
++                     });
++@@ -223,8 +223,8 @@ module Big_to_small1 : B2S = functor (X : Big) -> X
++ [%%expect{|
++ {
++  "Big_to_small1"[module] ->
++-   Abs<.40>(X/387, {<.39>
++-                    "t"[type] -> X/387<.39> . "t"[type];
+++   Abs<.40>(X/382, {<.39>
+++                    "t"[type] -> X/382<.39> . "t"[type];
++                     });
++  }
++ module Big_to_small1 : B2S
++@@ -234,8 +234,8 @@ module Big_to_small2 : B2S = functor (X : Big) -> struct include X end
++ [%%expect{|
++ {
++  "Big_to_small2"[module] ->
++-   Abs<.42>(X/390, {
++-                    "t"[type] -> X/390<.41> . "t"[type];
+++   Abs<.42>(X/385, {
+++                    "t"[type] -> X/385<.41> . "t"[type];
++                     });
++  }
++ module Big_to_small2 : B2S
++diff --git a/testsuite/tests/shapes/open_arg.ml b/testsuite/tests/shapes/open_arg.ml
++index a422cc8ece..b82be26527 100644
++--- a/testsuite/tests/shapes/open_arg.ml
+++++ b/testsuite/tests/shapes/open_arg.ml
++@@ -22,7 +22,7 @@ end = struct end
++ 
++ [%%expect{|
++ {
++- "Make"[module] -> Abs<.3>(I/281, {
+++ "Make"[module] -> Abs<.3>(I/276, {
++                                    });
++  }
++ module Make : functor (I : sig end) -> sig end
++diff --git a/testsuite/tests/shapes/recmodules.ml b/testsuite/tests/shapes/recmodules.ml
++index c6f743e4b4..fe47a48629 100644
++--- a/testsuite/tests/shapes/recmodules.ml
+++++ b/testsuite/tests/shapes/recmodules.ml
++@@ -43,8 +43,8 @@ and B : sig
++ end = B
++ [%%expect{|
++ {
++- "A"[module] -> A/304<.11>;
++- "B"[module] -> B/305<.12>;
+++ "A"[module] -> A/299<.11>;
+++ "B"[module] -> B/300<.12>;
++  }
++ module rec A : sig type t = Leaf of B.t end
++ and B : sig type t = int end
++@@ -82,12 +82,12 @@ end = Set.Make(A)
++  "ASet"[module] ->
++    {
++     "compare"[value] ->
++-      CU Stdlib . "Set"[module] . "Make"[module](A/326<.19>) .
+++      CU Stdlib . "Set"[module] . "Make"[module](A/321<.19>) .
++       "compare"[value];
++     "elt"[type] ->
++-      CU Stdlib . "Set"[module] . "Make"[module](A/326<.19>) . "elt"[type];
+++      CU Stdlib . "Set"[module] . "Make"[module](A/321<.19>) . "elt"[type];
++     "t"[type] ->
++-      CU Stdlib . "Set"[module] . "Make"[module](A/326<.19>) . "t"[type];
+++      CU Stdlib . "Set"[module] . "Make"[module](A/321<.19>) . "t"[type];
++     };
++  }
++ module rec A :
++diff --git a/testsuite/tests/shapes/rotor_example.ml b/testsuite/tests/shapes/rotor_example.ml
++index 5802595844..961d5d4e80 100644
++--- a/testsuite/tests/shapes/rotor_example.ml
+++++ b/testsuite/tests/shapes/rotor_example.ml
++@@ -25,7 +25,7 @@ end
++ [%%expect{|
++ {
++  "Pair"[module] ->
++-   Abs<.9>(X/281, Y/282, {
+++   Abs<.9>(X/276, Y/277, {
++                           "t"[type] -> <.5>;
++                           "to_string"[value] -> <.6>;
++                           });
++diff --git a/testsuite/tests/statmemprof/alloc_counts.ml b/testsuite/tests/statmemprof/alloc_counts.ml
++index de0d1e9e49..f8cbb5658d 100644
++--- a/testsuite/tests/statmemprof/alloc_counts.ml
+++++ b/testsuite/tests/statmemprof/alloc_counts.ml
++@@ -1,7 +1,4 @@
++-(* TEST
++-* skip
++-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++-*)
+++(* TEST *)
++ module MP = Gc.Memprof
++ 
++ let allocs_by_memprof f =
++diff --git a/testsuite/tests/statmemprof/arrays_in_major.ml b/testsuite/tests/statmemprof/arrays_in_major.ml
++index eb627324ba..78907a18e3 100644
++--- a/testsuite/tests/statmemprof/arrays_in_major.ml
+++++ b/testsuite/tests/statmemprof/arrays_in_major.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    flags = "-g"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ *)
++ 
++ open Gc.Memprof
++diff --git a/testsuite/tests/statmemprof/arrays_in_major.reference b/testsuite/tests/statmemprof/arrays_in_major.reference
++new file mode 100644
++index 0000000000..1f34ad8ec8
++--- /dev/null
+++++ b/testsuite/tests/statmemprof/arrays_in_major.reference
++@@ -0,0 +1,11 @@
+++check_nosample
+++check_counts_full_major
+++check_counts_full_major
+++check_no_nested
+++check_distrib 300 3000 3 0.000010
+++check_distrib 300 3000 1 0.000100
+++check_distrib 300 3000 1 0.010000
+++check_distrib 300 3000 1 0.900000
+++check_distrib 300 300 100000 0.100000
+++check_distrib 300000 300000 30 0.100000
+++OK !
++diff --git a/testsuite/tests/statmemprof/arrays_in_minor.ml b/testsuite/tests/statmemprof/arrays_in_minor.ml
++index 4359642d0e..432f8b1d09 100644
++--- a/testsuite/tests/statmemprof/arrays_in_minor.ml
+++++ b/testsuite/tests/statmemprof/arrays_in_minor.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    flags = "-g"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ *)
++ 
++ open Gc.Memprof
++diff --git a/testsuite/tests/statmemprof/arrays_in_minor.reference b/testsuite/tests/statmemprof/arrays_in_minor.reference
++new file mode 100644
++index 0000000000..1dad91939c
++--- /dev/null
+++++ b/testsuite/tests/statmemprof/arrays_in_minor.reference
++@@ -0,0 +1,11 @@
+++check_nosample
+++check_counts_full_major
+++check_counts_full_major
+++check_no_nested
+++check_distrib 1 250 1000 0.000010
+++check_distrib 1 250 1000 0.000100
+++check_distrib 1 250 1000 0.010000
+++check_distrib 1 250 1000 0.900000
+++check_distrib 1 1 10000000 0.010000
+++check_distrib 250 250 100000 0.100000
+++OK !
++diff --git a/testsuite/tests/statmemprof/blocking_in_callback.ml b/testsuite/tests/statmemprof/blocking_in_callback.ml
++index e1e40f1fb6..00f49cfc74 100644
++--- a/testsuite/tests/statmemprof/blocking_in_callback.ml
+++++ b/testsuite/tests/statmemprof/blocking_in_callback.ml
++@@ -1,8 +1,6 @@
++ (* TEST
++ * hassysthreads
++ include systhreads
++-* skip
++-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ ** bytecode
++ ** native
++ *)
++diff --git a/testsuite/tests/statmemprof/callstacks.flat-float-array.reference b/testsuite/tests/statmemprof/callstacks.flat-float-array.reference
++index baea29a0d5..d71791641d 100644
++--- a/testsuite/tests/statmemprof/callstacks.flat-float-array.reference
+++++ b/testsuite/tests/statmemprof/callstacks.flat-float-array.reference
++@@ -1,74 +1,74 @@
++ -----------
++ Raised by primitive operation at Callstacks.alloc_list_literal in file "callstacks.ml", line 18, characters 30-53
++ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
++ -----------
++ Raised by primitive operation at Callstacks.alloc_pair in file "callstacks.ml", line 21, characters 30-76
++ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
++ -----------
++ Raised by primitive operation at Callstacks.alloc_record in file "callstacks.ml", line 26, characters 12-66
++ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
++ -----------
++ Raised by primitive operation at Callstacks.alloc_some in file "callstacks.ml", line 29, characters 30-60
++ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
++ -----------
++ Raised by primitive operation at Callstacks.alloc_array_literal in file "callstacks.ml", line 32, characters 30-55
++ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
++ -----------
++ Raised by primitive operation at Callstacks.alloc_float_array_literal in file "callstacks.ml", line 36, characters 12-62
++ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
++ -----------
++ Raised by primitive operation at Callstacks.do_alloc_unknown_array_literal in file "callstacks.ml", line 39, characters 22-27
++ Called from Callstacks.alloc_unknown_array_literal in file "callstacks.ml", line 41, characters 30-65
++ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
++ -----------
++ Raised by primitive operation at Callstacks.alloc_small_array in file "callstacks.ml", line 44, characters 30-69
++ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
++ -----------
++ Raised by primitive operation at Callstacks.alloc_large_array in file "callstacks.ml", line 47, characters 30-73
++ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
++ -----------
++ Raised by primitive operation at Callstacks.alloc_closure.(fun) in file "callstacks.ml", line 51, characters 30-43
++ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
++ -----------
++ Raised by primitive operation at Callstacks.get0 in file "callstacks.ml", line 54, characters 28-33
++ Called from Callstacks.getfloatfield in file "callstacks.ml", line 56, characters 30-47
++ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
++ -----------
++ Raised by primitive operation at Stdlib__Marshal.from_bytes in file "marshal.ml", line 61, characters 9-35
++ Called from Callstacks.alloc_unmarshal in file "callstacks.ml", line 62, characters 12-87
++ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
++ -----------
++ Raised by primitive operation at Callstacks.alloc_ref in file "callstacks.ml", line 65, characters 30-59
++ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
++ -----------
++ Raised by primitive operation at Callstacks.prod_floats in file "callstacks.ml", line 68, characters 37-43
++ Called from Callstacks.alloc_boxedfloat in file "callstacks.ml", line 70, characters 30-49
++ Called from Callstacks.test in file "callstacks.ml", line 92, characters 2-10
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Callstacks in file "callstacks.ml", line 99, characters 2-27
++diff --git a/testsuite/tests/statmemprof/callstacks.ml b/testsuite/tests/statmemprof/callstacks.ml
++index e864a50019..ec5a4199f0 100644
++--- a/testsuite/tests/statmemprof/callstacks.ml
+++++ b/testsuite/tests/statmemprof/callstacks.ml
++@@ -3,15 +3,11 @@
++ 
++    * flat-float-array
++      reference = "${test_source_directory}/callstacks.flat-float-array.reference"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++    ** native
++    ** bytecode
++ 
++    * no-flat-float-array
++      reference = "${test_source_directory}/callstacks.no-flat-float-array.reference"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++    ** native
++    ** bytecode
++ *)
++diff --git a/testsuite/tests/statmemprof/comballoc.byte.reference b/testsuite/tests/statmemprof/comballoc.byte.reference
++index 4db26f1c99..98c4fd718d 100644
++--- a/testsuite/tests/statmemprof/comballoc.byte.reference
+++++ b/testsuite/tests/statmemprof/comballoc.byte.reference
++@@ -1,49 +1,49 @@
++ 2: 0.42 false
++ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 2-19
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ 3: 0.42 false
++ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 6-18
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ 4: 0.42 true
++ Raised by primitive operation at Comballoc.f4 in file "comballoc.ml", line 11, characters 11-20
++ Called from Comballoc.f in file "comballoc.ml", line 14, characters 13-17
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ 2: 0.01 false
++ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 2-19
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ 3: 0.01 false
++ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 6-18
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ 4: 0.01 true
++ Raised by primitive operation at Comballoc.f4 in file "comballoc.ml", line 11, characters 11-20
++ Called from Comballoc.f in file "comballoc.ml", line 14, characters 13-17
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ 2: 0.83 false
++ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 2-19
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ 3: 0.83 false
++ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 6-18
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ 4: 0.83 true
++ Raised by primitive operation at Comballoc.f4 in file "comballoc.ml", line 11, characters 11-20
++ Called from Comballoc.f in file "comballoc.ml", line 14, characters 13-17
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ OK
++diff --git a/testsuite/tests/statmemprof/comballoc.ml b/testsuite/tests/statmemprof/comballoc.ml
++index 60ca4a0123..22b2547101 100644
++--- a/testsuite/tests/statmemprof/comballoc.ml
+++++ b/testsuite/tests/statmemprof/comballoc.ml
++@@ -1,10 +1,8 @@
++ (* TEST
++    flags = "-g"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++-   ** bytecode
+++   * bytecode
++      reference = "${test_source_directory}/comballoc.byte.reference"
++-   ** native
+++   * native
++      reference = "${test_source_directory}/comballoc.opt.reference"
++ *)
++ 
++diff --git a/testsuite/tests/statmemprof/comballoc.opt.reference b/testsuite/tests/statmemprof/comballoc.opt.reference
++index 3afd163aa8..b6bd4f18fe 100644
++--- a/testsuite/tests/statmemprof/comballoc.opt.reference
+++++ b/testsuite/tests/statmemprof/comballoc.opt.reference
++@@ -1,49 +1,49 @@
++ 2: 0.42 false
++ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 2-19
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ 3: 0.42 false
++ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 6-18
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ 4: 0.42 true
++ Raised by primitive operation at Comballoc.f4 in file "comballoc.ml" (inlined), line 11, characters 11-20
++ Called from Comballoc.f in file "comballoc.ml", line 14, characters 13-17
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ 2: 0.01 false
++ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 2-19
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ 3: 0.01 false
++ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 6-18
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ 4: 0.01 true
++ Raised by primitive operation at Comballoc.f4 in file "comballoc.ml" (inlined), line 11, characters 11-20
++ Called from Comballoc.f in file "comballoc.ml", line 14, characters 13-17
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ 2: 0.83 false
++ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 2-19
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ 3: 0.83 false
++ Raised by primitive operation at Comballoc.f in file "comballoc.ml", line 14, characters 6-18
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ 4: 0.83 true
++ Raised by primitive operation at Comballoc.f4 in file "comballoc.ml" (inlined), line 11, characters 11-20
++ Called from Comballoc.f in file "comballoc.ml", line 14, characters 13-17
++ Called from Comballoc.test in file "comballoc.ml", line 39, characters 25-48
++-Called from Stdlib__List.iter in file "list.ml", line 110, characters 12-15
+++Called from Stdlib__List.iter in file "list.ml", line 112, characters 12-15
++ Called from Comballoc in file "comballoc.ml", line 69, characters 2-35
++ OK
++diff --git a/testsuite/tests/statmemprof/custom.ml b/testsuite/tests/statmemprof/custom.ml
++index 41cf902ec8..f0ddfa7eed 100644
++--- a/testsuite/tests/statmemprof/custom.ml
+++++ b/testsuite/tests/statmemprof/custom.ml
++@@ -1,7 +1,4 @@
++-(* TEST
++-* skip
++-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++-*)
+++(* TEST *)
++ 
++ open Gc.Memprof
++ 
++diff --git a/testsuite/tests/statmemprof/exception_callback.ml b/testsuite/tests/statmemprof/exception_callback.ml
++index f9f02f690f..e1589372ab 100644
++--- a/testsuite/tests/statmemprof/exception_callback.ml
+++++ b/testsuite/tests/statmemprof/exception_callback.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    exit_status = "2"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ *)
++ 
++ open Gc.Memprof
++diff --git a/testsuite/tests/statmemprof/exception_callback_minor.ml b/testsuite/tests/statmemprof/exception_callback_minor.ml
++index 0bb37782be..f514123276 100644
++--- a/testsuite/tests/statmemprof/exception_callback_minor.ml
+++++ b/testsuite/tests/statmemprof/exception_callback_minor.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    exit_status = "2"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ *)
++ 
++ open Gc.Memprof
++diff --git a/testsuite/tests/statmemprof/intern.ml b/testsuite/tests/statmemprof/intern.ml
++index bebcc3c8ff..bce6f89c5c 100644
++--- a/testsuite/tests/statmemprof/intern.ml
+++++ b/testsuite/tests/statmemprof/intern.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    flags = "-g"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ *)
++ 
++ open Gc.Memprof
++diff --git a/testsuite/tests/statmemprof/intern.reference b/testsuite/tests/statmemprof/intern.reference
++new file mode 100644
++index 0000000000..d83e8d6d50
++--- /dev/null
+++++ b/testsuite/tests/statmemprof/intern.reference
++@@ -0,0 +1,10 @@
+++check_nosample
+++check_counts_full_major
+++check_counts_full_major
+++check_no_nested
+++check_distrib 2 3000 3 0.000010
+++check_distrib 2 3000 1 0.000100
+++check_distrib 2 2000 1 0.010000
+++check_distrib 2 2000 1 0.900000
+++check_distrib 300000 300000 20 0.100000
+++OK !
++diff --git a/testsuite/tests/statmemprof/lists_in_minor.ml b/testsuite/tests/statmemprof/lists_in_minor.ml
++index d08716c71b..ebd434857e 100644
++--- a/testsuite/tests/statmemprof/lists_in_minor.ml
+++++ b/testsuite/tests/statmemprof/lists_in_minor.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    flags = "-g"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ *)
++ 
++ open Gc.Memprof
++diff --git a/testsuite/tests/statmemprof/lists_in_minor.reference b/testsuite/tests/statmemprof/lists_in_minor.reference
++new file mode 100644
++index 0000000000..11cfe0ca12
++--- /dev/null
+++++ b/testsuite/tests/statmemprof/lists_in_minor.reference
++@@ -0,0 +1,8 @@
+++check_distrib 10 1000000 0.010000
+++check_distrib 1000000 10 0.000010
+++check_distrib 1000000 10 0.000100
+++check_distrib 1000000 10 0.001000
+++check_distrib 1000000 10 0.010000
+++check_distrib 100000 10 0.100000
+++check_distrib 100000 10 0.900000
+++OK !
++diff --git a/testsuite/tests/statmemprof/minor_no_postpone.ml b/testsuite/tests/statmemprof/minor_no_postpone.ml
++index 21c8bfb244..fcb94cf81d 100644
++--- a/testsuite/tests/statmemprof/minor_no_postpone.ml
+++++ b/testsuite/tests/statmemprof/minor_no_postpone.ml
++@@ -1,7 +1,5 @@
++ (* TEST
++    modules = "minor_no_postpone_stub.c"
++-   * skip
++-   reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ *)
++ 
++ open Gc.Memprof
++diff --git a/testsuite/tests/statmemprof/moved_while_blocking.ml b/testsuite/tests/statmemprof/moved_while_blocking.ml
++index bb8dfc9848..8efc172aea 100644
++--- a/testsuite/tests/statmemprof/moved_while_blocking.ml
+++++ b/testsuite/tests/statmemprof/moved_while_blocking.ml
++@@ -1,8 +1,6 @@
++ (* TEST
++ * hassysthreads
++ include systhreads
++-* skip
++-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ ** bytecode
++ ** native
++ *)
++diff --git a/testsuite/tests/statmemprof/thread_exit_in_callback.ml b/testsuite/tests/statmemprof/thread_exit_in_callback.ml
++index 28e2aabb8b..563be966a8 100644
++--- a/testsuite/tests/statmemprof/thread_exit_in_callback.ml
+++++ b/testsuite/tests/statmemprof/thread_exit_in_callback.ml
++@@ -1,8 +1,6 @@
++ (* TEST
++ * hassysthreads
++ include systhreads
++-* skip
++-reason = "port stat-mem-prof : https://github.com/ocaml/ocaml/pull/8634"
++ ** bytecode
++ ** native
++ *)
++@@ -12,7 +10,7 @@ let _ =
++   Gc.Memprof.(start ~callstack_size:10 ~sampling_rate:1.
++                 { null_tracker with alloc_minor = fun _ ->
++                       if Thread.id (Thread.self ()) <> main_thread then
++-                        Thread.exit ();
+++                        raise Thread.Exit;
++                       None });
++   let t = Thread.create (fun () ->
++       ignore (Sys.opaque_identity (ref 1));
++@@ -21,6 +19,8 @@ let _ =
++   Thread.join t;
++   Gc.Memprof.stop ()
++ 
+++[@@@ocaml.alert "-deprecated"]
+++
++ let _ =
++   Gc.Memprof.(start ~callstack_size:10 ~sampling_rate:1.
++     { null_tracker with alloc_minor = fun _ -> Thread.exit (); None });
++diff --git a/testsuite/tests/typing-sigsubst/sigsubst.ml b/testsuite/tests/typing-sigsubst/sigsubst.ml
++index 6e3a30306e..7e48ca4534 100644
++--- a/testsuite/tests/typing-sigsubst/sigsubst.ml
+++++ b/testsuite/tests/typing-sigsubst/sigsubst.ml
++@@ -24,11 +24,11 @@ end
++ Line 3, characters 2-36:
++ 3 |   include Comparable with type t = t
++       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
++-Error: Illegal shadowing of included type t/286 by t/291
+++Error: Illegal shadowing of included type t/281 by t/286
++        Line 2, characters 2-19:
++-         Type t/286 came from this include
+++         Type t/281 came from this include
++        Line 3, characters 2-23:
++-         The value print has no valid type if t/286 is shadowed
+++         The value print has no valid type if t/281 is shadowed
++ |}]
++ 
++ module type Sunderscore = sig
++diff --git a/testsuite/tests/unwind/unwind_test.reference b/testsuite/tests/unwind/unwind_test.reference
++index b3804d00e5..827cc4affc 100644
++--- a/testsuite/tests/unwind/unwind_test.reference
+++++ b/testsuite/tests/unwind/unwind_test.reference
++@@ -1,5 +1,4 @@
++ ml_perform_stack_walk
++-caml_c_call
++ Mylib.baz
++ Driver.entry
++ caml_program
++diff --git a/testsuite/tests/weak-ephe-final/ephetest_par.ml b/testsuite/tests/weak-ephe-final/ephetest_par.ml
++index e3cab0e83e..26b5878c7a 100644
++--- a/testsuite/tests/weak-ephe-final/ephetest_par.ml
+++++ b/testsuite/tests/weak-ephe-final/ephetest_par.ml
++@@ -1,4 +1,7 @@
++-(* TEST *)
+++(* TEST
+++   * skip
+++   reason = "OCaml 5 only"
+++ *)
++ 
++ (* Due to GCs running at non-deterministic places, the output from these tests
++  * are unreliable except the bad value checks and as a check for catastrophic
++diff --git a/testsuite/tests/weak-ephe-final/finaliser2.ml b/testsuite/tests/weak-ephe-final/finaliser2.ml
++index 666a55efeb..5a36157e0e 100644
++--- a/testsuite/tests/weak-ephe-final/finaliser2.ml
+++++ b/testsuite/tests/weak-ephe-final/finaliser2.ml
++@@ -1,4 +1,7 @@
++-(* TEST *)
+++(* TEST
+++   * skip
+++   reason = "OCaml 5 only"
+++*)
++ 
++ let () = Out_channel.set_buffered stdout false
++ 
++diff --git a/testsuite/tests/weak-ephe-final/finaliser_handover.ml b/testsuite/tests/weak-ephe-final/finaliser_handover.ml
++index fa2d2efc43..752a7eeabf 100644
++--- a/testsuite/tests/weak-ephe-final/finaliser_handover.ml
+++++ b/testsuite/tests/weak-ephe-final/finaliser_handover.ml
++@@ -1,4 +1,7 @@
++-(* TEST *)
+++(* TEST
+++   * skip
+++   reason = "OCaml 5 only"
+++*)
++ 
++ (* ocaml-multicore issues 528 and 468 *)
++ 
++diff --git a/testsuite/tests/weak-ephe-final/weaklifetime_par.ml b/testsuite/tests/weak-ephe-final/weaklifetime_par.ml
++index b42d399907..656e318473 100644
++--- a/testsuite/tests/weak-ephe-final/weaklifetime_par.ml
+++++ b/testsuite/tests/weak-ephe-final/weaklifetime_par.ml
++@@ -1,3 +1,7 @@
+++(* TEST
+++   * skip
+++   reason = "OCaml 5 only"
+++*)
++ (* This test is currently disabled,
++    until the random failures have been investigated.
++ *)
++diff --git a/testsuite/tests/weak-ephe-final/weaktest_par_load.ml b/testsuite/tests/weak-ephe-final/weaktest_par_load.ml
++index f5e0711b79..8beb1f6433 100644
++--- a/testsuite/tests/weak-ephe-final/weaktest_par_load.ml
+++++ b/testsuite/tests/weak-ephe-final/weaktest_par_load.ml
++@@ -1,4 +1,7 @@
++-(* TEST *)
+++(* TEST
+++* skip
+++reason = "OCaml 5 only"
+++*)
++ 
++ (* Testing unsynchronized, parallel Weak usage *)
++ 
++diff --git a/tools/ci/actions/runner.sh b/tools/ci/actions/runner.sh
++index de10bd1fd3..5f9e31bc66 100755
++--- a/tools/ci/actions/runner.sh
+++++ b/tools/ci/actions/runner.sh
++@@ -40,19 +40,7 @@ EOF
++     --enable-debug-runtime \
++     $CONFIG_ARG"
++ 
++-  case $XARCH in
++-  x64)
++-    ./configure $configure_flags
++-    ;;
++-  i386)
++-    ./configure --build=x86_64-pc-linux-gnu --host=i386-pc-linux-gnu \
++-      $configure_flags
++-    ;;
++-  *)
++-    echo unknown arch
++-    exit 1
++-    ;;
++-  esac
+++  ./configure $configure_flags
++ }
++ 
++ Build () {
++diff --git a/tools/ci/appveyor/appveyor_build.sh b/tools/ci/appveyor/appveyor_build.sh
++index 3292ad9c31..f69aeb342c 100644
++--- a/tools/ci/appveyor/appveyor_build.sh
+++++ b/tools/ci/appveyor/appveyor_build.sh
++@@ -64,8 +64,8 @@ function set_configuration {
++         mingw64)
++             build='--build=i686-pc-cygwin'
++             host='--host=x86_64-w64-mingw32'
++-            dep='--disable-dependency-generation'
++-            man='--disable-stdlib-manpages'
+++            # Explicitly test dependency generation on msvc64
+++            dep='--enable-dependency-generation'
++         ;;
++         msvc32)
++             build='--build=i686-pc-cygwin'
++@@ -139,29 +139,40 @@ case "$1" in
++     ;;
++   test)
++     FULL_BUILD_PREFIX="$APPVEYOR_BUILD_FOLDER/../$BUILD_PREFIX"
++-    run 'ocamlc.opt -version' "$FU
\ No newline at end of file
diff --git a/lambda/matching.ml b/lambda/matching.ml
index e2d1b08fab..d80b0d7c24 100644
--- a/lambda/matching.ml
+++ b/lambda/matching.ml
@@ -1877,7 +1877,11 @@ let get_mod_field modname field =
 
 let code_force_lazy_block = get_mod_field "CamlinternalLazy" "force_lazy_block"
 
+(* BACKPORT_BEGIN
 let code_force_lazy = get_mod_field "CamlinternalLazy" "force_gen"
+*)
+let code_force_lazy = get_mod_field "CamlinternalLazy" "force"
+(* BACKPORT END *)
 
 (* inline_lazy_force inlines the beginning of the code of Lazy.force. When
    the value argument is tagged as:
@@ -1900,7 +1904,11 @@ let call_force_lazy_block varg loc =
     { ap_tailcall = Default_tailcall;
       ap_loc = loc;
       ap_func = force_fun;
+(* BACKPORT BEGIN
       ap_args = [ Lprim (Popaque, [ varg ], loc) ];
+*)
+      ap_args = [ varg ];
+(* BACKPORT END *)
       ap_inlined = Default_inline;
       ap_specialised = Default_specialise
     }
@@ -1909,9 +1917,14 @@ let inline_lazy_force_cond arg loc =
   let idarg = Ident.create_local "lzarg" in
   let varg = Lvar idarg in
   let tag = Ident.create_local "tag" in
+(* BACKPORT BEGIN *)
+  let tag_var = Lvar tag in
+(* BACKPORT END *)
+(* BACKPORT
   let test_tag t =
     Lprim(Pintcomp Ceq, [Lvar tag; Lconst(Const_base(Const_int t))], loc)
   in
+*)
 
   Llet
     ( Strict,
@@ -1924,16 +1937,32 @@ let inline_lazy_force_cond arg loc =
           tag,
           Lprim (Pccall prim_obj_tag, [ varg ], loc),
           Lifthenelse
+(* BACKPORT BEGIN
             ( (* if (tag == Obj.forward_tag) then varg.(0) else ... *)
               test_tag Obj.forward_tag,
               Lprim (Pfield (0, Pointer, Mutable), [ varg ], loc),
+*)
+            ( Lprim
+                ( Pintcomp Ceq,
+                  [ tag_var; Lconst (Const_base (Const_int Obj.forward_tag)) ],
+                  loc ),
+              Lprim (Pfield (0, Pointer, Mutable), [ varg ], loc),
+(* BACKPORT END *)
               Lifthenelse
+(* BACKPORT BEGIN *)
+                ( Lprim
+                    ( Pintcomp Ceq,
+                      [ tag_var; Lconst (Const_base (Const_int Obj.lazy_tag)) ],
+                      loc ),
+(* BACKPORT END *)
+(* BACKPORT
                 (
                   (* ... if tag == Obj.lazy_tag || tag == Obj.forcing_tag then
                          Lazy.force varg
                        else ... *)
                   Lprim (Psequor,
                        [test_tag Obj.lazy_tag; test_tag Obj.forcing_tag], loc),
+*)
                   call_force_lazy_block varg loc,
                   (* ... arg *)
                   varg ) ) ) )
@@ -1950,16 +1979,31 @@ let inline_lazy_force_switch arg loc =
         ( Lprim (Pisint, [ varg ], loc),
           varg,
           Lswitch
+(* BACKPORT BEGIN
             ( Lprim (Pccall prim_obj_tag, [ varg ], loc),
               { sw_numblocks = 0;
                 sw_blocks = [];
                 sw_numconsts = 256;
+*)
+            ( varg,
+              { sw_numconsts = 0;
+                sw_consts = [];
+                sw_numblocks = 256;
+(* BACKPORT END *)
                 (* PR#6033 - tag ranges from 0 to 255 *)
+(* BACKPORT BEGIN *)
+                sw_blocks =
+                  [ (Obj.forward_tag,
+                     Lprim (Pfield (0, Pointer, Mutable), [ varg ], loc));
+                    (Obj.lazy_tag, call_force_lazy_block varg loc)
+(* BACKPORT END *)
+(* BACKPORT
                 sw_consts =
                   [ (Obj.forward_tag, Lprim (Pfield(0, Pointer, Mutable),
                                              [ varg ], loc));
                     (Obj.lazy_tag, call_force_lazy_block varg loc);
                     (Obj.forcing_tag, call_force_lazy_block varg loc)
+*)
                   ];
                 sw_failaction = Some varg
               },
@@ -1975,7 +2019,11 @@ let inline_lazy_force arg loc =
       { ap_tailcall = Default_tailcall;
         ap_loc = loc;
         ap_func = Lazy.force code_force_lazy;
+(* BACKPORT BEGIN
         ap_args = [ Lconst (Const_base (Const_int 0)); arg ];
+*)
+        ap_args = [ arg ];
+(* BACKPORT END *)
         ap_inlined = Default_inline;
         ap_specialised = Default_specialise
       }
diff --git a/manual/src/library/stdlib-blurb.etex b/manual/src/library/stdlib-blurb.etex
index 7c90119eb4..39518d86cb 100644
--- a/manual/src/library/stdlib-blurb.etex
+++ b/manual/src/library/stdlib-blurb.etex
@@ -130,10 +130,10 @@ be called from C \\
 \stddocitem{Callback}{registering OCaml values with the C runtime}
 \stddocitem{Char}{character operations}
 \stddocitem{Complex}{complex numbers}
-\stddocitem{Condition}{condition variables to synchronize between threads}
-\stddocitem{Domain}{Domain spawn/join and domain local variables}
+%\stddocitem{Condition}{condition variables to synchronize between threads}
+%\stddocitem{Domain}{Domain spawn/join and domain local variables}
 \stddocitem{Digest}{MD5 message digest}
-\stddocitem{Effect}{deep and shallow effect handlers}
+%\stddocitem{Effect}{deep and shallow effect handlers}
 \stddocitem{Either}{either values}
 \stddocitem{Ephemeron}{Ephemerons and weak hash table}
 \stddocitem{Filename}{operations on file names}
@@ -153,7 +153,7 @@ be called from C \\
 \stddocitem{Map}{association tables over ordered types}
 \stddocitem{Marshal}{marshaling of data structures}
 \stddocitem{MoreLabels}{include modules \texttt{Hashtbl}, \texttt{Map} and \texttt{Set} with labels}
-\stddocitem{Mutex}{locks for mutual exclusion}
+%\stddocitem{Mutex}{locks for mutual exclusion}
 \stddocitem{Nativeint}{processor-native integers}
 \stddocitem{Oo}{object-oriented extension}
 \stddocitem{Option}{option values}
@@ -167,7 +167,7 @@ be called from C \\
 \stddocitem{Scanf}{formatted input functions}
 \stddocitem{Seq}{functional iterators}
 \stddocitem{Set}{sets over ordered types}
-\stddocitem{Semaphore}{semaphores, another thread synchronization mechanism}
+%\stddocitem{Semaphore}{semaphores, another thread synchronization mechanism}
 \stddocitem{Stack}{last-in first-out stacks}
 \stddocitem{StdLabels}{include modules \texttt{Array}, \texttt{List} and \texttt{String} with labels}
 \stddocitem{String}{string operations}
diff --git a/manual/src/refman/extensions/effects.etex b/manual/src/refman/extensions/effects.etex
index 0d6826cfc7..a054ed30a6 100644
--- a/manual/src/refman/extensions/effects.etex
+++ b/manual/src/refman/extensions/effects.etex
@@ -24,7 +24,7 @@ To understand the basics, let us define an effect (that is, an operation) that
 takes an integer argument and returns an integer result. We name this effect
 "Xchg".
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 open Effect
 open Effect.Deep
 
@@ -42,7 +42,7 @@ returns their sum.
 We can handle the "Xchg" effect by implementing a handler that always returns
 the successor of the offered value:
 
-\begin{caml_example}{verbatim}
+\begin{caml_example}{verbatim}[error]
 try_with comp1 ()
 { effc = fun (type a) (eff: a t) ->
     match eff with
@@ -99,7 +99,7 @@ computations \textit{tasks}.
 A task either is in a suspended state or is completed. We represent the task
 status as follows:
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 type 'a status =
   Complete of 'a
 | Suspended of {msg: int; cont: (int, 'a status) continuation}
@@ -113,7 +113,7 @@ resume and returns a "'a status" value when resumed.
 Next, we define a "step" function that executes one step of computation until
 it completes or suspends:
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 let step (f : unit -> 'a) () : 'a status =
   match_with f ()
   { retc = (fun v -> Complete v);
@@ -156,7 +156,7 @@ the status does not perform the "Xchg" effect.
 
 We can now write a simple scheduler that runs a pair of tasks to completion:
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 let rec run_both a b =
   match a (), b () with
   | Complete va, Complete vb -> (va, vb)
@@ -175,13 +175,13 @@ the handler to raise an exception
 
 We can now define a second computation that also exchanges two messages:
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 let comp2 () = perform (Xchg 21) * perform (Xchg 21)
 \end{caml_example*}
 
 Finally, we can run the two computations together:
 
-\begin{caml_example}{verbatim}
+\begin{caml_example}{verbatim}[error]
 run_both (step comp1) (step comp2)
 \end{caml_example}
 
@@ -202,7 +202,7 @@ user-level threading systems provide a "fork" primitive to spawn off a new
 concurrent task and a "yield" primitive to yield control to some other task.
 Correspondingly, we shall declare two effects as follows:
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 type _ Effect.t += Fork : (unit -> unit) -> unit t
                  | Yield : unit t
 \end{caml_example*}
@@ -215,7 +215,7 @@ also offering to exchange a value.
 
 We shall also define helper functions that simply perform these effects:
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 let fork f = perform (Fork f)
 let yield () = perform Yield
 let xchg v = perform (Xchg v)
@@ -223,7 +223,7 @@ let xchg v = perform (Xchg v)
 
 A top-level "run" function defines the scheduler:
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 (* A concurrent round-robin scheduler *)
 let run (main : unit -> unit) : unit =
   let exchanger = ref None in (* waiting exchanger *)
@@ -296,7 +296,7 @@ explain and fix this in the next section~\ref{s:effects-discontinue}.
 Now we can write a concurrent program that utilises the newly defined
 operations:
 
-\begin{caml_example}{verbatim}
+\begin{caml_example}{verbatim}[error]
 open Printf
 
 let _ = run (fun _ ->
@@ -341,7 +341,7 @@ exchange a value (stored in the reference cell "exchanger"), which remains
 blocked forever! If the blocked task holds onto resources, these resources are
 leaked. For example, consider the following task:
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 let leaky_task () =
   fork (fun _ ->
     let oc = open_out "secret.txt" in
@@ -442,7 +442,7 @@ lst_iter (fun i -> Printf.printf "%d\n" i)
 The expression "invert lst_iter" returns a sequence that allows the consumer to
 traverse the list on demand. For example,
 
-\begin{caml_example}{verbatim}
+\begin{caml_example}{verbatim}[error]
 let s = invert ~iter:lst_iter
 let next = Seq.to_dispenser s;;
 next();;
@@ -453,7 +453,7 @@ next();;
 
 We can use the same "invert" function on any "iter" function. For example,
 
-\begin{caml_example}{verbatim}
+\begin{caml_example}{verbatim}[error]
 let s = invert ~iter:(Fun.flip String.iter "OCaml")
 let next = Seq.to_dispenser s;;
 next();;
@@ -468,7 +468,7 @@ next();;
 
 The implementation of the "invert" function is given below:
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 let invert (type a) ~(iter : (a -> unit) -> unit) : a Seq.t =
   let module M = struct
     type _ Effect.t += Yield : a -> unit t
@@ -517,7 +517,7 @@ examples.
 
 Like exception handlers, effect handlers can be nested.
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 type _ Effect.t += E : int t
                  | F : string t
 
@@ -544,7 +544,7 @@ In this example, the computation "foo" performs "F", the inner handler handles
 only "E" and the outer handler handles "F". The call to "baz" returns "Hello,
 world!".
 
-\begin{caml_example}{verbatim}
+\begin{caml_example}{verbatim}[error]
 baz ()
 \end{caml_example}
 
@@ -606,7 +606,7 @@ corresponding "perform". For example, in the previous example, "bar" does not
 handle the effect "F". Hence, we will get an "Effect.Unhandled F" exception
 when we run "bar".
 
-\begin{caml_example}{verbatim}
+\begin{caml_example}{verbatim}[error]
 try bar () with Effect.Unhandled F -> "Saw Effect.Unhandled exception"
 \end{caml_example}
 
@@ -618,7 +618,7 @@ must be resumed either with a "continue" or "discontinue" exactly once}}.
 Attempting to use a continuation more than once raises a
 "Continuation_already_resumed" exception. For example:
 
-\begin{caml_example}{verbatim}
+\begin{caml_example}{verbatim}[error]
 try_with perform (Xchg 0)
 { effc = fun (type a) (eff : a t) ->
     match eff with
@@ -685,7 +685,7 @@ implement a shallow handler that enforces a particular sequence of effects (a
 protocol) on a computation. For this example, let us consider that the
 computation may perform the following effects:
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 type _ Effect.t += Send : int -> unit Effect.t
                  | Recv : int Effect.t
 \end{caml_example*}
@@ -698,7 +698,7 @@ not "[Recv]", "[Send;Send]", "[Send;Recv;Recv]", etc. The key observation here
 is that the set of effects handled evolves over time. We can enforce this
 protocol quite naturally using shallow handlers as shown below:
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 open Effect.Shallow
 
 let run (comp: unit -> unit) : unit =
@@ -753,7 +753,7 @@ be handled by an outer handler.
 We can see that the "run" function will permit a computation that follows the
 protocol:
 
-\begin{caml_example}{verbatim}
+\begin{caml_example}{verbatim}[error]
 run (fun () ->
   printf "Send 42\n";
   perform (Send 42);
@@ -765,7 +765,7 @@ run (fun () ->
 
 and aborts those that do not:
 
-\begin{caml_example}{verbatim}
+\begin{caml_example}{verbatim}[error]
 run (fun () ->
   Printf.printf "Send 0\n";
   perform (Send 0);
diff --git a/manual/src/tutorials/memorymodel.etex b/manual/src/tutorials/memorymodel.etex
index a04c7bb29d..44d19fd4e1 100644
--- a/manual/src/tutorials/memorymodel.etex
+++ b/manual/src/tutorials/memorymodel.etex
@@ -25,7 +25,7 @@ can be explained through some interleaving of the operations from different
 domains in the program. For example, consider the following program with two
 domains "d1" and "d2" executing in parallel:
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 let d1 a b =
   let r1 = !a * 2 in
   let r2 = !b in
@@ -52,7 +52,7 @@ of the operations from different domains.
 
 Let us now assume that "a" and "b" are aliases of each other.
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 let d1 a b =
   let r1 = !a * 2 in
   let r2 = !b in
@@ -83,7 +83,7 @@ Surprisingly, this assertion may fail in OCaml due to compiler optimisations.
 The OCaml compiler observes the common sub-expression "!a * 2" in "d1" and
 optimises the program to:
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 let d1 a b =
   let r1 = !a * 2 in
   let r2 = !b in
@@ -138,7 +138,7 @@ location respect sequential consistency, the guarantees on programs that
 operate on different memory locations are much weaker. Consider the following
 program:
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 let a = ref 0
 and b = ref 0
 
@@ -660,7 +660,7 @@ B: 5,  [a -> t2; b -> t4; c -> t6]
 
 Let us revisit an example from earlier (section \ref{s:why_relaxed_memory}).
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 let a = ref 0
 and b = ref 0
 
diff --git a/manual/src/tutorials/parallelism.etex b/manual/src/tutorials/parallelism.etex
index a1db688727..cf04170107 100644
--- a/manual/src/tutorials/parallelism.etex
+++ b/manual/src/tutorials/parallelism.etex
@@ -27,7 +27,7 @@ Domains are the units of parallelism in OCaml. The module \stdmoduleref{Domain}
 provides the primitives to create and manage domains. New domains can be
 spawned using the "spawn" function.
 
-\begin{caml_example}{verbatim}
+\begin{caml_example}{verbatim}[error]
 Domain.spawn (fun _ -> print_endline "I ran in parallel")
 \end{caml_example}
 
@@ -90,7 +90,7 @@ Spawned domains can be joined using the "join" function to get their results.
 The "join" function waits for target domain to terminate. The following program
 computes the nth Fibonacci number twice in parallel.
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 (* fib_twice.ml *)
 let n = int_of_string Sys.argv.(1)
 
@@ -132,7 +132,7 @@ Let us attempt to parallelise the Fibonacci function. The two recursive calls
 may be executed in parallel. However, naively parallelising the recursive calls
 by spawning domains for each one will not work as it spawns too many domains.
 
-\begin{caml_example}{verbatim}
+\begin{caml_example}{verbatim}[error]
 (* fib_par1.ml *)
 let n = try int_of_string Sys.argv.(1) with _ -> 1
 
@@ -468,7 +468,7 @@ rest of this chapter, we shall call the threads created by the threads library
 as \emph{systhreads}. The following program implements a concurrent stack using
 mutex and condition variables.
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 module Blocking_stack : sig
   type 'a t
   val make : unit -> 'a t
@@ -615,7 +615,7 @@ often compiled to atomic read-modify-write primitives that the hardware
 provides. As an example, the following program increments a non-atomic counter
 and an atomic counter in parallel.
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 (* incr.ml *)
 let twice_in_parallel f =
   let d1 = Domain.spawn f in
@@ -672,7 +672,7 @@ The atomic variables can be used for low-level synchronisation between the
 domains. The following example uses an atomic variable to exchange a message
 between two domains.
 
-\begin{caml_example}{verbatim}
+\begin{caml_example}{verbatim}[error]
 let r = Atomic.make None
 
 let sender () = Atomic.set r (Some "Hello")
@@ -699,7 +699,7 @@ race since "r" is an atomic reference.
 The Atomic module is used to implement non-blocking, lock-free data structures.
 The following program implements a lock-free stack.
 
-\begin{caml_example*}{verbatim}
+\begin{caml_example*}{verbatim}[error]
 module Lockfree_stack : sig
   type 'a t
   val make : unit -> 'a t
diff --git a/otherlibs/dynlink/byte/dynlink.ml b/otherlibs/dynlink/byte/dynlink.ml
index 70ead03193..e0f77d8579 100644
--- a/otherlibs/dynlink/byte/dynlink.ml
+++ b/otherlibs/dynlink/byte/dynlink.ml
@@ -22,6 +22,9 @@ open! Dynlink_compilerlibs
 
 module DC = Dynlink_common
 module DT = Dynlink_types
+(* BACKPORT BEGIN *)
+module Mutex = DC.Mutex
+(* BACKPORT END *)
 
 module Bytecode = struct
   type filename = string
diff --git a/otherlibs/dynlink/dynlink_common.ml b/otherlibs/dynlink/dynlink_common.ml
index 6f4d8c0b4b..1fd2f98e86 100644
--- a/otherlibs/dynlink/dynlink_common.ml
+++ b/otherlibs/dynlink/dynlink_common.ml
@@ -31,6 +31,15 @@ module String = struct
   end
 end
 
+(* BACKPORT BEGIN *)
+module Mutex = struct
+  type t = unit
+  let create () = ()
+  let lock () = ()
+  let unlock () = ()
+end
+(* BACKPORT END *)
+
 module Make (P : Dynlink_platform_intf.S) = struct
   module DT = Dynlink_types
   module UH = P.Unit_header
diff --git a/otherlibs/dynlink/dynlink_common.mli b/otherlibs/dynlink/dynlink_common.mli
index c6f92d05cd..beb712d3e7 100644
--- a/otherlibs/dynlink/dynlink_common.mli
+++ b/otherlibs/dynlink/dynlink_common.mli
@@ -33,3 +33,12 @@ module Make (_ : Dynlink_platform_intf.S) : sig
   val all_units : unit -> string list
   val allow_unsafe_modules : bool -> unit
 end
+
+(* BACKPORT BEGIN *)
+module Mutex : sig
+  type t = unit
+  val create : unit -> t
+  val lock : t -> unit
+  val unlock : t -> unit
+end
+(* BACKPORT END *)
diff --git a/otherlibs/dynlink/dynlink_platform_intf.ml b/otherlibs/dynlink/dynlink_platform_intf.ml
index b2075070d2..3a175c5424 100644
--- a/otherlibs/dynlink/dynlink_platform_intf.ml
+++ b/otherlibs/dynlink/dynlink_platform_intf.ml
@@ -61,7 +61,11 @@ module type S = sig
     -> handle * (Unit_header.t list)
 
   val run_shared_startup : handle -> unit
+(* BACKPORT BEGIN
   val run : Mutex.t -> handle -> unit_header:Unit_header.t -> priv:bool -> unit
+*)
+  val run : unit -> handle -> unit_header:Unit_header.t -> priv:bool -> unit
+(* BACKPORT END *)
 
   val unsafe_get_global_value : bytecode_or_asm_symbol:string -> Obj.t option
 
diff --git a/otherlibs/dynlink/native/dynlink.ml b/otherlibs/dynlink/native/dynlink.ml
index 7a46a07ee3..f6e6eaf014 100644
--- a/otherlibs/dynlink/native/dynlink.ml
+++ b/otherlibs/dynlink/native/dynlink.ml
@@ -37,8 +37,10 @@ module Native = struct
 
   external ndl_open : string -> bool -> handle * Cmxs_format.dynheader
     = "caml_natdynlink_open"
+(* BACKPORT
   external ndl_register : handle -> string array -> unit
     = "caml_natdynlink_register"
+*)
   external ndl_run : handle -> string -> unit = "caml_natdynlink_run"
   external ndl_getmap : unit -> global_map list = "caml_natdynlink_getmap"
   external ndl_globals_inited : unit -> int = "caml_natdynlink_globals_inited"
@@ -98,11 +100,13 @@ module Native = struct
     if header.dynu_magic <> Config.cmxs_magic_number then begin
       raise (DT.Error (Not_a_bytecode_file filename))
     end;
+(* BACKPORT
     let syms =
       "_shared_startup" ::
       List.concat_map Unit_header.defined_symbols header.dynu_units
     in
     ndl_register handle (Array.of_list syms);
+*)
     handle, header.dynu_units
 
   let unsafe_get_global_value ~bytecode_or_asm_symbol =
diff --git a/otherlibs/str/str.ml b/otherlibs/str/str.ml
index 2fb5de9ea6..1122960547 100644
--- a/otherlibs/str/str.ml
+++ b/otherlibs/str/str.ml
@@ -607,7 +607,18 @@ external re_search_forward: regexp -> string -> int -> int array
 external re_search_backward: regexp -> string -> int -> int array
      = "re_search_backward"
 
+(* BACKPORT BEGIN
 let last_search_result_key = Domain.DLS.new_key (fun () -> [||])
+*)
+let last_search_result_key = ref [||]
+
+module Domain = struct
+  module DLS = struct
+    let get = (!)
+    let set = (:=)
+  end
+end
+(* BACKPORT END *)
 
 let string_match re s pos =
   let res = re_string_match re s pos in
diff --git a/otherlibs/systhreads/.depend b/otherlibs/systhreads/.depend
index 11b76f90bb..661d3575de 100644
--- a/otherlibs/systhreads/.depend
+++ b/otherlibs/systhreads/.depend
@@ -1,8 +1,34 @@
+condition.cmo : \
+    mutex.cmi \
+    condition.cmi
+condition.cmx : \
+    mutex.cmx \
+    condition.cmi
+condition.cmi : \
+    mutex.cmi
 event.cmo : \
+    mutex.cmi \
+    condition.cmi \
     event.cmi
 event.cmx : \
+    mutex.cmx \
+    condition.cmx \
     event.cmi
 event.cmi :
+mutex.cmo : \
+    mutex.cmi
+mutex.cmx : \
+    mutex.cmi
+mutex.cmi :
+semaphore.cmo : \
+    mutex.cmi \
+    condition.cmi \
+    semaphore.cmi
+semaphore.cmx : \
+    mutex.cmx \
+    condition.cmx \
+    semaphore.cmi
+semaphore.cmi :
 thread.cmo : \
     thread.cmi
 thread.cmx : \
diff --git a/otherlibs/systhreads/Makefile b/otherlibs/systhreads/Makefile
index 51cffb0492..dc25a56475 100644
--- a/otherlibs/systhreads/Makefile
+++ b/otherlibs/systhreads/Makefile
@@ -45,12 +45,12 @@ LIBNAME=threads
 BYTECODE_C_OBJS=st_stubs.b.$(O)
 NATIVECODE_C_OBJS=st_stubs.n.$(O)
 
-THREADS_SOURCES = thread.ml event.ml
+THREADS_SOURCES = thread.ml mutex.ml condition.ml event.ml semaphore.ml
 
 THREADS_BCOBJS = $(THREADS_SOURCES:.ml=.cmo)
 THREADS_NCOBJS = $(THREADS_SOURCES:.ml=.cmx)
 
-MLIFILES=thread.mli event.mli
+MLIFILES=thread.mli mutex.mli condition.mli event.mli semaphore.mli
 
 CMIFILES=$(MLIFILES:.mli=.cmi)
 
diff --git a/otherlibs/systhreads/condition.ml b/otherlibs/systhreads/condition.ml
new file mode 100644
index 0000000000..9a014528ab
--- /dev/null
+++ b/otherlibs/systhreads/condition.ml
@@ -0,0 +1,20 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*   Xavier Leroy and Pascal Cuoq, projet Cristal, INRIA Rocquencourt     *)
+(*                                                                        *)
+(*   Copyright 1995 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+type t
+external create: unit -> t = "caml_condition_new"
+external wait: t -> Mutex.t -> unit = "caml_condition_wait"
+external signal: t -> unit = "caml_condition_signal"
+external broadcast: t -> unit = "caml_condition_broadcast"
diff --git a/otherlibs/systhreads/condition.mli b/otherlibs/systhreads/condition.mli
new file mode 100644
index 0000000000..36c71fc818
--- /dev/null
+++ b/otherlibs/systhreads/condition.mli
@@ -0,0 +1,53 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*          Xavier Leroy and Damien Doligez, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(** Condition variables to synchronize between threads.
+
+   Condition variables are used when one thread wants to wait until another
+   thread has finished doing something: the former thread 'waits' on the
+   condition variable, the latter thread 'signals' the condition when it
+   is done. Condition variables should always be protected by a mutex.
+   The typical use is (if [D] is a shared data structure, [m] its mutex,
+   and [c] is a condition variable):
+   {[
+     Mutex.lock m;
+     while (* some predicate P over D is not satisfied *) do
+       Condition.wait c m
+     done;
+     (* Modify D *)
+     if (* the predicate P over D is now satisfied *) then Condition.signal c;
+     Mutex.unlock m
+   ]}
+*)
+
+type t
+(** The type of condition variables. *)
+
+val create : unit -> t
+(** Return a new condition variable. *)
+
+val wait : t -> Mutex.t -> unit
+(** [wait c m] atomically unlocks the mutex [m] and suspends the
+   calling process on the condition variable [c]. The process will
+   restart after the condition variable [c] has been signalled.
+   The mutex [m] is locked again before [wait] returns. *)
+
+val signal : t -> unit
+(** [signal c] restarts one of the processes waiting on the
+   condition variable [c]. *)
+
+val broadcast : t -> unit
+(** [broadcast c] restarts all processes waiting on the
+   condition variable [c]. *)
diff --git a/otherlibs/systhreads/mutex.ml b/otherlibs/systhreads/mutex.ml
new file mode 100644
index 0000000000..836109e761
--- /dev/null
+++ b/otherlibs/systhreads/mutex.ml
@@ -0,0 +1,20 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*           Xavier Leroy and Pascal Cuoq, INRIA Rocquencourt             *)
+(*                                                                        *)
+(*   Copyright 1995 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+type t
+external create: unit -> t = "caml_mutex_new"
+external lock: t -> unit = "caml_mutex_lock"
+external try_lock: t -> bool = "caml_mutex_try_lock"
+external unlock: t -> unit = "caml_mutex_unlock"
diff --git a/otherlibs/systhreads/mutex.mli b/otherlibs/systhreads/mutex.mli
new file mode 100644
index 0000000000..70a67ce408
--- /dev/null
+++ b/otherlibs/systhreads/mutex.mli
@@ -0,0 +1,60 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*          Xavier Leroy and Damien Doligez, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(** Locks for mutual exclusion.
+
+   Mutexes (mutual-exclusion locks) are used to implement critical sections
+   and protect shared mutable data structures against concurrent accesses.
+   The typical use is (if [m] is the mutex associated with the data structure
+   [D]):
+   {[
+     Mutex.lock m;
+     (* Critical section that operates over D *);
+     Mutex.unlock m
+   ]}
+*)
+
+type t
+(** The type of mutexes. *)
+
+val create : unit -> t
+(** Return a new mutex. *)
+
+val lock : t -> unit
+(** Lock the given mutex. Only one thread can have the mutex locked
+   at any time. A thread that attempts to lock a mutex already locked
+   by another thread will suspend until the other thread unlocks
+   the mutex.
+
+   @raise Sys_error if the mutex is already locked by the thread calling
+   {!Mutex.lock}.
+
+   @before 4.12 {!Sys_error} was not raised for recursive locking
+   (platform-dependent behaviour) *)
+
+val try_lock : t -> bool
+(** Same as {!Mutex.lock}, but does not suspend the calling thread if
+   the mutex is already locked: just return [false] immediately
+   in that case. If the mutex is unlocked, lock it and
+   return [true]. *)
+
+val unlock : t -> unit
+(** Unlock the given mutex. Other threads suspended trying to lock
+   the mutex will restart.  The mutex must have been previously locked
+   by the thread that calls {!Mutex.unlock}.
+   @raise Sys_error if the mutex is unlocked or was locked by another thread.
+
+   @before 4.12 {!Sys_error} was not raised when unlocking an unlocked mutex
+   or when unlocking a mutex from a different thread. *)
diff --git a/otherlibs/systhreads/semaphore.ml b/otherlibs/systhreads/semaphore.ml
new file mode 100644
index 0000000000..e4fa4181a0
--- /dev/null
+++ b/otherlibs/systhreads/semaphore.ml
@@ -0,0 +1,86 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*          Xavier Leroy, Collège de France and INRIA Paris               *)
+(*                                                                        *)
+(*   Copyright 2020 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(** Semaphores *)
+
+type sem = {
+  mut: Mutex.t;                         (* protects [v] *)
+  mutable v: int;                       (* the current value *)
+  nonzero: Condition.t                  (* signaled when [v > 0] *)
+}
+
+module Counting = struct
+
+type t = sem
+
+let make v =
+  if v < 0 then invalid_arg "Semaphore.Counting.init: wrong initial value";
+  { mut = Mutex.create(); v; nonzero = Condition.create() }
+
+let release s =
+  Mutex.lock s.mut;
+  if s.v < max_int then begin
+    s.v <- s.v + 1;
+    Condition.signal s.nonzero;
+    Mutex.unlock s.mut
+  end else begin
+    Mutex.unlock s.mut;
+    raise (Sys_error "Semaphore.Counting.release: overflow")
+  end
+
+let acquire s =
+  Mutex.lock s.mut;
+  while s.v = 0 do Condition.wait s.nonzero s.mut done;
+  s.v <- s.v - 1;
+  Mutex.unlock s.mut
+
+let try_acquire s =
+  Mutex.lock s.mut;
+  let ret = if s.v = 0 then false else (s.v <- s.v - 1; true) in
+  Mutex.unlock s.mut;
+  ret
+
+let get_value s = s.v
+
+end
+
+module Binary = struct
+
+type t = sem
+
+let make b =
+  { mut = Mutex.create();
+    v = if b then 1 else 0;
+    nonzero = Condition.create() }
+
+let release s =
+  Mutex.lock s.mut;
+  s.v <- 1;
+  Condition.signal s.nonzero;
+  Mutex.unlock s.mut
+
+let acquire s =
+  Mutex.lock s.mut;
+  while s.v = 0 do Condition.wait s.nonzero s.mut done;
+  s.v <- 0;
+  Mutex.unlock s.mut
+
+let try_acquire s =
+  Mutex.lock s.mut;
+  let ret = if s.v = 0 then false else (s.v <- 0; true) in
+  Mutex.unlock s.mut;
+  ret
+
+end
diff --git a/otherlibs/systhreads/semaphore.mli b/otherlibs/systhreads/semaphore.mli
new file mode 100644
index 0000000000..3a62747829
--- /dev/null
+++ b/otherlibs/systhreads/semaphore.mli
@@ -0,0 +1,140 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*          Xavier Leroy, Collège de France and INRIA Paris               *)
+(*                                                                        *)
+(*   Copyright 2020 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(** Semaphores
+
+  A semaphore is a thread synchronization device that can be used to
+  control access to a shared resource.
+
+  Two flavors of semaphores are provided: counting semaphores and
+  binary semaphores.
+
+  @since 4.12 *)
+
+(** {2 Counting semaphores} *)
+
+(**
+  A counting semaphore is a counter that can be accessed concurrently
+  by several threads.  The typical use is to synchronize producers and
+  consumers of a resource by counting how many units of the resource
+  are available.
+
+  The two basic operations on semaphores are:
+- "release" (also called "V", "post", "up", and "signal"), which
+  increments the value of the counter.  This corresponds to producing
+  one more unit of the shared resource and making it available to others.
+- "acquire" (also called "P", "wait", "down", and "pend"), which
+  waits until the counter is greater than zero and decrements it.
+  This corresponds to consuming one unit of the shared resource.
+
+  @since 4.12 *)
+
+module Counting : sig
+
+type t
+(** The type of counting semaphores. *)
+
+val make : int -> t
+(** [make n] returns a new counting semaphore, with initial value [n].
+    The initial value [n] must be nonnegative.
+
+    @raise Invalid_argument if [n < 0]
+*)
+
+val release : t -> unit
+(** [release s] increments the value of semaphore [s].
+    If other threads are waiting on [s], one of them is restarted.
+    If the current value of [s] is equal to [max_int], the value of
+    the semaphore is unchanged and a [Sys_error] exception is raised
+    to signal overflow.
+
+    @raise Sys_error if the value of the semaphore would overflow [max_int]
+*)
+
+val acquire : t -> unit
+(** [acquire s] blocks the calling thread until the value of semaphore [s]
+    is not zero, then atomically decrements the value of [s] and returns.
+*)
+
+val try_acquire : t -> bool
+(** [try_acquire s] immediately returns [false] if the value of semaphore [s]
+    is zero.  Otherwise, the value of [s] is atomically decremented
+    and [try_acquire s] returns [true].
+*)
+
+val get_value : t -> int
+(** [get_value s] returns the current value of semaphore [s].
+    The current value can be modified at any time by concurrent
+    {!release} and {!acquire} operations.  Hence, the [get_value]
+    operation is racy, and its result should only be used for debugging
+    or informational messages.
+*)
+
+end
+
+(** {2 Binary semaphores} *)
+
+(** Binary semaphores are a variant of counting semaphores
+    where semaphores can only take two values, 0 and 1.
+
+    A binary semaphore can be used to control access to a single
+    shared resource, with value 1 meaning "resource is available" and
+    value 0 meaning "resource is unavailable".
+
+    The "release" operation of a binary semaphore sets its value to 1,
+    and "acquire" waits until the value is 1 and sets it to 0.
+
+    A binary semaphore can be used instead of a mutex (see module
+    {!Mutex}) when the mutex discipline (of unlocking the mutex from the
+    thread that locked it) is too restrictive.  The "acquire" operation
+    corresponds to locking the mutex, and the "release" operation to
+    unlocking it, but "release" can be performed in a thread different
+    than the one that performed the "acquire".  Likewise, it is safe
+    to release a binary semaphore that is already available.
+
+    @since 4.12
+*)
+
+module Binary : sig
+
+type t
+(** The type of binary semaphores. *)
+
+val make : bool -> t
+(** [make b] returns a new binary semaphore.
+    If [b] is [true], the initial value of the semaphore is 1, meaning
+    "available".  If [b] is [false], the initial value of the
+    semaphore is 0, meaning "unavailable".
+*)
+
+val release : t -> unit
+(** [release s] sets the value of semaphore [s] to 1, putting it in the
+    "available" state.  If other threads are waiting on [s], one of them is
+    restarted.
+*)
+
+val acquire : t -> unit
+(** [acquire s] blocks the calling thread until the semaphore [s]
+    has value 1 (is available), then atomically sets it to 0
+    and returns.
+*)
+
+val try_acquire : t -> bool
+(** [try_acquire s] immediately returns [false] if the semaphore [s]
+    has value 0.  If [s] has value 1, its value is atomically set to 0
+    and [try_acquire s] returns [true].
+*)
+
+end
diff --git a/otherlibs/systhreads/thread.ml b/otherlibs/systhreads/thread.ml
index 83cbb80ca8..0324c2c617 100644
--- a/otherlibs/systhreads/thread.ml
+++ b/otherlibs/systhreads/thread.ml
@@ -18,6 +18,10 @@
 type t
 
 external thread_initialize : unit -> unit = "caml_thread_initialize"
+(* BACKPORT
+external thread_initialize_domain : unit -> unit =
+            "caml_thread_initialize_domain"
+*)
 external thread_cleanup : unit -> unit = "caml_thread_cleanup"
 external thread_new : (unit -> unit) -> t = "caml_thread_new"
 external thread_uncaught_exception : exn -> unit =
@@ -27,6 +31,9 @@ external yield : unit -> unit = "caml_thread_yield"
 external self : unit -> t = "caml_thread_self" [@@noalloc]
 external id : t -> int = "caml_thread_id" [@@noalloc]
 external join : t -> unit = "caml_thread_join"
+(* BACKPORT BEGIN *)
+external exit_stub : unit -> unit = "caml_thread_exit"
+(* BACKPORT END *)
 
 (* For new, make sure the function passed to thread_new never
    raises an exception. *)
@@ -69,7 +76,17 @@ let create fn arg =
           flush stderr)
 
 let exit () =
+(* BACKPORT BEGIN
   raise Exit
+*)
+  ignore (Sys.opaque_identity (check_memprof_cb ()));
+  exit_stub ()
+
+(* Thread.kill is currently not implemented due to problems with
+   cleanup handlers on several platforms *)
+
+let kill th = invalid_arg "Thread.kill: not implemented"
+(* BACKPORT END *)
 
 (* Preemption *)
 
@@ -83,8 +100,11 @@ let preempt_signal =
   | _       -> Sys.sigvtalrm
 
 let () =
+  Sys.set_signal preempt_signal (Sys.Signal_handle preempt);
   thread_initialize ();
+(* BACKPORT
   Sys.set_signal preempt_signal (Sys.Signal_handle preempt);
+*)
   (* Callback in [caml_shutdown], when the last domain exits. *)
   Callback.register "Thread.at_shutdown" (fun () ->
     thread_cleanup();
@@ -99,6 +119,11 @@ let () =
 
 let delay = Unix.sleepf
 
+(* BACKPORT BEGIN *)
+let wait_read fd = ()
+let wait_write fd = ()
+(* BACKPORT END *)
+
 let wait_timed_read fd d =
   match Unix.select [fd] [] [] d with ([], _, _) -> false | (_, _, _) -> true
 let wait_timed_write fd d =
diff --git a/otherlibs/unix/channels_win32.c b/otherlibs/unix/channels_win32.c
index 0a1531f616..7f915c3541 100644
--- a/otherlibs/unix/channels_win32.c
+++ b/otherlibs/unix/channels_win32.c
@@ -60,6 +60,7 @@ static DWORD check_stream_semantics(value handle)
   }
 }
 
+#if 0 /* BACKPORT BEGIN */
 #define CRT_field_val(v) (((struct filedescr *) Data_custom_val(v))->crt_fd)
 
 int caml_win32_get_CRT_fd(value handle)
@@ -94,13 +95,30 @@ int caml_win32_CRT_fd_of_filedescr(value handle)
     }
   }
 }
+#endif
+
+int caml_win32_CRT_fd_of_filedescr(value handle)
+{
+  if (CRT_fd_val(handle) != NO_CRT_FD) {
+    return CRT_fd_val(handle);
+  } else {
+    int fd = _open_osfhandle((intptr_t) Handle_val(handle), O_BINARY);
+    if (fd == -1) caml_uerror("channel_of_descr", Nothing);
+    CRT_fd_val(handle) = fd;
+    return fd;
+  }
+}
+#define CRT_field_val CRT_fd_val
+/* BACKPORT END */
 
 CAMLprim value caml_unix_inchannel_of_filedescr(value handle)
 {
   CAMLparam1(handle);
   CAMLlocal1(vchan);
+#if 0 /* BACKPORT */
   int flags = 0;
   int fd;
+#endif
   struct channel * chan;
   DWORD err;
 
@@ -109,10 +127,20 @@ CAMLprim value caml_unix_inchannel_of_filedescr(value handle)
     caml_win32_maperr(err);
     caml_uerror("in_channel_of_descr", Nothing);
   }
+#if 0 /* BACKPORT BEGIN */
   fd = caml_win32_CRT_fd_of_filedescr(handle);
+#endif
+  chan = caml_open_descriptor_in(caml_win32_CRT_fd_of_filedescr(handle));
+  chan->flags |= CHANNEL_FLAG_MANAGED_BY_GC;
+                 /* as in caml_ml_open_descriptor_in() */
+/* BACKPORT END */
   if (Descr_kind_val(handle) == KIND_SOCKET)
+    chan->flags |= CHANNEL_FLAG_FROM_SOCKET;
+  vchan = caml_alloc_channel(chan);
+#if 0 /* BACKPORT */
     flags |= CHANNEL_FLAG_FROM_SOCKET;
   vchan = caml_ml_open_descriptor_in_with_flags(fd, flags);
+#endif
   CAMLreturn(vchan);
 }
 
@@ -121,7 +149,9 @@ CAMLprim value caml_unix_outchannel_of_filedescr(value handle)
   CAMLparam1(handle);
   CAMLlocal1(vchan);
   int fd;
+#if 0 /* BACKPORT */
   int flags = 0;
+#endif
   struct channel * chan;
   DWORD err;
 
@@ -130,10 +160,20 @@ CAMLprim value caml_unix_outchannel_of_filedescr(value handle)
     caml_win32_maperr(err);
     caml_uerror("out_channel_of_descr", Nothing);
   }
+#if 0 /* BACKPORT BEGIN */
   fd = caml_win32_CRT_fd_of_filedescr(handle);
+#endif
+  chan = caml_open_descriptor_out(caml_win32_CRT_fd_of_filedescr(handle));
+  chan->flags |= CHANNEL_FLAG_MANAGED_BY_GC;
+                 /* as in caml_ml_open_descriptor_out() */
+/* BACKPORT END */
   if (Descr_kind_val(handle) == KIND_SOCKET)
+    chan->flags |= CHANNEL_FLAG_FROM_SOCKET;
+  vchan = caml_alloc_channel(chan);
+#if 0 /* BACKPORT */
     flags |= CHANNEL_FLAG_FROM_SOCKET;
   vchan = caml_ml_open_descriptor_out_with_flags(fd, flags);
+#endif
   CAMLreturn(vchan);
 }
 
diff --git a/otherlibs/unix/close_win32.c b/otherlibs/unix/close_win32.c
index bd1f6e9acc..b605354c51 100644
--- a/otherlibs/unix/close_win32.c
+++ b/otherlibs/unix/close_win32.c
@@ -28,9 +28,14 @@ CAMLprim value caml_unix_close(value fd)
     /* If we have an fd then closing it also closes
      * the underlying handle. Also, closing only
      * the handle and not the fd leads to fd leaks. */
+#if 0 /* BACKPORT BEGIN */
     int crt_fd = caml_win32_get_CRT_fd(fd);
     if (crt_fd != NO_CRT_FD) {
       if (_close(crt_fd) != 0)
+#endif
+    if (CRT_fd_val(fd) != NO_CRT_FD) {
+      if (_close(CRT_fd_val(fd)) != 0)
+/* BACKPORT END */
          caml_uerror("close", Nothing);
     } else {
       if (! CloseHandle(Handle_val(fd))) {
diff --git a/otherlibs/unix/createprocess.c b/otherlibs/unix/createprocess.c
index 132944b37e..fca240c49c 100644
--- a/otherlibs/unix/createprocess.c
+++ b/otherlibs/unix/createprocess.c
@@ -99,6 +99,10 @@ static DWORD do_create_process_native(wchar_t * exefile, wchar_t * cmdline,
   return err;
 }
 
+/* BACKPORT BEGIN */
+#define caml_win32_multi_byte_to_wide_char win_multi_byte_to_wide_char
+/* BACKPORT END */
+
 value caml_unix_create_process_native(value cmd, value cmdline, value env,
                                  value fd1, value fd2, value fd3)
 {
diff --git a/otherlibs/unix/dup_win32.c b/otherlibs/unix/dup_win32.c
index d2e677a0bf..dd96b7f0b1 100644
--- a/otherlibs/unix/dup_win32.c
+++ b/otherlibs/unix/dup_win32.c
@@ -109,8 +109,12 @@ CAMLprim value caml_unix_dup2(value cloexec, value fd1, value fd2)
   }
 
   /* Reflect the dup2 on the CRT fds, if any */
+#if 0 /* BACKPORT BEGIN */
   if (caml_win32_get_CRT_fd(fd1) != NO_CRT_FD ||
       caml_win32_get_CRT_fd(fd2) != NO_CRT_FD)
+#endif
+  if (CRT_fd_val(fd1) != NO_CRT_FD || CRT_fd_val(fd2) != NO_CRT_FD)
+/* BACKPORT END */
     _dup2(caml_win32_CRT_fd_of_filedescr(fd1),
           caml_win32_CRT_fd_of_filedescr(fd2));
   CAMLreturn(Val_unit);
diff --git a/otherlibs/unix/fork.c b/otherlibs/unix/fork.c
index 653034ac4b..5bd650d14b 100644
--- a/otherlibs/unix/fork.c
+++ b/otherlibs/unix/fork.c
@@ -17,11 +17,16 @@
 
 #include <caml/mlvalues.h>
 #include <caml/debugger.h>
+#if 0 /* BACKPORT BEGIN */
 #include <caml/runtime_events.h>
+#endif
+#include <caml/eventlog.h>
+/* BACKPORT END */
 #include "unixsupport.h"
 #include <caml/domain.h>
 #include <caml/fail.h>
 
+#if 0 /* BACKPORT */
 /* Post-fork tasks to be carried out in the parent */
 void caml_atfork_parent(pid_t child_pid) {
   CAML_EV_LIFECYCLE(EV_FORK_PARENT, child_pid);
@@ -32,19 +37,29 @@ void caml_atfork_child(void) {
   caml_runtime_events_post_fork();
   CAML_EV_LIFECYCLE(EV_FORK_CHILD, 0);
 }
+#endif
 
 CAMLprim value caml_unix_fork(value unit)
 {
   int ret;
+#if 0 /* BACKPORT */
   if (caml_domain_is_multicore()) {
     caml_failwith
       ("Unix.fork may not be called while other domains were created");
   }
+#endif
 
-  ret = fork();
+/* BACKPORT BEGIN */
+  CAML_EV_FLUSH();
+/* BACKPORT END */
 
+  ret = fork();
+#if 0 /* BACKPORT */
+  if (ret == 0) caml_atfork_hook();
+#endif
   if (ret == -1) caml_uerror("fork", Nothing);
 
+#if 0 /* BACKPORT BEGIN */
   if (ret == 0) {
     caml_atfork_child();
     /* the following hook can be redefined in other places */
@@ -52,6 +67,12 @@ CAMLprim value caml_unix_fork(value unit)
   } else {
     caml_atfork_parent(ret);
   }
+#endif
+  CAML_EVENTLOG_DO({
+      if (ret == 0)
+        caml_eventlog_disable();
+  });
+/* BACKPORT END */
 
   if (caml_debugger_in_use)
     if ((caml_debugger_fork_mode && ret == 0) ||
diff --git a/otherlibs/unix/readlink_win32.c b/otherlibs/unix/readlink_win32.c
index d03f0ff08a..cb0d6d3bb2 100644
--- a/otherlibs/unix/readlink_win32.c
+++ b/otherlibs/unix/readlink_win32.c
@@ -25,6 +25,10 @@
 #include <winioctl.h>
 #include <caml/winsupport.h>
 
+/* BACKPORT BEGIN */
+#define caml_win32_wide_char_to_multi_byte win_wide_char_to_multi_byte
+/* BACKPORT END */
+
 CAMLprim value caml_unix_readlink(value opath)
 {
   CAMLparam1(opath);
diff --git a/otherlibs/unix/signals.c b/otherlibs/unix/signals.c
index b9cc32040e..7f83d8b537 100644
--- a/otherlibs/unix/signals.c
+++ b/otherlibs/unix/signals.c
@@ -25,6 +25,12 @@
 #include <caml/signals.h>
 #include "unixsupport.h"
 
+/* BACKPORT BEGIN */
+#ifndef NSIG
+#define NSIG 64
+#endif
+/* BACKPORT END */
+
 #ifdef POSIX_SIGNALS
 
 static void decode_sigset(value vset, sigset_t * set)
@@ -44,9 +50,15 @@ static value encode_sigset(sigset_t * set)
 
   for (i = 1; i < NSIG; i++)
     if (sigismember(set, i) > 0) {
+/* BACKPORT BEGIN */
+      value newcons = caml_alloc_small(2, 0);
+      Field(newcons, 0) = Val_int(caml_rev_convert_signal_number(i));
+      Field(newcons, 1) = res;
+#if 0 /* BACKPORT */
       value newcons = caml_alloc_2(Tag_cons,
         Val_int(caml_rev_convert_signal_number(i)),
         res);
+#endif
       res = newcons;
     }
   CAMLreturn(res);
@@ -63,7 +75,11 @@ CAMLprim value caml_unix_sigprocmask(value vaction, value vset)
   how = sigprocmask_cmd[Int_val(vaction)];
   decode_sigset(vset, &set);
   caml_enter_blocking_section();
+#if 0 /* BACKPORT BEGIN */
   retcode = sigprocmask(how, &set, &oldset);
+#endif
+  retcode = caml_sigmask_hook(how, &set, &oldset);
+/* BACKPORT END */
   caml_leave_blocking_section();
   /* Run any handlers for just-unmasked pending signals */
   caml_process_pending_actions();
@@ -74,9 +90,15 @@ CAMLprim value caml_unix_sigprocmask(value vaction, value vset)
 CAMLprim value caml_unix_sigpending(value unit)
 {
   sigset_t pending;
+/* BACKPORT BEGIN */
+  int i;
+/* BACKPORT END */
+#if 0 /* BACKPORT */
   int i, j;
   uintnat curr;
+#endif
   if (sigpending(&pending) == -1) caml_uerror("sigpending", Nothing);
+#if 0 /* BACKPORT */
   for (i = 0; i < NSIG_WORDS; i++) {
     curr = atomic_load(&caml_pending_signals[i]);
     if (curr == 0) continue;
@@ -85,6 +107,12 @@ CAMLprim value caml_unix_sigpending(value unit)
       sigaddset(&pending, i * BITS_PER_WORD + j + 1);
     }
   }
+#endif
+/* BACKPORT BEGIN */
+  for (i = 1; i < NSIG; i++)
+    if(caml_pending_signals[i])
+      sigaddset(&pending, i);
+/* BACKPORT END */
   return encode_sigset(&pending);
 }
 
diff --git a/otherlibs/unix/unixsupport.h b/otherlibs/unix/unixsupport.h
index 2d9f95d8a3..77054318ba 100644
--- a/otherlibs/unix/unixsupport.h
+++ b/otherlibs/unix/unixsupport.h
@@ -46,7 +46,11 @@ struct filedescr {
     SOCKET socket;
   } fd;                   /* Real windows handle */
   enum { KIND_HANDLE, KIND_SOCKET } kind;
+#if 0 /* BACKPORT BEGIN */
   _Atomic int crt_fd;     /* C runtime descriptor */
+#endif
+  int crt_fd;             /* C runtime descriptor */
+/* BACKPORT END */
   unsigned int flags_fd;  /* See FLAGS_FD_* */
 };
 
@@ -61,6 +65,9 @@ struct filedescr {
 #define Handle_val(v) (((struct filedescr *) Data_custom_val(v))->fd.handle)
 #define Socket_val(v) (((struct filedescr *) Data_custom_val(v))->fd.socket)
 #define Descr_kind_val(v) (((struct filedescr *) Data_custom_val(v))->kind)
+/* BACKPORT BEGIN */
+#define CRT_fd_val(v) (((struct filedescr *) Data_custom_val(v))->crt_fd)
+/* BACKPORT END */
 #define Flags_fd_val(v) (((struct filedescr *) Data_custom_val(v))->flags_fd)
 
 extern value caml_win32_alloc_handle(HANDLE);
@@ -80,7 +87,9 @@ extern int caml_win32_CRT_fd_of_filedescr(value handle);
 extern int caml_win32_get_CRT_fd(value handle);
 
 // Export this macro as an alias for the getter function, for compatibility
+#if 0 /* BACKPORT */
 #define CRT_fd_val caml_win32_get_CRT_fd
+#endif
 
 extern SOCKET caml_win32_socket(int domain, int type, int protocol,
                                 LPWSAPROTOCOL_INFO info,
@@ -170,4 +179,8 @@ extern void caml_unix_clear_cloexec(int fd, char * cmdname, value arg);
 #define EXECV_CAST
 #endif
 
+/* BACKPORT BEGIN */
+#define caml_process_pending_signals caml_process_pending_actions
+/* BACKPORT END */
+
 #endif /* CAML_UNIXSUPPORT_H */
diff --git a/otherlibs/unix/unixsupport_win32.c b/otherlibs/unix/unixsupport_win32.c
index f9e85a4586..a83368a381 100644
--- a/otherlibs/unix/unixsupport_win32.c
+++ b/otherlibs/unix/unixsupport_win32.c
@@ -55,7 +55,11 @@ value caml_win32_alloc_handle(HANDLE h)
     caml_alloc_custom(&handle_ops, sizeof(struct filedescr), 0, 1);
   Handle_val(res) = h;
   Descr_kind_val(res) = KIND_HANDLE;
+#if 0 /* BACKPORT BEGIN */
   ((struct filedescr *) Data_custom_val(res))->crt_fd = NO_CRT_FD;
+#endif
+  CRT_fd_val(res) = NO_CRT_FD;
+/* BACKPORT END */
   Flags_fd_val(res) = FLAGS_FD_IS_BLOCKING;
   return res;
 }
@@ -66,7 +70,11 @@ value caml_win32_alloc_socket(SOCKET s)
     caml_alloc_custom(&handle_ops, sizeof(struct filedescr), 0, 1);
   Socket_val(res) = s;
   Descr_kind_val(res) = KIND_SOCKET;
+#if 0 /* BACKPORT BEGIN */
   ((struct filedescr *) Data_custom_val(res))->crt_fd = NO_CRT_FD;
+#endif
+  CRT_fd_val(res) = NO_CRT_FD;
+/* BACKPORT END */
   Flags_fd_val(res) = FLAGS_FD_IS_BLOCKING;
   return res;
 }
diff --git a/stdlib/.depend b/stdlib/.depend
index ed9cd8f0ce..734424a438 100644
--- a/stdlib/.depend
+++ b/stdlib/.depend
@@ -188,14 +188,6 @@ stdlib__Complex.cmx : complex.ml \
     stdlib__Float.cmx \
     stdlib__Complex.cmi
 stdlib__Complex.cmi : complex.mli
-stdlib__Condition.cmo : condition.ml \
-    stdlib__Mutex.cmi \
-    stdlib__Condition.cmi
-stdlib__Condition.cmx : condition.ml \
-    stdlib__Mutex.cmx \
-    stdlib__Condition.cmi
-stdlib__Condition.cmi : condition.mli \
-    stdlib__Mutex.cmi
 stdlib__Digest.cmo : digest.ml \
     stdlib__String.cmi \
     stdlib__Char.cmi \
@@ -207,41 +199,6 @@ stdlib__Digest.cmx : digest.ml \
     stdlib__Bytes.cmx \
     stdlib__Digest.cmi
 stdlib__Digest.cmi : digest.mli
-stdlib__Domain.cmo : domain.ml \
-    stdlib__Sys.cmi \
-    stdlib.cmi \
-    stdlib__Obj.cmi \
-    stdlib__Mutex.cmi \
-    stdlib__List.cmi \
-    stdlib__Condition.cmi \
-    stdlib__Atomic.cmi \
-    stdlib__Array.cmi \
-    stdlib__Domain.cmi
-stdlib__Domain.cmx : domain.ml \
-    stdlib__Sys.cmx \
-    stdlib.cmx \
-    stdlib__Obj.cmx \
-    stdlib__Mutex.cmx \
-    stdlib__List.cmx \
-    stdlib__Condition.cmx \
-    stdlib__Atomic.cmx \
-    stdlib__Array.cmx \
-    stdlib__Domain.cmi
-stdlib__Domain.cmi : domain.mli
-stdlib__Effect.cmo : effect.ml \
-    stdlib__Printf.cmi \
-    stdlib__Printexc.cmi \
-    stdlib__Obj.cmi \
-    stdlib__Callback.cmi \
-    stdlib__Effect.cmi
-stdlib__Effect.cmx : effect.ml \
-    stdlib__Printf.cmx \
-    stdlib__Printexc.cmx \
-    stdlib__Obj.cmx \
-    stdlib__Callback.cmx \
-    stdlib__Effect.cmi
-stdlib__Effect.cmi : effect.mli \
-    stdlib__Printexc.cmi
 stdlib__Either.cmo : either.ml \
     stdlib__Either.cmi
 stdlib__Either.cmx : either.ml \
@@ -278,8 +235,8 @@ stdlib__Filename.cmo : filename.ml \
     stdlib__Random.cmi \
     stdlib__Printf.cmi \
     stdlib__List.cmi \
+    stdlib__Lazy.cmi \
     stdlib__Fun.cmi \
-    stdlib__Domain.cmi \
     stdlib__Buffer.cmi \
     stdlib__Filename.cmi
 stdlib__Filename.cmx : filename.ml \
@@ -288,8 +245,8 @@ stdlib__Filename.cmx : filename.ml \
     stdlib__Random.cmx \
     stdlib__Printf.cmx \
     stdlib__List.cmx \
+    stdlib__Lazy.cmx \
     stdlib__Fun.cmx \
-    stdlib__Domain.cmx \
     stdlib__Buffer.cmx \
     stdlib__Filename.cmi
 stdlib__Filename.cmi : filename.mli
@@ -316,8 +273,8 @@ stdlib__Format.cmo : format.ml \
     stdlib__Queue.cmi \
     stdlib__List.cmi \
     stdlib__Int.cmi \
+    stdlib__Fun.cmi \
     stdlib__Either.cmi \
-    stdlib__Domain.cmi \
     camlinternalFormatBasics.cmi \
     camlinternalFormat.cmi \
     stdlib__Bytes.cmi \
@@ -332,8 +289,8 @@ stdlib__Format.cmx : format.ml \
     stdlib__Queue.cmx \
     stdlib__List.cmx \
     stdlib__Int.cmx \
+    stdlib__Fun.cmx \
     stdlib__Either.cmx \
-    stdlib__Domain.cmx \
     camlinternalFormatBasics.cmx \
     camlinternalFormat.cmx \
     stdlib__Bytes.cmx \
@@ -344,7 +301,6 @@ stdlib__Format.cmi : format.mli \
     stdlib.cmi \
     stdlib__Seq.cmi \
     stdlib__Either.cmi \
-    stdlib__Domain.cmi \
     stdlib__Buffer.cmi
 stdlib__Fun.cmo : fun.ml \
     stdlib__Printexc.cmi \
@@ -375,8 +331,8 @@ stdlib__Hashtbl.cmo : hashtbl.ml \
     stdlib__Seq.cmi \
     stdlib__Random.cmi \
     stdlib__Obj.cmi \
+    stdlib__Lazy.cmi \
     stdlib__Int.cmi \
-    stdlib__Domain.cmi \
     stdlib__Atomic.cmi \
     stdlib__Array.cmi \
     stdlib__Hashtbl.cmi
@@ -386,8 +342,8 @@ stdlib__Hashtbl.cmx : hashtbl.ml \
     stdlib__Seq.cmx \
     stdlib__Random.cmx \
     stdlib__Obj.cmx \
+    stdlib__Lazy.cmx \
     stdlib__Int.cmx \
-    stdlib__Domain.cmx \
     stdlib__Atomic.cmx \
     stdlib__Array.cmx \
     stdlib__Hashtbl.cmi
@@ -507,11 +463,6 @@ stdlib__MoreLabels.cmi : moreLabels.mli \
     stdlib__Seq.cmi \
     stdlib__Map.cmi \
     stdlib__Hashtbl.cmi
-stdlib__Mutex.cmo : mutex.ml \
-    stdlib__Mutex.cmi
-stdlib__Mutex.cmx : mutex.ml \
-    stdlib__Mutex.cmi
-stdlib__Mutex.cmi : mutex.mli
 stdlib__Nativeint.cmo : nativeint.ml \
     stdlib__Sys.cmi \
     stdlib.cmi \
@@ -616,7 +567,6 @@ stdlib__Random.cmo : random.ml \
     stdlib__Nativeint.cmi \
     stdlib__Int64.cmi \
     stdlib__Int32.cmi \
-    stdlib__Domain.cmi \
     stdlib__Digest.cmi \
     stdlib__Bytes.cmi \
     stdlib__Bigarray.cmi \
@@ -628,7 +578,6 @@ stdlib__Random.cmx : random.ml \
     stdlib__Nativeint.cmx \
     stdlib__Int64.cmx \
     stdlib__Int32.cmx \
-    stdlib__Domain.cmx \
     stdlib__Digest.cmx \
     stdlib__Bytes.cmx \
     stdlib__Bigarray.cmx \
@@ -668,15 +617,6 @@ stdlib__Scanf.cmx : scanf.ml \
     stdlib__Scanf.cmi
 stdlib__Scanf.cmi : scanf.mli \
     stdlib.cmi
-stdlib__Semaphore.cmo : semaphore.ml \
-    stdlib__Mutex.cmi \
-    stdlib__Condition.cmi \
-    stdlib__Semaphore.cmi
-stdlib__Semaphore.cmx : semaphore.ml \
-    stdlib__Mutex.cmx \
-    stdlib__Condition.cmx \
-    stdlib__Semaphore.cmi
-stdlib__Semaphore.cmi : semaphore.mli
 stdlib__Seq.cmo : seq.ml \
     stdlib__Lazy.cmi \
     stdlib__Either.cmi \
diff --git a/stdlib/Makefile b/stdlib/Makefile
index ffd472eaef..04a7812d9c 100644
--- a/stdlib/Makefile
+++ b/stdlib/Makefile
@@ -247,7 +247,8 @@ GNUISH_SED = \
 .PHONY: depend
 depend:
 	$(V_OCAMLDEP){ \
-	  $(OCAMLDEP_CMD) $(filter-out stdlib.%,$(wildcard *.mli *.ml)); \
+	  $(OCAMLDEP_CMD) $(filter-out stdlib.%,std_exit.ml std_exit.mli \
+      $(STDLIB_MODULE_BASENAMES:=.mli) $(STDLIB_MODULE_BASENAMES:=.ml)); \
 	  $(OCAMLDEP_CMD) -pp "$(AWK) -f ./remove_module_aliases.awk" \
 	  stdlib.ml stdlib.mli; \
 	} | \
diff --git a/stdlib/StdlibModules b/stdlib/StdlibModules
index 963a25f4f1..4235aa89fa 100644
--- a/stdlib/StdlibModules
+++ b/stdlib/StdlibModules
@@ -67,10 +67,6 @@ STDLIB_MODULE_BASENAMES = \
   stack \
   queue \
   buffer \
-  mutex \
-  condition \
-  semaphore \
-  domain \
   camlinternalFormat \
   printf \
   arg \
@@ -98,8 +94,7 @@ STDLIB_MODULE_BASENAMES = \
   moreLabels \
   stdLabels \
   in_channel \
-  out_channel \
-  effect
+  out_channel
 
 STDLIB_PREFIXED_MODULES = \
   $(filter-out stdlib camlinternal%, $(STDLIB_MODULE_BASENAMES))
diff --git a/stdlib/atomic.ml b/stdlib/atomic.ml
index d5d6e99e1d..aa057e3985 100644
--- a/stdlib/atomic.ml
+++ b/stdlib/atomic.ml
@@ -12,6 +12,7 @@
 (*                                                                        *)
 (**************************************************************************)
 
+(* BACKPORT BEGIN
 type !'a t
 
 external make : 'a -> 'a t = "%makemutable"
@@ -19,8 +20,53 @@ external get : 'a t -> 'a = "%atomic_load"
 external exchange : 'a t -> 'a -> 'a = "%atomic_exchange"
 external compare_and_set : 'a t -> 'a -> 'a -> bool = "%atomic_cas"
 external fetch_and_add : int t -> int -> int = "%atomic_fetch_add"
+*)
+external ( == ) : 'a -> 'a -> bool = "%eq"
+external ( + ) : int -> int -> int = "%addint"
+(* BACKPORT END *)
 external ignore : 'a -> unit = "%ignore"
 
+(* BACKPORT BEGIN *)
+(* We are not reusing ('a ref) directly to make it easier to reason
+   about atomicity if we wish to: even in a sequential implementation,
+   signals and other asynchronous callbacks might break atomicity. *)
+type 'a t = {mutable v: 'a}
+
+let make v = {v}
+let get r = r.v
+let set r v = r.v <- v
+
+(* The following functions are set to never be inlined: Flambda is
+   allowed to move surrounding code inside the critical section,
+   including allocations. *)
+
+let[@inline never] exchange r v =
+  (* BEGIN ATOMIC *)
+  let cur = r.v in
+  r.v <- v;
+  (* END ATOMIC *)
+  cur
+
+let[@inline never] compare_and_set r seen v =
+  (* BEGIN ATOMIC *)
+  let cur = r.v in
+  if cur == seen then (
+    r.v <- v;
+    (* END ATOMIC *)
+    true
+  ) else
+    false
+
+let[@inline never] fetch_and_add r n =
+  (* BEGIN ATOMIC *)
+  let cur = r.v in
+  r.v <- (cur + n);
+  (* END ATOMIC *)
+  cur
+
+(* BACKPORT END *)
+(* BACKPORT
 let set r x = ignore (exchange r x)
+*)
 let incr r = ignore (fetch_and_add r 1)
 let decr r = ignore (fetch_and_add r (-1))
diff --git a/stdlib/camlinternalLazy.ml b/stdlib/camlinternalLazy.ml
index 6035541601..247bfcfb58 100644
--- a/stdlib/camlinternalLazy.ml
+++ b/stdlib/camlinternalLazy.ml
@@ -13,12 +13,15 @@
 (*                                                                        *)
 (**************************************************************************)
 
+(* BACKPORT - REVERTED to 4.14 STATE *)
+
 (* Internals of forcing lazy values. *)
 
 type 'a t = 'a lazy_t
 
 exception Undefined
 
+(*
 (* [update_to_forcing blk] tries to update a [blk] with [lazy_tag] to
    [forcing_tag] using compare-and-swap (CAS), taking care to handle concurrent
    marking of the header word by a concurrent GC thread. Returns [0] if the
@@ -103,3 +106,56 @@ let force_gen ~only_val (lzv : 'arg lazy_t) =
   else if t = Obj.forcing_tag then raise Undefined
   else if t <> Obj.lazy_tag then (Obj.obj x : 'arg)
   else force_gen_lazy_block ~only_val lzv
+*)
+let raise_undefined = Obj.repr (fun () -> raise Undefined)
+
+external make_forward : Obj.t -> Obj.t -> unit = "caml_obj_make_forward"
+
+(* Assume [blk] is a block with tag lazy *)
+let force_lazy_block (blk : 'arg lazy_t) =
+  let closure = (Obj.obj (Obj.field (Obj.repr blk) 0) : unit -> 'arg) in
+  Obj.set_field (Obj.repr blk) 0 raise_undefined;
+  try
+    let result = closure () in
+    make_forward (Obj.repr blk) (Obj.repr result);
+    result
+  with e ->
+    Obj.set_field (Obj.repr blk) 0 (Obj.repr (fun () -> raise e));
+    raise e
+
+
+(* Assume [blk] is a block with tag lazy *)
+let force_val_lazy_block (blk : 'arg lazy_t) =
+  let closure = (Obj.obj (Obj.field (Obj.repr blk) 0) : unit -> 'arg) in
+  Obj.set_field (Obj.repr blk) 0 raise_undefined;
+  let result = closure () in
+  make_forward (Obj.repr blk) (Obj.repr result);
+  result
+
+
+(* [force] is not used, since [Lazy.force] is declared as a primitive
+   whose code inlines the tag tests of its argument, except when afl
+   instrumentation is turned on. *)
+
+let force (lzv : 'arg lazy_t) =
+  (* Using [Sys.opaque_identity] prevents two potential problems:
+     - If the value is known to have Forward_tag, then its tag could have
+       changed during GC, so that information must be forgotten (see GPR#713
+       and issue #7301)
+     - If the value is known to be immutable, then if the compiler
+       cannot prove that the last branch is not taken it will issue a
+       warning 59 (modification of an immutable value) *)
+  let lzv = Sys.opaque_identity lzv in
+  let x = Obj.repr lzv in
+  let t = Obj.tag x in
+  if t = Obj.forward_tag then (Obj.obj (Obj.field x 0) : 'arg) else
+  if t <> Obj.lazy_tag then (Obj.obj x : 'arg)
+  else force_lazy_block lzv
+
+
+let force_val (lzv : 'arg lazy_t) =
+  let x = Obj.repr lzv in
+  let t = Obj.tag x in
+  if t = Obj.forward_tag then (Obj.obj (Obj.field x 0) : 'arg) else
+  if t <> Obj.lazy_tag then (Obj.obj x : 'arg)
+  else force_val_lazy_block lzv
diff --git a/stdlib/camlinternalLazy.mli b/stdlib/camlinternalLazy.mli
index ac8b7a8bee..2fd6aa2bf4 100644
--- a/stdlib/camlinternalLazy.mli
+++ b/stdlib/camlinternalLazy.mli
@@ -23,4 +23,13 @@ exception Undefined
 
 val force_lazy_block : 'a lazy_t -> 'a
 
+(* BACKPORT BEGIN *)
+val force_val_lazy_block : 'a lazy_t -> 'a
+
+val force : 'a lazy_t -> 'a
+val force_val : 'a lazy_t -> 'a
+(* BACKPORT END *)
+
+(* BACKPORT
 val force_gen : only_val:bool -> 'a lazy_t -> 'a
+*)
diff --git a/stdlib/filename.ml b/stdlib/filename.ml
index a2fafafc9d..7c72614ce6 100644
--- a/stdlib/filename.ml
+++ b/stdlib/filename.ml
@@ -326,14 +326,34 @@ let remove_extension name =
 external open_desc: string -> open_flag list -> int -> int = "caml_sys_open"
 external close_desc: int -> unit = "caml_sys_close"
 
+(* BACKPORT BEGIN
 let prng_key =
   Domain.DLS.new_key Random.State.make_self_init
+*)
+let prng_key = lazy(Random.State.make_self_init ())
+(* BACKPORT END *)
 
 let temp_file_name temp_dir prefix suffix =
+(* BACKPORT BEGIN
   let random_state = Domain.DLS.get prng_key in
+*)
+  let random_state = Lazy.force prng_key in
+(* BACKPORT END *)
   let rnd = (Random.State.bits random_state) land 0xFFFFFF in
   concat temp_dir (Printf.sprintf "%s%06x%s" prefix rnd suffix)
 
+(* BACKPORT BEGIN *)
+module Domain = struct
+  module DLS = struct
+    let new_key ~split_from_parent:_ f =
+      ref (f ())
+
+    let get = (!)
+    let set = (:=)
+  end
+end
+(* BACKPORT END *)
+
 let current_temp_dir_name =
   Domain.DLS.new_key ~split_from_parent:Fun.id (fun () -> temp_dir_name)
 
diff --git a/stdlib/format.ml b/stdlib/format.ml
index 669494be53..8b92d36cb9 100644
--- a/stdlib/format.ml
+++ b/stdlib/format.ml
@@ -1020,6 +1020,7 @@ and err_formatter = formatter_of_out_channel Stdlib.stderr
 and str_formatter = formatter_of_buffer stdbuf
 
 (* Initialise domain local state *)
+(* BACKPORT BEGIN
 module DLS = Domain.DLS
 
 let stdbuf_key = DLS.new_key pp_make_buffer
@@ -1066,6 +1067,17 @@ let err_formatter_key = DLS.new_key (fun () ->
   Domain.at_exit (pp_print_flush ppf);
   ppf)
 let _ = DLS.set err_formatter_key err_formatter
+*)
+
+let std_formatter_key = std_formatter
+let err_formatter_key = err_formatter
+let str_formatter_key = str_formatter
+let stdbuf_key = stdbuf
+
+module DLS = struct
+  let get = Fun.id
+end
+(* BACKPORT END *)
 
 let get_std_formatter () = DLS.get std_formatter_key
 let get_err_formatter () = DLS.get err_formatter_key
@@ -1088,6 +1100,7 @@ let flush_str_formatter () =
   let str_formatter = DLS.get str_formatter_key in
   flush_buffer_formatter stdbuf str_formatter
 
+(* BACKPORT
 let make_synchronized_formatter output flush =
   DLS.new_key (fun () ->
     let buf = Buffer.create pp_buffer_size in
@@ -1101,6 +1114,7 @@ let make_synchronized_formatter output flush =
 
 let synchronized_formatter_of_out_channel oc =
   make_synchronized_formatter (output_substring oc) (fun () -> flush oc)
+*)
 
 (*
   Symbolic pretty-printing
@@ -1471,6 +1485,7 @@ let flush_standard_formatters () =
 
 let () = at_exit flush_standard_formatters
 
+(* BACKPORT
 let () = Domain.before_first_spawn (fun () ->
   flush_standard_formatters ();
   let fs = pp_get_formatter_out_functions std_formatter () in
@@ -1483,3 +1498,4 @@ let () = Domain.before_first_spawn (fun () ->
     {fs with out_string = buffered_out_string err_buf_key;
              out_flush = buffered_out_flush Stdlib.stderr err_buf_key};
 )
+*)
diff --git a/stdlib/format.mli b/stdlib/format.mli
index ef8093bb1b..7be04ac538 100644
--- a/stdlib/format.mli
+++ b/stdlib/format.mli
@@ -963,6 +963,7 @@ val formatter_of_out_channel : out_channel -> formatter
     to the corresponding output channel [oc].
 *)
 
+(* BACKPORT
 val synchronized_formatter_of_out_channel :
   out_channel -> formatter Domain.DLS.key
 [@@alert unstable][@@alert "-unstable"]
@@ -974,7 +975,7 @@ val synchronized_formatter_of_out_channel :
     domains will be interleaved with each other at points where the formatter
     is flushed, such as with {!print_flush}.
 *)
-
+*)
 
 val std_formatter : formatter
 (** The initial domain's standard formatter to write to standard output.
@@ -1046,6 +1047,7 @@ val make_formatter :
   returns a formatter to the {!Stdlib.out_channel} [oc].
 *)
 
+(* BACKPORT
 val make_synchronized_formatter :
   (string -> int -> int -> unit) -> (unit -> unit) -> formatter Domain.DLS.key
 [@@alert unstable][@@alert "-unstable"]
@@ -1058,6 +1060,7 @@ val make_synchronized_formatter :
     is flushed, such as with {!print_flush}.
     @since 5.0
 *)
+*)
 
 val formatter_of_out_functions :
   formatter_out_functions -> formatter
diff --git a/stdlib/gc.ml b/stdlib/gc.ml
index 832cfedb4d..84611ad812 100644
--- a/stdlib/gc.ml
+++ b/stdlib/gc.ml
@@ -61,9 +61,15 @@ external major : unit -> unit = "caml_gc_major"
 external full_major : unit -> unit = "caml_gc_full_major"
 external compact : unit -> unit = "caml_gc_compaction"
 external get_minor_free : unit -> int = "caml_get_minor_free"
+(* BACKPORT BEGIN *)
+external eventlog_pause : unit -> unit = "caml_eventlog_pause"
+external eventlog_resume : unit -> unit = "caml_eventlog_resume"
+(* BACKPORT END *)
 
+(* BACKPORT
 let eventlog_pause () = ()
 let eventlog_resume () = ()
+*)
 
 open Printf
 
diff --git a/stdlib/hashtbl.ml b/stdlib/hashtbl.ml
index b579a6991f..f800ca79dc 100644
--- a/stdlib/hashtbl.ml
+++ b/stdlib/hashtbl.ml
@@ -57,7 +57,11 @@ let randomized = Atomic.make randomized_default
 let randomize () = Atomic.set randomized true
 let is_randomized () = Atomic.get randomized
 
+(* BACKPORT BEGIN
 let prng_key = Domain.DLS.new_key Random.State.make_self_init
+*)
+let prng = lazy (Random.State.make_self_init())
+(* BACKPORT END *)
 
 (* Functions which appear before the functorial interface must either be
    independent of the hash function or take it as a parameter (see #2202 and
@@ -73,7 +77,11 @@ let rec power_2_above x n =
 let create ?(random = Atomic.get randomized) initial_size =
   let s = power_2_above 16 initial_size in
   let seed =
+(* BACKPORT BEGIN
     if random then Random.State.bits (Domain.DLS.get prng_key) else 0
+*)
+    if random then Random.State.bits (Lazy.force prng) else 0
+(* BACKPORT END *)
   in
   { initial_size = s; size = 0; seed = seed; data = Array.make s Empty }
 
@@ -621,7 +629,11 @@ let of_seq i =
 let rebuild ?(random = Atomic.get randomized) h =
   let s = power_2_above 16 (Array.length h.data) in
   let seed =
+(* BACKPORT BEGIN
     if random then Random.State.bits (Domain.DLS.get prng_key)
+*)
+    if random then Random.State.bits (Lazy.force prng)
+(* BACKPORT END *)
     else if Obj.size (Obj.repr h) >= 4 then h.seed
     else 0 in
   let h' = {
diff --git a/stdlib/lazy.ml b/stdlib/lazy.ml
index ab29d404c9..8534cb3222 100644
--- a/stdlib/lazy.ml
+++ b/stdlib/lazy.ml
@@ -53,7 +53,11 @@ exception Undefined = CamlinternalLazy.Undefined
 external make_forward : 'a -> 'a lazy_t = "caml_lazy_make_forward"
 external force : 'a t -> 'a = "%lazy_force"
 
+(* BACKPORT BEGIN
 let force_val l = CamlinternalLazy.force_gen ~only_val:true l
+*)
+let force_val = CamlinternalLazy.force_val
+(* BACKPORT END *)
 
 let from_fun (f : unit -> 'arg) =
   let x = Obj.new_block Obj.lazy_tag 1 in
diff --git a/stdlib/random.ml b/stdlib/random.ml
index ff3b90480f..4a5f7f8032 100644
--- a/stdlib/random.ml
+++ b/stdlib/random.ml
@@ -217,6 +217,7 @@ let mk_default () =
            (-8591268803865043407L)
            6388613595849772044L
 
+(* BACKPORT BEGIN
 let random_key =
   Domain.DLS.new_key ~split_from_parent:State.split mk_default
 
@@ -233,14 +234,39 @@ let bits64 () = State.bits64 (Domain.DLS.get random_key)
 let nativebits () = State.nativebits (Domain.DLS.get random_key)
 
 let full_init seed = State.reinit (Domain.DLS.get random_key) seed
+*)
+let default = mk_default ()
+let bits () = State.bits default
+let int bound = State.int default bound
+let full_int bound = State.full_int default bound
+let int32 bound = State.int32 default bound
+let nativeint bound = State.nativeint default bound
+let int64 bound = State.int64 default bound
+let float scale = State.float default scale
+let bool () = State.bool default
+let bits32 () = State.bits32 default
+let bits64 () = State.bits64 default
+let nativebits () = State.nativebits default
+
+let full_init seed = State.reinit default seed
 let init seed = full_init [| seed |]
+(* BACKPORT END *)
 let self_init () = full_init (random_seed())
 
 (* Splitting *)
 
+(* BACKPORT BEGIN
 let split () = State.split (Domain.DLS.get random_key)
+*)
+let split () = State.split default
+(* BACKPORT END *)
 
 (* Manipulating the current state. *)
 
+(* BACKPORT BEGIN
 let get_state () = State.copy (Domain.DLS.get random_key)
 let set_state s = State.assign (Domain.DLS.get random_key) s
+*)
+let get_state () = State.copy default
+let set_state s = State.assign default s
+(* BACKPORT END *)
diff --git a/stdlib/stdlib.ml b/stdlib/stdlib.ml
index e24e5a2820..7fcc68dd56 100644
--- a/stdlib/stdlib.ml
+++ b/stdlib/stdlib.ml
@@ -550,11 +550,27 @@ let ( ^^ ) (Format (fmt1, str1)) (Format (fmt2, str2)) =
 external sys_exit : int -> 'a = "caml_sys_exit"
 
 (* for at_exit *)
+(* BACKPORT BEGIN
 type 'a atomic_t
 external atomic_make : 'a -> 'a atomic_t = "%makemutable"
 external atomic_get : 'a atomic_t -> 'a = "%atomic_load"
 external atomic_compare_and_set : 'a atomic_t -> 'a -> 'a -> bool
   = "%atomic_cas"
+*)
+type 'a t = {mutable v: 'a}
+
+let atomic_make v = {v}
+let atomic_get r = r.v
+let[@inline never] atomic_compare_and_set r seen v =
+  (* BEGIN ATOMIC *)
+  let cur = r.v in
+  if cur == seen then (
+    r.v <- v;
+    (* END ATOMIC *)
+    true
+  ) else
+    false
+(* BACKPORT END *)
 
 let exit_function = atomic_make flush_all
 
@@ -581,6 +597,13 @@ let exit retcode =
 
 let _ = register_named_value "Pervasives.do_at_exit" do_at_exit
 
+(* BACKPORT BEGIN *)
+external major : unit -> unit = "caml_gc_major"
+external naked_pointers_checked : unit -> bool
+  = "caml_sys_const_naked_pointers_checked"
+let () = if naked_pointers_checked () then at_exit major
+(* BACKPORT END *)
+
 (*MODULE_ALIASES*)
 module Arg            = Arg
 module Array          = Array
@@ -594,10 +617,14 @@ module BytesLabels    = BytesLabels
 module Callback       = Callback
 module Char           = Char
 module Complex        = Complex
+(* BACKPORT
 module Condition      = Condition
+*)
 module Digest         = Digest
+(* BACKPORT
 module Domain         = Domain
 module Effect         = Effect
+*)
 module Either         = Either
 module Ephemeron      = Ephemeron
 module Filename       = Filename
@@ -617,7 +644,9 @@ module ListLabels     = ListLabels
 module Map            = Map
 module Marshal        = Marshal
 module MoreLabels     = MoreLabels
+(* BACKPORT
 module Mutex          = Mutex
+*)
 module Nativeint      = Nativeint
 module Obj            = Obj
 module Oo             = Oo
@@ -630,7 +659,9 @@ module Queue          = Queue
 module Random         = Random
 module Result         = Result
 module Scanf          = Scanf
+(* BACKPORT
 module Semaphore      = Semaphore
+*)
 module Seq            = Seq
 module Set            = Set
 module Stack          = Stack
diff --git a/stdlib/stdlib.mli b/stdlib/stdlib.mli
index 3d2ffe10e8..d590e714dd 100644
--- a/stdlib/stdlib.mli
+++ b/stdlib/stdlib.mli
@@ -1399,8 +1399,11 @@ module BytesLabels    = BytesLabels
 module Callback       = Callback
 module Char           = Char
 module Complex        = Complex
+(* BACKPORT
 module Condition      = Condition
+*)
 module Digest         = Digest
+(* BACKPORT
 module Domain         = Domain
 [@@alert "-unstable"]
 [@@alert unstable
@@ -1411,6 +1414,7 @@ module Effect         = Effect
 [@@alert unstable
     "The Effect interface may change in incompatible ways in the future."
 ]
+*)
 module Either         = Either
 module Ephemeron      = Ephemeron
 module Filename       = Filename
@@ -1430,7 +1434,9 @@ module ListLabels     = ListLabels
 module Map            = Map
 module Marshal        = Marshal
 module MoreLabels     = MoreLabels
+(* BACKPORT
 module Mutex          = Mutex
+*)
 module Nativeint      = Nativeint
 module Obj            = Obj
 module Oo             = Oo
@@ -1443,7 +1449,9 @@ module Queue          = Queue
 module Random         = Random
 module Result         = Result
 module Scanf          = Scanf
+(* BACKPORT
 module Semaphore      = Semaphore
+*)
 module Seq            = Seq
 module Set            = Set
 module Stack          = Stack
diff --git a/tools/check-symbol-names b/tools/check-symbol-names
index 0e1c829de4..8a88cfa1f3 100755
--- a/tools/check-symbol-names
+++ b/tools/check-symbol-names
@@ -32,6 +32,9 @@ $2 ~ /^_?wmain$/ { next }
 $2 ~ /^__x86.get_pc_thunk./ { next }
 # for mingw32
 $2 ~ /^.debug_/ { next }
+# windows unicode support
+$2 ~ /^_?win_multi_byte_to_wide_char$/ { next }
+$2 ~ /^_?win_wide_char_to_multi_byte$/ { next }
 # print the rest
 { found=1; print $1 " " $2 " " $3 }
 # fail if there were any results
diff --git a/tools/dumpobj.ml b/tools/dumpobj.ml
index 621cac264f..02d619d3de 100644
--- a/tools/dumpobj.ml
+++ b/tools/dumpobj.ml
@@ -394,10 +394,12 @@ let op_shapes = [
   opUGEINT, Nothing;
   opBULTINT, Uint_Disp;
   opBUGEINT, Uint_Disp;
+(* BACKPORT
   opPERFORM, Nothing;
   opRESUME, Nothing;
   opRESUMETERM, Uint;
   opREPERFORMTERM, Uint;
+*)
   opSTOP, Nothing;
   opEVENT, Nothing;
   opBREAK, Nothing;
diff --git a/tools/eventlog_metadata.in b/tools/eventlog_metadata.in
new file mode 100644
index 0000000000..00d51897e0
--- /dev/null
+++ b/tools/eventlog_metadata.in
@@ -0,0 +1,256 @@
+/* CTF 1.8 */
+
+typealias integer {size = 8;}  := uint8_t;
+typealias integer {size = 16;} := uint16_t;
+typealias integer {size = 32;} := uint32_t;
+typealias integer {size = 64;} := uint64_t;
+
+clock {
+    name = tracing_clock;
+    freq = 1000000000; /* tick = 1 ns */
+};
+
+typealias integer {
+    size = 64;
+    map = clock.tracing_clock.value;
+} := tracing_clock_int_t;
+
+
+/*
+
+Main trace description,
+major and minor refers to the CTF version being used.
+
+The packet header must contain at the very least
+a stream id and the CTF magic number.
+We only use one stream for now, and CTF magic number is 0xc1fc1fc1.
+
+We add an extra field ocaml_trace_version to enable simpler transition if we add
+or remove metrics in the future.
+
+*/
+trace {
+    major = 1;
+    minor = 8;
+    byte_order = @endianness@;
+    packet.header := struct {
+        uint32_t magic; /* required: must contain CTF magic number */
+        uint16_t ocaml_trace_version; /* our own trace format versioning */
+        uint16_t stream_id; /* required, although we have only one. */
+    };
+};
+
+/*
+
+We use only one stream at the moment.
+Each event payload must contain a header with a timestamp and a pid.
+The id field refers to the various event kinds defined further down this file.
+
+*/
+stream {
+    id = 0;
+    event.header := struct { /* for each event */
+        tracing_clock_int_t timestamp;
+        uint32_t id;
+    };
+    event.context := struct {
+        uint32_t tid;
+        uint8_t is_backup_thread;
+    };
+};
+
+/*
+
+These enumerations are mostly following the instrumented runtime datapoints.
+gc_phase aims to track the entry and exit time of each of the following events
+during collection.
+
+*/
+enum gc_phase : uint16_t {
+    "compact/main" = 0,
+    "compact/recompact",
+    "explicit/gc_set",
+    "explicit/gc_stat",
+    "explicit/gc_minor",
+    "explicit/gc_major",
+    "explicit/gc_full_major",
+    "explicit/gc_compact",
+    "major",
+    "major/roots",
+    "major/sweep",
+    "major/mark/roots",
+    "major/mark/main",
+    "major/mark/final",
+    "major/mark",
+    "major/mark/global_roots_slice",
+    "major_roots/global",
+    "major_roots/dynamic_global",
+    "major_roots/local",
+    "major_roots/C",
+    "major_roots/finalised",
+    "major_roots/memprof",
+    "major_roots/hook",
+    "major/check_and_compact",
+    "minor",
+    "minor/local_roots",
+    "minor/ref_tables",
+    "minor/copy",
+    "minor/update_weak",
+    "minor/finalized",
+    "explicit/gc_major_slice",
+    "domain/spawn",
+    "domain/send_interrupt",
+    "domain/idle_wait",
+    "finalise/update_first",
+    "finalise/update_last",
+    "interrupt/gc",
+    "interrupt/remote",
+    "major/ephe_mark",
+    "major/ephe_sweep",
+    "major/finish_marking",
+    "major_gc/cycle_domains",
+    "major_gc/phase_change",
+    "major_gc/stw",
+    "major/mark_opportunistic",
+    "major/slice",
+    "minor/clear",
+    "minor/finalizers/oldify",
+    "minor/global_roots",
+    "minor/leave_barrier",
+    "stw/api_barrier",
+    "stw/handler",
+    "stw/leader",
+    "minor/clear",
+    "minor_finalized",
+    "minor_finalizers_oldify",
+    "minor_global_roots",
+    "minor_leave_barrier",
+    "minor_local_roots",
+    "minor_ref_tables",
+    "minor_update_weak",
+    "stw_api_barrier",
+    "stw_handler",
+    "stw_leader",
+    "major_finish_sweeping",
+    "minor_finalizers_admin",
+    "domain/condition_wait",
+    "domain/resize_minor_heap_reservation"
+};
+
+/*
+
+Miscellaneous GC counters
+
+*/
+enum gc_counter : uint16_t {
+    "alloc_jump",
+    "force_minor/alloc_small",
+    "force_minor/make_vect",
+    "force_minor/set_minor_heap_size",
+    "force_minor/weak",
+    "force_minor/memprof",
+    "major/mark/slice/remain",
+    "major/mark/slice/fields",
+    "major/mark/slice/pointers",
+    "major/work/extra",
+    "major/work/mark",
+    "major/work/sweep",
+    "minor/promoted",
+    "request_major/alloc_shr",
+    "request_major/adjust_gc_speed",
+    "request_minor/realloc_ref_table",
+    "request_minor/realloc_ephe_ref_table",
+    "request_minor/realloc_custom_table"
+};
+
+/*
+
+Block allocation counters, per size buckets.
+
+*/
+enum alloc_bucket : uint8_t {
+  "alloc 01" = 1,
+  "alloc 02",
+  "alloc 03",
+  "alloc 04",
+  "alloc 05",
+  "alloc 06",
+  "alloc 07",
+  "alloc 08",
+  "alloc 09",
+  "alloc 10-19",
+  "alloc 20-29",
+  "alloc 30-39",
+  "alloc 40-49",
+  "alloc 50-59",
+  "alloc 60-69",
+  "alloc 70-79",
+  "alloc 80-89",
+  "alloc 90-99",
+  "alloc large"
+};
+
+/*
+
+Each event is comprised of the previously defined event.header
+and the fields defined here.
+
+An entry event marks the start of a gc phase.
+
+*/
+event {
+    id = 0;
+    name = "entry";
+    stream_id = 0;
+    fields := struct {
+        enum gc_phase phase;
+    };
+};
+
+/*
+
+exit counterparts to entry events
+
+*/
+event {
+    id = 1;
+    name = "exit";
+    stream_id = 0;
+    fields := struct {
+        enum gc_phase phase;
+    };
+};
+
+event {
+    id = 2;
+    name = "counter";
+    stream_id = 0;
+    fields := struct {
+        uint64_t count;
+        enum gc_counter kind;
+    };
+};
+
+event {
+    id = 3;
+    name = "alloc";
+    stream_id = 0;
+    fields := struct {
+        uint64_t count;
+        enum alloc_bucket bucket;
+    };
+};
+
+/*
+ Flush events are used to track the time spent by the tracing runtime flushing
+ data to disk, useful to remove flushing overhead for other runtime measurements
+ in the trace.
+*/
+event {
+     id = 4;
+     name = "flush";
+     stream_id = 0;
+     fields := struct {
+        tracing_clock_int_t duration;
+     };
+};
diff --git a/utils/config.common.ml b/utils/config.common.ml
index 32781cb2d9..aa5f8e7398 100644
--- a/utils/config.common.ml
+++ b/utils/config.common.ml
@@ -28,26 +28,26 @@ let standard_library =
   with Not_found ->
     standard_library_default
 
-let exec_magic_number = "Caml1999X032"
+let exec_magic_number = "Caml1999X031"
     (* exec_magic_number is duplicated in runtime/caml/exec.h *)
-and cmi_magic_number = "Caml1999I032"
-and cmo_magic_number = "Caml1999O032"
-and cma_magic_number = "Caml1999A032"
+and cmi_magic_number = "Caml1999I031"
+and cmo_magic_number = "Caml1999O031"
+and cma_magic_number = "Caml1999A031"
 and cmx_magic_number =
   if flambda then
-    "Caml1999y032"
+    "Caml1999y031"
   else
-    "Caml1999Y032"
+    "Caml1999Y031"
 and cmxa_magic_number =
   if flambda then
-    "Caml1999z032"
+    "Caml1999z031"
   else
-    "Caml1999Z032"
-and ast_impl_magic_number = "Caml1999M032"
-and ast_intf_magic_number = "Caml1999N032"
-and cmxs_magic_number = "Caml1999D032"
-and cmt_magic_number = "Caml1999T032"
-and linear_magic_number = "Caml1999L032"
+    "Caml1999Z031"
+and ast_impl_magic_number = "Caml1999M031"
+and ast_intf_magic_number = "Caml1999N031"
+and cmxs_magic_number = "Caml1999D031"
+and cmt_magic_number = "Caml1999T031"
+and linear_magic_number = "Caml1999L031"
 
 let safe_string = true
 let default_safe_string = true
@@ -62,8 +62,13 @@ let max_tag = 243
 let lazy_tag = 246
 
 let max_young_wosize = 256
+(* BACKPORT BEGIN
 let stack_threshold = 32 (* see runtime/caml/config.h *)
 let stack_safety_margin = 6
+*)
+let stack_threshold = 256 (* see runtime/caml/config.h *)
+let stack_safety_margin = 60
+(* BACKPORT END *)
 let default_executable_name =
   match Sys.os_type with
     "Unix" -> "a.out"
diff --git a/utils/domainstate.ml.c b/utils/domainstate.ml.c
index 6dbae1d07a..1eee2142ad 100644
--- a/utils/domainstate.ml.c
+++ b/utils/domainstate.ml.c
@@ -16,7 +16,9 @@
 
 #define CAML_CONFIG_H_NO_TYPEDEFS
 #include "config.h"
+/* BACKPORT
 let stack_ctx_words = Stack_ctx_words
+*/
 
 type t =
 #define DOMAIN_STATE(type, name) | Domain_##name
diff --git a/utils/domainstate.mli.c b/utils/domainstate.mli.c
index 66a4750d4c..c4a77ff976 100644
--- a/utils/domainstate.mli.c
+++ b/utils/domainstate.mli.c
@@ -14,7 +14,9 @@
 /*                                                                        */
 /**************************************************************************/
 
+/* BACKPORT
 val stack_ctx_words : int
+*/
 
 type t =
 #define DOMAIN_STATE(type, name) | Domain_##name
