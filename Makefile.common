#**************************************************************************
#*                                                                        *
#*                                 OCaml                                  *
#*                                                                        *
#*            Gabriel Scherer, projet Parsifal, INRIA Saclay              *
#*                                                                        *
#*   Copyright 2018 Institut National de Recherche en Informatique et     *
#*     en Automatique.                                                    *
#*                                                                        *
#*   All rights reserved.  This file is distributed under the terms of    *
#*   the GNU Lesser General Public License version 2.1, with the          *
#*   special exception on linking described in the file LICENSE.          *
#*                                                                        *
#**************************************************************************

# This makefile contains common definitions and rules shared by
# other Makefiles

# XXX Use the same equality check as in flexdll/Makefile on SHELL
#SHELL = cmd

include $(ROOTDIR)/Makefile.config_if_required

# $(SENSIBLE_MAKE) is empty on a default macOS installation and undefine on any
# other reasonable system!
SENSIBLE_MAKE := $(filter undefine, $(.FEATURES))

# GNU make's detection of the shell on Windows is complicated, and the end
# result is a little bit strange.
# If we're using Cygwin (or MSYS2's) make, and we execute the binary directly
# from a Windows shell (e.g. as C:\cygwin64\bin\make.exe) then SHELL will most
# likely end up at its default value /bin/sh. Cygwin will find this, since
# make is a Cygwin executable (so `/bin/sh` is translated). Things will fail
# fairly quickly, though, if Cygwin's build directly is not in PATH, since no
# login shell will have been invoked.
# The story is more complicated for a native Windows GNU make (and is covered
# in the SHELL section of the GNU make manual). In essence, GNU make tries very
# hard to find sh.exe in as compatible a way as possible to create "portable"
# (in the POSIX sense) Makefiles. One can force selection of cmd by setting
# SHELL=cmd in Makefile (the logic means that it will correctly find where
# cmd.exe is in PATH). If sh.exe is not found and SHELL has not been specified,
# the COMSPEC environment variable will be used for SHELL. Curiously (at least
# with GNU make 4.4.1), the value of SHELL does not reflect this decision and
# $(SHELL) appears just to be `sh.exe`. The detection of cmd is therefore done
# by feature-checking the shell.

# $(SHELL_IS_CMD) lazily expands to a GNU make boolean variable (i.e. the empty
# string when false, and non-empty otherwise). The detection is done by seeing
# if %VAR% notation expands environment variables.

define DETECT_WINDOWS_SHELL
export override OCAML_DETECT_CMD = detect
SHELL_IS_CMD := \
  $$(if $$(filter %OCAML_DETECT_CMD%, $$(shell echo %OCAML_DETECT_CMD%)),,true)
unexport OCAML_DETECT_CMD
ifneq "$(SENSIBLE_MAKE)" ""
undefine DETECT_WINDOWS_SHELL
endif
endef

SHELL_IS_CMD = $(eval $(call DETECT_WINDOWS_SHELL))$(SHELL_IS_CMD)

SHELL_COMMANDS =
define MAKE_SHELL_COMMAND
SHELL_COMMANDS := $(SHELL_COMMANDS) $(1)
$(1) = \
  $$(foreach command, $$(SHELL_COMMANDS), \
    $$(eval $$(command) = \
      $$(if $$(SHELL_IS_CMD), \
        $$$$(call $$(command)_CMD,$\
          $$$$(subst /,\,$$$$(strip $$$$(1))),$\
          $$$$(subst /,\,$$$$(strip $$$$(2))),$\
          $$$$(subst /,\,$$$$(strip $$$$(3))),$\
          $$$$(subst /,\,$$$$(strip $$$$(4)))),\
        $$$$(call $$(command)_SH,$\
          $$$$(strip $$$$(1)),$\
          $$$$(strip $$$$(2)),$\
          $$$$(strip $$$$(3)),$\
          $$$$(strip $$$$(4)))))) \
  $$(call $(1),$$(1),$$(2),$$(3),$$(4))
endef

MKDIR_SH = mkdir -p $(1)
CP_SH = cp $(1) $(2)
CAT_SH = cat $(1)
CAT_TO_SH = cat $(1) > $(2)
RM_F_SH = rm -f $(1)
RENAME_SH = mv $(1) $(2)
LN_IN_SH = cd $(1) && $(LN) $(2) $(3)

MKDIR_CMD = md $(1)
CP_CMD = $(if $(filter 1, $(words $(1))), copy $(1) $(2) > nul, for %%f in ($(1)) do @copy %%f $(2) > nul)
CAT_CMD = type $(1)
CAT_TO_CMD = copy /b $(firstword $(1))$(addprefix $(SPACE)+ /b ,$(wordlist 2, 100, $(1))) $(2) > nul
RM_F_CMD = $(if $(wildcard $(1)), del /f $(wildcard $(1)))
RENAME_CMD = $(if $(wildcard $(2)), del /f $(subst /,\,$(2)) && )$(subst /,\,ren $(1) $(2))
LN_IN_CMD = $(if $(wildcard $(strip $(1))/$(strip $(3))),$(call RM_F,$(strip $(1))/$(strip $(3))) && )cd $(1) && mklink $(3) $(2)

$(eval $(call MAKE_SHELL_COMMAND, MKDIR))
$(eval $(call MAKE_SHELL_COMMAND, CP))
$(eval $(call MAKE_SHELL_COMMAND, CAT))
$(eval $(call MAKE_SHELL_COMMAND, CAT_TO))
$(eval $(call MAKE_SHELL_COMMAND, RM_F))
$(eval $(call MAKE_SHELL_COMMAND, RENAME))
$(eval $(call MAKE_SHELL_COMMAND, LN_IN))

# XXX The laziness of these is harder to determine! Temporarily just forcing the shell detection, but these need converting too
ifeq "$(SHELL_IS_CMD)" ""
DIR_SEP = /
SAK_BUILD = $(SAK)
SHELL_QUOT = '$(1)'
# MKLIB from Makefile.config can be used as-is
else
# There must be another trick??
DIR_SEP := $(subst /,\,/)
SAK_BUILD = $(subst /,\,$(SAK))
SHELL_QUOT = "$(1)"
MKLIB = $(if $(wildcard $(1)), del /f $(subst /,\,$(wildcard $(1))) &&)$(call MKLIB_RAW,$(1),$(2))
endif

ifneq "$(SENSIBLE_MAKE)" ""
undefine MAKE_SHELL_COMMAND
endif

# %(DEPDIR) must be kept in sync with entries in .gitignore
DEPDIR=.dep
D=d

# $(EMPTY) is defined in Makefile.config, but may not have been loaded
EMPTY :=
# $(SPACE) contains a single space
SPACE := $(EMPTY) $(EMPTY)
# $(NEWLINE) contains exactly one newline character
define NEWLINE


endef
# $( ) suppresses warning from the alignments in the V_ macros below
$(SPACE) :=
LBRACKET = (
RBRACKET = )

V ?= 0

ifeq "$(V)" "0"

V_CC         = @$(info $   CC $@)
V_CCDEPS     = @$(info $   CCDEPS $@)
V_OCAMLC     = @$(info $   OCAMLC $@)
V_OCAMLOPT   = @$(info $   OCAMLOPT $@)
V_GEN        = @$(info $   GEN $@)
V_LINKC      = @$(info $   LINKC $@)
V_LINKOPT    = @$(info $   LINKOPT $@)
V_MKEXE      = @$(info $   MKEXE $@)
V_MKLIB      = @$(info $   MKLIB $@)
V_MKDLL      = @$(info $   MKDLL $@)
V_OCAMLLEX   = @$(info $   OCAMLLEX $@)
V_OCAMLYACC  = @$(info $   OCAMLYACC $@)
V_OCAMLDEP   = @$(info $   OCAMLDEP $@)
V_ASM        = @$(info $   ASM $@)
V_OCAMLMKLIB = @$(info $   OCAMLMKLIB $@)
V_OCAMLDOC   = @$(info $   OCAMLDOC $@)
V_ODOC       = @$(info $   ODOC $@)

else

V_CC         =
V_CCDEPS     =
V_OCAMLC     =
V_OCAMLOPT   =
V_GEN        =
V_LINKC      =
V_LINKOPT    =
V_MKEXE      =
V_MKLIB      =
V_MKDLL      =
V_OCAMLLEX   =
V_OCAMLYACC  =
V_OCAMLDEP   =
V_ASM        =
V_OCAMLMKLIB =
V_OCAMLDOC   =
V_ODOC       =

endif

DESTDIR ?=
INSTALL_BINDIR := $(DESTDIR)$(BINDIR)
INSTALL_LIBDIR := $(DESTDIR)$(LIBDIR)
INSTALL_INCDIR=$(INSTALL_LIBDIR)/caml
INSTALL_STUBLIBDIR := $(DESTDIR)$(STUBLIBDIR)
INSTALL_LIBDIR_PROFILING = $(INSTALL_LIBDIR)/profiling
INSTALL_MANDIR := $(DESTDIR)$(MANDIR)
INSTALL_PROGRAMS_MAN_DIR := $(DESTDIR)$(PROGRAMS_MAN_DIR)
INSTALL_LIBRARIES_MAN_DIR := $(DESTDIR)$(LIBRARIES_MAN_DIR)
INSTALL_DOCDIR := $(DESTDIR)$(DOCDIR)

FLEXDLL_SUBMODULE_PRESENT := $(wildcard $(ROOTDIR)/flexdll/Makefile)

IN_COREBOOT_CYCLE ?= false

# Variables used to represent the OCaml runtime system
# Most of the time, boot/ocamlrun and runtime/ocamlrun are the same.
# However, under some circumstances it is important to be able to
# distinguish one from the other, hence these two variables.
# Boot/ocamlrun is the most frequently used in the build system, so
# we use OCAMLRUN to designate it and keep NEW_OCAMLRUN to refer
# to runtime/ocamlrun, because it's less frequently used.
# Have to be careful about just changing OCAMLRUN to have backslashes - *make* needs forward-slashes!
OCAMLRUN ?= $(subst /,$(DIR_SEP),$(ROOTDIR)/boot/ocamlrun$(EXE))
NEW_OCAMLRUN ?= $(ROOTDIR)/runtime/ocamlrun$(EXE)

# Standard library flags
STDLIBFLAGS ?= -nostdlib -I $(ROOTDIR)/stdlib
BOOT_STDLIBFLAGS ?= -nostdlib -I $(ROOTDIR)/boot

# XXX This can possibly be done with a directory ordering trick for Windows?
#     i.e. something like dir /b /od
TEST_BOOT_OCAMLC_OPT = $(shell \
  test $(ROOTDIR)/boot/ocamlc.opt -nt $(ROOTDIR)/boot/ocamlc; \
  echo $$?)
TEST_BOOT_OCAMLC_OPT =

# Use boot/ocamlc.opt if available
ifeq "$(TEST_BOOT_OCAMLC_OPT)" "0"
  BOOT_OCAMLC = $(ROOTDIR)/boot/ocamlc.opt
else
  BOOT_OCAMLC = $(subst /,$(DIR_SEP),$(OCAMLRUN) $(ROOTDIR)/boot/ocamlc)
endif

BOOT_OCAMLDEP = $(BOOT_OCAMLC) -depend

ifeq "$(BOOTSTRAPPING_FLEXDLL)" "true"
  # XXX There might be a better way to do this! It avoids a race condition
  #     when promoting flexlink.opt.exe when a link is already taking place
  # Native GNU make will translate colon separators in $(PATH) back to
  # semi-colon when calling cmd, which means that sub-make invocations won't
  # detect that the elements are already in PATH
  DIR := $(realpath $(ROOTDIR))/boot/bin
# XXX Refactor, etc.
ifeq "$(SHELL_IS_CMD)" ""
ifeq "$(filter $(DIR).byte, $(subst :, ,$(PATH)))" ""
  export PATH := $(DIR).opt:$(DIR).byte:$(PATH)
endif
else
ifeq "$(filter $(DIR).byte, $(subst ;, ,$(PATH)))" ""
  export PATH := $(DIR).opt;$(DIR).byte;$(PATH)
endif
endif
  undefine DIR
endif

# List of other libraries
ALL_OTHERLIBS = dynlink str systhreads unix runtime_events

# Flags to pass to the C preprocessor when preprocessing assembly files
OC_ASPPFLAGS=$(OC_CPPFLAGS) $(OC_NATIVE_CPPFLAGS)

OPTCOMPFLAGS=
ifeq "$(FUNCTION_SECTIONS)" "true"
OPTCOMPFLAGS += -function-sections
endif

# The rule to compile C files

# This rule is similar to GNU make's implicit rule, except that it is more
# general (it supports both .o and .obj)

RUNTIME_HEADERS = $(eval \
  RUNTIME_HEADERS := \
    $$(wildcard $(ROOTDIR)/runtime/caml/*.tbl) \
    $$(wildcard $(ROOTDIR)/runtime/caml/*.h))$(RUNTIME_HEADERS)
# This looks incorrect - it probably works for systhreads, but it won't work for runtime anymore?
REQUIRED_HEADERS = $(RUNTIME_HEADERS) $(wildcard *.h)

#ifeq "$(COMPUTE_DEPS)" "true"
#RUNTIME_HEADERS :=
#REQUIRED_HEADERS :=
#else
#RUNTIME_HEADERS := $(wildcard $(ROOTDIR)/runtime/caml/*.tbl) \
#                   $(wildcard $(ROOTDIR)/runtime/caml/*.h)
#REQUIRED_HEADERS := $(RUNTIME_HEADERS) $(wildcard *.h)
#endif

%.$(O): %.c $(REQUIRED_HEADERS)
	$(V_CC)$(CC) -c $(OC_CFLAGS) $(CFLAGS) $(OC_CPPFLAGS) $(CPPFLAGS) \
	  $(OUTPUTOBJ)$@ $<

$(DEPDIR):
	$(MKDIR) $@

# When executable files have an extension (e.g. ".exe"),
# provide phony synonyms
define PROGRAM_SYNONYM
ifneq ($(EXE),)
.PHONY: $(1)
$(1): $(1)$(EXE)
endif
endef # PROGRAM_SYNONYM

# Definitions related to ocamldep

# Default value for OCAMLDEP
# In those directories where this needs to be overridden, the overriding
# should take place *before* Makefile.common is included.

OCAMLDEP ?= $(BEST_OCAMLDEP)
OCAMLDEPFLAGS ?=
OC_OCAMLDEPFLAGS = -slash
OC_OCAMLDEPDIRS =
OCAMLDEP_CMD = $(OCAMLDEP) $(OC_OCAMLDEPFLAGS) \
  $(addprefix -I ,$(OC_OCAMLDEPDIRS)) $(OCAMLDEPFLAGS)

# Lexer generation

BOOT_OCAMLLEX ?= $(subst /,$(DIR_SEP),$(OCAMLRUN) $(ROOTDIR)/boot/ocamllex)

# Default value for OCAMLLEX
# In those directories where this needs to be overridden, the overriding
# should take place *before* Makefile.common is included.

OCAMLLEX ?= $(BEST_OCAMLLEX)

OCAMLLEXFLAGS ?= -q

%.ml: %.mll
	$(V_OCAMLLEX)$(OCAMLLEX) $(OCAMLLEXFLAGS) $<

# Parser generation

OCAMLYACC ?= $(subst /,$(DIR_SEP),$(ROOTDIR)/yacc/ocamlyacc$(EXE))

OCAMLYACCFLAGS ?= --strict -v

%.ml %.mli: %.mly
	$(V_OCAMLYACC)$(OCAMLYACC) $(OCAMLYACCFLAGS) $<

SAK = $(ROOTDIR)/runtime/sak$(EXE)

# Used with the Microsoft toolchain to merge generated manifest files into
# executables
if_file_exists = ( test ! -f $(1) || $(2) && rm -f $(1) )
MERGEMANIFESTEXE = $(call if_file_exists, $(1).manifest, \
  mt -nologo -outputresource:$(1) -manifest $(1).manifest)

# Macros and rules to compile OCaml programs

# We use secondary expansion here so that variables like
# foo_LIBRARIES and foo_MODULES can be defined after the calls
# to the macros below. Without secondary expansion, those variables
# would have to be defined before the calls to OCAML_BYTECODE_PROGRAM etc.

.SECONDEXPANSION:

LINK_BYTECODE_PROGRAM =\
  $(CAMLC) $(OC_COMMON_LINKFLAGS) $(OC_BYTECODE_LINKFLAGS)

# $(CAMLC) may include -use-prims $(ROOTDIR)/runtime/primitives. We do not
# automatically re-link programs when the the compiler chnages
# (cf. stdlib/Makefile where this is done explictly), but we do need to be sure
# that runtime/primitives has been generated, hence the order-only dependency
# on it. Being order-only both prevents an updated runtime/primitives forcing a
# re-link and, conveniently, order-only dependencies are not included in $^.
define OCAML_BYTECODE_PROGRAM
$(eval $(call PROGRAM_SYNONYM,$(1)))
$(1)$(EXE): | $(ROOTDIR)/runtime/primitives
$(1)$(EXE): \
  $$$$(patsubst %,%.cma, $$$$($(basename $(notdir $(1)))_LIBRARIES)) \
  $$$$(patsubst %,%.cmo, $$$$($(basename $(notdir $(1)))_MODULES))
	$$(V_LINKC)$$(LINK_BYTECODE_PROGRAM) -o $$@ $$^
endef # OCAML_BYTECODE_PROGRAM

LINK_NATIVE_PROGRAM =\
  $(CAMLOPT) $(OC_COMMON_LINKFLAGS) $(OC_NATIVE_LINKFLAGS)

define OCAML_NATIVE_PROGRAM
$(eval $(call PROGRAM_SYNONYM,$(1)))
$(1)$(EXE): \
  $$$$(patsubst %,%.cmxa, $$$$($(basename $(notdir $(1)))_LIBRARIES)) \
  $$$$(patsubst %,%.cmx, $$$$($(basename $(notdir $(1)))_MODULES))
	$$(V_LINKOPT)$$(LINK_NATIVE_PROGRAM) -o $$@ $$^
endef # OCAML_NATIVE_PROGRAM

define OCAML_PROGRAM
$(eval $(call OCAML_BYTECODE_PROGRAM,$(1)))
$(eval $(call OCAML_NATIVE_PROGRAM,$(1).opt))
endef # OCAML_PROGRAM

# Installing a bytecode executable, with debug information removed
define INSTALL_STRIPPED_BYTE_PROG
$(OCAMLRUN) $(ROOTDIR)/tools/stripdebug $(1) $(1).tmp \
&& $(INSTALL_PROG) $(1).tmp $(2) \
&& rm $(1).tmp
endef # INSTALL_STRIPPED_BYTE_PROG

# Determine if we're using GNU make 3.82 or later (macOS ships with 3.81)
ifeq "$(filter undefine, $(.FEATURES))" "undefine"
LEGACY_MAKE = false
else
LEGACY_MAKE = true
endif
